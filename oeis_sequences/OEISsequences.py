# -*- coding: utf-8 -*-
"""
Created on Thu Dec  2 11:43:37 2021

@author: Chai Wah Wu

Python functions to generate The On-Line Encyclopedia of Integer Sequences (OEIS) sequences

Requires python >= 3.8

Installation: pip install OEISsequences

After installation, `from oeis_sequences import OEISsequences` will import all the functions accessible via `OEISsequences.Axxxxxx`.
Alternatively, invidividual functions can be imported as `from oeis_sequences.OEISsequences import Axxxxxx`.

For each sequence, there are 3 different kinds of functions:

1. Functions named `Axxxxxx`: Axxxxxx(n) returns the *n*-th term of OEIS sequence Axxxxxx.

2. Functions named `Axxxxxx_T`: returns T(n,k) for OEIS sequences where the natural definition is a 2D table T.

3. Functions named `Axxxxxx_gen`: Axxxxxx_gen() returns a generator of OEIS sequence Axxxxxx.

The function `Axxxxxx` is best used to compute a single term. The generator `Axxxxxx_gen` is typically defined for sequences where terms are best generated sequentially and is best used when computing a sequence of consecutive terms. 

For the generator, we can for example use `list(islice(Axxxxxx_gen(),10))` to return the first 10 terms of sequence Axxxxxx
Alternatively, setting `gen = Axxxxxx_gen()` and using `next(gen)` returns the next term of the sequence.

Given `Axxxxxx_gen`, one can define a function `Axxxxxx` as: 

def Axxxxxx(n,offset=1): return next(islice(Axxxxxx_gen(),n-offset,None))

where a(offset) is the first term returned by the generator. This value of offset is the same as the offset parameter in the OEIS database.

Some functions `Axxxxxx_gen` contain an optional keyword `startvalue` that returns a generator of terms that are larger than or equal to `startvalue`.

For some sequences, e.g. `A269483`, both type of functions `Axxxxxx` and `Axxxxxx_gen` are provided.

Examples:
    
   from oeis_sequences.OEISsequences import A131546
   print(A131546(5))
   >> 721
  
   from itertools import islice
   from oeis_sequences.OEISsequences import A153695_gen
   print(list(islice(A153695_gen(),10)))
   >> [1, 2, 3, 4, 5, 6, 13, 17, 413, 555]
   
   from oeis_sequences.OEISsequences import A235811_gen 
   print(list(islice(A235811_gen(startvalue=1475),10)))
   >> [1475, 1484, 1531, 1706, 1721, 1733, 1818, 1844, 1895, 1903]

The module also includes some utility functions for exploring integer sequences in OEIS such as palindrome generator, 
Boustrophedon transform, run length transform, lunar arithmetic, etc.

"""

from __future__ import print_function, division
import sys, bisect, re
import sympy
from functools import lru_cache, reduce
from itertools import (
    islice,
    count,
    product,
    permutations,
    takewhile,
    dropwhile,
    accumulate,
    combinations_with_replacement,
    combinations,
    repeat,
    groupby,
    chain,
    starmap,
    zip_longest,
    tee,
)
from fractions import Fraction
from collections import Counter, deque
from math import factorial, floor, comb, prod, isqrt
from operator import mul, xor, add, or_, and_, ior, ixor, iand, itemgetter
from operator import sub as operator_sub
from re import finditer, split, sub
from statistics import pvariance
from sympy.core.numbers import igcdex
from sympy import (
    factorint,
    divisors,
    integer_nthroot,
    divisor_sigma,
    nextprime,
    Matrix,
    divisor_count,
    isprime,
    prime,
    totient,
    sympify,
    primerange,
    primepi,
    composite,
    compositepi,
    factorial2,
    prevprime,
    primefactors,
    harmonic,
    multiplicity,
    primorial,
    sqrt,
    ff,
    rf,
    sin,
    cos,
    tan,
    fibonacci,
    lucas,
    pi,
    hyperexpand,
    expand,
    Poly,
    hermite,
    mod_inverse,
    EulerGamma,
    digamma,
    discrete_log,
    S,
    catalan,
    npartitions,
    ceiling,
    log,
    simplify,
    perfect_power,
    convex_hull,
    GF,
    binomial,
    I,
    is_primitive_root,
    diff,
    integer_log,
    chebyshevu,
    chebyshevt,
    resultant,
    Rational,
    sturm,
    oo,
    LT,
    nan,
    sign,
    proper_divisors,
    exp,
    is_nthpow_residue,
    cyclotomic_poly,
)
from sympy.functions import hyper, partition, euler
from sympy.ntheory import (
    mobius,
    jacobi_symbol,
    legendre_symbol,
    sqrt_mod,
    sqrt_mod_iter,
    multinomial_coefficients,
    is_gaussian_prime,
)
from sympy.ntheory.factor_ import (
    digits as sympydigits,
    udivisor_sigma,
    sieve,
    reduced_totient,
    core as numbercore,
    antidivisors,
    udivisors,
    udivisor_count,
    antidivisor_count,
    primeomega,
    primenu,
)
from sympy.combinatorics.partitions import IntegerPartition
from sympy.utilities.iterables import (
    partitions,
    multiset_permutations,
    multiset_combinations,
    multiset_partitions,
)
from sympy.functions.combinatorial.numbers import stirling, bell
from sympy.ntheory.continued_fraction import (
    continued_fraction,
    continued_fraction_periodic,
    continued_fraction_reduce,
)
from sympy.ntheory.modular import crt, solve_congruence
from sympy.ntheory.residue_ntheory import (
    nthroot_mod,
    primitive_root,
    quadratic_residues,
)
from sympy.combinatorics.subsets import Subset
from sympy.solvers.diophantine import diophantine
from sympy.solvers.diophantine.diophantine import (
    diop_quadratic,
    diop_DN,
    cornacchia,
    power_representation,
)
from sympy.abc import x as symbolx, y as symboly
from gmpy2 import (
    mpz,
    fac,
    popcount,
    is_prime,
    is_square,
    next_prime,
    c_divmod,
    lucas2,
    fib,
    fib2,
    isqrt_rem,
    iroot_rem,
    is_power,
    digits as gmpy2digits,
)
from num2words import num2words
from unidecode import unidecode
from networkx import (
    empty_graph,
    find_cliques,
    complement,
    power,
    cartesian_product,
    star_graph,
    path_graph,
    cycle_graph,
    mycielski_graph,
    hypercube_graph,
    contracted_nodes,
    simple_cycles,
)
from heapq import heappop, heappushpop
from bitarray import bitarray

if sys.version_info < (3, 9):
    from sympy import lcm as sympylcm, gcd as sympygcd

    def gcd(*x):
        r = x[0]
        for y in x[1:]:
            r = sympygcd(r, y)
        return r

    def lcm(*x):
        r = x[0]
        for y in x[1:]:
            r = sympylcm(r, y)
        return r

else:
    from math import lcm, gcd
if sys.version_info >= (3, 10):
    from itertools import pairwise

""" Utility functions """


def is_pal(n, b=10):
    """check if n is a palindrome in base b"""
    return (s := sympydigits(n, b)[1:])[: (t := len(s) + 1 >> 1)] == s[: -t - 1 : -1]


def is_cubefree_string(s):
    """check if s is a cubefree string, i.e. there is no substring of the form ttt"""
    l = len(s)
    for i in range(l - 2):
        for j in range(1, (l - i) // 3 + 1):
            if s[i : i + 2 * j] == s[i + j : i + 3 * j]:
                return False
    return True


def palindrome(n, b=10):
    """n-th palindrome in base b, where 2 <= b <= 62"""
    if n == 1:
        return 0
    y = b * (x := b ** integer_log(n >> 1, b)[0])
    return int(
        (c := n - x) * x + mpz(gmpy2digits(c, b)[-2::-1] or "0", b)
        if n < x + y
        else (c := n - y) * y + mpz(gmpy2digits(c, b)[::-1] or "0", b)
    )


def pal10_gen():
    """generator of palindromes in base 10"""
    yield 0
    for x in count(1):
        for y in range(10 ** (x - 1), 10**x):
            s = str(y)
            yield int(s + s[-2::-1])
        for y in range(10 ** (x - 1), 10**x):
            s = str(y)
            yield int(s + s[::-1])


def pal_gen(b=10):
    """generator of palindromes in base b"""
    yield 0
    x = 1
    while True:
        n = b ** (x - 1)
        n2 = n * b
        for y in range(n, n2):  # odd-length
            k, m = y // b, 0
            while k >= b:
                k, r = divmod(k, b)
                m = b * m + r
            yield y * n + b * m + k
        for y in range(n, n2):  # even length
            k, m = y, 0
            while k >= b:
                k, r = divmod(k, b)
                m = b * m + r
            yield y * n2 + b * m + k
        x += 1


def palbase_gen(b=10):
    """generator of palindromes in base b <=10 written in base b"""
    yield 0
    for x in count(1):
        for y in range(b ** (x - 1), b**x):
            s = gmpy2digits(y, b)
            yield int(s + s[-2::-1])
        for y in range(b ** (x - 1), b**x):
            s = gmpy2digits(y, b)
            yield int(s + s[::-1])


def pal_odd_gen(l, b=10):
    """generator of odd-length palindromes in base b of length <= 2*l"""
    if l > 0:
        yield 0
        for x in range(1, l + 1):
            n = b ** (x - 1)
            n2 = n * b
            for y in range(n, n2):
                k, m = y // b, 0
                while k >= b:
                    k, r = divmod(k, b)
                    m = b * m + r
                yield y * n + b * m + k


def pal10_odd_range_gen(m=1):
    """generator of odd-length palindromes in base 10 of length at least m"""
    if m == 1:
        yield 0
    for x in count(m // 2 + 1):
        n = 10 ** (x - 1)
        for y in range(n, n * 10):
            s = str(y)
            yield int(s + s[-2::-1])


def multiset_perm_count(x):
    """count the number of permutations in a multiset (from a list or tuple)"""
    return factorial(len(x)) // prod(factorial(d) for d in Counter(x).values())


def intpartitiongen(n, m):
    """generator of partition of n into m decimal digits, return as list of strings"""
    return (
        "".join(str(d) for d in IntegerPartition(p).partition + [0] * (m - s))
        for s, p in partitions(n, k=9, m=m, size=True)
    )


@lru_cache(maxsize=None)
def intpartition(n, m):
    """partition of n into m decimal digits, return as list of strings"""
    return tuple(intpartitiongen(n, m))


def partitionpairs(xlist):
    """generator of all partitions into pairs and at most 1 singleton, returning the sums of the pairs"""
    if len(xlist) <= 2:
        yield [sum(xlist)]
    else:
        m = len(xlist)
        for i in range(m - 1):
            for j in range(i + 1, m):
                rem = xlist[:i] + xlist[i + 1 : j] + xlist[j + 1 :]
                y = [xlist[i] + xlist[j]]
                for d in partitionpairs(rem):
                    yield y + d


def integerlog(n, b):
    """computes largest integer k>=0 such that b^k <= n"""
    kmin, kmax = 0, 1
    while b**kmax <= n:
        kmax <<= 1
    while True:
        kmid = kmax + kmin >> 1
        if b**kmid > n:
            kmax = kmid
        else:
            kmin = kmid
        if kmax - kmin <= 1:
            break
    return kmin


def ispandigital(m, n):
    """return True iff m is pandigital in base n"""
    s = set()
    while m > 0:
        m, b = divmod(m, n)
        if b in s:
            return False
        s.add(b)
    return True


def ispandigital0(m, n):
    """return (True, s) if m is pandigital in base n and (False, False) otherwise where s is true iff m has a zero digit"""
    s = set()
    z = False
    while m > 0:
        m, b = divmod(m, n)
        if b in s:
            return False, False
        if b == 0:
            z = True
        s.add(b)
    return True, z


def intbase(dlist, b=10):
    """convert list of digits in base b to integer"""
    y = 0
    for d in dlist:
        y = y * b + d
    return y


def is_emirp(n, b=10):
    """check if n is an emirp in base b"""
    x, y = n, 0
    while x >= b:
        x, r = divmod(x, b)
        y = y * b + r
    y = y * b + x
    return n != y and isprime(y)


def antidivisor_sigma(n):
    """sum of antidivisors of n"""
    return (
        sum(2 * d for d in divisors(n, generator=True) if n > 2 * d and n % (2 * d))
        + sum(d for d in divisors(2 * n - 1, generator=True) if n > d >= 2 and n % d)
        + sum(d for d in divisors(2 * n + 1, generator=True) if n > d >= 2 and n % d)
    )


def divisor_prod(n):
    """product of divisors of n"""
    d = divisor_count(n)
    return isqrt(n) ** d if d % 2 else n ** (d // 2)


def divisor_sigma_mod(n, m):
    """computes divisor_sigma(n) mod m"""
    y = 1
    for p, e in factorint(n).items():
        y = (y * (p ** (e + 1) - 1) // (p - 1)) % m
    return y


def reversedigits(n, b=10):
    """reverse digits of n in base b"""
    x, y = n, 0
    while x >= b:
        x, r = divmod(x, b)
        y = b * y + r
    return b * y + x


@lru_cache(maxsize=None)
def divisor_tuple(n):
    """cached unordered tuple of divisors"""
    return tuple(divisors(n, generator=True))


def RLT(n, f):
    """run length transform of a function f"""
    return prod(f(len(d)) for d in split("0+", bin(n)[2:]) if d != "") if n > 0 else 1


def n_order(a, b):
    """returns 1 if b = 1 following older version of n_order in sympy"""
    return sympy.n_order(a, b) if b > 1 else 1


def repeating_decimals_expr(f, digits_only=False):
    """returns repeating decimals of Fraction f as the string aaa.bbb[ccc].
    returns only digits if digits_only=True.
    """
    a, b = f.as_integer_ratio()
    m2, m5 = multiplicity(2, b), multiplicity(5, b)
    r = max(m2, m5)
    k, m = 10**r, 10 ** (t := n_order(10, (b >> m2) // 5**m5)) - 1
    c = k * a // b
    s = str(c).zfill(r)
    if digits_only:
        return s + str(m * k * a // b - c * m).zfill(t)
    else:
        w = len(s) - r
        return s[:w] + "." + s[w:] + "[" + str(m * k * a // b - c * m).zfill(t) + "]"


def repeating_decimals_period(f):
    """returns period of repeating decimals of Fraction f"""
    return (
        0
        if (
            m := ((n := f.denominator) >> (~n & n - 1).bit_length())
            // 5 ** multiplicity(5, n)
        )
        == 1
        else n_order(10, m)
    )


def Boustrophedon_transform(x):
    """Boustrophedon transform of the iterable x
    returns generator"""
    blist = tuple()
    for m in x:
        yield (blist := tuple(accumulate(reversed(blist), initial=m)))[-1]


def inverse_Boustrophedon_transform(x):
    """inverse Boustrophedon transform of the iterable x
    returns generator"""
    blist = tuple()
    for m in x:
        yield (
            blist := tuple(accumulate(reversed(blist), func=operator_sub, initial=m))
        )[-1]


def round_sqrt(n, k=1):
    """round(k*sqrt(n))"""
    return (m := isqrt(r := n * k * k)) + int(r - m * (m + 1) >= 1)


@lru_cache(maxsize=None)
def is_squareful(n):
    """return True if and only if n is squareful"""
    return n == 1 or min(factorint(n).values()) > 1


def iteratedphi(n):
    m = n
    while m > 1:
        m = totient(m)
        yield m


def bernoulli(n):
    """use the convention that bernoulli(1) = 1/2"""
    return sympy.bernoulli(n) if n != 1 else S.Half


@lru_cache(maxsize=None)
def faulhaber(n, p):
    """Faulhaber's formula for calculating Sum_{k=1..n} k^p"""
    return sum(
        comb(p + 1, k) * bernoulli(k) * n ** (p - k + 1) for k in range(p + 1)
    ) // (p + 1)


def iterfun(f, n=0):
    """iterate function f starting from n until fixed point of f"""
    m, k = n, f(n)
    while m != k:
        m, k = k, f(k)
    return m


def bisection(f, kmin=0, kmax=1):
    """bisection method to find fixed point of f"""
    while f(kmax) > kmax:
        kmax <<= 1
    while kmax - kmin > 1:
        kmid = kmax + kmin >> 1
        if f(kmid) <= kmid:
            kmax = kmid
        else:
            kmin = kmid
    return kmax


def almostprimepi(n, k):
    """number of k-almost primes <= n"""
    if k == 0:
        return int(n >= 1)

    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b, isqrt(x // c) + 1), a))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b, integer_nthroot(x // c, m)[0] + 1), a
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    return int(
        sum(primepi(n // prod(c[1] for c in a)) - a[-1][0] for a in g(n, 0, 1, 1, k))
        if k > 1
        else primepi(n)
    )


def squarefreealmostprimepi(n, k):
    """number of squarefree k-almost primes <= n"""
    if k == 0:
        return int(n >= 1)

    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b + 1, isqrt(x // c) + 1), a + 1))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b + 1, integer_nthroot(x // c, m)[0] + 1), a + 1
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    return int(
        sum(primepi(n // prod(c[1] for c in a)) - a[-1][0] for a in g(n, 0, 1, 1, k))
        if k > 1
        else primepi(n)
    )


def squarefreepi(n):
    """number of squarefree numbers <= n"""
    return int(sum(mobius(k) * (n // k**2) for k in range(1, isqrt(n) + 1)))


def almostprime(n, k):
    """n-th k-almost prime"""

    def f(x):
        return n + x - almostprimepi(x, k)

    return bisection(f, m := f(f(n)), m) if k > 1 else prime(n)


def squarefreealmostprime(n, k):
    """n-th squarefree k-almost prime"""

    def f(x):
        return n + x - squarefreealmostprimepi(x, k)

    return bisection(f, m := f(f(n)), m) if k > 1 else prime(n)


def squarefree(n):
    """n-th squarefree number"""

    def f(x):
        return n + x - squarefreepi(x)

    return bisection(f, m := f(f(n)), m)


""" Lunar arithmetic """


def lunar_add(n, m):
    """lunar addition"""
    sn, sm = str(n), str(m)
    l = max(len(sn), len(sm))
    return int("".join(max(i, j) for i, j in zip(sn.rjust(l, "0"), sm.rjust(l, "0"))))


def lunar_mul(n, m):
    """lunar multiplication"""
    sn, sm, y = str(n), str(m), 0
    for i in range(len(sm)):
        c = sm[-i - 1]
        y = lunar_add(y, int("".join(min(j, c) for j in sn)) * 10**i)
    return y


""" """

""" List of OEIS sequences """


def A349804(n):
    return int((lambda x: x + x[::-1])("".join(str(d) for d in range(1, n + 1))))


def A349805(n):
    return int((lambda x: x + x[::-1])("".join(str(d) for d in range(1, n + 1)))) // 11


def A173426(n):
    return int(
        "".join(str(d) for d in range(1, n + 1))
        + "".join(str(d) for d in range(n - 1, 0, -1))
    )


def A349724():  # generator of terms
    for k in count(1):
        if (
            not k
            * (k + 1)
            // 2
            % prod(p ** (e - 1) * ((p - 1) * e + p) for p, e in factorint(k).items())
        ):
            yield k


def A018804(n):
    return prod(p ** (e - 1) * ((p - 1) * e + p) for p, e in factorint(n).items())


def A349711(n):
    f = factorint(n)
    plist, m = list(f.keys()), sum(f[p] * p for p in f)
    return sum(
        (lambda x: x * (m - x))(sum(d[i] * p for i, p in enumerate(plist)))
        for d in product(*(list(range(f[p] + 1)) for p in plist))
    )


def A349712(n):
    f = factorint(n)
    plist = list(f.keys())
    return sum(
        sum(int(d[i] > 0) * p for i, p in enumerate(plist))
        * sum(int(d[i] < f[p]) * p for i, p in enumerate(plist))
        for d in product(*(list(range(f[p] + 1)) for p in plist))
    )


def A348169_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        for d in divisors(n, generator=False):
            x, x2 = 1, 1
            while 3 * x2 <= d:
                y, y2 = x, x2
                z2 = d - x2 - y2
                while z2 >= y2:
                    z, w = integer_nthroot(z2, 2)
                    if w:
                        A = n // d
                        B, u = divmod(n, x * (y + z) + y * z)
                        if u == 0 and gcd(A, B) == 1:
                            yield n
                            break
                    y += 1
                    y2 += 2 * y - 1
                    z2 -= 2 * y - 1
                else:
                    x += 1
                    x2 += 2 * x - 1
                    continue
                break
            else:
                continue
            break


def A349680(n):
    return n + (n - 1) * divisor_sigma(n, 0) - divisor_sigma(n, 1)


def A349643(n):
    plist, clist = [2], [1]
    for i in range(1, n + 1):
        plist.append(nextprime(plist[-1]))
        clist.append((-1) ** i * comb(n, i))
    while True:
        if sum(clist[i] * plist[i] for i in range(n + 1)) == 0:
            return plist[0]
        plist = plist[1:] + [nextprime(plist[-1])]


def A349544helper_(k, n):
    if k == 0 and n == 0:
        return (x for x in (1,))
    if k < n:
        return (y * 3 for y in A349544helper_(k, n - 1))
    return (abs(x + y) for x in A349544helper_(k - 1, n) for y in (2**n, -(2**n)))


def A349544(n):
    return min(A349544helper_(n, n))


def A348183(n):
    return Matrix(n, n, [pow(i + j, 2, n) for i in range(n) for j in range(n)]).det()


def A348226(n):
    """code assumes n <= 63 or n is prime"""
    if is_prime(n):
        return 2
    if n > 63:
        return "Error: n <= 63 or n is prime"
    p = 2
    while True:
        for i in range(n - 1, 1, -1):
            s = gmpy2digits(p, i)
            if not is_prime(int(s, n)):
                break
        else:
            return p
        p = next_prime(p)


def A349529(n):
    return len(
        list(
            filter(
                lambda x: x == 1,
                Counter(
                    "".join(d)
                    for d in permutations(bin(i)[2:] for i in range(1, n + 1))
                ).values(),
            )
        )
    )


def A066640_gen():  # generator of terms
    return filter(
        lambda n: all(
            set(str(m)) <= {"1", "3", "5", "7", "9"}
            for m in divisors(n, generator=True)
        ),
        count(1, 2),
    )


def A014261_gen():  # generator of terms
    return filter(lambda n: set(str(n)) <= {"1", "3", "5", "7", "9"}, count(1, 2))


def A117960_gen():  # generator of terms
    return filter(
        lambda n: set(str(n)) <= {"1", "3", "5", "7", "9"},
        (m * (m + 1) // 2 for m in count(0)),
    )


def A349243_gen(startvalue=0):  # generator of terms
    return filter(
        lambda n: set(str(n * (n + 1) // 2)) <= {"1", "3", "5", "7", "9"},
        count(max(startvalue, 0)),
    )


def A348162_gen():  # generator of terms
    s, n, m = "0", 1, 0
    while True:
        yield m
        n, m = n * 2, int(s, 4) + int(("02" * n)[: len(s)], 4)
        s = format(m, "0" + str(n) + "b")


def A349360(n):
    m = divisor_count(n)
    return m * (m - n) + n * (n + 1) // 2


def A349460_gen():  # generator of terms
    return filter(lambda n: set(str(n)) <= {"0", "2", "4"}, (n * n for n in count(0)))


def A342975_gen():  # generator of terms
    return filter(lambda n: set(str(n)) <= {"0", "1", "3"}, (n**3 for n in count(0)))


def A050251(n):
    return (
        4 * n if n <= 1 else 1 + sum(1 for i in pal_odd_gen((n + 1) // 2) if isprime(i))
    )


def A229629_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        s, sn = str(n**n), str(n)
        l, ln = len(s), len(sn)
        if (ln - l) % 2 == 0 and s[l // 2 - ln // 2 : l // 2 + (ln + 1) // 2] == sn:
            yield n


def A347113_gen():  # generator of terms
    j, nset, m = 2, {1}, 2
    yield 1
    while True:
        k = m
        while k == j or gcd(k, j) == 1 or k in nset:
            k += 1
        yield k
        j = k + 1
        nset.add(k)
        while m in nset:
            m += 1


def A347313(n):
    p, gen = prime(n), A347113_gen()
    for i in count(1):
        q = next(gen)
        if p == q:
            return i


def A179993_gen(startvalue=1):  # generator of terms
    for m in count(max(startvalue, 1)):
        if all(
            isprime(m // a - a) for a in takewhile(lambda x: x * x <= m, divisors(m))
        ):
            yield m


def A349327_gen():  # generator of terms
    n = 2
    while True:
        if isprime(n**2 - 2) and isprime(2 * n**2 - 1):
            yield n
        n = nextprime(n)


def A348784_gen():  # generator of terms
    i = 1
    for m in A347113_gen():
        if isprime(m):
            yield i
        i += 1


def A348158(n):
    return sum(set(map(totient, divisors(n, generator=True))))


def A348213(n):
    c, k = 0, n
    m = A348158(k)
    while m != k:
        k, m = m, A348158(m)
        c += 1
    return c


def A003434(n):
    c, m = 0, n
    while m > 1:
        c += 1
        m = totient(m)
    return c


def A013588(n):
    s, k = set(Matrix(n, n, p).det() for p in product([0, 1], repeat=n**2)), 1
    while k in s:
        k += 1
    return k


def A092694(n):
    return prod(iteratedphi(n))


def A092693(n):
    return sum(iteratedphi(n))


def A254007(n):
    return (
        1
        if n == 0
        else len(
            set(tuple(sorted(accumulate(d))) for d in product((-1, 1), repeat=n - 1))
        )
    )


def A348780(n):
    return sum(islice(A347113_gen(), n))


def A343878(n):
    k, c = 0, dict()
    while True:
        m, r = 0, 1
        while r > 0:
            k += 1
            r = c.get(m, 0)
            if n == r:
                return k
            c[r] = c.get(r, 0) + 1
            m += 1


def A348781(n):
    k, s, c = 0, 0, dict()
    while True:
        m, r = 0, 1
        while r > 0:
            k += 1
            if k > n:
                return s
            r = c.get(m, 0)
            s += r
            c[r] = c.get(r, 0) + 1
            m += 1


def A172500(n):
    return sympify("0.[" + str(n) + "]").p


def A172502(n):
    return sympify("0.[" + str(n) + "]").q


def A348870(n):
    return (lambda m, r: r.p if m % 2 else r.q)(
        n, sympify("0.[" + str((n + 1) // 2) + "]")
    )


def A339665(n):
    ds = tuple(divisors(n, generator=True))
    return sum(
        sum(1 for d in combinations(ds, i) if n * i % sum(d) == 0)
        for i in range(1, len(ds) + 1)
    )


def A339453(n):
    m = lcm(*range(2, n + 1))
    return sum(
        1
        for i in range(1, n + 1)
        for d in combinations((m // i for i in range(1, n + 1)), i)
        if m * i % sum(d) == 0
    )


def A349148(n):
    k = lcm(*range(2, n + 1))
    return sum(
        1
        for d in combinations_with_replacement((k // d for d in range(1, n + 1)), n)
        if sum(d) % k == 0
    )


def A349215(n):
    fs = factorint(n)
    return sum(a - 1 for a in fs.keys()) + prod(1 + d for d in fs.values())


def A349214(n):
    p = list(primerange(2, n + 1))
    return n - len(p) + sum(p)


@lru_cache(maxsize=None)
def A339508(n):
    nlist = [i for i in range(2, n) if i % 10 != 0]
    if n == 0 or n == 1:
        return 1
    c = A339508(n - 1)
    if n % 10 != 0:
        sn = str(n)
        if sn == sn[::-1]:
            c += 1
        for i in range(1, len(nlist) + 1):
            for d in combinations(nlist, i):
                s = str(prod(d) * n)
                if s == s[::-1]:
                    c += 1
    return c


@lru_cache(maxsize=None)
def A339484(n):
    return (
        1
        if n == 1
        else A339484(n - 1)
        + sum(
            sum(d) + n == (i + 1) ** 2
            for i in range(1, n)
            for d in combinations(range(1, n), i)
        )
    )


def A348516(n):
    k, s = 1, gmpy2digits(n, 3).rstrip("0")
    if s == "1" or s == "":
        return 1 - len(s)
    m = int(s, 3)
    mk = m
    while s.count("1") != s.count("2"):
        k += 1
        mk *= m
        s = gmpy2digits(mk, 3)
    return k


def A349179_gen():  # generator of terms
    c = 0
    for i in count(1):
        if (m := A339665(i)) > c:
            yield i
            c = m


def A349145(n):
    return sum(
        1
        for d in product(range(1, n + 1), repeat=n)
        if sum(Fraction(i + 1, j) for i, j in enumerate(d)).denominator == 1
    )


def A349146(n):
    k = lcm(*range(2, n + 1))
    dlist = tuple(k // d for d in range(1, n + 1))
    return sum(
        multiset_perm_count(d)
        for d in combinations_with_replacement(range(1, n + 1), n)
        if sum(dlist[e - 1] for e in d) % k == 0
    )


def A348895(n):
    l, c, nmax, k = 9 * n, 0, 0, 10 ** (n - 1)
    while l > c:
        for p in intpartition(l, n):
            for q in multiset_permutations(p):
                w = int("".join(q))
                if w >= k:
                    wr = w % l
                    if wr > c:
                        c = wr
                        nmax = w
                    if wr == c and nmax < w:
                        nmax = w
        l -= 1
    return nmax


def A348894(n):
    l, c, nmin, k = 9 * n, 0, 10**n - 1, 10 ** (n - 1)
    while l > c:
        for p in intpartition(l, n):
            for q in multiset_permutations(p):
                w = int("".join(q))
                if w >= k:
                    wr = w % l
                    if wr > c:
                        c = wr
                        nmin = w
                    if wr == c and nmin > w:
                        nmin = w
        l -= 1
    return nmin


def A348730(n):
    l, c, k = 9 * n, 0, 10 ** (n - 1)
    while l - 1 > c:
        c = max(
            c,
            max(
                s % l
                for s in (
                    int("".join(q))
                    for p in intpartition(l, n)
                    for q in multiset_permutations(p)
                )
                if s >= k
            ),
        )
        l -= 1
    return c


def A348706(n):
    return int(gmpy2digits(n, 3).replace("0", ""), 3)


def A348651(n):
    return popcount(fac(fac(n)))


def A348658_gen(startvalue=1):  # generator of terms
    for k in count(max(startvalue, 1)):
        a, b = divisor_sigma(k), divisor_sigma(k, 0) * k
        c = gcd(a, b)
        n1, n2 = 5 * (a // c) ** 2 - 4, 5 * (b // c) ** 2 - 4
        if (integer_nthroot(n1, 2)[1] or integer_nthroot(n1 + 8, 2)[1]) and (
            integer_nthroot(n2, 2)[1] or integer_nthroot(n2 + 8, 2)[1]
        ):
            yield k


def A108861_gen():  # generator of terms
    k2, kf = 1, 1
    for k in count(1):
        k2 *= 2
        kf *= k
        if not sum(int(d) for d in str(k2 * kf)) % k:
            yield k


def A244060(n):
    return sum(int(d) for d in str(factorial(2**n)))


def A008906(n):
    return len(str(factorial(n)).rstrip("0"))


def A348446_gen():  # generator of terms. Greedy algorithm.
    a = 1
    c, b = Counter(), 1
    while True:
        k, kb = 1, b
        while c[kb] >= kb:
            k += 1
            kb += b
        c[kb] += 1
        b = k
        a2 = k
        yield a - a2
        k, kb = 1, b
        while c[kb] >= kb:
            k += 1
            kb += b
        c[kb] += 1
        b = k
        a = k


def A348441_gen():  # generator of terms
    yield 1
    c, p, a = 1, {1}, 1
    for i in count(3):
        n, na = 1, a
        while na in p:
            n += 1
            na += a
        p.add(na)
        a = n
        if c < n:
            c = n
            yield i


def A348247(n):
    c, b, p = Counter(), 1, prime(n)
    for i in count(1):
        k, kb = 1, b
        while c[kb] >= kb:
            k += 1
            kb += b
        if kb == p:
            return i
        c[kb] += 1
        b = k


def A348353_gen():  # generator of terms.
    p, q, r = 2, 3, 5
    while True:
        if isprime(p * p + q + r) and isprime(p + q * q + r) and isprime(p + q + r * r):
            yield p
        p, q, r = q, r, nextprime(r)


def A307730_gen():  # generator of terms. Greedy algorithm.
    c, b = Counter(), 1
    while True:
        k, kb = 1, b
        while c[kb] >= kb:
            k += 1
            kb += b
        c[kb] += 1
        b = k
        yield kb


def A348442_gen():  # generator of terms
    yield 1
    c, p, a = 1, {1}, 1
    while True:
        n, na = 1, a
        while na in p:
            n += 1
            na += a
        p.add(na)
        a = n
        if c < na:
            c = na
            yield c


def A348443_gen():  # generator of terms
    yield 1
    c, p, a = 1, {1}, 1
    for i in count(2):
        n, na = 1, a
        while na in p:
            n += 1
            na += a
        p.add(na)
        a = n
        if c < na:
            c = na
            yield i


def A348440_gen():  # generator of terms
    yield 1
    c, p, a = 1, {1}, 1
    while True:
        n, na = 1, a
        while na in p:
            n += 1
            na += a
        p.add(na)
        a = n
        if c < n:
            c = n
            yield c


def A088177_gen():  # generator of terms
    yield 1
    yield 1
    p, a = {1}, 1
    while True:
        n = 1
        while n * a in p:
            n += 1
        p.add(n * a)
        a = n
        yield n


def A088178_gen():  # generator of terms
    yield 1
    p, a = {1}, 1
    while True:
        n, na = 1, a
        while na in p:
            n += 1
            na += a
        p.add(na)
        a = n
        yield na


def A099378(n):
    return (lambda x, y: x // gcd(x, y * n))(divisor_sigma(n), divisor_sigma(n, 0))


def A099377(n):
    return (lambda x, y: y * n // gcd(x, y * n))(divisor_sigma(n), divisor_sigma(n, 0))


def A103339(n):
    return (lambda x, y: y * n // gcd(x, y * n))(
        udivisor_sigma(n), udivisor_sigma(n, 0)
    )


def A103340(n):
    return (lambda x, y: x // gcd(x, y * n))(udivisor_sigma(n), udivisor_sigma(n, 0))


def A348411_gen():  # generator of terms
    return filter(
        (
            lambda n: (lambda x, y: 2 * gcd(x, y * n) == x)(
                divisor_sigma(n), divisor_sigma(n, 0)
            )
        ),
        count(1),
    )


def A066411(n):
    b = tuple(comb(n, k) for k in range(n // 2 + 1))
    return len(
        set(
            (
                sum(d[i] * b[i] for i in range(n // 2 + 1))
                for d in partitionpairs(list(range(n + 1)))
            )
        )
    )


def A348338(n):
    m, s = 10**n, set()
    for k in range(m):
        c, k2, kset = 0, k, set()
        while k2 not in kset:
            kset.add(k2)
            c += 1
            k2 = 2 * k2 % m
        s.add(c)
    return len(s)


def A348339(n):
    m, s = 10**n, set()
    for k in range(m):
        c, k2, kset = 0, k, set()
        while k2 not in kset:
            kset.add(k2)
            c += 1
            k2 = k2 * k2 % m
        s.add(c)
    return len(s)


def A260355_T(n, k):  # compute T(n, k)
    if k == 1:
        return n * (n + 1) // 2
    ntuple, count = tuple(range(1, n + 1)), n ** (k + 1)
    for s in combinations_with_replacement(permutations(ntuple, n), k - 2):
        t = list(ntuple)
        for d in s:
            for i in range(n):
                t[i] *= d[i]
        t.sort()
        v = 0
        for i in range(n):
            v += (n - i) * t[i]
        if v < count:
            count = v
    return count


def A219032(n):
    s = str(n * n)
    m = len(s)
    return len(
        set(
            filter(
                lambda x: integer_nthroot(x, 2)[1],
                (int(s[i:j]) for i in range(m) for j in range(i + 1, m + 1)),
            )
        )
    )


def A348467(n):
    s = str(factorial(n))
    m = len(s)
    return len(set(int(s[i:j]) for i in range(m) for j in range(i + 1, m + 1)))


def A120004(n):
    s = str(n)
    m = len(s)
    return len(set(int(s[i:j]) for i in range(m) for j in range(i + 1, m + 1)))


def A348428_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        s = [int(d) for d in str(n)]
        m = len(s)
        if n == Matrix(m, m, lambda i, j: s[(i + j) % m]).det():
            yield n


def A306853_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        s = [int(d) for d in str(n)]
        m = len(s)
        if n == Matrix(m, m, lambda i, j: s[(i - j) % m]).per():
            yield n


def A219325_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        s = [int(d) for d in bin(n)[2:]]
        m = len(s)
        if n == Matrix(m, m, lambda i, j: s[(i - j) % m]).det():
            yield n


def A000108_gen():  # generator of terms
    yield 1
    yield 1
    m = 1
    for n in count(1):
        m = m * (4 * n + 2) // (n + 2)
        yield m


@lru_cache(maxsize=None)
def A000700(n):
    return (
        1
        if n == 0
        else sum(
            (-1) ** (k + 1)
            * A000700(n - k)
            * prod(
                (p ** (e + 1) - 1) // (p - 1) for p, e in factorint(k).items() if p > 2
            )
            for k in range(1, n + 1)
        )
        // n
    )


def A010815(n):
    m = isqrt(24 * n + 1)
    return (
        0
        if m**2 != 24 * n + 1
        else ((-1) ** ((m - 1) // 6) if m % 6 == 1 else (-1) ** ((m + 1) // 6))
    )


if sys.version_info >= (3, 10):

    def A000120(n):
        return n.bit_count()

else:

    def A000120(n):
        return bin(n).count("1")


def A000110_gen():  # generator of terms
    yield 1
    blist, b = (1,), 1
    while True:
        blist = list(accumulate(blist, initial=(b := blist[-1])))
        yield b


def A000110(n):
    return bell(n)


@lru_cache(maxsize=None)
def A000009(n):
    return (
        1
        if n == 0
        else A010815(n)
        + 2 * sum((-1) ** (k + 1) * A000009(n - k**2) for k in range(1, isqrt(n) + 1))
    )


def A007953(n):
    return sum(int(d) for d in str(n))


def A000984_gen():  # generator of terms
    yield 1
    m = 1
    for n in count(0):
        m = m * (4 * n + 2) // (n + 1)
        yield m


def A000578(n):
    return n**3


def A002808(n):
    return composite(n)


def A002808_gen():  # generator of terms
    n, m = 3, 5
    while True:
        for i in range(n + 1, m):
            yield i
        n, m = m, nextprime(m)


def A000961_gen():  # generator of terms
    yield 1
    for n in count(2):
        if len(factorint(n)) == 1:
            yield n


def A002113_gen():  # generator of terms
    return pal10_gen()


def A003415(n):
    return sum((n * e // p for p, e in factorint(n).items())) if n > 1 else 0


def A000265(n):
    return n >> (~n & n - 1).bit_length()


def A001006_gen():  # generator of terms
    yield 1
    yield 1
    m, k = 1, 1
    for n in count(2):
        m, k = k, (k * (2 * n + 1) + (3 * n - 3) * m) // (n + 2)
        yield k


def A000166_gen():  # generator of terms
    m, x = 1, 1
    for n in count(0):
        x, m = x * n + m, -m
        yield x


def A004086(n):
    return int(str(n)[::-1])


def A001414(n):
    return sum(p * e for p, e in factorint(n).items())


def A002144_gen():  # generator of terms
    for n in count(1):
        p = prime(n)
        if not (p - 1) % 4:
            yield p


def A002182_gen():  # generator of terms
    r = 0
    for i in count(1):
        if (d := divisor_count(i)) > r:
            r = d
            yield i


def A001700(n):
    return comb(2 * n + 1, n + 1)


def A001700_gen():  # generator of terms
    b = 1
    for n in count(0):
        yield b
        b = b * (4 * n + 6) // (n + 2)


def A003418(n):
    return prod(p ** integerlog(n, p) for p in sieve.primerange(1, n + 1))


def A000111_gen():  # generator of terms
    yield from (1, 1)
    blist = (0, 1)
    while True:
        yield (blist := tuple(accumulate(reversed(blist), initial=0)))[-1]


def A014137_gen():  # generator of terms
    return accumulate(A000108_gen())


def A014138_gen():  # generator of terms
    return (x - 1 for x in A014137_gen())


def A349866_gen(startvalue=1):  # generator of terms
    return filter(
        lambda m: sum(divisor_sigma(m) % d for d in divisors(m, generator=True)) == m,
        count(max(startvalue, 1)),
    )


def A005349_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: not n % sum((int(d) for d in str(n))), count(max(startvalue, 1))
    )


def A002322(n):
    return reduced_totient(n)


def A006318_gen():  # generator of terms
    m, k = 1, 2
    yield m
    yield k
    for n in count(3):
        m, k = k, (k * (6 * n - 9) - (n - 3) * m) // n
        yield k


def A007913(n):
    return prod(p for p, e in factorint(n).items() if e % 2)


def A000178_gen():  # generator of terms
    yield 1
    n, m = 1, 1
    for i in count(1):
        m *= i
        n *= m
        yield n


def A010888(n):
    return 1 + (n - 1) % 9 if n else 0


def A000523(n):
    return n.bit_length() - 1


def A000583(n):
    return n**4


def A000593(n):
    return prod((p ** (e + 1) - 1) // (p - 1) for p, e in factorint(n).items() if p > 2)


def A064413_gen():  # generator of terms
    yield 1
    yield 2
    l, s, b = 2, 3, set()
    while True:
        i = s
        while True:
            if not i in b and gcd(i, l) > 1:
                yield i
                l = i
                b.add(i)
                while s in b:
                    b.remove(s)
                    s += 1
                break
            i += 1


def A006218(n):
    return -((s := isqrt(n)) ** 2) + (sum(n // k for k in range(1, s + 1)) << 1)


def A001694_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: n == 1 or min(factorint(n).values()) > 1, count(max(startvalue, 1))
    )


def A019565(n):
    return (
        prod(prime(i + 1) for i, v in enumerate(bin(n)[:1:-1]) if v == "1")
        if n > 0
        else 1
    )


def A006882(n):
    return factorial2(n)


if sys.version_info >= (3, 10):

    def A005187(n):
        return (n << 1) - n.bit_count()

else:

    def A005187(n):
        return (n << 1) - bin(n).count("1")


def A001003_gen():  # generator of terms
    m, k = 1, 1
    yield m
    yield k
    for n in count(3):
        m, k = k, (k * (6 * n - 9) - (n - 3) * m) // n
        yield k


def A005836(n):
    return int(format(n - 1, "b"), 3)


def A002496_gen():  # generator of terms
    return filter(
        isprime, (n + 1 for n in accumulate(count(0), lambda x, y: x + 2 * y - 1))
    )


def A052382_gen(startvalue=1):  # generator of terms
    return filter(lambda n: "0" not in str(n), count(max(startvalue, 1)))


def A003714(n):
    tlist, s = [1, 2], 0
    while tlist[-1] + tlist[-2] <= n:
        tlist.append(tlist[-1] + tlist[-2])
    for d in tlist[::-1]:
        s *= 2
        if d <= n:
            s += 1
            n -= d
    return s


def A026741(n):
    return n if n & 1 else n >> 1


def A006567_gen():  # generator of terms
    return filter(
        lambda p: str(p) != str(p)[::-1] and isprime(int(str(p)[::-1])),
        (prime(n) for n in count(1)),
    )


def A006370(n):
    q, r = divmod(n, 2)
    return 3 * n + 1 if r else q


def A151800(n):
    return nextprime(n)


def A051903(n):
    return max(factorint(n).values()) if n > 1 else 0


def A001850_gen():  # generator of terms
    m, k = 1, 3
    yield m
    yield k
    for n in count(2):
        m, k = k, (k * (6 * n - 3) - (n - 1) * m) // n
        yield k


def A001850(n):
    return sum(comb(n, k) * comb(n + k, k) for k in range(n + 1))


def A002293(n):
    return comb(4 * n, n) // (3 * n + 1)


def A002293_gen():  # generator of terms
    m = 1
    yield m
    for n in count(0):
        m = (
            m
            * 4
            * (4 * n + 3)
            * (4 * n + 2)
            * (4 * n + 1)
            // ((3 * n + 2) * (3 * n + 3) * (3 * n + 4))
        )
        yield m


def A098550_gen():  # generator of terms
    yield from [1, 2, 3]
    l1, l2, s, b = 3, 2, 4, set()
    while True:
        i = s
        while True:
            if not i in b and gcd(i, l1) == 1 and gcd(i, l2) > 1:
                yield i
                l2, l1 = l1, i
                b.add(i)
                while s in b:
                    b.remove(s)
                    s += 1
                break
            i += 1


def A001220_gen():  # generator of terms
    return filter(lambda p: pow(2, p - 1, p * p) == 1, (prime(n) for n in count(1)))


def A047999_T(n, k):
    return int(not ~n & k)


@lru_cache(maxsize=None)
def A001175(n):
    if n == 1:
        return 1
    f = factorint(n).items()
    if len(f) > 1:
        return lcm(*(A001175(a**b) for a, b in f))
    else:
        k, x = 1, (1, 1)
        while x != (0, 1):
            k += 1
            x = (x[1], (x[0] + x[1]) % n)
        return k


def A066272(n):
    return (
        len([d for d in divisors(2 * n) if n > d >= 2 and n % d])
        + len([d for d in divisors(2 * n - 1) if n > d >= 2 and n % d])
        + len([d for d in divisors(2 * n + 1) if n > d >= 2 and n % d])
    )


@lru_cache(maxsize=None)
def A002321(n):
    if n == 0:
        return 0
    c, j = n, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * A002321(k1)
        j, k1 = j2, n // j2
    return j - c


def A007376_gen():  # generator of terms
    return (int(d) for n in count(0) for d in str(n))


def A054632_gen():  # generator of terms
    return accumulate(A007376_gen())


def A127353_gen():  # generator of terms
    return islice(A007376_gen(), 2, None, 2)


def A127050_gen():  # generator of terms
    return islice(A007376_gen(), 1, None, 2)


def A127950_gen():  # generator of terms
    return islice(A007376_gen(), 2, None, 8)


def A347345_gen():  # generator of terms
    return filter(
        lambda k: set(str(k * (k + 1) // 2)) <= {"1", "3", "5", "7", "9"},
        (int("".join(d)) for l in count(1) for d in product("13579", repeat=l)),
    )


def A132739(n):
    a, b = divmod(n, 5)
    while b == 0:
        a, b = divmod(a, 5)
    return 5 * a + b


def A349487(n):
    a, b = divmod(n * n - 25, 5)
    while b == 0:
        a, b = divmod(a, 5)
    return 5 * a + b


def A349791(n):
    b = primepi(n**2) + primepi((n + 1) ** 2) + 1
    return (prime(b // 2) + prime((b + 1) // 2)) // 2 if b % 2 else prime(b // 2)


def A000188(n):
    return isqrt(n // numbercore(n))


def A020449_gen():  # generator of terms
    return filter(isprime, (int(format(n, "b")) for n in count(1)))


def A033676(n):
    d = divisors(n)
    return d[(len(d) - 1) // 2]


def A047994(n):
    return prod(p**e - 1 for p, e in factorint(n).items())


def d(n, m):
    return not n % m


def A007678(n):
    return (
        1176 * d(n, 12) * n
        - 3744 * d(n, 120) * n
        + 1536 * d(n, 18) * n
        - d(n, 2) * (5 * n**3 - 42 * n**2 + 40 * n + 48)
        - 2304 * d(n, 210) * n
        + 912 * d(n, 24) * n
        - 1728 * d(n, 30) * n
        - 36 * d(n, 4) * n
        - 2400 * d(n, 42) * n
        - 4 * d(n, 6) * n * (53 * n - 310)
        - 9120 * d(n, 60) * n
        - 3744 * d(n, 84) * n
        - 2304 * d(n, 90) * n
        + 2 * n**4
        - 12 * n**3
        + 46 * n**2
        - 84 * n
    ) // 48 + 1


def A063990_gen(startvalue=2):  # generator of terms
    return filter(
        lambda n: divisor_sigma(n) - 2 * n
        and not divisor_sigma(divisor_sigma(n) - n) - divisor_sigma(n),
        count(max(startvalue, 2)),
    )


def A051674(n):
    return prime(n) ** prime(n)


def A001951(n):
    return isqrt(2 * n**2)


def A000587_gen():  # generator of terms
    yield 1
    yield -1
    blist, b = [1], -1
    while True:
        blist = list(accumulate([b] + blist))
        b = -blist[-1]
        yield b


def A003132(n):
    return sum(int(d) ** 2 for d in str(n))


def A003601_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: not sum(divisors(n)) % divisor_count(n), count(max(startvalue, 1))
    )


@lru_cache(maxsize=None)
def A002088(n):  # based on second formula in A018805
    if n == 0:
        return 0
    c, j = 0, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * (2 * A002088(k1) - 1)
        j, k1 = j2, n // j2
    return (n * (n - 1) - c + j) // 2


def A045917(n):
    return sum(1 for i in range(2, n + 1) if isprime(i) and isprime(2 * n - i))


def A019546_gen():  # generator of terms
    return filter(
        lambda n: set(str(n)) <= {"2", "3", "5", "7"}, (prime(n) for n in count(1))
    )


def A011540_gen(startvalue=0):  # generator of terms
    return filter(lambda n: "0" in str(n), count(max(startvalue, 0)))


def A014963(n):
    y = factorint(n)
    return list(y.keys())[0] if len(y) == 1 else 1


def A115004(n):
    return n**2 + sum(
        totient(i) * (n + 1 - i) * (2 * n + 2 - i) for i in range(2, n + 1)
    )


def A316524(n):
    fs = [primepi(p) for p in factorint(n, multiple=True)]
    return sum(fs[::2]) - sum(fs[1::2])


def A048050(n):
    return 0 if n == 1 else divisor_sigma(n) - n - 1


def A349806(n):
    for i in count(n**2 + (n % 2) + 1, 2):
        if len(fs := factorint(i)) == 2 == sum(fs.values()):
            return i - n**2


def A099610(n):
    for i in count(n**2 + (n % 2) + 1, 2):
        if len(fs := factorint(i)) == 2 == sum(fs.values()):
            return i


def A348762(n):
    a, b = divmod(n * n - 64, 2)
    while b == 0:
        a, b = divmod(a, 2)
    return 2 * a + b


def A069834(n):
    a, b = divmod(n * n + n, 2)
    while b == 0:
        a, b = divmod(a, 2)
    return 2 * a + b


def A328447(n):
    if n == 0:
        return 0
    s = str(n)
    l, s = len(s), "".join(sorted(s.replace("0", "")))
    return int(s[0] + "0" * (l - len(s)) + s[1:])


def A005188_gen():  # generator of terms
    for k in range(1, 40):
        a = tuple(i**k for i in range(10))
        yield from (
            x[0]
            for x in sorted(
                filter(
                    lambda x: x[0] > 0
                    and tuple(int(d) for d in sorted(str(x[0]))) == x[1],
                    (
                        (sum(map(lambda y: a[y], b)), b)
                        for b in combinations_with_replacement(range(10), k)
                    ),
                )
            )
        )


def A031443_gen():  # generator of terms
    for n in count(1):
        yield from (
            int("1" + "".join(p), 2)
            for p in multiset_permutations("0" * n + "1" * (n - 1))
        )


def A071925_gen():  # generator of terms
    for n in count(1):
        yield from (
            int("1" + "".join(p))
            for p in multiset_permutations("0" * n + "1" * (n - 1))
        )


def A349929_gen():  # generator of terms
    for n in count(3, 3):
        if 3 * gcd(comb(n * (n * (n + 6) - 6) + 2, 6 * n * (n - 1) + 3), n**3) == n**3:
            yield n


def A349509(n):
    return n**3 // gcd(comb(n * (n * (n + 6) - 6) + 2, 6 * n * (n - 1) + 3), n**3)


def A099611(n):
    for i in count(n**2 - (n % 2) - 1, -2):
        fs = factorint(i)
        if len(fs) == 2 == sum(fs.values()):
            return i


def A349809(n):
    for i in count(n**2 - (n % 2) - 1, -2):
        fs = factorint(i)
        if len(fs) == 2 == sum(fs.values()):
            return n**2 - i


def A002982_gen(startvalue=1):  # generator of terms
    return filter(lambda n: isprime(factorial(n) - 1), count(max(startvalue, 1)))


def A000058_gen():  # generator of terms
    yield (a := 2)
    while True:
        a = a * (a - 1) + 1
        yield a


def A151799(n):
    return prevprime(n)


def A000078_gen():  # generator of terms
    b = [0, 0, 0, 1]
    yield from b
    while True:
        yield (c := sum(b))
        b = b[1:] + [c]


def A002054(n):
    return comb(2 * n + 1, n - 1)


def A006720_gen():  # generator of terms
    b = [1, 1, 1, 1]
    yield from b
    while True:
        yield (c := (b[-1] * b[-3] + b[-2] ** 2) // b[-4])
        b = b[1:] + [c]


def A033677(n):
    return (lambda d: d[len(d) // 2])(divisors(n))


def A078972_gen():  # generator of terms
    for n in count(0):
        yield from sorted(
            prod(p)
            for p in combinations_with_replacement(
                sieve.primerange(10**n, 10 ** (n + 1)), 2
            )
        )


def A005493_gen():  # generator of terms
    blist, b = [1], 1
    while True:
        blist = list(accumulate([b] + blist))
        b = blist[-1]
        yield blist[-2]


def A188014(n):
    return (
        int((isqrt(5 * n**2) + n) // 2 - (isqrt(5 * (n - 4) ** 2) + n) // 2 - 4)
        if n > 3
        else 1 - (n % 2)
    )


def A348209(n):
    if n > 2 and bin(n).count("1") == 1:
        return 0
    k, m, n1, n2, n3 = 1, 2, n ** (n - 2), n ** (n - 1), n**n
    while m < n2:
        k += 1
        m = (2 * m) % n3
    while k <= n3:
        if m >= n1:
            a = ispandigital0(m, n)
            if a[0] and ((not a[1]) or m >= n2):
                return k
        k += 1
        m = (2 * m) % n3
    return 0


def A000978_gen():  # generator of terms
    return filter(lambda p: isprime(((1 << p) + 1) // 3), (prime(n) for n in count(2)))


def A007500_gen():  # generator of terms
    return filter(lambda p: isprime(int(str(p)[::-1])), (prime(n) for n in count(1)))


def A010784_gen(startvalue=0):  # generator of terms
    return filter(lambda n: len(set(str(n))) == len(str(n)), count(max(startvalue, 0)))


def A050278_gen():  # generator of terms
    return (
        int(e + "".join(d))
        for e in "123456789"
        for d in permutations("0123456789".replace(e, ""), 9)
    )


def A071924(n):
    return primepi(
        max(
            primefactors(
                next(
                    islice(
                        (
                            int(e + "".join(d))
                            for e in "123456789"
                            for d in permutations("0123456789".replace(e, ""), 9)
                        ),
                        n - 1,
                        None,
                    )
                )
            )
        )
    )


def A071924_gen():  # generator of terms
    return (
        primepi(max(primefactors(m)))
        for m in (
            int(e + "".join(d))
            for e in "123456789"
            for d in permutations("0123456789".replace(e, ""), 9)
        )
    )


def A000538(n):
    return n * (n**2 * (n * (6 * n + 15) + 10) - 1) // 30


def A330151(n):
    return 8 * n * (n**2 * (n * (6 * n + 15) + 10) - 1) // 15


def A259317(n):
    return n * (n * (n**2 * (n * (16 * n + 48) + 40) - 11) - 3) // 45


def A254640(n):
    return (
        n
        * (
            n
            * (
                n
                * (
                    n * (n * (n * (n * (n * (10 * n + 135) + 720) + 1890) + 2394) + 945)
                    - 640
                )
                - 450
            )
            + 36
        )
        // 5040
    )


def A002109_gen():  # generator of terms
    return accumulate((k**k for k in count(0)), mul)


def A002109(n):
    return prod(k**k for k in range(1, n + 1))


@lru_cache(maxsize=None)
def A018805(n):  # based on second formula in A018805
    if n == 0:
        return 0
    c, j = 1, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * A018805(k1)
        j, k1 = j2, n // j2
    return n * (n - 1) - c + j


def A023194_gen():  # generator of terms
    yield 2
    yield from filter(lambda n: isprime(divisor_sigma(n)), (n**2 for n in count(1)))


def A010057(n):
    return int(integer_nthroot(n, 3)[1])


def A001286(n):
    return (n - 1) * factorial(n) // 2


def A001286_gen():  # generator of terms
    b = 1
    yield b
    for n in count(2):
        b = b * n * (n + 1) // (n - 1)
        yield b


def A007602_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: not ("0" in str(n) or n % prod(int(d) for d in str(n))),
        count(max(startvalue, 1)),
    )


def A001608_gen():  # generator of terms
    a, b, c = 3, 0, 2
    yield from (a, b, c)
    while True:
        a, b, c = b, c, a + b
        yield c


def A031971(n):
    return harmonic(n, -n)


def A348470(n):
    return 1 if n == 1 else min(primefactors(next(islice(A064413_gen(), n - 1, None))))


def A348470_gen():  # generator of terms
    return (min(primefactors(n)) if n > 1 else 1 for n in A064413_gen())


def A349662(n):
    return 0 if n <= 1 else isqrt(n**3 - 1) - n


def A349993(n):
    return isqrt(n**3) - n + 1


def A349792_gen():  # generator of terms
    p1 = 0
    for n in count(1):
        p2 = primepi((n + 1) ** 2)
        b = p1 + p2 + 1
        if b % 2:
            p = prime(b // 2)
            q = nextprime(p)
            if p + q == 2 * n * (n + 1):
                yield n
        p1 = p2


def A308533_gen(startvalue=3):  # generator of terms
    for n in count(max(startvalue, 3)):
        a = antidivisors(n)
        if int("".join(str(s) for s in a)) % sum(a) == 0:
            yield n


def A130846(n):
    return int("".join(str(s) for s in antidivisors(n)))


def A003278(n):
    return int(format(n - 1, "b"), 3) + 1


def A027868_gen():  # generator of terms
    yield from [0] * 5
    p5 = 0
    for n in count(5, 5):
        p5 += multiplicity(5, n)
        yield from [p5] * 5


def A187950(n):
    return int((isqrt(5 * (n + 4) ** 2) + n) // 2 - (isqrt(5 * n**2) + n) // 2 - 4)


def A018900_gen():  # generator of terms
    return (2**a + 2**b for a in count(1) for b in range(a))


@lru_cache(maxsize=None)
def A005728(n):  # based on second formula in A018805
    if n == 0:
        return 1
    c, j = -2, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * (2 * A005728(k1) - 3)
        j, k1 = j2, n // j2
    return (n * (n - 1) - c + j) // 2


def A007629_gen(startvalue=10):  # generator of terms
    for n in count(max(startvalue, 10)):
        x = [int(d) for d in str(n)]
        y = sum(x)
        while y < n:
            x, y = x[1:] + [y], 2 * y - x[0]
        if y == n:
            yield n


def A007774_gen(startvalue=1):  # generator of terms
    return filter(lambda n: len(primefactors(n)) == 2, count(max(startvalue, 1)))


def A009994_gen():  # generator of terms
    yield 0
    yield from (
        int("".join(i))
        for l in count(1)
        for i in combinations_with_replacement("123456789", l)
    )


def A004159(n):
    return sum(int(d) for d in str(n * n))


def A005917(n):
    return n * (n * (4 * n - 6) + 4) - 1


def A031347(n):
    while n > 9:
        n = prod(int(d) for d in str(n))
    return n


def A069010(n):
    return sum(1 for d in bin(n)[2:].split("0") if len(d))


def A005823(n):
    return 2 * int(format(n - 1, "b"), 3)


def A014311_gen():  # generator of terms
    return (2**a + 2**b + 2**c for a in count(2) for b in range(1, a) for c in range(b))


def A349783(n):
    return sum(abs(stirling(2 * n, j, kind=1)) for j in range(n + 1))


def A011971_gen():  # generator of terms
    blist = [1]
    yield 1
    while True:
        b = blist[-1]
        blist = list(accumulate([b] + blist))
        yield from blist


def A046936_gen():  # generator of terms
    yield 0
    blist = [1, 1]
    yield from blist
    while True:
        b = blist[-1]
        blist = list(accumulate([b] + blist))
        yield from blist


def A349960(n):
    if n <= 2:
        return 3 - n
    a, b = "", ""
    for i in count(1, 2):
        a += str(i)
        b += str(i + 1)
        ai, bi = int(a), int(b)
        if len(a) + n - 2 == len(b):
            return bi // ai
        m = 10 ** (n - 2 - len(b) + len(a))
        lb = bi * m // (ai + 1)
        ub = (bi + 1) * m // ai
        if lb == ub:
            return lb


def A349958(n):
    for j in range(n + 1):
        for k in range(j + 1):
            if comb(j, k) % n == 0:
                return j


def A045918(n):
    return int(
        "".join(
            [str(len(m.group(0))) + m.group(0)[0] for m in finditer(r"(\d)\1*", str(n))]
        )
    )


def A001602(n):
    a, b, i, p = 0, 1, 1, prime(n)
    while b % p:
        a, b, i = b, (a + b) % p, i + 1
    return i


def A014577(n):
    s = bin(n + 1)[2:]
    m = len(s)
    i = s[::-1].find("1")
    return 1 - int(s[m - i - 2]) if m - i - 2 >= 0 else 1


def A081145_gen():  # generator of terms
    yield from [1, 2]
    l, s, b1, b2 = 2, 3, set(), set([1])
    for n in count(3):
        i = s
        while True:
            m = abs(i - l)
            if not (i in b1 or m in b2):
                yield i
                b1.add(i)
                b2.add(m)
                l = i
                while s in b1:
                    b1.remove(s)
                    s += 1
                break
            i += 1


def A000127(n):
    return n * (n * (n * (n - 6) + 23) - 18) // 24 + 1


def A007407(n):
    return sum(Fraction(1, k**2) for k in range(1, n + 1)).denominator


def A039724(n):
    s, q = "", n
    while q >= 2 or q < 0:
        q, r = divmod(q, -2)
        if r < 0:
            q += 1
            r += 2
        s += str(r)
    return int(str(q) + s[::-1])


def A065855(n):
    return 0 if n < 4 else n - primepi(n) - 1


def A004290(n):
    if n > 0:
        for i in range(1, 2**n):
            x = int(bin(i)[2:])
            if not x % n:
                return x
    return 0


def A006521_gen(startvalue=1):
    return filter(lambda n: pow(2, n, n) == n - 1, count(max(startvalue, 1)))


def A124240_gen(startvalue=1):
    return filter(lambda n: n % reduced_totient(n) == 0, count(max(startvalue, 1)))


def A289257_gen(startvalue=1):
    return filter(
        lambda n: 2 * n % reduced_totient(2 * n) == 0 and pow(2, n, n) == n - 1,
        count(max(startvalue, 1)),
    )


def A306302(n):
    return 2 * n * (n + 1) + sum(
        totient(i) * (n + 1 - i) * (2 * n + 2 - i) for i in range(2, n + 1)
    )


def A307720_gen():  # generator of terms. Greedy algorithm
    yield 1
    c, b = Counter(), 1
    while True:
        k, kb = 1, b
        while c[kb] >= kb:
            k += 1
            kb += b
        c[kb] += 1
        b = k
        yield k


def A007569(n):
    return (
        2
        if n == 2
        else n
        * (
            42 * (not n % 12)
            - 144 * (not n % 120)
            + 60 * (not n % 18)
            - 96 * (not n % 210)
            + 35 * (not n % 24)
            - 38 * (not n % 30)
            - 82 * (not n % 42)
            - 330 * (not n % 60)
            - 144 * (not n % 84)
            - 96 * (not n % 90)
        )
        + (
            n**4
            - 6 * n**3
            + 11 * n**2
            + 18 * n
            - (not n % 2) * (5 * n**3 - 45 * n**2 + 70 * n - 24)
            - 36 * (not n % 4) * n
            - 4 * (not n % 6) * n * (45 * n - 262)
        )
        // 24
    )


def A003401_gen(startvalue=1):
    return filter(
        lambda n: format(totient(n), "b").count("1") == 1, count(max(startvalue, 1))
    )


def A014127_gen():
    return filter(lambda p: pow(3, p - 1, p * p) == 1, (prime(n) for n in count(1)))


def A031346(n):
    mp = 0
    while n > 9:
        n = prod(int(d) for d in str(n))
        mp += 1
    return mp


def A029967_gen():
    return filter(lambda n: is_pal(n, 12), pal10_gen())


def A029968_gen():
    return filter(lambda n: is_pal(n, 13), pal10_gen())


def A049445_gen(startvalue=1):
    return filter(
        lambda n: not n % sum([int(d) for d in bin(n)[2:]]), count(max(startvalue, 1))
    )


def A348623_gen():  # generator of terms
    n = 1
    yield n
    while True:
        n = prod(q + 1 for p, q in factorint(n).items() if p > 2)
        yield n


def A349775_helper(n):  # generate sums of 2 subsets A,B with |A|,|B| >= 2 for A349775
    for l in range(2, n + 2):
        for a in combinations(range(n + 1), l):
            amax = max(a)
            bmax = min(amax, n - amax)
            for lb in range(2, bmax + 2):
                for b in combinations(range(bmax + 1), lb):
                    yield tuple(sorted(set(x + y for x in a for y in b)))


def A349775(n):
    c = Counter()
    for s in set(A349775_helper(n)):
        c[len(s)] += 1
    for i in range(n + 1, 1, -1):
        if c[i] < comb(n + 1, i):
            return i


def A002779_gen():
    return filter(lambda n: str(n) == str(n)[::-1], (n**2 for n in count(0)))


def A004185(n):
    return int("".join(sorted(str(n))).replace("0", "")) if n > 0 else 0


def A029731_gen():
    return filter(lambda n: is_pal(n, 16), pal10_gen())


def A029804_gen():
    return filter(lambda n: is_pal(n, 8), pal10_gen())


def A056608(n):
    return min(factorint(composite(n)))


def A006261(n):
    return (n * (n * (n * (n * (n - 5) + 25) + 5) + 94) + 120) // 120


def A006561(n):
    return (
        0
        if n == 2
        else n
        * (
            42 * (not n % 12)
            - 144 * (not n % 120)
            + 60 * (not n % 18)
            - 96 * (not n % 210)
            + 35 * (not n % 24)
            - 38 * (not n % 30)
            - 82 * (not n % 42)
            - 330 * (not n % 60)
            - 144 * (not n % 84)
            - 96 * (not n % 90)
        )
        + (
            n**4
            - 6 * n**3
            + 11 * n**2
            - 6 * n
            - (not n % 2) * (5 * n**3 - 45 * n**2 + 70 * n - 24)
            - 36 * (not n % 4) * n
            - 4 * (not n % 6) * n * (45 * n - 262)
        )
        // 24
    )


def A001129_gen():  # generator of terms
    r1, r2 = 1, 0
    yield r2
    yield r1
    while True:
        l, r2 = r1 + r2, r1
        r1 = int(str(l)[::-1])
        yield l


def A034838_gen():  # generator of terms
    for g in count(1):
        for n in product("123456789", repeat=g):
            s = "".join(n)
            m = int(s)
            if not any(m % int(d) for d in s):
                yield m


def A076479(n):
    return mobius(prod(primefactors(n)))


def A229037_gen():  # generator of terms
    blist = []
    for n in count(0):
        i, j, b = 1, 1, set()
        while n - 2 * i >= 0:
            b.add(2 * blist[n - i] - blist[n - 2 * i])
            i += 1
            while j in b:
                j += 1
        blist.append(j)
        yield j


def A034709_gen(startvalue=1):
    return filter(lambda n: n % 10 and not n % (n % 10), count(max(startvalue, 1)))


def A051802(n):
    if n == 0:
        return 1
    while n > 9:
        n = prod(int(d) for d in str(n) if d != "0")
    return n


def A054977(n):
    return 1 if n else 2


def A084937_gen():  # generator of terms
    yield from [1, 2]
    l1, l2, s, b = 2, 1, 3, set()
    while True:
        i = s
        while True:
            if not i in b and gcd(i, l1) == 1 and gcd(i, l2) == 1:
                yield i
                l2, l1 = l1, i
                b.add(i)
                while s in b:
                    b.remove(s)
                    s += 1
                break
            i += 1


def A099165_gen():
    return filter(lambda n: is_pal(n, 32), pal10_gen())


def A133500(n):
    s = str(n)
    l = len(s)
    m = int(s[-1]) if l % 2 else 1
    for i in range(0, l - 1, 2):
        m *= int(s[i]) ** int(s[i + 1])
    return m


def A023109(n):
    if n > 0:
        k = 0
        while True:
            m = k
            for i in range(n):
                if str(m) == str(m)[::-1]:
                    break
                m += int(str(m)[::-1])
            else:
                if str(m) == str(m)[::-1]:
                    return k
            k += 1
    else:
        return 0


def A023330_gen():
    return filter(
        lambda p: all((isprime(2**m * (p + 1) - 1) for m in range(1, 6))),
        (prime(n) for n in count(1)),
    )


def A071321(n):
    fs = factorint(n, multiple=True)
    return sum(fs[::2]) - sum(fs[1::2])


def A290447(n):
    p, p2 = set(), set()
    for b, c, d in combinations(range(1, n), 3):
        e = b + d - c
        f1, f2, g = (
            Fraction(b * d, e),
            Fraction(b * d * (c - b) * (d - c), e**2),
            (n - 1) * e - 2 * b * d,
        )
        for i in range(n - d):
            if 2 * i * e < g:
                p2.add((i + f1, f2))
            elif 2 * i * e == g:
                p.add(f2)
            else:
                break
    return len(p) + 2 * len(p2)


def A000387_gen():  # generator of terms
    m, x = 1, 0
    for n in count(0):
        x, m = x * n + m * (n * (n - 1) // 2), -m
        yield x


def A003893_gen():  # generator of terms
    (
        a,
        b,
    ) = (
        0,
        1,
    )
    yield a
    while True:
        a, b = b, (a + b) % 10
        yield a


def A001917(n):
    p = prime(n)
    return 1 if n == 2 else (p - 1) // n_order(2, p)


def A007540_gen():  # generator of terms
    for n in count(1):
        p, m = prime(n), 1
        p2 = p * p
        for i in range(2, p):
            m = (m * i) % p2
        if m == p2 - 1:
            yield p


def A027870(n):
    return str(2**n).count("0")


def A029955_gen():
    return pal_gen(9)


def A061910_gen(startvalue=1):
    return filter(
        lambda n: is_square(sum(int(d) for d in str(n * n))), count(max(startvalue, 1))
    )


def A006721_gen():  # generator of terms
    blist = [1, 1, 1, 1, 1]
    yield from blist
    for n in count(5):
        blist = blist[1:] + [
            (blist[-1] * blist[-4] + blist[-2] * blist[-3]) // blist[-5]
        ]
        yield blist[-1]


def A087062_T(n, k):
    return lunar_mul(n, k)


def A007488_gen():
    return filter(lambda p: is_square(int(str(p)[::-1])), (prime(n) for n in count(1)))


def A059758_gen():  # generator of terms
    for l in count(1):
        for a in "1379":
            for b in "0123456789":
                if a != b and isprime(p := int((a + b) * l + a)):
                    yield p


def A175046(n):
    return int(
        "".join(
            d + "1" if "1" in d else d + "0"
            for d in split("(0+)|(1+)", bin(n)[2:])
            if d != "" and d != None
        ),
        2,
    )


def A228407_gen():  # generator of terms
    yield from [0, 11]
    l, s, b = Counter("11"), 1, {11}
    while True:
        i = s
        while True:
            if i not in b:
                li, o = Counter(str(i)), 0
                for d in (l + li).values():
                    if d % 2:
                        if o > 0:
                            break
                        o += 1
                else:
                    yield i
                    l = li
                    b.add(i)
                    while s in b:
                        b.remove(s)
                        s += 1
                    break
            i += 1


def A317081(n):
    if n == 0:
        return 1
    c = 0
    for d in partitions(n):
        s = set(d.values())
        if len(s) == max(s):
            c += 1
    return c


def A000979_gen():
    return filter(isprime, ((2 ** prime(n) + 1) // 3 for n in count(2)))


def A004094(n):
    return int(str(2**n)[::-1])


def A029954_gen():
    return pal_gen(7)


def A036691(n):
    return factorial(composite(n)) // primorial(primepi(composite(n))) if n > 0 else 1


def A054377_gen(startvalue=2):
    return filter(
        lambda n: sum(n / p for p in primefactors(n)) + 1 == n,
        count(max(startvalue, 2)),
    )


def A227349(n):
    return prod(len(d) for d in split("0+", bin(n)[2:]) if d) if n > 0 else 1


def A000540(n):
    return n * (n**2 * (n**2 * (n * (6 * n + 21) + 21) - 7) + 1) // 42


def A034947(n):
    s = bin(n)[2:]
    m = len(s)
    i = s[::-1].find("1")
    return 1 - 2 * int(s[m - i - 2]) if m - i - 2 >= 0 else 1


def A049060(n):
    return prod((p ** (e + 1) - 2 * p + 1) // (p - 1) for p, e in factorint(n).items())


@lru_cache(maxsize=None)
def A015614(n):  # based on second formula in A018805
    if n == 0:
        return -1
    c, j = 2, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * (2 * A015614(k1) + 1)
        j, k1 = j2, n // j2
    return (n * (n - 1) - c + j) // 2


def A045875(n):
    l, x = [str(d) * n for d in range(10)], 1
    for m in count(0):
        s = str(x)
        for k in l:
            if k in s:
                return m
        x *= 2


def A080670(n):
    return (
        1
        if n == 1
        else int(
            "".join([str(y) for x in sorted(factorint(n).items()) for y in x if y != 1])
        )
    )


def A006590(n):
    return (lambda m: n + 2 * sum((n - 1) // k for k in range(1, m + 1)) - m * m)(
        isqrt(n - 1)
    )


def A006794_gen():  # generator of terms
    p, q = 2, 2
    while True:
        if isprime(q - 1):
            yield p
        p = nextprime(p)
        q *= p


def A036229(n):
    k, r, m = (10**n - 1) // 9, 2**n - 1, 0
    while m <= r:
        t = k + int(bin(m)[2:])
        if isprime(t):
            return t
        m += 1
    return -1


def A233466_gen(startvalue=1):
    return filter(
        lambda n: 2 * totient(n) == n - 5,
        count(max(startvalue + 1 - startvalue % 2, 1), 2),
    )


def A078971_gen():  # generator of terms
    for t in count(0):
        yield (2 ** (2 * t) - 1) // 3
        yield from ((2 ** (2 * t + 1) + 2 ** (2 * j + 1) - 1) // 3 for j in range(t))


def A048054(n):
    return len(
        [p for p in primerange(10 ** (n - 1), 10**n) if isprime(int(str(p)[::-1]))]
    )


def A059729(n):
    s = [int(d) for d in str(n)]
    l = len(s)
    t = [0] * (2 * l - 1)
    for i in range(l):
        for j in range(l):
            t[i + j] = (t[i + j] + s[i] * s[j]) % 10
    return int("".join(str(d) for d in t))


if sys.version_info >= (3, 10):

    def A159918(n):
        return n * n.bit_count()

else:

    def A159918(n):
        return bin(n * n).count("1")


def A061712(n):
    l, k = n - 1, 2**n
    while True:
        for d in combinations(range(l - 1, -1, -1), l - n + 1):
            m = k - 1 - sum(2 ** (e) for e in d)
            if isprime(m):
                return m
        l += 1
        k *= 2


def A110566(n):
    return lcm([k for k in range(1, n + 1)]) // harmonic(n).q


def A256630_gen():  # generator of terms
    for l in count(0):
        for a in ("1", "2", "3", "4"):
            for b in product("01234", repeat=l):
                for c in ("0", "1", "2"):
                    s = a + "".join(b) + c
                    if "0" in s and "4" in s:
                        n = int(s)
                        s2 = set(str(n**2))
                        if {"0", "4"} <= s2 <= {"0", "1", "2", "3", "4"}:
                            yield n


def A007608(n):
    s, q = "", n
    while q >= 4 or q < 0:
        q, r = divmod(q, -4)
        if r < 0:
            q += 1
            r += 4
        s += str(r)
    return int(str(q) + s[::-1])


def A000139_gen():  # generator of terms
    b = 2
    yield b
    for n in count(1):
        b = 3 * (3 * n - 2) * (3 * n - 1) * b // (2 * n + 2) // (2 * n + 1)
        yield b


def A000139(n):
    return 2 if n == 0 else 2 * comb(3 * n, n - 1) // n // (n + 1)


def A065197_gen(startvalue=1):
    return filter(
        lambda n: n
        == reduce(lambda m, k: m + (k if (m // k) % 2 else -k), range(n, 1, -1), n),
        count(max(startvalue, 1)),
    )


def A014847_gen():  # generator of terms
    b = 1
    for n in count(1):
        if not b % n:
            yield n
        b = b * (4 * n + 2) // (n + 2)


def A050486(n):
    return (2 * n + 7) * comb(n + 6, 6) // 7


def A053347(n):
    return (n + 4) * comb(n + 7, 7) // 4


def A057147(n):
    return n * sum(int(d) for d in str(n))


def A063655(n):
    d = divisors(n)
    l = len(d)
    return d[(l - 1) // 2] + d[l // 2]


def A074832_gen():
    return filter(
        lambda p: isprime(int(bin(p)[:1:-1], 2)), (prime(n) for n in count(1))
    )


def A175498_gen():  # generator of terms
    yield from [1, 2]
    l, s, b1, b2 = 2, 3, set(), {1}
    for n in count(3):
        i = s
        while True:
            if not (i in b1 or i - l in b2):
                yield i
                b1.add(i)
                b2.add(i - l)
                l = i
                while s in b1:
                    b1.remove(s)
                    s += 1
                break
            i += 1


def A000475_gen():  # generator of terms
    m, x = 1, 0
    for n in count(4):
        x, m = x * n + m * comb(n, 4), -m
        yield x


def A003684(n):
    return len(
        [
            p
            for p in primerange(10 ** (n - 1), 10**n)
            if len(set(str(p))) == len(str(p)) and isprime(int(str(p)[::-1]))
        ]
    )


def A007497_gen():
    return accumulate(repeat(2), lambda x, _: divisor_sigma(x))


def A031877_gen():  # generator of terms
    for n in count(1):
        if n % 10:
            s1 = str(n)
            s2 = s1[::-1]
            if s1 != s2 and not n % int(s2):
                yield n


def A038189(n):
    s = bin(n)[2:]
    m = len(s)
    i = s[::-1].find("1")
    return int(s[m - i - 2]) if m - i - 2 >= 0 else 0


@lru_cache(maxsize=None)
def A071778(n):
    if n == 0:
        return 0
    c, j = 1, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * A071778(k1)
        j, k1 = j2, n // j2
    return n * (n**2 - 1) - c + j


def A078241(n):
    if n > 0:
        for i in range(1, 2**n):
            x = 2 * int(bin(i)[2:])
            if not x % n:
                return x
    return 0


def A161710(n):
    return (
        n
        * (
            n * (n * (n * (n * (n * (154 - 6 * n) - 1533) + 7525) - 18879) + 22561)
            - 7302
        )
        // 2520
        + 1
    )


def A161713(n):
    return n * (n * (n * (n * (15 - n) - 65) + 125) - 34) // 40 + 1


def A250408_gen():  # generator of terms
    return filter(lambda n: is_pal(n, 20), pal10_gen())


def A345957(n):
    if n == 1:
        return 1
    fs = factorint(n, multiple=True)
    q, r = divmod(len(fs), 2)
    return 0 if r else len(list(multiset_combinations(fs, q)))


def A004520(n):
    return int("".join(str(2 * int(d) % 10) for d in str(n)))


def A005807_gen():  # generator of terms
    b = 2
    yield b
    for n in count(0):
        b = b * (4 * n + 2) * (5 * n + 9) // ((n + 3) * (5 * n + 4))
        yield b


def A014707(n):
    s = bin(n + 1)[2:]
    m = len(s)
    i = s[::-1].find("1")
    return int(s[m - i - 2]) if m - i - 2 >= 0 else 0


def A031423_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        cf = continued_fraction_periodic(0, 1, n)
        if (
            len(cf) > 1
            and len(cf[1]) > 1
            and len(cf[1]) % 2
            and cf[1][len(cf[1]) // 2] == 10
        ):
            yield n


def A114043(n):
    return (
        4 * n**2
        - 6 * n
        + 3
        + 2 * sum(totient(i) * (n - i) * (2 * n - i) for i in range(2, n))
    )


def A249156_gen():  # generator of terms
    return filter(lambda n: is_pal(n, 7), pal_gen(5))


def A250410_gen():  # generator of terms
    return filter(lambda n: is_pal(n, 25), pal10_gen())


def A000449_gen():  # generator of terms
    m, x = 1, 0
    for n in count(3):
        x, m = x * n + m * (n * (n - 1) * (n - 2) // 6), -m
        yield x


def A000541(n):
    return n**2 * (n**2 * (n**2 * (n * (3 * n + 12) + 14) - 7) + 2) // 24


def A001287(n):
    return comb(n, 10)


def A022842(n):
    return isqrt(8 * n**2)


def A031286(n):
    ap = 0
    while n > 9:
        n = sum(int(d) for d in str(n))
        ap += 1
    return ap


def A055165(n):
    return sum(1 for s in product([0, 1], repeat=n**2) if Matrix(n, n, s).det() != 0)


def A145768(n):
    return reduce(xor, (x**2 for x in range(n + 1)))


def A145829_gen():  # generator of terms
    m = 0
    for n in count(1):
        m ^= n**2
        a, b = integer_nthroot(m, 2)
        if b:
            yield a


def A249155_gen():  # generator of terms
    return filter(lambda n: is_pal(n, 15), pal_gen(6))


def A145828_gen():  # generator of terms
    m = 0
    for n in count(0):
        m ^= n**2
        if isqrt(m) ** 2 == m:
            yield m


def A193232(n):
    return reduce(xor, (x * (x + 1) for x in range(n + 1))) // 2


def A062700_gen():  # generator of terms
    yield 3
    yield from filter(isprime, (divisor_sigma(d**2) for d in count(1)))


def A065710(n):
    return str(2**n).count("2")


def A215732(n):
    l, x = [str(d) * n for d in range(10)], 1
    while True:
        s = str(x)
        for k in range(10):
            if l[k] in s:
                return k
        x *= 2


def A260343_gen(startvalue=2):  # generator of terms
    return filter(
        lambda n: isprime(
            intbase(list(range(1, n)) + [1, 0] + list(range(n - 1, 0, -1)), n)
        ),
        count(max(startvalue, 2)),
    )


def A320486(n):
    return int("0" + "".join(d if str(n).count(d) == 1 else "" for d in str(n)))


def A002708_gen():  # generator of terms
    a, b = 1, 1
    for n in count(1):
        yield a % n
        a, b = b, a + b


def A003098_gen():  # generator of terms
    return filter(
        lambda m: str(m) == str(m)[::-1], (n * (n + 1) // 2 for n in count(0))
    )


def A005001_gen():  # generator of terms
    yield from [0, 1, 2]
    blist, a, b = [1], 2, 1
    while True:
        blist = list(accumulate([b] + blist))
        b = blist[-1]
        a += b
        yield a


def A006533(n):
    return (
        1176 * (not n % 12) * n
        - 3744 * (not n % 120) * n
        + 1536 * (not n % 18) * n
        - (not n % 2) * (5 * n**3 - 42 * n**2 + 40 * n + 48)
        - 2304 * (not n % 210) * n
        + 912 * (not n % 24) * n
        - 1728 * (not n % 30) * n
        - 36 * (not n % 4) * n
        - 2400 * (not n % 42) * n
        - 4 * (not n % 6) * n * (53 * n - 310)
        - 9120 * (not n % 60) * n
        - 3744 * (not n % 84) * n
        - 2304 * (not n % 90) * n
        + 2 * n**4
        - 12 * n**3
        + 46 * n**2
        - 36 * n
    ) // 48 + 1


def A018796(n):
    if n == 0:
        return 0
    else:
        d, nd = 1, n
        while True:
            x = (isqrt(nd - 1) + 1) ** 2
            if x < nd + d:
                return int(x)
            d *= 10
            nd *= 10


def A027611(n):
    return (n * harmonic(n)).q


def A037015_gen(startvalue=0):  # generator of terms
    for n in count(max(startvalue, 0)):
        c = None
        for x, y in groupby(bin(n)[2:]):
            z = len(list(y))
            if c != None and z >= c:
                break
            c = z
        else:
            yield n


def A038003_gen():  # generator of terms
    yield from [1, 1]
    c, s = 1, 3
    for n in count(2):
        c = (c * (4 * n - 2)) // (n + 1)
        if n == s:
            yield c
            s = 2 * s + 1


def A050782(n):
    if n % 10:
        for i in islice(pal10_gen(), 1, None):
            q, r = divmod(i, n)
            if not r:
                return q
    else:
        return 0


def A073327(n):
    return sum(ord(d) - 96 for d in sub(r"\sand\s|[^a-z]", "", num2words(n)))


def A088177():  # generator of terms
    yield 1
    yield 1
    p, a = {1}, 1
    while True:
        n = 1
        while n * a in p:
            n += 1
        p.add(n * a)
        a = n
        yield n


def A096497(n):
    return nextprime((10**n - 1) // 9)


def A101337(n):
    s = str(n)
    l = len(s)
    return sum(int(d) ** l for d in s)


def A141255(n):
    return 2 * (n - 1) * (2 * n - 1) + 2 * sum(
        totient(i) * (n - i) * (2 * n - i) for i in range(2, n)
    )


def A176774(n):
    k = (isqrt(8 * n + 1) - 1) // 2
    while k >= 2:
        a, b = divmod(2 * (k * (k - 2) + n), k * (k - 1))
        if not b:
            return a
        k -= 1


def A002131(n):
    return prod(
        (p ** (e + 1) - 1) // (p - 1) if p & 1 else 1 << e
        for p, e in factorint(n).items()
    )


def A024916(n):
    return (
        -((s := isqrt(n)) ** 2) * (s + 1)
        + sum((q := n // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
        >> 1
    )


def A350146(n):
    return (
        -((s := isqrt(n)) ** 2) * (s + 1)
        + sum((q := n // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
        + (t := isqrt(m := n >> 1)) ** 2 * (t + 1)
        - sum((q := m // k) * ((k << 1) + q + 1) for k in range(1, t + 1))
    ) >> 1


def A252867_gen():  # generator of terms
    yield from [0, 1, 2]
    l1, l2, s, b = 2, 1, 3, set()
    while True:
        i = s
        while True:
            if not (i in b or i & l1) and i & l2:
                yield i
                l2, l1 = l1, i
                b.add(i)
                while s in b:
                    b.remove(s)
                    s += 1
                break
            i += 1


def A002419(n):
    return (6 * n - 2) * comb(n + 2, 3) // 4


def A015950_gen(startvalue=1):  # generator of terms
    return filter(lambda n: pow(4, n, n) == n - 1, count(max(startvalue, 1)))


def A016069_gen():  # generator of terms
    for g in count(2):
        n, blist = 2**g - 1, []
        for x in combinations("0123456789", 2):
            for i, y in enumerate(product(x, repeat=g)):
                if i > 0 and i < n and y[0] != "0":
                    z = int("".join(y))
                    a, b = integer_nthroot(z, 2)
                    if b:
                        blist.append(a)
        yield from sorted(blist)


def A350092(n):
    return floor((1 + sqrt(5) / 2) ** n)


def A014217(n):
    return floor(((1 + sqrt(5)) / 2) ** n)


def A350174_gen():  # generator of terms
    return chain.from_iterable([k] * prime(k + 1) for k in count(0))


def A350173(n):
    return prime(n) ** (n % 2 + 1)


def A350171(n):
    return prime(n) + n % 2


def A349425(n):
    if n % 10 == 0:
        return 0
    m, n1, n2 = n, 10**n, 10 ** (n - 1)
    while (k := pow(n, m, n1)) != m:
        m = k
    return k // n2


def A309081(n):
    return n + sum((1 if k % 2 else -1) * (n // k**2) for k in range(2, isqrt(n) + 1))


def A055882_gen():  # generator of terms
    yield from [1, 2]
    blist, b, n2 = [1], 1, 4
    while True:
        blist = list(accumulate([b] + blist))
        b = blist[-1]
        yield b * n2
        n2 *= 2


def A068679_gen():  # generator of terms
    for n in count(1):
        if isprime(10 * n + 1):
            s = str(n)
            for i in range(len(s)):
                if not isprime(int(s[:i] + "1" + s[i:])):
                    break
            else:
                yield n


def A082183(n):
    t = n * (n + 1)
    ds = divisors(t)
    for i in range(len(ds) // 2 - 2, -1, -1):
        x = ds[i]
        y = t // x
        a, b = divmod(y - x, 2)
        if b:
            return a
    return -1


def A098464_gen():  # generator of terms
    l, h = 1, Fraction(1, 1)
    for k in count(1):
        l = lcm(l, k)
        h += Fraction(1, k)
        if l == h.denominator:
            yield k


def A109812_gen():  # generator of terms
    yield 1
    l1, s, b = 1, 2, set()
    while True:
        i = s
        while True:
            if not (i in b or i & l1):
                yield i
                l1 = i
                b.add(i)
                while s in b:
                    b.remove(s)
                    s += 1
                break
            i += 1


def A132106(n):
    return (lambda m: 2 * (sum(n // k for k in range(1, m + 1))) + m * (1 - m) + 1)(
        isqrt(n)
    )


def A215727(n):
    l, x = [str(d) * n for d in range(10)], 1
    for m in count(0):
        s = str(x)
        for k in l:
            if k in s:
                return m
        x *= 3


def A000542(n):
    return n * (n**2 * (n**2 * (n**2 * (n * (10 * n + 45) + 60) - 42) + 20) - 3) // 90


def A002796_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: all((d == "0" or n % int(d) == 0) for d in set(str(n))),
        count(max(startvalue, 1)),
    )


def A004167(n):
    return int(str(3**n)[::-1])


def A014312_gen():  # generator of terms
    return (
        2**a + 2**b + 2**c + 2**d
        for a in count(3)
        for b in range(2, a)
        for c in range(1, b)
        for d in range(c)
    )


def A046732_gen():  # generator of terms
    return filter(
        lambda p: len(str(p)) == len(set(str(p))) and isprime(int(str(p)[::-1])),
        (prime(n) for n in count(1)),
    )


def A050985(n):
    return 1 if n <= 1 else prod(p ** (e % 3) for p, e in factorint(n).items())


def A061242_gen():  # generator of terms
    return filter(lambda p: not (p + 1) % 18, (prime(n) for n in count(1)))


def A061762(n):
    return sum(a := [int(d) for d in str(n)]) + prod(a)


def A219324_gen():  # generator of terms
    for n in count(1):
        s = [int(d) for d in str(n)]
        m = len(s)
        if n == Matrix(m, m, lambda i, j: s[(i - j) % m]).det():
            yield n


def A246544_gen():  # generator of terms
    for m in count(1):
        n = composite(m)
        x = divisors(n)
        x.pop()
        y = sum(x)
        while y < n:
            x, y = x[1:] + [y], 2 * y - x[0]
        if y == n:
            yield n


def A276037_gen():  # generator of terms
    return (int("".join(d)) for l in count(1) for d in product("15", repeat=l))


def A290131(n):
    return 2 * (n - 1) ** 2 + sum(
        totient(i) * (n - i) * (2 * n - i) for i in range(2, n)
    )


def A317087_gen():  # generator of terms
    yield 1
    for n in count(1):
        d = factorint(n)
        k, l = sorted(d.keys()), len(d)
        if l > 0 and l == primepi(max(d)):
            for i in range(l // 2):
                if d[k[i]] != d[k[l - i - 1]]:
                    break
            else:
                yield n


def A332517(n):
    return sum(totient(d) * (n // d) ** n for d in divisors(n, generator=True))


def A006722_gen():  # generator of terms
    blist = [1] * 6
    yield from blist
    while True:
        blist = blist[1:] + [
            (blist[-1] * blist[-5] + blist[-2] * blist[-4] + blist[-3] ** 2)
            // blist[-6]
        ]
        yield blist[-1]


def A008863(n):
    return (
        n
        * (
            n
            * (
                n
                * (
                    n
                    * (
                        n
                        * (n * (n * (n * (n * (n - 35) + 600) - 5790) + 36813) - 140595)
                        + 408050
                    )
                    - 382060
                )
                + 1368936
            )
            + 2342880
        )
        // 3628800
        + 1
    )


def A011965_gen():  # generator of terms
    yield 1
    blist = [1, 2]
    while True:
        blist = list(accumulate([blist[-1]] + blist))
        yield blist[-3]


def A034302_gen():  # generator of terms
    yield from [23, 37, 53, 73]
    for l in count(1):
        for d in product("123456789", repeat=l):
            for e in product("1379", repeat=2):
                s = "".join(d + e)
                if isprime(int(s)):
                    for i in range(len(s)):
                        if not isprime(int(s[:i] + s[i + 1 :])):
                            break
                    else:
                        yield int(s)


def A036953_gen():  # generator of terms
    return filter(isprime, (int(gmpy2digits(n, 3)) for n in count(0)))


def A054683_gen(startvalue=0):  # generator of terms
    return filter(
        lambda i: not sum(int(d) for d in str(i)) % 2, count(max(startvalue, 0))
    )


def A064538(n):
    p, m = 2, n + 1
    while p <= (n + 2) // (2 + (n % 2)):
        if sum(d for d in sympydigits(n + 1, p)[1:]) >= p:
            m *= p
        p = nextprime(p)
    return m


def A066321(n):
    if n == 0:
        return 0
    else:
        s, q = "", n
        while q:
            q, r = c_divmod(q, -4)
            s += ("0000", "1000", "0011", "1011")[r]
        return int(s[::-1], 2)


@lru_cache(maxsize=None)
def A082540(n):
    if n == 0:
        return 0
    c, j = 1, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * A082540(k1)
        j, k1 = j2, n // j2
    return n * (n**3 - 1) - c + j


def A087116(n):
    return sum(1 for d in bin(n)[2:].split("1") if len(d))


def A096825(n):
    fs = factorint(n)
    return len(list(multiset_combinations(fs, sum(fs.values()) // 2)))


@lru_cache(maxsize=None)
def A100448(n):
    if n == 0:
        return 0
    c, j = 2, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * (6 * A100448(k1) + 1)
        j, k1 = j2, n // j2
    return (n * (n**2 - 1) - c + j) // 6


def A129135_gen():  # generator of terms
    m, x = 1, 0
    for n in count(5):
        x, m = x * n + m * comb(n, 5), -m
        yield x


def A187795(n):
    return sum(d for d in divisors(n, generator=True) if divisor_sigma(d) > 2 * d)


def A246660(n):
    return prod(factorial(len(d)) for d in split("0+", bin(n)[2:]) if d) if n > 0 else 1


def A256617_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: len(plist := primefactors(n)) == 2
        and plist[1] == nextprime(plist[0]),
        count(max(startvalue, 1)),
    )


def A272369_gen():  # generator of terms
    return filter(
        lambda n: all(
            (d in (1, 2, 4, 46) or not isprime(d + 1))
            for d in divisors(n, generator=True)
        ),
        count(92, 92),
    )


def A317086(n):
    if n > 3 and isprime(n):
        return 1
    else:
        c = 1
        for d in partitions(n, k=integer_nthroot(2 * n, 2)[0], m=n * 2 // 3):
            l = len(d)
            if l > 0:
                k = max(d)
                if l == k:
                    for i in range(k // 2):
                        if d[i + 1] != d[k - i]:
                            break
                    else:
                        c += 1
        return c


def A331757(n):
    return (
        8
        if n == 1
        else 2
        * (
            n * (n + 3)
            + sum(totient(i) * (n + 1 - i) * (n + 1 + i) for i in range(2, n // 2 + 1))
            + sum(
                totient(i) * (n + 1 - i) * (2 * n + 2 - i)
                for i in range(n // 2 + 1, n + 1)
            )
        )
    )


def A005351(n):
    s, q = "", n
    while q >= 2 or q < 0:
        q, r = divmod(q, -2)
        if r < 0:
            q += 1
            r += 2
        s += str(r)
    return int(str(q) + s[::-1], 2)


def A028909(n):
    return int("".join(sorted(str(2**n))))


def A028910(n):
    return int("".join(sorted(str(2**n), reverse=True)))


def A039723(n):
    s, q = "", n
    while q >= 10 or q < 0:
        q, r = divmod(q, -10)
        if r < 0:
            q += 1
            r += 10
        s += str(r)
    return int(str(q) + s[::-1])


def A055685_gen(startvalue=2):  # generator of terms
    return filter(lambda n: pow(2, n, n - 1) == n - 2, count(max(startvalue, 2)))


def A065712(n):
    return str(2**n).count("1")


def A067388_gen():  # generator of terms
    p = 2
    q, r, s = p + 48, p + 96, p + 144
    while True:
        np = nextprime(p)
        if (
            np == q
            and isprime(r)
            and isprime(s)
            and nextprime(q) == r
            and nextprime(r) == s
        ):
            yield p
        p, q, r, s = np, np + 48, np + 96, np + 144


def A075101(n):
    return (Fraction(2**n) / n).numerator


@lru_cache(maxsize=None)
def A090025(n):
    if n == 0:
        return 0
    c, j = 1, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * A090025(k1)
        j, k1 = j2, n // j2
    return (n + 1) ** 3 - c + 7 * (j - n - 1)


def A350153_gen():  # generator of terms
    return filter(
        lambda p: isprime(p),
        (
            int(s)
            for n in count(1)
            for s in accumulate(
                str(d) for d in chain(range(1, n + 1), range(n - 1, 0, -1))
            )
        ),
    )


def A259937(n):
    return int("".join(str(d) for d in chain(range(1, n + 1), range(n, 0, -1))))


def A350233_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: (m := int(str(n)[::-1])) % 5 and not m % 4,
        filter(lambda n: n % 4 and not n % 5, count(max(startvalue, 1))),
    )


def A350232_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: (m := int(str(n)[::-1])) % 4 and not m % 5,
        filter(lambda n: n % 5 and not n % 4, count(max(startvalue, 1))),
    )


def A350228_gen():  # generator of terms
    yield from (1, 0)
    b, bdict = 0, {1: (1,), 0: (2,)}
    for n in count(3):
        if len(l := bdict[b]) > 1:
            m = (n - 1 - l[-2]) * b
            if m in bdict:
                bdict[m] = (bdict[m][-1], n)
            else:
                bdict[m] = (n,)
            b = m
        else:
            bdict[1] = (bdict[1][-1], n)
            b = 1
        yield b


def A171918_gen():  # generator of terms
    yield 8
    b, bdict = 8, {8: (1,)}
    for n in count(2):
        if len(l := bdict[b]) > 1:
            b = n - 1 - l[-2]
        else:
            b = 0
        if b in bdict:
            bdict[b] = (bdict[b][-1], n)
        else:
            bdict[b] = (n,)
        yield b


def A171917_gen():  # generator of terms
    b, bdict = 7, {7: (1,)}
    for n in count(2):
        yield b
        if len(l := bdict[b]) > 1:
            b = n - 1 - l[-2]
        else:
            b = 0
        if b in bdict:
            bdict[b] = (bdict[b][-1], n)
        else:
            bdict[b] = (n,)


def A171916_gen():  # generator of terms
    b, bdict = 6, {6: (1,)}
    for n in count(2):
        yield b
        if len(l := bdict[b]) > 1:
            b = n - 1 - l[-2]
        else:
            b = 0
        if b in bdict:
            bdict[b] = (bdict[b][-1], n)
        else:
            bdict[b] = (n,)


def A171915_gen():  # generator of terms
    b, bdict = 5, {5: (1,)}
    for n in count(2):
        yield b
        if len(l := bdict[b]) > 1:
            b = n - 1 - l[-2]
        else:
            b = 0
        if b in bdict:
            bdict[b] = (bdict[b][-1], n)
        else:
            bdict[b] = (n,)


def A171914_gen():  # generator of terms
    b, bdict = 4, {4: (1,)}
    for n in count(2):
        yield b
        if len(l := bdict[b]) > 1:
            b = n - 1 - l[-2]
        else:
            b = 0
        if b in bdict:
            bdict[b] = (bdict[b][-1], n)
        else:
            bdict[b] = (n,)


def A171913_gen():  # generator of terms
    b, bdict = 3, {3: (1,)}
    for n in count(2):
        yield b
        if len(l := bdict[b]) > 1:
            b = n - 1 - l[-2]
        else:
            b = 0
        if b in bdict:
            bdict[b] = (bdict[b][-1], n)
        else:
            bdict[b] = (n,)


def A171912_gen():  # generator of terms
    b, bdict = 2, {2: (1,)}
    for n in count(2):
        yield b
        if len(l := bdict[b]) > 1:
            b = n - 1 - l[-2]
        else:
            b = 0
        if b in bdict:
            bdict[b] = (bdict[b][-1], n)
        else:
            bdict[b] = (n,)


def A171911_gen():  # generator of terms
    b, bdict = 1, {1: (1,)}
    for n in count(2):
        yield b
        if len(l := bdict[b]) > 1:
            b = n - 1 - l[-2]
        else:
            b = 0
        if b in bdict:
            bdict[b] = (bdict[b][-1], n)
        else:
            bdict[b] = (n,)


def A181391_gen():  # generator of terms
    b, bdict = 0, {0: (1,)}
    for n in count(2):
        yield b
        if len(l := bdict[b]) > 1:
            b = n - 1 - l[-2]
            if b in bdict:
                bdict[b] = (bdict[b][-1], n)
            else:
                bdict[b] = (n,)
        else:
            b = 0
            bdict[0] = (bdict[0][-1], n)


def A309363_gen():  # generator of terms
    b, bdict = 0, {0: (1,)}
    for n in count(2):
        yield b
        if len(l := bdict[b]) > 1:
            b = n - 1 - l[-2]
        else:
            b = 2
        if b in bdict:
            bdict[b] = (bdict[b][-1], n)
        else:
            bdict[b] = (n,)


def A092221_gen(startvalue=0):  # generator of terms
    return filter(lambda n: not bernoulli(2 * n).p % 59, count(max(startvalue, 0)))


def A281502_gen(startvalue=0):  # generator of terms
    return filter(lambda n: not bernoulli(2 * n).p % 691, count(max(startvalue, 0)))


def A100208_gen():  # generator of terms
    xset, a = {1}, 1
    yield a
    while True:
        a, b = 1, 1 + a**2
        while not isprime(b) or a in xset:
            b += 2 * a + 1
            a += 1
        xset.add(a)
        yield a


def A349731(n):
    return -1 if n == 0 else -((-n) ** n) * ff(Fraction(1, n), n)


def A109890_gen():  # generator of terms
    yield from [1, 2]
    s, y, b = 3, 3, set()
    while True:
        for i in divisors(s, generator=True):
            if i >= y and i not in b:
                yield i
                s += i
                b.add(i)
                while y in b:
                    b.remove(y)
                    y += 1
                break


def A110751_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: primefactors(n) == primefactors(int(str(n)[::-1])),
        count(max(startvalue, 1)),
    )


def A112822(n):
    k, l, h = 1, 1, Fraction(1, 1)
    while l != h.denominator * (2 * n - 1):
        k += 1
        l = lcm(l, k)
        h += Fraction(1, k)
    return k


def A115005(n):
    return (n - 1) * (2 * n - 1) + sum(
        totient(i) * (n - i) * (2 * n - i) for i in range(2, n)
    )


def A115920_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: sorted(str(divisor_sigma(n))) == sorted(str(n)),
        count(max(startvalue, 1)),
    )


def A115921_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: sorted(str(totient(n))) == sorted(str(n)), count(max(startvalue, 1))
    )


def A153671_gen():  # generator of terms
    n, k, q = 101, 100, 0
    for m in count(1):
        r = n % k
        if r > q:
            q = r
            yield m
        n *= 101
        k *= 100
        q *= 100


def A215728(n):
    l, x = [str(d) * n for d in range(10)], 1
    for m in count(0):
        s = str(x)
        for k in l:
            if k in s:
                return m
        x *= 5


def A215729(n):
    l, x = [str(d) * n for d in range(10)], 1
    for m in count(0):
        s = str(x)
        for k in l:
            if k in s:
                return m
        x *= 6


def A215730(n):
    l, x = [str(d) * n for d in range(10)], 1
    for m in count(0):
        s = str(x)
        for k in l:
            if k in s:
                return m
        x *= 7


def A215733(n):
    l, x = [str(d) * n for d in range(10)], 1
    while True:
        s = str(x)
        for k in range(10):
            if l[k] in s:
                return k
        x *= 3


def A260273_gen():  # generator of terms
    yield 1
    a = 1
    while True:
        b, s = 1, format(a, "b")
        while format(b, "b") in s:
            b += 1
        a += b
        s = format(a, "b")
        yield a


def A331776(n):
    return (
        4
        if n == 1
        else 20 * n * (n - 1)
        + 4 * sum(totient(i) * (n + 1 - i) * (2 * n + 2 - i) for i in range(2, n + 1))
    )


def A003128_gen():  # generator of terms
    blist, a, b = [1], 1, 1
    while True:
        blist = list(accumulate([b] + blist))
        c = blist[-1]
        yield (c + a - 3 * b) // 2
        a, b = b, c


def A048701(n):
    return int((s := bin(n - 1)[2:]) + s[::-1], 2)


def A049479(n):
    return min(factorint(2**n - 1))


def A061040(n):
    return 9 * n**2 // gcd(n**2 - 9, 9 * n**2)


def A064614(n):
    return (
        prod((5 - p if 2 <= p <= 3 else p) ** e for p, e in factorint(n).items())
        if n > 1
        else n
    )


def A065715(n):
    return str(2**n).count("4")


def A065719(n):
    return str(2**n).count("8")


def A072960_gen():  # generator of terms
    return chain(
        [0],
        (
            int(a + "".join(b))
            for l in count(0)
            for a in "3689"
            for b in product("03689", repeat=l)
        ),
    )


@lru_cache(maxsize=None)
def A100449(n):
    if n == 0:
        return 1
    c, j = 0, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * ((A100449(k1) - 3) // 2)
        j, k1 = j2, n // j2
    return 2 * (n * (n - 1) - c + j) + 1


def A127936_gen(startvalue=1):  # generator of terms
    return filter(lambda i: isprime(int("01" * i + "1", 2)), count(max(startvalue, 1)))


def A171901is_ok(n):
    s = str(n)
    return any(s[i] == s[i - 1] for i in range(1, len(s)))


def A171901_gen(startvalue=0):  # generator of terms
    return filter(A171901is_ok, count(max(startvalue, 0)))


def A215731(n):
    l, x = [str(d) * n for d in range(10)], 1
    for m in count(0):
        s = str(x)
        for k in l:
            if k in s:
                return m
        x *= 11


def A215737(n):
    a, s = 1, tuple(str(i) * n for i in range(10))
    while True:
        a *= 11
        t = str(a)
        for i, x in enumerate(s):
            if x in t:
                return i


def A230625(n):
    return (
        1
        if n == 1
        else int(
            "".join(
                [bin(y)[2:] for x in sorted(factorint(n).items()) for y in x if y != 1]
            ),
            2,
        )
    )


def A237600_gen(startvalue=2):  # generator of terms
    n = max(nextprime(startvalue - 1), 2)
    while True:
        s = format(n, "x")
        for i in range(1, len(s)):
            if not is_prime(int(s[:-i], 16)):
                break
        else:
            yield n
        n = nextprime(n)


def A252648_gen():  # generator of terms
    yield 1
    for m in count(1):
        l, L, dm, xlist, q = 1, 1, [d**m for d in range(10)], [0], 9**m
        while l * q >= L:
            for c in combinations_with_replacement(range(1, 10), l):
                n = sum(dm[d] for d in c)
                if sorted(int(d) for d in str(n)) == [0] * (
                    len(str(n)) - len(c)
                ) + list(c):
                    xlist.append(n)
            l += 1
            L *= 10
        yield from sorted(xlist)


def A272695(n):
    return int((n * sin(n)).round())


def A000790(n):
    c = 4
    while pow(n, c, c) != (n % c) or isprime(c):
        c += 1
    return c


def A008281_gen():  # generator of terms
    blist = [1]
    while True:
        yield from blist
        blist = [0] + list(accumulate(reversed(blist)))


@lru_cache(maxsize=None)
def A015631(n):
    if n == 0:
        return 0
    c, j = 1, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * A015631(k1)
        j, k1 = j2, n // j2
    return n * (n - 1) * (n + 4) // 6 - c + j


def A046447_gen():  # generator of terms
    yield 1
    m = 4
    while True:
        k = nextprime(m)
        for n in range(m, k):
            if (
                s := "".join([str(p) * e for p, e in sorted(factorint(n).items())])
            ) == s[::-1]:
                yield n
        m = k + 1


def A057708_gen():  # generator of terms
    m = 2
    for k in count(1):
        if isprime(int(str(m)[::-1])):
            yield k
        m *= 2


def A063454(n):
    ndict = {}
    for i in range(n):
        m = pow(i, 3, n)
        if m in ndict:
            ndict[m] += 1
        else:
            ndict[m] = 1
    count = 0
    for i in ndict:
        ni = ndict[i]
        for j in ndict:
            k = (i + j) % n
            if k in ndict:
                count += ni * ndict[j] * ndict[k]
    return count


def A350244_gen():  # generator of terms
    yield 1
    k, b, bdict = 1, 0, {1: (1,), 0: (2,)}
    for n in count(3):
        if len(l := bdict[b]) > 1:
            m = (n - 1 - l[-2]) * b
            if m in bdict:
                bdict[m] = (bdict[m][-1], n)
            else:
                bdict[m] = (n,)
            b = m
        else:
            bdict[1] = (bdict[1][-1], n)
            b = 1
        if b > k:
            k = b
            yield n


def A069942_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: sum(map(lambda x: int(str(x)[::-1]) if x < n else 0, divisors(n)))
        == int(str(n)[::-1]),
        count(max(startvalue, 1)),
    )


def A071869_gen():  # generator of terms
    p, q, r = 1, 2, 3
    for n in count(2):
        p, q, r = q, r, max(factorint(n + 2))
        if p < q < r:
            yield n


def A071870_gen():  # generator of terms
    p, q, r = 1, 2, 3
    for n in count(2):
        p, q, r = q, r, max(factorint(n + 2))
        if p > q > r:
            yield n


def A076197_gen():  # generator of terms
    g = 1
    for i in count(3, 2):
        g *= i
        if is_prime(g + 1024):
            yield i


@lru_cache(maxsize=None)
def A090026(n):
    if n == 0:
        return 0
    c, j = 1, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * A090026(k1)
        j, k1 = j2, n // j2
    return (n + 1) ** 4 - c + 15 * (j - n - 1)


@lru_cache(maxsize=None)
def A090027(n):
    if n == 0:
        return 0
    c, j = 1, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * A090027(k1)
        j, k1 = j2, n // j2
    return (n + 1) ** 5 - c + 31 * (j - n - 1)


@lru_cache(maxsize=None)
def A090028(n):
    if n == 0:
        return 0
    c, j = 1, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * A090028(k1)
        j, k1 = j2, n // j2
    return (n + 1) ** 6 - c + 63 * (j - n - 1)


@lru_cache(maxsize=None)
def A090029(n):
    if n == 0:
        return 0
    c, j = 1, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * A090029(k1)
        j, k1 = j2, n // j2
    return (n + 1) ** 7 - c + 127 * (j - n - 1)


def A114146(n):
    return (
        1
        if n == 0
        else 8 * n**2
        - 12 * n
        + 6
        + 4 * sum(totient(i) * (n - i) * (2 * n - i) for i in range(2, n))
    )


def A153679_gen():  # generator of terms
    n, k, q = 1024, 1000, 0
    for m in count(1):
        r = n % k
        if r > q:
            q = r
            yield m
        n *= 1024
        k *= 1000
        q *= 1000


def A166374_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: sum([int(n * e / p) for p, e in factorint(n).items()]) == totient(n),
        count(max(startvalue, 1)),
    )


def A350253(n):
    return (
        1
        if (m := n % 6) == 2 or m == 5
        else (fibonacci(n + 1) if m == 3 else fibonacci(n))
    )


def A195269(n):
    m, s = 1, "0" * n
    for i in count(1):
        m *= 3
        if s in str(m):
            return i


def A230891_gen():  # generator of terms
    yield from [0, 11]
    l, s, b = Counter("11"), 1, {3}
    while True:
        i = s
        while True:
            if i not in b:
                li, o = Counter(bin(i)[2:]), 0
                for d in (l + li).values():
                    if d % 2:
                        if o > 0:
                            break
                        o += 1
                else:
                    yield int(bin(i)[2:])
                    l = li
                    b.add(i)
                    while s in b:
                        b.remove(s)
                        s += 1
                    break
            i += 1


def A245562_gen():  # generator of terms
    yield 0
    for n in count(1):
        yield from (len(d) for d in split("0+", bin(n)[2:]) if d != "")


def A247648_gen(startvalue=1):  # generator of terms
    return filter(lambda n: n % 2 and not "00" in bin(n), count(max(startvalue, 1)))


def A274086(n):
    return int((n * tan(n)).round())


def A274087(n):
    return int((n**2 * sin(n)).round())


def A274088(n):
    return int((n**2 * sin(sqrt(n))).round())


def A274090(n):
    return int((n**2 * cos(sqrt(n))).round())


def A274091(n):
    k, j = divmod(n, 2)
    return int((k**2 * sin(sqrt(k) + j * pi / 2)).round())


def A274092(n):
    k, j = divmod(n, 3)
    return int((k**2 * sin(sqrt(k) + j * pi / 2)).round())


def A274095(n):
    return int((n * sin(sqrt(n))).round())


def A274097(n):
    k, j = divmod(n, 3)
    return int((k * sin(sqrt(k) + j * pi / 2)).round())


def A317085(n):
    c = 1
    for d in partitions(n, m=n * 2 // 3):
        l = len(d)
        if l > 0:
            k = sorted(d.keys())
            for i in range(l // 2):
                if d[k[i]] != d[k[l - i - 1]]:
                    break
            else:
                c += 1
    return c


def A320485(n):
    return (lambda x: int(x) if x != "" else -1)(
        "".join(d if str(n).count(d) == 1 else "" for d in str(n))
    )


def A328095_gen(startvalue=0):  # generator of terms
    return filter(
        lambda n: (sn := str(n)) in str(n * prod(int(d) for d in sn)),
        count(max(startvalue, 0)),
    )


def A337856(n):
    k, n1, n2, pset = 0, 10 ** (n - 1) // 2 - 18, 10**n // 2 - 18, set()
    while 50 * k**2 + 60 * k < n2:
        a, b = divmod(n1 - 30 * k, 50 * k + 30)
        m = max(k, a + int(b > 0))
        r = 50 * k * m + 30 * (k + m)
        while r < n2:
            pset.add(r)
            m += 1
            r += 50 * k + 30
        k += 1
    return len(pset)


def A345687(n):
    return pvariance(
        n**2 * u
        for u, v, w in (igcdex(x, y) for x in range(1, n + 1) for y in range(1, n + 1))
    )


def A003512(n):
    return 2 * n + int(isqrt(3 * n**2))


def A004720(n):
    l = len(str(n - 1))
    m = (10**l - 1) // 9
    k = n + l - 2 + int(n + l - 1 >= m)
    return 0 if k == m else int(str(k).replace("1", ""))


def A005487_gen():  # generator of terms
    blist, bset = [0, 4], {0, 4}
    yield from blist
    for i in count(0):
        n, flag = blist[-1] + 1, False
        while True:
            for j in range(i + 1, 0, -1):
                m = 2 * blist[j] - n
                if m in bset:
                    break
                if m < 0:
                    flag = True
                    break
            else:
                blist.append(n)
                bset.add(n)
                yield n
                break
            if flag:
                blist.append(n)
                bset.add(n)
                yield n
                break
            n += 1


def A006723_gen():  # generator of terms
    blist = [1] * 7
    yield from blist
    while True:
        blist = blist[1:] + [
            (blist[-1] * blist[-6] + blist[-2] * blist[-5] + blist[-3] * blist[-4])
            // blist[-7]
        ]
        yield blist[-1]


def A007487(n):
    return n**2 * (n**2 * (n**2 * (n**2 * (n * (2 * n + 10) + 15) - 14) + 10) - 3) // 20


def A008559_gen():  # generator of terms
    b = 2
    while True:
        yield b
        b = int(bin(b)[2:])


def A027602(n):
    return n * (n * (3 * n + 9) + 15) + 9


def A029976_gen():  # generator of terms
    return filter(isprime, pal_gen(8))


def A029997_gen():  # generator of terms
    return filter(
        lambda n: gmpy2digits(n, 11) == gmpy2digits(n, 11)[::-1],
        (n**2 for n in count(0)),
    )


def A036967_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: min(factorint(n).values(), default=4) >= 4, count(max(startvalue, 1))
    )


def A048543(n):
    k, m = 1, 2
    while True:
        if str(m).count("7") == n:
            return k
        k += 1
        m += 2 * k


def A048544(n):
    k, m = 1, 2
    while True:
        if str(m).count("7") == n:
            return m
        k += 1
        m += 2 * k


def A053165(n):
    return 1 if n <= 1 else prod(p ** (e & 3) for p, e in factorint(n).items())


def A054383_gen():  # generator of terms
    l = {}
    for d in permutations("123456789", 9):
        for i in range(8):
            s1, s2 = int("".join(d[: i + 1])), int("".join(d[i + 1 :]))
            q, r = divmod(s1, s2)
            if not r:
                if q in l:
                    l[q] += 1
                else:
                    l[q] = 1
    for i in count(1):
        if i in l:
            yield l[i]
        else:
            yield 0


def A055155(n):
    return sum(gcd(d, n // d) for d in divisors(n, generator=True))


def A058411_gen(startvalue=0):  # generator of terms
    return filter(lambda i: i % 10 and max(str(i**2)) < "3", count(max(startvalue, 0)))


def A064834(n):
    x, y = str(n), 0
    lx2, r = divmod(len(x), 2)
    for a, b in zip(x[:lx2], x[: lx2 + r - 1 : -1]):
        y += abs(int(a) - int(b))
    return y


def A065714(n):
    return str(2**n).count("3")


def A065716(n):
    return str(2**n).count("5")


def A065717(n):
    return str(2**n).count("6")


def A065718(n):
    return str(2**n).count("7")


def A065744(n):
    return str(2**n).count("9")


def A073785(n):
    s, q = "", n
    while q >= 3 or q < 0:
        q, r = divmod(q, -3)
        if r < 0:
            q += 1
            r += 3
        s += str(r)
    return int(str(q) + s[::-1])


def A073786(n):
    s, q = "", n
    while q >= 5 or q < 0:
        q, r = divmod(q, -5)
        if r < 0:
            q += 1
            r += 5
        s += str(r)
    return int(str(q) + s[::-1])


def A073787(n):
    s, q = "", n
    while q >= 6 or q < 0:
        q, r = divmod(q, -6)
        if r < 0:
            q += 1
            r += 6
        s += str(r)
    return int(str(q) + s[::-1])


def A073788(n):
    s, q = "", n
    while q >= 7 or q < 0:
        q, r = divmod(q, -7)
        if r < 0:
            q += 1
            r += 7
        s += str(r)
    return int(str(q) + s[::-1])


def A073789(n):
    s, q = "", n
    while q >= 8 or q < 0:
        q, r = divmod(q, -8)
        if r < 0:
            q += 1
            r += 8
        s += str(r)
    return int(str(q) + s[::-1])


def A073790(n):
    s, q = "", n
    while q >= 9 or q < 0:
        q, r = divmod(q, -9)
        if r < 0:
            q += 1
            r += 9
        s += str(r)
    return int(str(q) + s[::-1])


def A066417(n):
    return (
        0
        if n == 1
        else divisor_sigma(2 * n - 1)
        + divisor_sigma(2 * n + 1)
        + divisor_sigma(n // 2 ** (k := multiplicity(2, n))) * 2 ** (k + 1)
        - 6 * n
        - 2
    )


def A073930_gen(startvalue=2):  # generator of terms
    return filter(
        lambda n: divisor_sigma(2 * n - 1)
        + divisor_sigma(2 * n + 1)
        + divisor_sigma(n // 2 ** (k := multiplicity(2, n))) * 2 ** (k + 1)
        - 7 * n
        - 2
        == 0,
        count(max(startvalue, 2)),
    )


def A192268_gen(startvalue=2):  # generator of terms
    return filter(
        lambda n: divisor_sigma(2 * n - 1)
        + divisor_sigma(2 * n + 1)
        + divisor_sigma(n // 2 ** (k := multiplicity(2, n))) * 2 ** (k + 1)
        - 7 * n
        - 2
        > 0,
        count(max(startvalue, 2)),
    )


def A082410(n):
    if n == 1:
        return 0
    s = bin(n - 1)[2:]
    m = len(s)
    i = s[::-1].find("1")
    return 1 - int(s[m - i - 2]) if m - i - 2 >= 0 else 1


def A111116_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: len(set(str(n)) & set(str(n**4))) == 0, count(max(startvalue, 1))
    )


def A115927_gen():  # generator of terms
    l = {}
    for d in permutations("0123456789", 10):
        if d[0] != "0":
            for i in range(9):
                if d[i + +1] != "0":
                    q, r = divmod(int("".join(d[: i + 1])), int("".join(d[i + 1 :])))
                    if not r:
                        if q in l:
                            l[q] += 1
                        else:
                            l[q] = 1
    for i in count(1):
        if i in l:
            yield l[i]
        else:
            yield 0


def A235811_gen(startvalue=0):  # generator of terms
    return filter(lambda n: len(set(str(n**3))) == 9, count(max(startvalue, 0)))


def A235809_gen(startvalue=0):  # generator of terms
    return filter(lambda n: len(set(str(n**3))) == 7, count(max(startvalue, 0)))


def A137921(n):
    return len([d for d in divisors(n, generator=True) if n % (d + 1)])


def A153686_gen():  # generator of terms
    k10, k11 = 10, 11
    for k in count(1):
        if (k11 % k10) * k < k10:
            yield k
        k10 *= 10
        k11 *= 11


def A153670_gen():  # generator of terms
    k10, k11 = 100, 101
    for k in count(1):
        if (k11 % k10) * k < k10:
            yield k
        k10 *= 100
        k11 *= 101


def A153687_gen():  # generator of terms
    n, k, q = 11, 10, 0
    for m in count(1):
        r = n % k
        if r > q:
            q = r
            yield m
        n *= 11
        k *= 10
        q *= 10


def A177029_gen(startvalue=1):  # generator of terms
    for m in count(max(startvalue, 1)):
        n, c = 3, 0
        while n * (n + 1) <= 2 * m:
            if not 2 * (n * (n - 2) + m) % (n * (n - 1)):
                c += 1
                if c > 1:
                    break
            n += 1
        if c == 1:
            yield m


def A187824(n):
    k = 1
    while (n + 1) % k < 3:
        k += 1
    return k - 1


def A206709(n):
    c, b, b2, n10 = 0, 1, 2, 10**n
    while b <= n10:
        if isprime(b2):
            c += 1
        b += 1
        b2 += 2 * b - 1
    return c


def A219531(n):
    return (
        n
        * (
            n
            * (
                n
                * (
                    n
                    * (
                        n
                        * (
                            n
                            * (
                                n * (n * (n * (n * (n - 44) + 935) - 11550) + 94083)
                                - 497112
                            )
                            + 1870385
                        )
                        - 3920950
                    )
                    + 8550916
                )
                + 4429656
            )
            + 29400480
        )
        // 39916800
        + 1
    )


def A226561(n):
    return sum(totient(d) * d**n for d in divisors(n, generator=True))


def A228640(n):
    return sum(totient(d) * n ** (n // d) for d in divisors(n, generator=True))


def A242171_gen():  # generator of terms
    yield 1
    bell_list, blist, b = [1, 1], [1], 1
    while True:
        blist = list(accumulate([b] + blist))
        b = blist[-1]
        fs = primefactors(b)
        for p in fs:
            if all(n % p for n in bell_list):
                yield p
                break
        else:
            yield 1
        bell_list.append(b)


def A245563_gen():  # generator of terms
    return chain(
        [0], (len(d) for n in count(1) for d in split("0+", bin(n)[:1:-1]) if d != "")
    )


def A246588(n):
    return (
        prod(bin(len(d)).count("1") for d in split("0+", bin(n)[2:]) if d)
        if n > 0
        else 1
    )


def A246595(n):
    return prod(len(d) ** 2 for d in split("0+", bin(n)[2:]) if d != "") if n > 0 else 1


def A246596(n):
    s, c = bin(n)[2:], [1, 1]
    for m in range(1, len(s)):
        c.append(c[-1] * (4 * m + 2) // (m + 2))
    return prod(c[len(d)] for d in split("0+", s)) if n > 0 else 1


def A247649_gen():  # generator of terms
    from sympy.abc import x

    f, g, blist = 1 / x**2 + 1 / x + 1 + x + x**2, 1, [1]
    yield 1
    for n in count(1):
        s = [int(d, 2) for d in bin(n)[2:].split("00") if d != ""]
        g = (g * f).expand(modulus=2)
        if len(s) == 1:
            blist.append(g.subs(x, 1))
            yield blist[-1]
        else:
            blist.append(prod(blist[d] for d in s))
            yield blist[-1]


def A225654_gen():  # generator of terms
    from sympy.abc import x

    f, g, blist, c = 1 / x**2 + 1 / x + 1 + x + x**2, 1, [1], 1
    yield c
    for n in count(1):
        s = [int(d, 2) for d in bin(n)[2:].split("00") if d != ""]
        g = (g * f).expand(modulus=2)
        if len(s) == 1:
            blist.append(g.subs(x, 1))
        else:
            blist.append(prod(blist[d] for d in s))
        c += blist[-1]
        yield c


def A254449(n):
    if n == 0:
        return 0
    i, m, s = 1, 1, "4" * n
    s2 = s + "4"
    while True:
        m *= i
        sn = str(m)
        if s in sn and s2 not in sn:
            return i
        i += 1


def A266142(n):
    return (
        4 * n
        if (n == 1 or n == 2)
        else sum(
            1
            for d in range(-3, 7)
            for i in range(n)
            if isprime((10**n - 1) // 3 + d * 10**i)
        )
    )


def A266146(n):
    return (
        4 * n
        if (n == 1 or n == 2)
        else sum(
            1
            for d in range(-7, 3)
            for i in range(n)
            if isprime(7 * (10**n - 1) // 9 + d * 10**i)
        )
    )


def A266148(n):
    return sum(
        1 for d in range(-9, 1) for i in range(n) if isprime(10**n - 1 + d * 10**i)
    )


def A289673_gen():  # generator of terms
    return (
        -1 if s == ("1",) else int(("".join(s) + ("2212" if s[0] == "2" else "11"))[3:])
        for l in count(1)
        for s in product("12", repeat=l)
    )


def A305611(n):
    fs = factorint(n)
    return len(
        set(
            sum(d)
            for i in range(1, sum(fs.values()) + 1)
            for d in multiset_combinations(fs, i)
        )
    )


def A317088(n):
    if n == 0:
        return 1
    c = 0
    for d in partitions(n, k=isqrt(2 * n)):
        l = len(d)
        if l > 0 and l == max(d):
            v = set(d.values())
            if len(v) == max(v):
                c += 1
    return c


def A345688(n):
    return pvariance(
        n**2 * v
        for u, v, w in (igcdex(x, y) for x in range(1, n + 1) for y in range(1, n + 1))
    )


def A004721(n):
    l = len(str(n))
    m = 2 * (10**l - 1) // 9
    k = n + l - int(n + l < m)
    return 1 if k == m else int(str(k).replace("2", ""))


def A004722(n):
    l = len(str(n))
    m = (10**l - 1) // 3
    k = n + l - int(n + l < m)
    return 2 if k == m else int(str(k).replace("3", ""))


def A004724(n):
    l = len(str(n))
    m = 5 * (10**l - 1) // 9
    k = n + l - int(n + l < m)
    return 4 if k == m else int(str(k).replace("5", ""))


def A004731(n):
    if n <= 1:
        return 1
    a, b = factorial2(n - 2), factorial2(n - 1)
    return b // gcd(a, b)


def A011968_gen():  # generator of terms
    yield from [1, 2]
    blist, b = [1], 1
    while True:
        blist = list(accumulate([b] + blist))
        yield b + blist[-1]
        b = blist[-1]


def A014710(n):
    s = bin(n + 1)[2:]
    m = len(s)
    i = s[::-1].find("1")
    return 2 - int(s[m - i - 2]) if m - i - 2 >= 0 else 2


def A017713_gen():  # generator of terms
    m = [1] * 50
    while True:
        yield m[-1]
        for i in range(49):
            m[i + 1] += m[i]


def A017713(n):
    return comb(n, 49)


def A020462_gen():  # generator of terms
    return filter(
        isprime, (int("".join(x)) for n in count(1) for x in product("35", repeat=n))
    )


@lru_cache(maxsize=None)
def A022825(n):
    if n <= 1:
        return n
    c, j = 0, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * A022825(k1)
        j, k1 = j2, n // j2
    return c + n + 1 - j


def A030665(n):
    d, nd = 10, 10 * n
    while True:
        x = nextprime(nd)
        if x < nd + d:
            return int(x)
        d *= 10
        nd *= 10


def A050932(n):
    return (q := bernoulli(n).q) // gcd(q, n + 1)


def A053600_gen():  # generator of terms
    yield 2
    p = 2
    while True:
        m, ps = 1, str(p)
        s = int("1" + ps + "1")
        while not isprime(s):
            m += 1
            ms = str(m)
            s = int(ms + ps + ms[::-1])
        p = s
        yield p


def A054268_gen():  # generator of terms
    return filter(
        lambda p: len(set(str(int(((q := nextprime(p)) - p - 1) * (q + p) // 2)))) == 1,
        (prime(n) for n in count(2)),
    )


def A061308_gen():  # generator of terms
    for n in count(2, 2):
        p = prevprime((n3 := n**3) // 2)
        if p + nextprime(p) == n3:
            yield p


def A061783_gen():  # generator of terms
    return filter(
        lambda p: isprime(p + int(str(p)[::-1])), (prime(n) for n in count(1))
    )


@lru_cache(maxsize=None)
def A063985(n):  # based on second formula in A018805
    if n == 0:
        return 0
    c, j = 0, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * (k1 * (k1 + 1) - 2 * A063985(k1) - 1)
        j, k1 = j2, n // j2
    return (2 * n + c - j) // 2


def A065847(n):
    return max(
        sum(
            1
            for t in multiset_permutations(s)
            if t[0] != "0" and isprime(int("".join(t), 6))
        )
        for s in combinations_with_replacement("012345", n)
    )


def A069862(n):
    nk, kr, r = n + 1, 1, 1 if n > 1 else 0
    while r:
        nk += 1
        kr = (kr + 1) % n
        r = (r * (10 ** len(str(nk)) % n) + kr) % n
    return nk - n


def A074989(n):
    a = integer_nthroot(n, 3)[0]
    return min(n - a**3, (a + 1) ** 3 - n)


def A082491_gen():  # generator of terms
    m, x = 1, 1
    for n in count(0):
        x, m = x * n**2 + m, -(n + 1) * m
        yield x


def A087666(n):
    c, x = 0, n
    a, b = divmod(x, 3)
    while b != 0:
        x *= a
        c += 1
        a, b = divmod(x, 3)
    return c


def A088658(n):
    return 4 * (n - 1) ** 2 + 4 * sum(
        totient(i) * (n - i) * (2 * n - i) for i in range(2, n)
    )


def A091049(n):
    k = 1
    while True:
        m1 = k
        for i in range(n + 1):
            m2 = int(str(m1), 1 + max(int(d) for d in str(m1)))
            if m1 == m2:
                if i == n:
                    return k
                else:
                    break
            m1 = m2
        k += 1


def A094577_gen():  # generator of terms
    yield 1
    blist, b = [1], 1
    for n in count(2):
        blist = list(accumulate([b] + blist))
        b = blist[-1]
        blist = list(accumulate([b] + blist))
        b = blist[-1]
        yield blist[-n]


def A094519_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        for i in range(1, len(d := divisors(n))):
            di = d[i]
            for j in range(i):
                if n % (di + d[j]) == 0:
                    yield n
                    break
            else:
                continue
            break


def A095149_gen():  # generator of terms
    yield from [1] * 3
    blist = [1]
    while True:
        blist = list(accumulate([blist[-1]] + blist))
        yield blist[-1]
        yield from blist


def A097227_gen():  # generator of terms
    ptuple = (2, 3, 5, 7, 11, 13, 17, 19, 23)
    for l in count(1):
        for d in combinations_with_replacement(range(1, 10), l):
            if (n := prod(ptuple[i - 1] for i in d)) < 10 ** l and tuple(
                sorted((int(x) for x in str(n)))
            ) == d:
                yield n


def A102487(n):
    return int(str(n), 12)


def A102491(n):
    return int(str(n), 20)


def A007091(n):
    return int(gmpy2digits(n, 5))


def A131535(n):
    s, t, m, k, u = "1" * n, "1" * (n + 1), 0, 1, "1"
    while s not in u or t in u:
        m += 1
        k *= 2
        u = str(k)
    return m


def A131544(n):
    m, s = 1, "9" * n
    for i in count(1):
        m *= 3
        if s in str(m):
            return i


def A131546(n):
    str7 = "7" * n
    x, exponent = 3, 1
    while not str7 in str(x):
        exponent += 1
        x *= 3
    return exponent


def A131552(n):
    m, s = 1, "1" * n
    for i in count(1):
        m *= 3
        if s in str(m):
            return i


def A153695_gen():  # generator of terms
    m10, m9, q = 10, 9, 0
    for m in count(1):
        r = m10 % m9
        if r > q:
            q = r
            yield m
        m10 *= 10
        m9 *= 9
        q *= 9


def A153745_gen():  # generator of terms
    for l in count(1):
        if not is_prime(l):
            fs = divisors(l)
            a = isqrt(10 ** (l - 1)) + ((l - 1) % 2)
            for n in range(a, isqrt(10**l - 1) + 1):
                for g in fs:
                    if not is_square(
                        sum(int(str(n**2)[h : h + g]) for h in range(0, l, g))
                    ):
                        break
                else:
                    yield n


def A155146_gen():  # generator of terms
    n3, m = 0, 0
    for n in count(1):
        m += 6 * (n - 1)
        n3 += m + 1
        if len(set(str(n3))) == 3:
            yield n


def A159065(n):
    return (
        n - 1
        if n <= 2
        else 2 * n
        - 3
        + 3 * sum(totient(i) * (n - i) * i for i in range(2, (n + 1) // 2))
        + sum(totient(i) * (n - i) * (2 * n - i) for i in range((n + 1) // 2, n))
    )


def A163573_gen():  # generator of terms
    return (
        4 * q - 3
        for q in (prime(i) for i in count(1))
        if isprime(4 * q - 3)
        and isprime(2 * q - 1)
        and (not (4 * q - 1) % 3)
        and isprime((4 * q - 1) // 3)
    )


def A175047(n):
    return int(
        "".join(
            d + "0" if "0" in d else d
            for d in split("(0+)|(1+)", bin(n)[2:])
            if d != "" and d != None
        ),
        2,
    )


def A188068(n):
    return int(isqrt(3 * n**2) - isqrt(3 * (n - 1) ** 2)) - 1


def A201053(n):
    return (
        a**3
        if 2 * n < (a := integer_nthroot(n, 3)[0]) ** 3 + (a + 1) ** 3
        else (a + 1) ** 3
    )


def A211264(n):
    return (lambda m: sum(n // k for k in range(1, m + 1)) - m * (m + 1) // 2)(isqrt(n))


def A212529(n):
    s, q = "", -n
    while q >= 2 or q < 0:
        q, r = divmod(q, -2)
        if r < 0:
            q += 1
            r += 2
        s += str(r)
    return int(str(q) + s[::-1])


def A219327_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        s = [int(d) for d in str(n)]
        m = len(s)
        if n == abs(Matrix(m, m, lambda i, j: s[(i - j) % m]).det()):
            yield n


def A230892_gen():  # generator of terms
    yield from [0, 3]
    l, s, b = Counter("11"), 1, {3}
    while True:
        i = s
        while True:
            if i not in b:
                li, o = Counter(bin(i)[2:]), 0
                for d in (l + li).values():
                    if d % 2:
                        if o > 0:
                            break
                        o += 1
                else:
                    yield i
                    l = li
                    b.add(i)
                    while s in b:
                        b.remove(s)
                        s += 1
                    break
            i += 1


def A244112(n):
    return int(
        "".join([str(str(n).count(d)) + d for d in "9876543210" if str(n).count(d) > 0])
    )


def A249915_gen():  # generator of terms
    for l in count(0):
        for a in product("23456", repeat=l):
            for b in ("2", "4", "5", "6"):
                s = "".join(a) + b
                if "2" in s and "6" in s:
                    n = int(s)
                    if {"2", "6"} <= set(str(n**2)) <= {"2", "3", "4", "5", "6"}:
                        yield n


def A287055_gen():  # generator of terms
    a = 1
    for n in count(1):
        b = prod(p**e - 1 for p, e in factorint(n + 1).items())
        if a == b:
            yield n
        a, n = b, n + 1


def A296369_gen(startvalue=1):  # generator of terms
    return filter(lambda n: pow(2, n + 1, n) == n - 1, count(max(startvalue, 1)))


def A324043(n):
    return (
        0
        if n == 1
        else -2 * (n - 1) ** 2
        + sum(
            totient(i) * (n + 1 - i) * (7 * i - 2 * n - 2) for i in range(2, n // 2 + 1)
        )
        + sum(
            totient(i) * (n + 1 - i) * (2 * n + 2 - i) for i in range(n // 2 + 1, n + 1)
        )
    )


def A335567(n):
    return (n - (m := divisor_count(n))) * (n - m + 1) // 2


def A341715(n):
    m, k = n, n
    while not isprime(m):
        k += 1
        m = int(str(m) + str(k))
    return m


def A345689(n):
    return pvariance(
        n**2 * abs(u)
        for u, v, w in (igcdex(x, y) for x in range(1, n + 1) for y in range(1, n + 1))
    )


def A003221_gen():  # generator terms
    m, x = -1, 0
    for n in count(0):
        x, m = x * n + m * (n * (n - 1) // 2 - 1), -m
        yield x


def A004723(n):
    l = len(str(n))
    m = 4 * (10**l - 1) // 9
    k = n + l - int(n + l < m)
    return 3 if k == m else int(str(k).replace("4", ""))


def A004725(n):
    l = len(str(n))
    m = 2 * (10**l - 1) // 3
    k = n + l - int(n + l < m)
    return 5 if k == m else int(str(k).replace("6", ""))


def A004726(n):
    l = len(str(n))
    m = 7 * (10**l - 1) // 9
    k = n + l - int(n + l < m)
    return 6 if k == m else int(str(k).replace("7", ""))


def A004727(n):
    l = len(str(n))
    m = 8 * (10**l - 1) // 9
    k = n + l - int(n + l < m)
    return 7 if k == m else int(str(k).replace("8", ""))


def A007464_gen():  # generator of terms
    blist = [1, 1]
    yield from blist
    for n in count(1):
        blist.append(sum(gcd(blist[i], blist[n - i]) for i in range(n + 1)))
        yield blist[-1]


def A022488_gen():  # generator of terms
    yield 2
    l = "2"
    while True:
        l = "".join(
            d[0] + str(len(d))
            for d in split("(0+|1+|2+|3+|4+|5+|6+|7+|8+|9+)", l[::-1])
            if d != ""
        )
        yield int(l)


def A047898_gen():  # generator of terms
    l = 6
    while True:
        yield l
        l *= sum(int(d) for d in str(l))


def A047901_gen():  # generator of terms
    l = 9
    while True:
        yield l
        l *= sum(int(d) for d in str(l))


def A059168_helper(w, dir):
    if dir == 1:
        for s in w:
            for t in range(int(s[-1]) + 1, 10):
                yield s + str(t)
    else:
        for s in w:
            for t in range(0, int(s[-1])):
                yield s + str(t)


def A059168_gen():  # generator of terms
    for l in count(0):
        for d in "123456789":
            x = d
            for i in range(1, l + 1):
                x = A059168_helper(x, (-1) ** i)
            yield from (int(p) for p in x if isprime(int(p)))
            if l > 0:
                y = d
                for i in range(1, l + 1):
                    y = A059168_helper(y, (-1) ** (i + 1))
                yield from (int(p) for p in y if isprime(int(p)))


def A061246_gen():  # generator of terms
    return (
        int(i + "".join(j) + k)
        for l in count(0)
        for i in "149"
        for j in product("0149", repeat=l)
        for k in "19"
        if isprime(int(i + "".join(j) + k))
    )


def A063565(n):
    s, k, k2 = str(n), 1, 2
    while True:
        if s in str(k2):
            return k
        k += 1
        k2 *= 2


def A064169(n):
    return (lambda x: x.p - x.q)(harmonic(n))


def A068187(n):
    if n == 1:
        return 1
    pf = factorint(n)
    return (
        0
        if max(pf) > 7
        else int(
            "".join(
                sorted(
                    "".join(str(a) * (n * b) for a, b in pf.items())
                    .replace("222", "8")
                    .replace("22", "4")
                    .replace("33", "9")
                )
            )
        )
    )


def A072961_gen():  # generator of terms
    return (int("".join(a)) for l in count(1) for a in product("25", repeat=l))


def A081134(n):
    kmin, kmax = 0, 1
    while 3**kmax <= n:
        kmax *= 2
    while True:
        kmid = (kmax + kmin) // 2
        if 3**kmid > n:
            kmax = kmid
        else:
            kmin = kmid
        if kmax - kmin <= 1:
            break
    return min(n - 3**kmin, 3 * 3**kmin - n)


@lru_cache(maxsize=None)
def A082544(n):
    if n == 0:
        return 0
    c, j = 1, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * A082544(k1)
        j, k1 = j2, n // j2
    return n * (n**4 - 1) - c + j


def A090709_gen():  # generator of terms
    return filter(isprime, (int(gmpy2digits(d, 6)) for d in count(0) if is_prime(d)))


def A091627(n):
    m = isqrt(n)
    return 0 if n == 0 else sum(n // k for k in range(1, m + 1)) - m * (m - 1) // 2 - 1


def A094593(n):
    p = prime(n)
    return 1 if n == 3 else (p - 1) // n_order(3, p)


def A118600_gen():
    return palbase_gen(9)


def A118599_gen():
    return palbase_gen(8)


def A118598_gen():
    return palbase_gen(7)


def A118597_gen():
    return palbase_gen(6)


def A118596_gen():
    return palbase_gen(5)


def A118595_gen():
    return palbase_gen(4)


def A118594_gen():
    return palbase_gen(3)


def A123098(n):
    return prod(1 if ~(n - 1) & k else prime(k + 1) for k in range(n))


def A131536(n):
    s, t, m, k, u = "2" * n, "2" * (n + 1), 0, 1, "1"
    while s not in u or t in u:
        m += 1
        k *= 2
        u = str(k)
    return m


def A145551_gen(startvalue=1):
    return filter(
        lambda n: not n ** divisor_sigma(n, 0) % divisor_sigma(n, 1) ** 2,
        count(max(startvalue, 1)),
    )


def A169639(n):
    return sum(ord(s) - 96 for s in unidecode(num2words(n, lang="fr")) if s.isalpha())


def A189718_gen():  # generator of terms
    blist = [0]
    yield 0
    while True:
        x = [1 - d for d in blist] * 2
        blist.extend(x)
        yield from x


def A241100(n):
    for i in range(1, 10):
        x = i * (10**n - 1) // 9
        for j in range(n - 1, -1, -1):
            for k in range(i, -1, -1):
                if j < n - 1 or k < i:
                    y = x - k * (10**j)
                    if isprime(y):
                        return y
        for j in range(n):
            for k in range(1, 9 - i + 1):
                y = x + k * (10**j)
                if isprime(y):
                    return y


def A266141(n):
    return 4 if n == 1 else sum(1 for d in "1379" if isprime(int("2" * (n - 1) + d)))


def A266144(n):
    return (
        4
        if n == 1
        else sum(1 for d in [-4, -2, 2, 4] if isprime(5 * (10**n - 1) // 9 + d))
    )


def A266145(n):
    return (
        4
        if n == 1
        else sum(1 for d in [-5, -3, 1, 3] if isprime(2 * (10**n - 1) // 3 + d))
    )


def A266147(n):
    return (
        4
        if n == 1
        else sum(1 for d in [-7, -5, -1, 1] if isprime(8 * (10**n - 1) // 9 + d))
    )


def A276740_gen():  # generator of terms
    yield from [1, 2, 4]
    yield from filter(lambda n: pow(3, n, n) == 5, count(5))


def A277289_gen():  # generator of terms
    yield from [1, 2, 4, 5]
    yield from filter(lambda n: pow(3, n, n) == n - 7, count(6))


def A277288_gen():  # generator of terms
    yield from [1, 2]
    yield from filter(lambda n: pow(3, n, n) == n - 5, count(3))


def A277340_gen():  # generator of terms
    yield from [1, 2, 4, 7, 10]
    yield from filter(lambda n: pow(3, n, n) == n - 11, count(11))


def A288104(n):
    ndict = {}
    for i in range(n):
        m = pow(i, 9, n)
        if m in ndict:
            ndict[m] += 1
        else:
            ndict[m] = 1
    count = 0
    for i in ndict:
        ni = ndict[i]
        for j in ndict:
            k = (i + j) % n
            if k in ndict:
                count += ni * ndict[j] * ndict[k]
    return count


def A288105(n):
    ndict = {}
    for i in range(n):
        m = pow(i, 10, n)
        if m in ndict:
            ndict[m] += 1
        else:
            ndict[m] = 1
    count = 0
    for i in ndict:
        ni = ndict[i]
        for j in ndict:
            k = (i + j) % n
            if k in ndict:
                count += ni * ndict[j] * ndict[k]
    return count


def A289677(n):
    c, k, r, n2, cs, ts = (
        0,
        1 + (n - 1) // 3,
        2 ** ((n - 1) % 3),
        2 ** (n - 1),
        set(),
        set(),
    )
    for i in range(2**k):
        j, l = int(bin(i)[2:], 8) * r, n2
        traj = set([(l, j)])
        while True:
            if j >= l:
                j = j * 16 + 13
                l *= 2
            else:
                j *= 4
                l //= 2
            if l == 0:
                ts.update(traj)
                break
            j %= 2 * l
            if (l, j) in traj:
                c += 1
                cs.update(traj)
                break
            if (l, j) in cs:
                c += 1
                break
            if (l, j) in ts:
                break
            traj.add((l, j))
    return c


def A307371_gen():  # generator of terms
    blist = [0, 1, 98, 99, 100, 9998]
    yield from blist
    while True:
        blist = blist[1:] + [101 * blist[-3] - 100 * blist[-6]]
        yield blist[-1]


def A307437(n):
    for k in count(1):
        if not reduced_totient(k) % (2 * n):
            return k


def A324042(n):
    return 2 * (
        2 * n**2
        - n
        + 1
        + 2
        * sum(totient(i) * (n + 1 - 2 * i) * (n + 1 - i) for i in range(2, n // 2 + 1))
    )


def A342632(n):
    return 2 * sum(t for t in sieve.totientrange(1, 2**n + 1)) - 1


@lru_cache(maxsize=None)
def A343978(n):
    if n == 0:
        return 0
    c, j, k1 = 1, 2, n // 2
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * A343978(k1)
        j, k1 = j2, n // j2
    return n * (n**5 - 1) - c + j


def A344866(n):
    return n * (n * (n * (2 * n - 11) + 23) - 21) + 7


def A345690(n):
    return pvariance(
        n**2 * abs(v)
        for u, v, w in (igcdex(x, y) for x in range(1, n + 1) for y in range(1, n + 1))
    )


def A004728(n):
    l = len(str(n))
    m = 10**l - 1
    k = n + l - int(n + l < m)
    return 8 if k == m else int(str(k).replace("9", ""))


def A014957_gen(startvalue=1):
    return filter(lambda n: n == 1 or pow(16, n, n) == 1, count(max(startvalue, 1)))


def A023002(n):
    return (
        n
        * (n**2 * (n**2 * (n**2 * (n**2 * (n * (6 * n + 33) + 55) - 66) + 66) - 33) + 5)
        // 66
    )


def A160773_gen():  # generator of terms
    p3, p5, p7 = [1] * 3
    for k in count(0):
        if isprime(p3 + p5 + p7):
            yield k
        p3 *= 3
        p5 *= 5
        p7 *= 7


def A349682(n):
    return n * (n * (36 * n + 36) + 11) + 1


def A349466(n):
    return 24 * 24**n + 64 * 2 ** (4 * n) - 81 * 18**n - 6 * 12**n


def A029455_gen():  # generator of terms
    r = 0
    for n in count(1):
        r = r * 10 ** len(str(n)) + n
        if not (r % n):
            yield n


def A052045_gen(startvalue=1):
    return filter(
        lambda n: not str(n).count("0"), (n**3 for n in count(max(startvalue, 1)))
    )


def A058233_gen():  # generator of terms
    p, q, r = 2, 3, 2
    while True:
        if (r + 1) % q == 0:
            yield p
        r *= q
        p, q = q, nextprime(q)


def A077110(n):
    n2 = n**2
    a = integer_nthroot(n2, 3)[0]
    a2, a3 = a**3, (a + 1) ** 3
    return a3 if a3 + a2 - 2 * n2 < 0 else a2


def A081762_gen():
    return filter(
        lambda p: pow(2, p - 1, p * (p - 2)) == 1, (prime(n) for n in count(2))
    )


def A082216(n):
    s = str(n)
    t = s[::-1]
    if s == t:
        return n
    for i in range(1, len(s)):
        if s[i:] == t[:-i]:
            return int(s + t[-i:])


def A085807(n):
    return Matrix(n, n, [abs(j - k) for j in range(n) for k in range(n)]).per()


def A090287(n):
    sn = str(n)
    if n in (231, 420, 759) or not (len(sn) % 2 or n % 11):
        return 0
    for i in count(1):
        for j in range(1, 10, 2):
            si = str(j) * i
            p = int(si + sn + si)
            if isprime(p):
                return p


def A099004_gen():  # generator of terms
    yield 1
    l, s, b1, b2 = 2, 3, set(), {1}
    while True:
        i = s
        while True:
            m = abs(i - l)
            if not (i in b1 or m in b2):
                yield i - l
                b1.add(i)
                b2.add(m)
                l = i
                while s in b1:
                    b1.remove(s)
                    s += 1
                break
            i += 1


def A110819_gen(startvalue=1):
    return filter(
        lambda n: (s := str(n)) != s[::-1]
        and primefactors(n) == primefactors(int(s[::-1])),
        count(max(startvalue, 1)),
    )


def A111163_gen():
    return filter(
        lambda n: not isprime(n // 2) and prevprime(n // 2) + nextprime(n // 2) == n,
        (n * (n + 1) // 2 for n in count(3)),
    )


def A111234_gen():
    return chain(
        (2,), (a + b // a for a, b in ((min(factorint(n)), n) for n in count(2)))
    )


def A124661_gen():  # generator of terms
    for n in count(1):
        p = prime(n)
        for k in range(1, n - 1):
            if prime(n - k) + prime(n + k) < 2 * p:
                break
        else:
            yield p


def A127962_gen():
    return (
        int(bin(p)[2:])
        for p in filter(isprime, ((2 ** prime(n) + 1) // 3 for n in count(2)))
    )


def A145642(n):
    return (
        1 if n <= 1 else prod(p ** (e % 3) for p, e in factorint(factorial(n)).items())
    )


def A160256_gen():  # generator of terms
    yield from [1, 2]
    l1, m, b = 2, 1, {1, 2}
    while True:
        i = m
        while True:
            if not i in b:
                yield i
                l1, m = i, l1 // gcd(l1, i)
                b.add(i)
                break
            i += m


def A165562_gen(startvalue=1):
    return filter(
        lambda n: isprime(n + sum(int(n * e / p) for p, e in factorint(n).items())),
        count(max(startvalue, 1)),
    )


@lru_cache(maxsize=None)
def A171503(n):  # based on second formula in A018805
    if n == 0:
        return 0
    c, j = 0, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * (A171503(k1) - 1) // 2
        j, k1 = j2, n // j2
    return 2 * (n * (n - 1) - c + j) - 1


def A175499_gen():  # generator of terms
    yield 1
    bset, l, s, b = {1}, 2, 3, set()
    while True:
        i, j = s, s - l
        while True:
            if not (i in b or j in bset):
                yield j
                bset.add(j)
                b.add(i)
                l = i
                while s in b:
                    b.remove(s)
                    s += 1
                break
            i += 1
            j += 1


def A210503_gen(startvalue=2):  # generator of terms
    for n in count(max(startvalue, 2)):
        nd = sum(n * e // p for p, e in factorint(n).items())
        if is_square(nd**2 + n**2) and gcd(n, nd, isqrt(nd**2 + n**2)) == 1:
            yield n


def A235800(n):
    return ((n & -2) << 1) + 3 if n & 1 else n >> 1


def A241816(n):
    s = bin(n)[2:]
    for i in range(len(s) - 2, -1, -1):
        if s[i : i + 2] == "10":
            return int(s[:i] + "01" + s[i + 2 :], 2)
    else:
        return n


def A243103(n):
    y, pf = 1, set(primefactors(n))
    for m in range(2, n + 1):
        if set(primefactors(m)) <= pf:
            y *= m
    return y


def A257226_gen(startvalue=1):
    return filter(
        lambda n: any("9" in str(d) for d in divisors(n, generator=True)),
        count(max(startvalue, 1)),
    )


def A257225_gen(startvalue=1):
    return filter(
        lambda n: any("8" in str(d) for d in divisors(n, generator=True)),
        count(max(startvalue, 1)),
    )


def A257224_gen(startvalue=1):
    return filter(
        lambda n: any("7" in str(d) for d in divisors(n, generator=True)),
        count(max(startvalue, 1)),
    )


def A257223_gen(startvalue=1):
    return filter(
        lambda n: any("6" in str(d) for d in divisors(n, generator=True)),
        count(max(startvalue, 1)),
    )


def A257222_gen(startvalue=1):
    return filter(
        lambda n: any("5" in str(d) for d in divisors(n, generator=True)),
        count(max(startvalue, 1)),
    )


def A257221_gen(startvalue=1):
    return filter(
        lambda n: any("4" in str(d) for d in divisors(n, generator=True)),
        count(max(startvalue, 1)),
    )


def A257220_gen(startvalue=1):
    return filter(
        lambda n: any("3" in str(d) for d in divisors(n, generator=True)),
        count(max(startvalue, 1)),
    )


def A257219_gen(startvalue=1):
    return filter(
        lambda n: any("2" in str(d) for d in divisors(n, generator=True)),
        count(max(startvalue, 1)),
    )


def A257486_gen():  # generator of terms
    for l in count(0):
        for a in product("34567", repeat=l):
            for b in ("4", "5", "6"):
                s = "".join(a) + b
                if "3" in s and "7" in s:
                    n = int(s)
                    if {"3", "7"} <= set(str(n**2)) <= {"3", "4", "5", "6", "7"}:
                        yield n


def A258981_gen():
    return filter(
        lambda n: max(gmpy2digits(n, 3)) <= "1",
        (int(format(d, "b"), 4) for d in count(0)),
    )


def A263132_gen(startvalue=1):
    return filter(lambda m: not ~(4 * m - 1) & m, count(max(startvalue, 1)))


def A267769_gen():
    return (
        int(s, 9) for s in filter(lambda s: max(s) < "9", (str(i**2) for i in count(0)))
    )


def A271472(n):
    if n == 0:
        return 0
    else:
        s, q = "", n
        while q:
            q, r = c_divmod(q, -4)
            s += ("0000", "1000", "0011", "1011")[r]
        return int(s[::-1])


def A350087(n):
    a, b = lucas2(n + 1)
    return pow(b, a, a + b)


def A272170_gen():  # generator of terms
    a, b = 1, 1
    while True:
        a, b = b, a + b
        yield int(bin(b)[3])


def A272170(n):
    return int(bin(fibonacci(n))[3])


def A284597(n):
    count, starti, s, i = 0, 1, 0, 1
    while True:
        d = divisor_count(i)
        if d < s:
            if count == n:
                return starti
            starti = i
            count = 0
        s = d
        i += 1
        count += 1


def A298684_gen(startvalue=1):  # generator of terms
    b, a = fib2((sv := max(startvalue, 1)) + 1)
    for n in count(sv):
        if not (a % (n * (n + 1) * (n + 2) // (1 if n % 2 else 2))):
            yield n
        a, b = b, a + b


def A306360_gen(startvalue=1):  # generator of terms
    for k in count(max(startvalue, 1)):
        s = str(k)
        l, c = len(s), 0
        for i in range(l):
            c = (c + int(s[i]) ** l) % k
        if c == 0:
            yield k


def A319651(n):
    return int("".join(sorted(gmpy2digits(n, 3), reverse=True)), 3)


def A331761(n):
    return (n - 1) ** 2 + 2 * sum(
        totient(i) * (n + 1 - 2 * i) * (n + 1 - i) for i in range(2, n // 2 + 1)
    )


def A011772(n):
    plist = tuple(p**q for p, q in factorint(2 * n).items())
    return (
        2 * n - 1
        if len(plist) == 1
        else int(
            min(
                min(crt((m, 2 * n // m), (0, -1))[0], crt((2 * n // m, m), (0, -1))[0])
                for m in (
                    prod(d)
                    for l in range(1, len(plist) // 2 + 1)
                    for d in combinations(plist, l)
                )
            )
        )
    )


def A344590(n):
    m = A011772(n)
    return sum(1 for d in divisors(n) if A011772(d) == m)


def A345691(n):
    return pvariance(
        n**2 * (u**2 + v**2)
        for u, v, w in (igcdex(x, y) for x in range(1, n + 1) for y in range(1, n + 1))
    )


def A004730(n):
    a, b = factorial2(n), factorial2(n + 1)
    return a // gcd(a, b)


def A025281(n):
    return sum(p * e for p, e in factorint(factorial(n)).items())


def A029732_gen():
    return filter(isprime, pal_gen(16))


def A030292_gen(startvalue=0):
    return filter(lambda n: len(set(str(n**3))) <= 2, count(max(startvalue, 0)))


def A031749_gen(startvalue=1):
    return (
        n
        for n, d in filter(
            lambda x: isinstance(x[1], list) and min(x[1]) == 71,
            (
                (n, continued_fraction_periodic(0, 1, n)[-1])
                for n in count(max(startvalue, 1))
            ),
        )
    )


def A038529(n):
    return prime(n) - composite(n)


@lru_cache(maxsize=None)
def A046657(n):  # based on second formula in A018805
    if n == 0:
        return 0
    c, j = 0, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * (4 * A046657(k1) - 1)
        j, k1 = j2, n // j2
    return (n * (n - 1) - c + j) // 4


def A048700(n):
    s = bin(n)[2:]
    return int(s + s[-2::-1], 2)


def A048890_gen():  # generator of terms
    for l in count(1):
        for e in "1689":
            for d in product("01689", repeat=l):
                s = e + "".join(d)
                p = int(s)
                if p > 0:
                    q = int(s[::-1].rstrip("0").translate("".maketrans("69", "96")))
                    if p != q and isprime(q) and isprime(p):
                        yield p


def A048943_gen(startvalue=1):
    return filter(
        lambda i: integer_nthroot(i, 4)[1] or not divisor_count(i) % 4,
        count(max(startvalue, 1)),
    )


def A053782_gen():  # generator of terms
    m, s, p = 4, 4, 5
    for n in count(1):
        if isprime(s):
            yield n
        m += 1
        if m == p:
            m += 1
            p = nextprime(p)
        s += m


def A055472_gen():
    return filter(isprime, (n * (n + 1) // 2 + 2 for n in count(0)))


def A059539(n):
    return integer_nthroot(3 * n**3, 3)[0]


def A064799(n):
    return prime(n) + composite(n)


def A068653_gen():  # generator of terms
    for l in count(1):
        for m in product(("1379" if l > 1 else "123579"), repeat=l):
            for d in "0123456789":
                s = "".join(m) + d
                n = int(s)
                if not isprime(n):
                    for k in range(len(s) - 1):
                        s = s[1:] + s[0]
                        if not isprime(int(s)):
                            break
                    else:
                        yield n


def A074200(n):
    a = lcm(range(1, n + 1))
    m = a
    while True:
        for k in range(n, 0, -1):
            if not isprime(m // k + 1):
                break
        else:
            return m
        m += a


def A074925_gen(startvalue=2):
    return filter(
        lambda i: prevprime(i**3 // 2) + nextprime(i**3 // 2) == i**3,
        count(max(startvalue + startvalue % 2, 2), 2),
    )


def A088104(n):
    return nextprime((p := prime(n)) * 10 ** (n - len(str(p))) - 1)


def A090693_gen():
    return (
        i
        for i, n in filter(
            lambda x: x[0] > 0 and isprime(x[1] + 2),
            enumerate(accumulate(range(10**5), lambda x, y: x + 2 * y - 3)),
        )
    )


def A091938(n):
    for i in range(n, -1, -1):
        q = 2**n
        for d in multiset_permutations("0" * (n - i) + "1" * i):
            p = q + int("".join(d), 2)
            if isprime(p):
                return p


def A099906(n):
    return comb(2 * n - 1, n - 1) % (n**2)


def A099908(n):
    return comb(2 * n - 1, n - 1) % (n**4)


@lru_cache(maxsize=None)
def A100613(n):  # based on second formula in A018805
    if n == 0:
        return 0
    c, j = 1, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * (k1**2 - A100613(k1))
        j, k1 = j2, n // j2
    return n + c - j


def A104804_gen():  # generator of terms
    blist = [1, 3]
    yield from blist
    while True:
        i, j = isqrt_rem(blist[-1] ** 2 + blist[-2] ** 2)
        blist = blist[1:] + [int(i + int(4 * (j - i) >= 1))]
        yield blist[-1]


def A105870_gen():  # generator of terms
    a, b = 0, 1
    while True:
        yield a
        a, b = b, (a + b) % 7


def A107715_gen():
    return filter(isprime, (int(gmpy2digits(n, 4)) for n in count(0)))


def A116017_gen(startvalue=1):
    return filter(
        lambda n: len(set(str(n + sum(divisors(n))))) == 1, count(max(startvalue, 1))
    )


def A121943_gen():  # generator of terms
    b = 2
    for n in count(1):
        if not b % (n**2):
            yield n
        b = b * (4 * n + 2) // (n + 1)


def A163574_helper(n, b):
    if n == 1:
        t = list(range(1, b))
        for i in range(1, b):
            u = list(t)
            u.remove(i)
            yield i, u
    else:
        for d, v in A163574_helper(n - 1, b):
            for g in v:
                k = d * b + g
                if not k % n:
                    u = list(v)
                    u.remove(g)
                    yield k, u


def A163574(n):
    if n % 2:
        return 0
    for a, b in A163574_helper(n - 1, n):
        return a
    return 0


def A168294(n):
    s, t = [int(d) for d in str(n)], [int(d) for d in str(n + 1)]
    l, m = len(s), len(t)
    u = [0] * (l + m - 1)
    for i in range(l):
        for j in range(m):
            u[i + j] = (u[i + j] + s[i] * t[j]) % 10
    return int("".join(str(d) for d in u))


def A195527_gen(startvalue=1):  # generator of terms
    for m in count(max(startvalue, 1)):
        n, c = 3, 0
        while n * (n + 1) <= 2 * m:
            if not 2 * (n * (n - 2) + m) % (n * (n - 1)):
                c += 1
                if c > 2:
                    break
            n += 1
        if c == 2:
            yield m


def A195528_gen(startvalue=1):  # generator of terms
    for m in count(max(startvalue, 1)):
        n, c = 3, 0
        while n * (n + 1) <= 2 * m:
            if not 2 * (n * (n - 2) + m) % (n * (n - 1)):
                c += 1
                if c > 3:
                    break
            n += 1
        if c == 3:
            yield m


def A196368(n):
    return int(all(str(n)[i] != str(n)[i - 1] for i in range(1, len(str(n)))))


def A216822_gen(startvalue=1):
    return filter(
        lambda n: n == 1 or pow(2, n, n * (n + 1)) == 2, count(max(startvalue, 1))
    )


def A226459(n):
    return sum(totient(d) * d ** (d - 1) for d in divisors(n, generator=True))


def A241206(n):
    for i in range(9, 0, -1):
        x = i * (10**n - 1) // 9
        for j in range(n - 1, -1, -1):
            for k in range(9 - i, -1, -1):
                y = x + k * (10**j)
                if isprime(y):
                    return y
        for j in range(n):
            for k in range(1, i + 1):
                if j < n - 1 or k < i:
                    y = x - k * (10**j)
                    if isprime(y):
                        return y


def A247012_gen(startvalue=2):  # generator of terms
    for n in count(max(startvalue, 2)):
        if not isprime(n):
            m = int(str(n)[::-1])
            x = divisors(n)
            x.pop()
            y = divisor_sigma(n) - n
            while y < m:
                x, y = x[1:] + [y], 2 * y - x[0]
            if y == m:
                yield n


def A247219_gen(startvalue=2):
    return filter(lambda n: pow(2, n, n * n - 1) == 1, count(max(startvalue, 2)))


def A252022_gen():  # generator of terms
    l, s, b = [1], 2, set()
    yield 1
    while True:
        i = s
        while True:
            if i not in b:
                li = [int(d) for d in str(i)[::-1]]
                for x, y in zip(li, l):
                    if x + y > 9:
                        break
                else:
                    l = li
                    b.add(i)
                    yield i
                    while s in b:
                        b.remove(s)
                        s += 1
                    break
            i += 1


def A253046(n):
    q2, r2 = divmod(n, 2)
    if not r2 and isprime(q2):
        return 3 * nextprime(q2)
    else:
        q3, r3 = divmod(n, 3)
        if not r3 and isprime(q3):
            return 2 * prevprime(q3)
        return n


def A259089(n):
    s, k2 = "2" * n, 1
    for k in count(0):
        if s in str(k2):
            return k
        k2 *= 2


def A267763_gen():
    return (
        int(d, 3) for d in filter(lambda d: max(d) < "3", (str(i**2) for i in count(0)))
    )


def A269784_gen():  # generator of terms
    j = -5
    for i in count(0):
        if isprime(j):
            yield j
        j += 4 * (i + 1)


def A286262_gen(startvalue=0):
    return filter(lambda n: is_cubefree_string(bin(n)[2:]), count(max(startvalue, 0)))


def A291626_gen(startvalue=1):
    return filter(lambda k: min(str(k**2)) == "1", count(max(startvalue, 1)))


def A291630_gen(startvalue=1):
    return filter(lambda k: min(str(k**2)) == "5", count(max(startvalue, 1)))


def A291644_gen(startvalue=1):
    return filter(lambda k: min(str(k**3)) == "5", count(max(startvalue, 1)))


def A322131(n):
    return int("".join(str(int(d) * 2) for d in str(n)))


def A332584(n):
    r, m = n, n + 1
    while True:
        r = r * 10 ** (len(str(m))) + m
        if m % 2 == 0 and r % (m + 1) == 0:
            return m
        m += 1


def A338228(n):
    return n - divisor_count(isqrt(n // numbercore(n, 2)))


def A338231(n):
    return n * (n + 1) // 2 - divisor_sigma(isqrt(n // numbercore(n, 2)))


def A338233(n):
    return 0 if n <= 1 else n - 1 - divisor_count(isqrt(n // numbercore(n, 2)))


def A338234(n):
    return (
        0 if n <= 1 else n * (n - 1) // 2 - divisor_sigma(isqrt(n // numbercore(n, 2)))
    )


def A338236(n):
    return isqrt(n) - divisor_count(isqrt(n // numbercore(n, 2)))


def A344993(n):
    return 2 * n * (n + 1) + 2 * sum(
        totient(i) * (n + 1 - i) * (2 * n + 2 - i) for i in range(2, n + 1)
    )


def A345428(n):
    return sum(
        u + v
        for u, v, w in (igcdex(x, y) for x in range(1, n + 1) for y in range(1, n + 1))
    )


def A345434(n):
    return sum(
        u**2 + v**2
        for u, v, w in (igcdex(x, y) for x in range(1, n + 1) for y in range(1, n + 1))
    )


def A347306(n):
    if n == 1:
        return 1
    i, j, nset, m = 1, 2, {1}, 2
    while True:
        k = m
        i += 1
        while k == j or gcd(k, j) == 1 or k in nset:
            k += 1
        if k == n:
            return i
        j = k + 1
        nset.add(k)
        while m in nset:
            m += 1


def A347307_gen():  # generator of terms
    yield 1
    nset, m, c, j = {1}, 2, 0, 2
    while True:
        k = m
        while k == j or gcd(k, j) == 1 or k in nset:
            k += 1
        if k > c:
            c = k
            yield k
        j = k + 1
        nset.add(k)
        while m in nset:
            m += 1


def A348004_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        pset = set()
        for d in udivisors(n, generator=True):
            u = prod(p**e - 1 for p, e in factorint(d).items())
            if u in pset:
                break
            pset.add(u)
        else:
            yield n


def A001962(n):
    return 3 * n + isqrt(5 * n**2)


@lru_cache(maxsize=None)
def A015634(n):
    if n == 0:
        return 0
    c, j = 1, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * A015634(k1)
        j, k1 = j2, n // j2
    return n * (n + 1) * (n + 2) * (n + 3) // 24 - c + j - n


@lru_cache(maxsize=None)
def A025523(n):
    if n == 0:
        return 1
    c, j = 2, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * A025523(k1)
        j, k1 = j2, n // j2
    return n + c - j


def A051572_gen():
    return accumulate(repeat(5), lambda x, _: divisor_sigma(x))


def A057436_gen():
    return (int("".join(d)) for l in count(1) for d in product("123456", repeat=l))


def A060984_gen():
    return accumulate(repeat(1), lambda x, _: x + isqrt(x) ** 2)


def A066058(n):
    if n > 0:
        for k in count(0):
            m = k
            for i in range(n):
                s1 = format(m, "b")
                s2 = s1[::-1]
                if s1 == s2:
                    break
                m += int(s2, 2)
            else:
                s1 = format(m, "b")
                if s1 == s1[::-1]:
                    return k
    else:
        return 0


def A066452(n):
    return len(
        [
            x
            for x in range(1, n)
            if all(
                [x % d for d in range(2, n) if (n % d) and (2 * n) % d in [d - 1, 0, 1]]
            )
        ]
    )


def A067872(n):
    y, x, n2 = n * (n + 2), 2 * n + 3, n**2
    m, r = divmod(y, n2)
    while r:
        y += x
        x += 2
        m, r = divmod(y, n2)
    return m


def A071220_gen():  # generator of terms
    for i in count(2):
        n = i**3
        m = n // 2
        if not isprime(m) and prevprime(m) + nextprime(m) == n:
            yield primepi(m)


def A071295(n):
    return bin(n)[1:].count("0") * bin(n).count("1")


def A082806_gen():
    return filter(
        lambda n: isprime(n) and isprime(sum(int(d) for d in str(n))), pal10_gen()
    )


def A085513(n):
    return num2words(n).count("e")


def A085831(n):
    return (lambda m, r: 2 * sum(r // k for k in range(1, m + 1)) - m * m)(
        isqrt(2**n), 2**n
    )


def A088754(n):
    p = prime(n)
    m = n - len(str(p))
    return primepi((p + 1) * 10**m) - primepi(p * 10**m)


def A113630(n):
    return (
        n * (n * (n * (n * (n * (n * (n * (9 * n + 8) + 7) + 6) + 5) + 4) + 3) + 2) + 1
    )


def A113963_gen():  # generator of terms
    bset, b = {1}, 1
    yield b
    while True:
        a = 1
        while a in bset or not (a + b) % (a - b):
            a += 1
        b = a
        yield b
        bset.add(b)


def A350034(n):
    return n // g if (g := gcd(n, 6)) > 1 else 5 * n + 1


def A350265(n):
    return hyperexpand(hyper((-n - 1, 1 - n, -n), (1, 3), -1))


def A115510_gen():  # generator of terms
    yield 1
    l1, s, b = 1, 2, set()
    while True:
        i = s
        while True:
            if i & l1 and not i in b:
                yield i
                l1 = i
                b.add(i)
                while s in b:
                    b.remove(s)
                    s += 1
                break
            i += 1


def A116018_gen(startvalue=1):
    return filter(
        lambda n: len(set(str(n + totient(n)))) == 1, count(max(startvalue, 1))
    )


def A125289_gen(startvalue=0):
    return filter(lambda n: len(set(str(n)) - {"0"}) == 1, count(max(startvalue, 0)))


def A138918_gen():
    return (
        a
        for a, b in filter(
            lambda x: not x[1], (divmod(prime(n) + 1, 18) for n in count(1))
        )
    )


def A161664(n):
    return (
        lambda m: n * (n + 1) // 2 + m * m - 2 * sum(n // k for k in range(1, m + 1))
    )(isqrt(n))


def A161886(n):
    return (lambda m: 2 * sum(n // k for k in range(1, m + 1)) + n - 1 - m * m)(
        isqrt(n)
    )


def A166623_gen():  # generator of terms
    for b in count(2):
        sublist = []
        for l in range(1, b + 2):
            for n in combinations_with_replacement(range(b), l):
                x = sum(d**d for d in n)
                if tuple(sorted(sympydigits(x, b)[1:])) == n:
                    sublist.append(x)
        yield from sorted(sublist)


def A189398(n):
    return prod(prime(i) ** int(d) for i, d in enumerate(str(n), start=1))


def A191610_gen():
    return chain((0,), accumulate(multiplicity(5, n) for n in count(5, 5)))


def A191871(n):
    return 0 if n == 0 else (n // 2 ** multiplicity(2, n)) ** 2


if sys.version_info >= (3, 10):

    def A192085(n):
        return (n**3).bit_count()

else:

    def A192085(n):
        return bin(n**3).count("1")


def A192293_gen(startvalue=1):
    return filter(
        lambda n: 3 * n == sum(antidivisors(sum(antidivisors(n)))),
        count(max(startvalue, 1)),
    )


def A206578(n):
    m = 1
    while True:
        s = continued_fraction_periodic(0, 1, m)[-1]
        if isinstance(s, list) and s.count(1) == n:
            return m
        m += 1


def A212526(n):
    s, q = "", -n
    while q >= 4 or q < 0:
        q, r = divmod(q, -4)
        if r < 0:
            q += 1
            r += 4
        s += str(r)
    return int(str(q) + s[::-1])


def A217465_gen(startvalue=1):
    return filter(
        lambda n: pow(2, n, n * (n + 1)) == 2 and not isprime(n),
        count(max(startvalue, 1)),
    )


def A219326_gen(startvalue=1):
    for n in count(max(startvalue, 1)):
        s = [int(d) for d in str(n)][::-1]
        m = len(s)
        if n == Matrix(m, m, lambda i, j: s[(i - j) % m]).det():
            yield n


def A236174(n):
    p = prime(n)
    for b in range(2, 11):
        x, y, z = p, 0, 1
        while x >= b:
            x, r = divmod(x, b)
            y += r * z
            z *= 10
        y += x * z
        if isprime(y):
            return y


if sys.version_info >= (3, 10):

    def A245788(n):
        return n * n.bit_count()

else:

    def A245788(n):
        return n * bin(n).count("1")


def A246029(n):
    return (
        prod(prime(len(d)) for d in split("0+", bin(n)[2:]) if d != "") if n > 0 else 1
    )


def A246593(n):
    s = bin(n)[2:]
    s2 = s.rstrip("0")
    s3 = s2.lstrip("1")
    return (
        int(s2[: -len(s3)] + "1" + s3[1:-1] + "0" + s[len(s2) :], 2)
        if (len(s3) > 0 and n > 1)
        else n
    )


def A246824_gen():
    return (
        a
        for a, b in ((n, prime(n) + 1) for n in count(3))
        if (
            not (isprime(b**2 - 1) and isprime(b**2 + 1))
            and (min(factorint(b**2 + 1)) > min(factorint(b**2 - 1)) >= b - 1)
        )
    )


def A247248(n):
    if n == 1:
        return 1
    else:
        x, k, kr = 1, 0, 0
        while (x + kr) % n:
            x, kr = (2 * x) % n, (kr + 1) % n
            k += 1
        return k


def A247647_gen():
    return (int(bin(n)[2:]) for n in count(1) if n % 2 and not "00" in bin(n))


def A259091(n):
    s, k, k2 = str(n) * 2, 0, 1
    while True:
        if s in str(k2):
            return k
        k += 1
        k2 *= 2


def A259092(n):
    s, k, k2 = str(n) * 3, 0, 1
    while True:
        if s in str(k2):
            return k
        k += 1
        k2 *= 2


def A261018_gen():  # generator of terms
    a = 1
    for i in count(0):
        b, s = 1, format(a, "b")
        while format(b, "b") in s:
            b += 1
        a += b
        s = format(a, "b")
        yield b


def A264596(n):
    return sorted(format(i, "b")[::-1] for i in range(n + 1)).index(
        format(n, "b")[::-1]
    )


def A267490_gen():
    return (
        int(s, 8)
        for s in (str(i**2) for i in count(0))
        if max(s) < "8" and isprime(int(s, 8))
    )


def A268412_gen(startvalue=0):
    return (
        i
        for i in count(max(startvalue, 0))
        if not len(list(filter(bool, format(i, "b").split("0")))) % 2
    )


def A268415_gen(startvalue=0):
    return (
        i
        for i in count(max(startvalue, 0))
        if len(list(filter(bool, format(i, "b").split("0")))) % 2
    )


def A275256_gen():  # generator of terms
    for m in count(2):
        n, c = 3, 0
        while (n * (n + 1)) <= 2 * m:
            if not 2 * (n * (n - 2) + m) % (n * (n - 1)):
                c += 1
                if c >= 6:
                    break
            n += 1
        if c >= 6:
            yield m


def A275600_gen():
    return (
        n
        for n in (int(gmpy2digits(m, 3), 6) for m in range(10**6))
        if max(gmpy2digits(n, 5)) <= "2" and max(gmpy2digits(n, 4)) <= "2"
    )


def A276854(n):
    return n + isqrt(5 * n**2)


def A289676(n):
    c, k, r, n2, cs, ts = (
        0,
        1 + (n - 1) // 3,
        2 ** ((n - 1) % 3),
        2 ** (n - 1),
        set(),
        set(),
    )
    for i in range(2**k):
        j, l = int(bin(i)[2:], 8) * r, n2
        traj = set([(l, j)])
        while True:
            if j >= l:
                j = j * 16 + 13
                l *= 2
            else:
                j *= 4
                l //= 2
            if l == 0:
                c += 1
                ts.update(traj)
                break
            j %= 2 * l
            if (l, j) in traj:
                cs.update(traj)
                break
            if (l, j) in cs:
                break
            if (l, j) in ts:
                c += 1
                break
            traj.add((l, j))
    return c


def A291625_gen(startvalue=1):
    return (k for k in count(max(startvalue, 1)) if "0" in str(k**2))


def A301273_gen():  # generator of terms
    mu = Fraction(0)
    for i in count(1):
        mu += (prime(i) - mu) / i
        yield mu.numerator


def A301273(n):
    return (p := sum(prime(i) for i in range(1, n + 1))) // gcd(p, n)


def A301274_gen():  # generator of terms
    mu = Fraction(0)
    for i in count(1):
        mu += (prime(i) - mu) / i
        yield mu.denominator


def A301274(n):
    return n // gcd(n, sum(prime(i) for i in range(1, n + 1)))


def A301275_gen():  # generator of terms
    yield 0
    mu, variance = Fraction(prime(1)), Fraction(0)
    for i in count(2):
        datapoint = prime(i)
        newmu = mu + (datapoint - mu) / i
        variance = (variance * (i - 2) + (datapoint - mu) * (datapoint - newmu)) / (
            i - 1
        )
        mu = newmu
        yield variance.numerator


def A301276_gen():  # generator of terms
    yield 1
    mu, variance = Fraction(prime(1)), Fraction(0)
    for i in count(2):
        datapoint = prime(i)
        newmu = mu + (datapoint - mu) / i
        variance = (variance * (i - 2) + (datapoint - mu) * (datapoint - newmu)) / (
            i - 1
        )
        mu = newmu
        yield variance.denominator


@lru_cache(maxsize=None)
def A304176_helper(n, i):
    return (
        1
        if n == 0 or i == 1
        else A304176_helper(n, i - 1) + A304176_helper(n - i, min(i, n - i))
    )


def A304176(n):
    return A304176_helper(n**3 - n, n)


def A306612(n):
    plist, x = [prime(i) for i in range(1, n + 1)], 3
    rlist = [-x % p for p in plist]
    while True:
        for i in range(n - 1):
            if rlist[i] >= rlist[i + 1]:
                break
        else:
            return x
        for i in range(n):
            rlist[i] = (rlist[i] - 1) % plist[i]
        x += 1


def A308190(n):
    c, x = 0, n
    while x != 5:
        y = min(factorint(x))
        x = y + x // y
        c += 1
    return c


def A317058_helper(n, p, q):  # compute (-n + sum_{k=1,n} k^p) mod q
    c = (-n) % q
    for k in range(1, n + 1):
        c = (c + pow(k, p, q)) % q
    return c


def A317058(n):
    k = 2
    while isprime(k) or A317058_helper(n, k - 1, k):
        k += 1
    return k


def A320037(n):
    return int(
        "".join(
            d + "0" if "1" in d else d + "1"
            for d in split("(0+)|(1+)", bin(n)[2:])
            if d != "" and d != None
        ),
        2,
    )


def A320038(n):
    return int(
        "".join(
            "0" + d if "1" in d else "1" + d
            for d in split("(0+)|(1+)", bin(n)[2:])
            if d != "" and d != None
        ),
        2,
    )


def A321005_gen():  # generator of terms
    plist = [2]
    for n in count(0):
        c, p = 0, plist[-1]
        for j in range(n):
            pj = plist[j]
            for i in range(j):
                if (plist[i] * pj) % p == 1:
                    c += 1
        yield c
        plist.append(nextprime(p))


def A321801(n):
    return int(
        "0"
        + "".join(
            d if len(d) == 1 else ""
            for d in split("(0+)|(1+)|(2+)|(3+)|(4+)|(5+)|(6+)|(7+)|(8+)|(9+)", str(n))
            if d != "" and d != None
        )
    )


def A321802(n):
    return (lambda x: int(x) if x != "" else -1)(
        "".join(
            d if len(d) == 1 else ""
            for d in split("(0+)|(1+)|(2+)|(3+)|(4+)|(5+)|(6+)|(7+)|(8+)|(9+)", str(n))
            if d != "" and d != None
        )
    )


def A323832_helper(n):
    x = 2 * n
    y = A321801(x)
    while x != y:
        x, y = y, A321801(y)
    return x


def A323832(n):
    mset, m, c = set(), n, 0
    while True:
        if m == 1 or m == 0 or m == 5:
            return c
        m = A323832_helper(m)
        if m in mset:
            return -1
        mset.add(m)
        c += 1


def A325148_gen(startvalue=0):  # generator of terms
    if startvalue == 0:
        yield 0
    j = isqrt(startvalue)
    if j * j < startvalue:
        j += 1
    for n in count(max(j, 0)):
        n2 = n**2
        for m in divisors(n2):
            if m > n:
                break
            if m == int(str(n2 // m)[::-1]):
                yield n2
                break


def A338434(n):
    m = integer_nthroot(n, 2)[0]
    return m * (m + 1) // 2 - divisor_sigma(
        integer_nthroot(n // numbercore(n, 2), 2)[0]
    )


def A342068(n):
    k, a, b, c = 2, 0, primepi(n), primepi(2 * n)
    while a + c <= 2 * b:
        k += 1
        a, b, c = b, c, primepi(k * n)
    return k


def A345422(n):
    return igcdex(11, prime(n))[0]


def A345692(n):
    zlist = [
        z
        for z in (igcdex(x, y) for x in range(1, n + 1) for y in range(1, n + 1))
        if z[2] == 1
    ]
    return pvariance(len(zlist) * u for u, v, w in zlist)


def A346004(n):
    return ((n + 1) // 2) ** 2 if n % 2 else n


def A347042(n):
    fs = factorint(n, multiple=True)
    return sum(
        len(list(multiset_combinations(fs, d)))
        for d in divisors(len(fs), generator=True)
    )


def A347045(n):
    fs = factorint(n, multiple=True)
    q, r = divmod(len(fs), 2)
    return 1 if r else prod(fs[:q])


def A347046(n):
    fs = factorint(n, multiple=True)
    q, r = divmod(len(fs), 2)
    return 1 if r else prod(fs[q:])


def A008849_gen(startvalue=1):
    return filter(
        lambda n: is_square(
            prod((p ** (3 * q + 1) - 1) // (p - 1) for p, q in factorint(n).items())
        ),
        count(max(startvalue, 1)),
    )


def A011966_gen():  # generator of terms
    yield 1
    blist, b = [2, 3, 5], 5
    while True:
        blist = list(accumulate([b] + blist))
        b = blist[-1]
        yield blist[-4]


def A011969_gen():  # generator of terms
    yield from [1, 3]
    blist, b, b2 = [1], 1, 1
    while True:
        blist = list(accumulate([b] + blist))
        yield 2 * b + b2 + blist[-1]
        b2, b = b, blist[-1]


@lru_cache(maxsize=None)
def A015616(n):
    if n <= 1:
        return 0
    c, j = n * (n - 1) * (n - 2) // 6, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c -= (j2 - j) * A015616(k1)
        j, k1 = j2, n // j2
    return c


@lru_cache(maxsize=None)
def A015650(n):
    if n == 0:
        return 0
    c, j = n + 1, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * A015650(k1)
        j, k1 = j2, n // j2
    return n * (n + 1) * (n + 2) * (n + 3) * (n + 4) // 120 - c + j


def A336643(n):
    return prod(primefactors(n)) // numbercore(n)


def A336644(n):
    return (n - prod(primefactors(n))) // numbercore(n)


def A350390(n):
    return n * numbercore(n) // prod(primefactors(n))


def A016070_gen(startvalue=1):
    return filter(
        lambda n: len(s := set(str(n**2))) == 2
        and s not in [{"0", "1"}, {"0", "4"}, {"0", "9"}],
        count(max(startvalue, 1)),
    )


def A017714(n):
    return comb(n, 50)


def A022519_gen():  # generator of terms
    b = 8
    while True:
        yield b
        b = int("".join(str(k) + str(len(list(g))) for k, g in groupby(str(b)[::-1])))


def A025502(n):
    m, tlist, s = 10**n, [1, 2], 0
    while tlist[-1] + tlist[-2] <= m:
        tlist.append(tlist[-1] + tlist[-2])
    for d in tlist[::-1]:
        if d <= m:
            s += 1
            m -= d
    return s


def A028820_gen():
    return chain(
        (0,),
        (
            n
            for n in (
                int("".join(i))
                for l in count(1)
                for i in combinations_with_replacement("123456789", l)
            )
            if is_square(n)
        ),
    )


def A030666(n):
    d, nd = 10, 10 * n
    while True:
        x = (isqrt(nd - 1) + 1) ** 2
        if x < nd + d:
            return int(x)
        d *= 10
        nd *= 10


def A046358_gen(startvalue=2):
    return (
        n
        for n in count(max(startvalue, 2))
        if not isprime(n)
        and not n % (m := sum(p * e for p, e in factorint(n).items()))
        and str(m) == str(m)[::-1]
    )


def A047972(n):
    return min((p := prime(n)) - (a := isqrt(p)) ** 2, (a + 1) ** 2 - p)


def A052072(n):
    a, b, c = 0, 0, 0
    for i in count(0):
        s = str(c)
        for d in set(s):
            if s.count(d) != n:
                break
        else:
            return c
        c += a + b + 1
        b += 2 * a + 3
        a += 3


def A052091_gen():  # generator of terms
    yield 2
    p = 2
    while True:
        m, ps = 1, str(p)
        s = int("1" + ps + "1")
        while not isprime(s):
            m += 1
            ms = str(m)
            if ms[0] in "268":
                ms = str(int(ms[0]) + 1) + "0" * (len(ms) - 1)
                m = int(ms)
            if ms[0] in "45":
                ms = "7" + "0" * (len(ms) - 1)
                m = int(ms)
            s = int(ms + ps + ms[::-1])
        p = s
        yield m


def A052092_gen():  # generator of terms
    yield 1
    l, p = 1, 2
    while True:
        m, ps = 1, str(p)
        s = int("1" + ps + "1")
        while not isprime(s):
            m += 1
            ms = str(m)
            if ms[0] in "268":
                ms = str(int(ms[0]) + 1) + "0" * (len(ms) - 1)
                m = int(ms)
            if ms[0] in "45":
                ms = "7" + "0" * (len(ms) - 1)
                m = int(ms)
            s = int(ms + ps + ms[::-1])
        p = s
        l += 2 * len(ms)
        yield l


def A063095(n):
    c, p = 0, 2
    for i in range(n):
        q = nextprime(p)
        c, p = max(c, q - p), q
    return c


def A063527_gen():  # generator of terms
    for g in count(1):
        for n in product("123456789", repeat=g):
            s = "".join(n)
            m = int(s)
            if not any([m % int(d) for d in s]):
                for i in range(len(s) - 1):
                    if m % int(s[i : i + 2]):
                        break
                else:
                    yield m


def A067563(n):
    return prime(n) * composite(n)


def A068084(n):
    u, v, t = 4 * (n + 1), (2 * (n + 1)) ** 2 - 1, 4 * n * (n + 1)
    while True:
        if not v % t:
            return v // 8
        v += u + 1
        u += 2


def A069706_gen():  # generator of terms
    yield from [2, 3, 5, 7]
    for i in count(5):
        p = prime(i)
        s = str(p)
        if isprime(int(s[-1] + s[1:-1] + s[0])):
            yield p


def A075075_gen():  # generator of terms
    yield from [1, 2]
    l1, m, b = 2, 2, {1, 2}
    while True:
        i = m
        while True:
            if not i in b:
                yield i
                l1, m = i, i // gcd(l1, i)
                b.add(i)
                break
            i += m


def A080478_gen():  # generator of terms
    yield 1
    a = 1
    while True:
        a += 1
        b = 2 * a * (a - 1) + 1
        while not isprime(b):
            b += 4 * (a + 1)
            a += 2
        yield a


def A091507(n):
    return prod(d for d in range(2, n) if n % d and 2 * n % d in [d - 1, 0, 1])


def A094685(n):
    i, j = isqrt_rem(n**3 if n % 2 else n)
    return int(i + int(4 * (j - i) >= 1))


def A100384(n):
    k, a = 2, [max(factorint(m + 2)) for m in range(n)]
    while True:
        for i in range(1, n):
            if a[i - 1] >= a[i]:
                break
        else:
            return k
        a = a[i:] + [max(factorint(k + j + n)) for j in range(i)]
        k += i


def A104301_gen():  # generator of terms
    for n in count(1):
        x = int(str((n + 1) ** 2) + str(n**2))
        if isprime(x):
            yield x


def A110713(n):
    return len(
        {prod(d) for d in combinations_with_replacement(list(range(1, n + 1)), n)}
    )


def A114065_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if sorted(str(divisor_sigma(n))) == sorted(str(totient(n))) == sorted(str(n))
    )


def A117345_gen():  # generator of terms
    plist = [2, 3, 5, 7, 11, 13, 17, 19, 23]
    for k in count(1):
        if Matrix(plist).reshape(3, 3).det() == 0:
            yield k
        plist = plist[1:] + [nextprime(plist[-1])]


def A117960():
    return filter(
        lambda n: set(str(n)) <= {"1", "3", "5", "7", "9"},
        (m * (m + 1) // 2 for m in count(0)),
    )


def A119908_gen():  # generator of terms
    c, s = {}, 3
    for n in count(2):
        for p, e in factorint(4 * n - 2).items():
            if p in c:
                c[p] += e
            else:
                c[p] = e
        for p, e in factorint(n + 1).items():
            if c[p] == e:
                del c[p]
            else:
                c[p] -= e
        if n == s:
            c2 = [p for p, e in c.items() if e >= 2]
            yield 1 if c2 == [] else max(c2)
            s = 2 * s + 1


def A130334(n):
    k, Tn, Tm = n + 1, n * (n + 1) // 2, (n + 1) * (n + 2) // 2
    while gcd(Tn, Tm) != 1:
        k += 1
        Tm += k
    return k


@lru_cache(maxsize=None)
def A137243(n):
    if n == 0:
        return 0
    c, j = 0, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * (A137243(k1) // 4 - 1)
        j, k1 = j2, n // j2
    return 4 * (n * (n - 1) - c + j)


def A155150_gen(startvalue=1):
    return filter(lambda n: len(set(str(n**4))) == 4, count(max(startvalue, 1)))


def A175795_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if sorted(str(divisor_sigma(n))) == sorted(str(totient(n)))
    )


def A178029_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if sum([d for d in range(2, n) if (n % d) and (2 * n) % d in [d - 1, 0, 1]])
        == sum(divisors(n))
    )


def A185704(n):
    p, k, m = 2, 73**n, 10
    q, m2 = p % k, m % k
    while True:
        p = nextprime(p)
        while p >= m:
            m *= 10
            m2 = m % k
        q = (q * m2 + p) % k
        if q == 0:
            return p


def A188187(n):
    return isqrt(5 * n**2) - isqrt(5 * (n - 1) ** 2) - 2


def A206585(n):
    i = 2
    while True:
        s = continued_fraction_periodic(0, 1, i)[-1]
        if isinstance(s, list) and s.count(5) == n:
            return i
        i += 1


def A209252(n):
    return len(
        [
            1
            for i in range(len(str(n)))
            for d in "0123456789"
            if d != str(n)[i] and isprime(int(str(n)[:i] + d + str(n)[i + 1 :]))
        ]
    )


def A214560(n):
    return bin(n * n)[2:].count("0")


def A214842_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if not (
            sum([d for d in range(2, n, 2) if n % d and not 2 * n % d])
            + sum([d for d in range(3, n, 2) if n % d and 2 * n % d in [d - 1, 1]])
        )
        % n
    )


def A215199(n):
    l = len(str(3**n)) - 1
    l10, result = 10**l, 2 * 10**l
    while result >= 2 * l10:
        l += 1
        l102, result = l10, 20 * l10
        l10 *= 10
        q, qn = 2, 2**n
        while qn <= l10:
            s, sn = 2, 2**n
            while sn <= l10:
                if s != q:
                    a, b = crt([qn, sn], [0, 1])
                    if a <= l102:
                        a = b * (l102 // b) + a
                    while a < l10:
                        p, t = a // qn, (a - 1) // sn
                        if p != q and t != s and isprime(p) and isprime(t):
                            result = min(result, a - 1)
                        a += b
                s = nextprime(s)
                sn = s**n
            q = nextprime(q)
            qn = q**n
    return result


def A215659_gen():  # generator of terms
    for i in count(1):
        a, b = integer_nthroot(4 * primorial(i) + 1, 2)
        if b:
            yield (a + 1) // 2


def A218013_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if not prod(int(d) for d in str(n**2) if d != "0") % n
    )


def A228410_gen():  # generator of terms
    yield 1
    l, s, b = Counter("1"), 2, set()
    while True:
        i = s
        while True:
            if i not in b:
                li, o = Counter(str(i)), 0
                for d in (l + li).values():
                    if d % 2:
                        if o > 0:
                            break
                        o += 1
                else:
                    yield i
                    l = li
                    b.add(i)
                    while s in b:
                        b.remove(s)
                        s += 1
                    break
            i += 1


def A228768(n):
    m = 1
    while True:
        m = nextprime(m)
        for b in range(2, n + 1):
            if not is_emirp(m, b):
                break
        else:
            return m


def A235807_gen(startvalue=0):
    return filter(lambda n: len(set(str(n**3))) == 5, count(max(startvalue, 0)))


def A236437_gen():
    return (p for n in count(1) if A236174(n) == (p := prime(n)))


def A240960_gen():
    return filter(
        lambda x: sum(divisors(x)) - totient(x)
        == divisor_count(x) ** len(primefactors(x)),
        count(1),
    )


def A242788_gen():
    return chain((1, 2, 4, 5, 6), (n for n in count(7) if pow(n, n, n - 3) == 3))


def A246198_gen(startvalue=2):  # generator of terms
    for n in count(max(startvalue, 2)):
        d = divisors(n)
        d.remove(n)
        s, dmax = sum(d), max(d)
        if not s % 2 and 2 * dmax <= s:
            d.remove(dmax)
            s2 = s / 2 - dmax
            for x in range(2 ** len(d)):
                if sum(Subset.unrank_binary(x, d).subset) == s2:
                    yield n
                    break


def A246591(n):
    if n <= 1:
        return n
    else:
        s = bin(n)[2:]
        l = len(s)
        y = 2**l - 1
        for i in combinations(range(l), 2):
            s2 = int(
                s[: i[0]] + s[i[1]] + s[i[0] + 1 : i[1]] + s[i[0]] + s[i[1] + 1 :], 2
            )
            if s2 < y:
                y = s2
        return y


def A246592(n):
    s = bin(n)[2:]
    for i in range(len(s) - 1):
        if s[i : i + 2] == "10":
            return int(s[:i] + "01" + s[i + 2 :], 2)
    else:
        return n


def A246594(n):
    s = bin(n)[2:]
    for i in range(len(s) - 1):
        if s[i : i + 2] == "01":
            return int(s[:i] + "10" + s[i + 2 :], 2)
    else:
        return n


def A246714_gen():  # generator of terms
    yield 1
    c = 1
    for n in count(2):
        c = c * (4 * n - 2) // (n + 1)
        yield c % prime(n)


def A349949(n):
    return sum(
        1
        for m in filter(
            lambda d: not (
                ((n - 1) % (d - 1) if d > 1 else True)
                and (n - 1) % (d + 1)
                and ((n + 1) % (d - 1) if d > 1 else True)
                and (n + 1) % (d + 1)
            ),
            divisors(n, generator=True),
        )
    )


def A246830_gen():  # generator of terms
    for n in count(0):
        for k in range(n):
            yield int(bin(n - k)[2:] + bin(n + k)[2:], 2)
        yield 2 * n


def A246830_T(n, k):
    return int(bin(n - k)[2:] + bin(n + k)[2:], 2)


def A246972(n):
    return int(str((n + 1) ** 2) + str(n**2))


def A247013_gen(startvalue=2):  # generator of terms
    for n in count(max(startvalue, 2)):
        m = int(str(n)[::-1])
        if n % 10 and not isprime(n):
            x = sorted(chain.from_iterable([p] * e for p, e in factorint(n).items()))
            y = sum(x)
            while y < m:
                x, y = x[1:] + [y], 2 * y - x[0]
            if y == m:
                yield n


def A247190(n):
    p, f, fv = prime(n), 1, {}
    for i in range(2, p):
        f = (f * i) % p
        if f in fv:
            return fv[f]
        else:
            fv[f] = i
    else:
        return 0


def A247220_gen(startvalue=0):
    return (i for i in count(max(startvalue, 0)) if pow(2, i, i * i + 1) == i * i)


def A247358_gen():
    return chain.from_iterable(
        sorted((b + 1) ** (n - b) for b in range(n)) for n in count(1)
    )


def A251240_gen():  # generator of terms
    l1, l2, s, b = 3, 2, 4, {}
    for n in count(4):
        i = s
        while True:
            if not i in b and gcd(i, l1) == 1 and gcd(i, l2) > 1:
                l2, l1, b[i] = l1, i, 1
                while s in b:
                    b.pop(s)
                    s += 1
                k, l = integer_nthroot(i, 2)
                if l and is_prime(k):
                    yield n
                break
            i += 1


def A251555_gen():  # generator of terms
    yield from [1, 3, 2]
    l1, l2, s, b = 2, 3, 4, set()
    while True:
        i = s
        while True:
            if not i in b and gcd(i, l1) == 1 and gcd(i, l2) > 1:
                yield i
                l2, l1 = l1, i
                b.add(i)
                while s in b:
                    b.remove(s)
                    s += 1
                break
            i += 1


def A253050_gen():  # generator of terms
    yield from [0, 1, 0]
    l1, l2, s, b = 2, 1, 3, set()
    while True:
        i = s
        while True:
            if not (i in b or i & l1) and i & l2:
                yield i & 1
                l2, l1 = l1, i
                b.add(i)
                while s in b:
                    b.remove(s)
                    s += 1
                break
            i += 1


def A253412(n):
    c, fs = 0, "0" + str(n) + "b"
    for i in range(2**n):
        s = "01" + format(i, fs) + "10"
        for j in range(n):
            if (
                s[j : j + 4] == "0100"
                or s[j + 1 : j + 5] == "0010"
                or s[j + 1 : j + 4] == "000"
                or s[j + 1 : j + 4] == "111"
            ):
                break
        else:
            c += 1
    return c


def A253574_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if set(str(n)) & set(str(n**4)) == set() and isprime(n)
    )


def A253646_gen(startvalue=2):  # generator of terms
    if startvalue <= 2:
        yield 2
    for i in count(max(startvalue, 3), 2):
        if not "0" in str(i):
            m = i
            for k in range(5):
                m *= i
                if "0" in str(m):
                    break
            else:
                if isprime(i):
                    yield i


def A254334_gen():
    return (
        int("".join(format(x, "02d") for x in sympydigits(3**i, 60)[1:]))
        for i in count(0)
    )


def A256229(n):
    y = 1
    for d in reversed(str(n)):
        y = int(d) ** y
    return y


def A257763_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if not "0" in str(n) and set(str(n)) == set(str(n**2))
    )


def A257893_gen(startvalue=1):  # generator of terms
    l = []
    for d in permutations("0123456789", 10):
        if d[0] != "0":
            d2 = int("".join(d))
            if d2 >= startvalue:
                d = d2
                r = d2 % 2
                while not r:
                    d2, r = divmod(d2, 2)
                l.append((d2, d))
    l.sort()
    yield from (b for a, b in l)


def A270807_gen():  # generator of terms
    b = 1
    while True:
        yield b
        b += b // (max(primefactors(b) + [1])) + 1


def A271713_gen():
    return ((n**2 + 5) // 3 for n in count(0) if not (n**2 + 5) % 3)


def A272653_gen():
    return (
        int(b + "".join(s), 2)
        for b in (bin(n)[2:] for n in count(1))
        for s in multiset_permutations(sorted(b))
    )


def A272679(n):
    if n == 0:
        return 0
    else:
        d, nd = 1, n
        while True:
            x = isqrt(nd - 1) + 1
            if x**2 < nd + d:
                return int(x)
            d *= 2
            nd *= 2


def A276466(n):
    return sum(Fraction(d, 10 ** len(str(d))) for d in divisors(n)).numerator


def A279204(n):
    return int(str(n) + str(n + 1) + str(n + 2) + str(n + 3))


def A289776(n):
    i = 1
    while len(divisors(i)) < n or not isprime(sum(divisors(i)[:n])):
        i += 1
    return i


def A291301(n):
    m = primorial(n)
    while not isprime(m):
        m = divisor_sigma(m) - 1
    return m


def A291302(n):
    m, c = primorial(n), 0
    while not isprime(m):
        m = divisor_sigma(m) - 1
        c += 1
    return c


def A291672_gen(startvalue=1):
    return (k for k in count(max(startvalue, 1)) if min(str(k**4)) == "4")


def A298463_gen():  # generator of terms
    m = 6
    for n in count(1):
        k = prevprime(m // 2)
        if k + nextprime(k) == m:
            yield n * (3 * n - 1) // 2
        m += 6 * n - 1


def A298464_gen():  # generator of terms
    m = 6
    for n in count(1):
        k = prevprime(m // 2)
        if k + nextprime(k) == m:
            yield k
        m += 6 * n - 1


def A298465_gen():  # generator of terms
    m = 8
    for n in count(1):
        k = prevprime(m // 2)
        if k + nextprime(k) == m:
            yield n * (5 * n - 3) // 2
        m += 10 * n - 3


def A298466_gen():  # generator of terms
    m = 8
    for n in count(1):
        k = prevprime(m // 2)
        if k + nextprime(k) == m:
            yield k
        n += 1
        m += 10 * n - 3


def A303260(n):
    return Matrix(n, n, lambda i, j: (j - i - 1) % n + (i == j)).det()


def A306582(n):
    plist, rlist, x = [prime(i) for i in range(1, n + 1)], [0] * n, 0
    while True:
        for i in range(n - 1):
            if rlist[i] >= rlist[i + 1]:
                break
        else:
            return x
        for i in range(n):
            rlist[i] = (rlist[i] + 1) % plist[i]
        x += 1


def A316434(n):
    pp = primepi(n)
    return 1 if n == 1 or n == 2 else A316434(pp) + A316434(n - pp)


def A317357(n):
    k = n + 1
    while isprime(k) or A317058_helper(n, k - 1, k):
        k += 1
    return k


def A317358(n):
    k = 2
    while A317058_helper(n, k - 1, k):
        k += 1
    return k


def A326806_gen(startvalue=0):  # generator of terms
    for n in count(max(startvalue, 0)):
        sn = str(n)
        if sn in str(n * sum(int(d) for d in sn)):
            yield n


def A333548_gen():  # generator of terms
    bset, y = {0}, 0
    for n in count(1):
        y -= n
        if y <= 0 or y in bset:
            y += 2 * n
        bset.add(y)
        if y == n + 1:
            yield y


def A340740(n):
    return sum(n % k for k in range(1, n // 2 + 1) if gcd(k, n) == 1)


def A341656(n):
    return divisor_count(prime(n) ** 4 - 1)


def A343590_helper(w, dir):
    if dir == 1:
        for s in w:
            for t in range(int(s[-1]) + 1, 10, 2):
                yield s + str(t)
    else:
        for s in w:
            for t in range(1 - int(s[-1]) % 2, int(s[-1]), 2):
                yield s + str(t)


def A343590_gen():  # generator of terms
    for l in count(0):
        for d in "123456789":
            x = d
            for i in range(1, l + 1):
                x = A343590_helper(x, (-1) ** i)
            yield from (int(p) for p in x if isprime(int(p)))
            if l > 0:
                y = d
                for i in range(1, l + 1):
                    y = A343590_helper(y, (-1) ** (i + 1))
                yield from (int(p) for p in y if isprime(int(p)))


def A343997(n):
    fs = factorint(2 * n)
    plist = [p ** fs[p] for p in fs]
    x = min(
        k
        for k in (crt(plist, d)[0] for d in product([0, -1], repeat=len(plist)))
        if k > 0
    )
    return x + x % 2


def A345926(n):
    fs = dict((primepi(a), b) for (a, b) in factorint(n).items())
    return len(
        set(sum(d) for d in multiset_combinations(fs, (sum(fs.values()) + 1) // 2))
    )


def A346005(n):
    return n if n % 3 == 0 else ((n + 2) // 3) ** 3 if n % 3 == 1 else (n + 1) ** 2 // 3


def A346007(n):
    i = (5 - n) % 5
    return comb(5, i + 1) * ((n + i) // 5) ** (i + 1)


def A346892_gen():
    return (
        1000 * n + d
        for n in count(0)
        for d in [38, 462, 538, 962]
        if (lambda x: x[0] == x[1] == x[2] != x[3])(str((1000 * n + d) ** 2))
    )


def A347043(n):
    fs = factorint(n, multiple=True)
    l = len(fs)
    return prod(fs[: (l + 1) // 2])


def A347044(n):
    fs = factorint(n, multiple=True)
    l = len(fs)
    return prod(fs[l // 2 :])


def A347594_gen():  # generator of terms
    b = 1
    for n in count(1):
        yield b
        m = b**2 + n**2
        b = (isqrt(m) + 1) ** 2 - m


def A347754_gen():  # generator of terms
    a = 1
    for n in count(1):
        m = a**2 + n**2
        k = isqrt(m) + 1
        a = k**2 - m
        yield k


def A347756_gen():  # generator of terms
    yield 1
    nset, m, j = {1}, 2, 2
    while True:
        k = m
        while k == j or gcd(k, j) == 1 or k in nset:
            k += 1
        j = k + 1
        nset.add(k)
        if k == m:
            yield k
        while m in nset:
            m += 1


def A348063(n):
    return sum(
        ff(n, n - k) * expand(ff(symbolx, k)).coeff(symbolx**2) for k in range(2, n + 1)
    )


def A348064(n):
    return sum(
        ff(n, n - k) * expand(ff(symbolx, k)).coeff(symbolx**3) for k in range(3, n + 1)
    )


def A348065(n):
    return sum(
        ff(n, n - k) * expand(ff(symbolx, k)).coeff(symbolx**4) for k in range(4, n + 1)
    )


def A348068(n):
    return sum(
        ff(n, n - k) * expand(ff(symbolx, k)).coeff(symbolx**5) for k in range(5, n + 1)
    )


@lru_cache(maxsize=None)
def A003318(n):
    if n == 0:
        return 1
    c, j = n + 1, 1
    k1 = (n - 1) // j
    while k1 > 1:
        j2 = (n - 1) // k1 + 1
        c += (j2 - j) * A003318(k1)
        j, k1 = j2, (n - 1) // j2
    return c - j


def A011970_gen():  # generator of terms
    yield from [1, 4, 8]
    blist, b, b2, b3 = [1, 2], 2, 1, 1
    while True:
        blist = list(accumulate([b] + blist))
        yield 3 * (b + b2) + b3 + blist[-1]
        b3, b2, b = b2, b, blist[-1]


def A011972_gen():  # generator of terms
    yield 1
    blist = [1]
    while True:
        b = blist[-1]
        blist = list(accumulate([b] + blist))
        yield from blist[1:]


def A014237(n):
    return 1 if n == 1 else prime(n) - composite(n - 1)


def A017764(n):
    return comb(n, 100)


def A017764_gen():  # generator of terms
    m = [1] * 101
    while True:
        yield m[-1]
        for i in range(100):
            m[i + 1] += m[i]


def A022797(n):
    return 3 if n == 1 else prime(n) + composite(n - 1)


def A028819_gen():
    return chain(
        (0,),
        (
            int(isqrt(n))
            for n in (
                int("".join(i))
                for l in count(1)
                for i in combinations_with_replacement("123456789", l)
            )
            if is_square(n)
        ),
    )


def A030056_gen():  # generator of terms
    b = 1
    for n in count(6):
        yield b
        b = b * (2 * n + 2) * (2 * n + 3) // ((n - 5) * (n + 8))


def A030056(n):
    return comb(2 * n + 1, n - 6)


def A030690(n):
    d, nd = 10, 10 * n**2
    while True:
        x = (integer_nthroot(nd - 1, 3)[0] + 1) ** 3
        if x < nd + d:
            return x
        d *= 10
        nd *= 10


def A046332_gen():
    return (x for x in pal10_gen() if sum(list(factorint(x).values())) == 6)


def A048332_gen():
    return chain((0,), (int(d * l, 7) for l in count(1) for d in "123456"))


def A048612(n):
    d = divisors((10**n - 1) // 9)
    l = len(d)
    return (d[l // 2] - d[(l - 1) // 2]) // 2


def A048703(n):
    s = bin(n - 1)[2:]
    if len(s) % 2:
        s = "0" + s
    t = [s[i : i + 2] for i in range(0, len(s), 2)]
    return int("".join(t + t[::-1]), 2)


def A050804_gen():
    return (
        2 * i
        for i in count(1)
        if not any(p % 4 == 1 or factorint(i)[p] % 2 for p in factorint(i))
    )


def A055268(n):
    return (11 * n + 4) * comb(n + 3, 3) // 4


def A055268_gen():  # generator of terms
    m = [11, 1, 1, 1, 1]
    while True:
        yield m[-1]
        for i in range(4):
            m[i + 1] += m[i]


def A057045(n):
    i, j = isqrt_rem(2 * lucas(n - 1))
    return int(i + int(4 * (j - i) >= 1))


def A057332_helper(w, dir):
    if dir == 1:
        for s in w:
            for t in range(int(s[-1]) + 1, 10):
                yield s + str(t)
    else:
        for s in w:
            for t in range(0, int(s[-1])):
                yield s + str(t)


def A057332(n):
    c = 0
    for d in "123456789":
        x = d
        for i in range(1, n + 1):
            x = A057332_helper(x, (-1) ** i)
        c += sum(1 for p in x if isprime(int(p + p[-2::-1])))
        if n > 0:
            y = d
            for i in range(1, n + 1):
                y = A057332_helper(y, (-1) ** (i + 1))
            c += sum(1 for p in y if isprime(int(p + p[-2::-1])))
    return c


def A057699_gen():  # generator of terms
    for l in count(1):
        blist = []
        for i in range(10 ** (l - 1), 10**l):
            if i % 10:
                p = int(str(i**3)[::-1])
                if isprime(p):
                    blist.append(p)
        yield from sorted(blist)


def A058009(n):
    k = n
    for _ in range(n):
        k = prime(k)
    return k


def A060358(n):
    return prevprime(lcm(range(1, n + 1)))


def A061906(n):
    return A050782(int(str(n).rstrip("0"))) if n > 0 else 1


def A069648(n):
    if n == 1:
        return 1
    else:
        m = 2
        while True:
            x = sum(int(d) for d in str(m**n))
            if x > 1 and not any(map(lambda x: x % n, factorint(x).values())):
                return m
            m += 1


def A071268(n):
    s = "".join(str(i) for i in range(1, n + 1))
    return (
        sum(int(d) for d in s)
        * factorial(len(s) - 1)
        * (10 ** len(s) - 1)
        // (9 * prod(factorial(d) for d in (s.count(w) for w in set(s))))
    )


def A070306_gen(startvalue=3):  # generator of terms
    for i in count(max(startvalue, 3)):
        n = i**3
        m = n // 3
        pm, nm = prevprime(m), nextprime(m)
        k = n - pm - nm
        if isprime(m):
            if m == k:
                yield i
        else:
            if nextprime(nm) == k or prevprime(pm) == k:
                yield i


def A076620(n):
    return (
        y := Poly(prod(symbolx + i for i in range(1, n + 1))).all_coeffs()[::-1]
    ).index(max(y))


def A078226_gen():  # generator of terms
    x = 1
    yield 1
    while True:
        y, x2 = x, 2 * x
        while True:
            y += x2
            s = str(y)
            for j in range(len(s) - 1, -1, -2):
                if not s[j] in ("1", "3", "5", "7", "9"):
                    break
            else:
                for k in range(len(s) - 2, -1, -2):
                    if not s[k] in ("0", "2", "4", "6", "8"):
                        break
                else:
                    yield y
                    x = y
                    break


def A078227_gen():  # generator of terms
    x = 2
    yield 2
    while True:
        y = x
        while True:
            y += x
            s = str(y)
            for j in range(len(s) - 1, -1, -2):
                if not s[j] in ("0", "2", "4", "6", "8"):
                    break
            else:
                for k in range(len(s) - 2, -1, -2):
                    if not s[k] in ("1", "3", "5", "7", "9"):
                        break
                else:
                    yield y
                    x = y
                    break


def A078242(n):
    if n > 0:
        for i in range(1, 2**n):
            x = 3 * int(bin(i)[2:])
            if not x % n:
                return x
    return 0


def A080719(n):
    return int("".join((format(int(d), "b") for d in str(n))), 2)


def A082232_gen():
    return filter(
        lambda n: not n % sum(int(d) for d in str(n)), islice(pal10_gen(), 1, None)
    )


def A087669(n):
    c, x = 0, 2 * n + 1
    a, b = divmod(x, n)
    while b != 0:
        x *= a
        c += 1
        a, b = divmod(x, n)
    return c


def A091626(n):
    m = isqrt(n)
    return 1 if n == 0 else n + sum(n // k for k in range(1, m + 1)) - m * (m - 1) // 2


def A097344_gen():  # generator of terms
    yield 1
    tlist = [Fraction(1, 1)]
    for i in count(1):
        for j in range(len(tlist)):
            tlist[j] *= Fraction(i, i - j)
        tlist += [Fraction(1, (i + 1) ** 2)]
        yield sum(tlist).numerator


def A350346_gen():  # generator of terms
    yield 0
    for n in count(1):
        s = bin(n)[2:]
        c, l = 0, len(s)
        for i in range(l):
            c += int(s[l - i - 1])
            if 2 * c <= i:
                break
        else:
            yield int(s)


def A036991_gen(startvalue=0):  # generator of terms
    if startvalue <= 0:
        yield 0
    for n in count(max(startvalue, 1)):
        s = bin(n)[2:]
        c, l = 0, len(s)
        for i in range(l):
            c += int(s[l - i - 1])
            if 2 * c <= i:
                break
        else:
            yield n


def A100580_gen():
    return filter(isprime, (int(bin(n)[2:]) for n in pal_gen(b=2)))


def A104242_gen():
    return filter(isprime, (int(str(n**2) + str((n + 1) ** 2)) for n in count(1)))


def A104265(n):
    m, a = integer_nthroot((10**n - 1) // 9, 2)
    if not a:
        m += 1
    k = m**2
    while "0" in str(k):
        m += 1
        k += 2 * m - 1
    return k


def A110765(n):
    return prod(prime(i) for i, d in enumerate(bin(n)[2:], start=1) if int(d))


def A119861_gen():  # generator of terms
    yield 0
    c, s = {}, 3
    for n in count(2):
        for p, e in factorint(4 * n - 2).items():
            if p in c:
                c[p] += e
            else:
                c[p] = e
        for p, e in factorint(n + 1).items():
            if c[p] == e:
                del c[p]
            else:
                c[p] -= e
        if n == s:
            yield len(c)
            s = 2 * s + 1


def A120623_gen():  # generator of terms
    b = 1
    for n in count(1):
        if b % n and not (3 * b) % n:
            yield n
        b = b * (4 * n + 2) // (n + 2)


def A125094(n):
    return (
        n
        * (
            n**2
            * (
                n**2
                * (
                    n**2 * (n**2 * (n**2 * (n * (210 * n + 1365) + 2730) - 5005) + 8580)
                    - 9009
                )
                + 4550
            )
            - 691
        )
        // 2730
    )


def A125095(n):
    return (
        n**2
        * (
            n**2 * (n**2 * (n**2 * (n**2 * (n * (2 * n + 12) + 22) - 33) + 44) - 33)
            + 10
        )
        // 24
    )


def A123346_gen():  # generator of terms
    yield 1
    blist = [1]
    while True:
        b = blist[-1]
        blist = list(accumulate([b] + blist))
        yield from reversed(blist)


def A130335(n):
    k, Tn, Tm = 1, n * (n + 1) // 2, (n + 1) * (n + 2) // 2
    while gcd(Tn, Tm) != 1:
        k += 1
        Tm += k + n
    return k


def A133421(n):
    return (
        n // 2
        if not n % 2
        else (n // 3 if not n % 3 else (n // 5 if not n % 5 else 7 * n + 1))
    )


def A138182(n):
    m, tlist = prime(n), [1, 2]
    while tlist[-1] + tlist[-2] <= m:
        tlist.append(tlist[-1] + tlist[-2])
    for d in tlist[::-1]:
        if d == m:
            return d
        elif d < m:
            m -= d


def A138290_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        k2, n2 = 1, 2 ** (n + 1)
        for k in range(n):
            if isprime(n2 - k2 - 1):
                break
            k2 *= 2
        else:
            yield n


def A142994(n):
    return n * (n * (n * (n * (64 * n + 160) + 240) + 200) + 86) // 15 + 1


def A143010(n):
    return (
        n
        * (
            n
            * (
                n * (n * (n * (n * (n * (35 * n + 140) + 630) + 1400) + 2595) + 3020)
                + 2500
            )
            + 1200
        )
        // 288
        + 1
    )


@lru_cache(maxsize=None)
def A143270(n):  # based on second formula in A018805
    if n == 0:
        return 0
    c, j = 0, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * (2 * A143270(k1) // k1 - 1)
        j, k1 = j2, n // j2
    return n * (n * (n - 1) - c + j) // 2


def A160827(n):
    return n * (n * (n * (3 * n + 12) + 30) + 36) + 17


def A169824_gen(startvalue=1):
    return (n for n in count(max(startvalue, 1)) if not n % int(str(n)[::-1]))


def A171865_gen():  # generator of terms
    n = 1
    for m in A181391_gen():
        if m == 0:
            yield n
        n += 1


def A171868_gen():  # generator of terms
    g = A171865_gen()
    m = next(g)
    for k in g:
        yield k - m
        m = k


def A171887_gen():  # generator of terms
    g = A171868_gen()
    n, c = 1, 0
    for k in g:
        if k > c:
            yield n
            c = k
        n += 1


def A171888_gen():  # generator of terms
    g, c = A171868_gen(), 0
    for k in g:
        if k > c:
            yield k
            c = k


def A176371_gen():
    return filter(
        lambda p: is_square(int(str(p)[::-1]) - 13), (prime(n) for n in count(1))
    )


def A177719(n):
    return 4 * (
        (n - 1) * (n - 2)
        + sum(totient(i) * (n - 2 * i) * (n - i) for i in range(2, n // 2 + 1))
    )


def A181134(n):
    return (
        n**2
        * (
            n**2
            * (
                n**2
                * (
                    n**2 * (n**2 * (n**2 * (n * (30 * n + 210) + 455) - 1001) + 2145)
                    - 3003
                )
                + 2275
            )
            - 691
        )
        // 420
    )


def A187338(n):
    return 3 * n + isqrt(2 * n**2)


def A187393(n):
    return 4 * n + isqrt(8 * n**2)


def A187946(n):
    return int((isqrt(5 * (n + 5) ** 2) + n + 1) // 2 - (isqrt(5 * n**2) + n) // 2 - 6)


def A188374(n):
    return int(isqrt((n + 2) ** 2 // 2) - isqrt(n**2 // 2)) - 1


def A190402_gen(startvalue=2):
    return (
        n
        for n in count(max(startvalue, 2))
        if totient(int(sum([n * e / p for p, e in factorint(n).items()]))) == totient(n)
    )


def A192290_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if antidivisor_sigma(n) != n and antidivisor_sigma(antidivisor_sigma(n)) == n
    )


def A211033(n):
    x, y, z = n // 3 + 1, (n - 1) // 3 + 1, (n - 2) // 3 + 1
    return (
        x**4
        + 4 * x**3 * y
        + 4 * x**3 * z
        + 4 * x**2 * y**2
        + 8 * x**2 * y * z
        + 4 * x**2 * z**2
        + y**4
        + 6 * y**2 * z**2
        + z**4
    )


def A211034(n):
    x, y, z = n // 3 + 1, (n - 1) // 3 + 1, (n - 2) // 3 + 1
    return (
        x**2 * y**2
        + 2 * x**2 * y * z
        + x**2 * z**2
        + 2 * x * y**3
        + 6 * x * y**2 * z
        + 6 * x * y * z**2
        + 2 * x * z**3
        + 2 * y**3 * z
        + 2 * y * z**3
    )


def A211158(n):
    return n * (n + 1) * (3 * n + 1 + 3 * n**2 - (-1) ** n * (2 * n + 1))


def A211349_gen():
    return (
        p for p in (prime(n) for n in count(1)) if p == 2 or pow(2, p, p - 1) == p - 3
    )


def A225671(n):
    xn, xd, k, p = 1, prime(n), n, prime(n)
    while xn < xd:
        k += 1
        po, p = p, prime(k)
        xn = xn * p + xd
        xd *= p
    return po


def A228122(n):
    k = 0
    while sum(factorint(k * (k + 1) + 41).values()) != n:
        k += 1
    return k


def A229269_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if isprime(n - sum(int(n * e / p) for p, e in factorint(n).items()))
    )


def A229270_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if isprime(sum(int(n * e / p) for p, e in factorint(n).items()) - n)
    )


def A229272_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        np = sum(int(n * e / p) for p, e in factorint(n).items())
        if isprime(np + n) and isprime(np - n):
            yield n


def A229294(n):
    ndict = {}
    n2 = 2 * n
    for i in range(n2):
        i3 = pow(i, 2, n2)
        for j in range(i + 1):
            j3 = pow(j, 2, n2)
            m = (i3 + j3) % n2
            if m in ndict:
                if i == j:
                    ndict[m] += 1
                else:
                    ndict[m] += 2
            else:
                if i == j:
                    ndict[m] = 1
                else:
                    ndict[m] = 2
    count = 0
    for i in ndict:
        j = (n - i) % n2
        if j in ndict:
            count += ndict[i] * ndict[j]
    return count


def A232178(n):
    if n == 0:
        return 0
    t = n * (n + 1) // 2
    ds = divisors(t)
    l, m = divmod(len(ds), 2)
    if m:
        return 0
    for i in range(l - 1, -1, -1):
        x = ds[i]
        y = t // x
        a, b = divmod(y - x, 2)
        if not b:
            return a
    return -1


def A232179(n):
    if n == 0:
        return 0
    t = 2 * n**2
    ds = divisors(t)
    for i in range(len(ds) // 2 - 1, -1, -1):
        x = ds[i]
        y = t // x
        a, b = divmod(y - x, 2)
        if b:
            return a
    return -1


def A232444_gen():
    return chain(
        (2,),
        (
            n
            for n in (d**2 for d in count(1))
            if isprime(divisor_sigma(n)) and isprime(divisor_sigma(n**2))
        ),
    )


def A235801_gen(startvalue=0):
    return (n if n % 6 != 4 else 10 * (n // 6) + 7 for n in count(max(startvalue, 0)))


def A240923(n):
    return (m := Fraction(int(divisor_sigma(n)), n)).numerator - divisor_sigma(
        m.denominator
    )


def A241557_gen(startvalue=1):
    return filter(
        lambda n: not any(isprime(d) for d in antidivisors(n, generator=True)),
        count(max(startvalue, 1)),
    )


def A241107_gen():  # generator of terms
    blist = [0, 1, 1, 1, 1, -1]
    yield from blist
    while True:
        blist = blist[1:] + [
            (-blist[-1] * blist[-4] + blist[-2] * blist[-3]) // blist[-5]
        ]
        yield blist[-1]


def A242800_gen(startvalue=0):
    return (n for n in count(max(startvalue, 0)) if pow(n, n, n + 3) == n)


def A244411_gen(startvalue=1):  # generator of terms
    if startvalue <= 1:
        yield 1
    for n in count(max(startvalue, 2)):
        d = divisor_count(n)
        if d > 2:
            q, r = divmod(d, 2)
            s = str(n**q * (isqrt(n) if r else 1))
            if s == s[::-1]:
                yield n


def A246044_gen():  # generator of terms
    for n in count(1):
        p = prime(n)
        for x in permutations(str(p)):
            if x[0] != "0":
                p2 = int("".join(x))
                if p2 != p and isprime(p2):
                    break
        else:
            yield p


def A246519_gen():
    return (
        p
        for p in (prime(n) for n in count(1))
        if all(isprime(4 + p**z) for z in (1, 2, 3, 5))
    )


def A247165_gen(startvalue=0):
    return (n for n in count(max(startvalue, 0)) if n == 0 or pow(2, n, n * n + 1) == 1)


def A247452_gen():  # generator of terms
    yield from [1, 3]
    blist, b, n3 = [1], 1, 9
    while True:
        blist = list(accumulate([b] + blist))
        b = blist[-1]
        yield b * n3
        n3 *= 3


def A249153_gen():  # generator of terms
    yield 0
    n = 0
    for i in count(2, 2):
        n += (~i & i - 1).bit_length() * i
        yield n


def A249157_gen():
    return filter(lambda n: is_pal(n, 13), pal_gen(11))


def A249158_gen():
    return filter(lambda n: is_pal(n, 29), pal_gen(7))


def A249667_gen():  # generator of terms
    p = 2
    while True:
        q = next_prime(p)
        n1 = 2 * p + 1
        n2 = p + q + 1
        while n1 < p + q:
            if isprime(n1) and isprime(n2):
                yield n1 - p
            n1 += 2
            n2 += 2
        p = q


def A251393_gen():  # generator of terms
    yield from [1, 2]
    l1, l2, s, p2, b = 3, 2, 4, 4, {}
    for n in count(4):
        i = s
        while True:
            if not i in b and gcd(i, l1) == 1 and gcd(i, l2) > 1:
                l2, l1, b[i] = l1, i, 1
                while s in b:
                    b.pop(s)
                    s += 1
                if i == p2:
                    yield n
                    p2 *= 2
                break
            i += 1


def A251603_gen(startvalue=1):
    return (n for n in count(max(startvalue, 1)) if pow(n, n, n + 2) == 2)


def A252079_gen():  # generator of terms
    yield 1
    l, s, b = [1], 2, set()
    for n in count(2):
        i = s
        while True:
            if i not in b:
                li = [int(d) for d in str(i)[::-1]]
                for x, y in zip(li, l):
                    if x + y > 9:
                        break
                else:
                    l = li
                    b.add(i)
                    if i == n:
                        yield i
                    while s in b:
                        b.remove(s)
                        s += 1
                    break
            i += 1


def A252652(n):
    if n == 0:
        return 0
    f, i, s = 1, 0, re.compile("[0-9]*[1-9]0{" + str(n) + "}[1-9][0-9]*")
    while s.match(str(f)) == None:
        i += 1
        f *= i
    return i


def A252865_gen():  # generator of terms
    yield from [1, 2, 3]
    l1, l2, s, b = 3, 2, 4, set()
    while True:
        i = s
        while True:
            if max(factorint(i).values()) == 1:
                if not i in b and gcd(i, l1) == 1 and gcd(i, l2) > 1:
                    yield i
                    l2, l1 = l1, i
                    b.add(i)
                    while s in b:
                        b.remove(s)
                        s += 1
                    break
            else:
                b.add(i)
            i += 1


def A252868_gen():  # generator of terms
    yield from [1, 2, 3]
    l1, l2, s, b = 2, 1, 3, set()
    while True:
        i = s
        while True:
            if not (i in b or i & l1) and i & l2:
                yield A019565(i)
                l2, l1 = l1, i
                b.add(i)
                while s in b:
                    b.remove(s)
                    s += 1
                break
            i += 1


def A253941_gen():  # generator of terms
    for p in (prime(n) for n in count(1)):
        p2, x = p**2, 1
        for i in range(5):
            x *= p2
            q, r = divmod(x + 5, 6)
            if r or not isprime(q):
                break
        else:
            yield p


def A254732(n):
    k = n + 1
    while pow(k, 2, n):
        k += 1
    return k


def A254734(n):
    k = n + 1
    while pow(k, 4, n):
        k += 1
    return k


def A257345(n):
    if n > 0:
        for i in range(1, 2**n):
            x = int(format(i, "b"))
            if not x % n:
                return int(str(x), 2)
    return 0


def A257349_gen():
    return accumulate(repeat(16), lambda x, _: divisor_sigma(x))


def A257899_gen():  # generator of terms
    l = []
    for d in permutations("0123456789", 10):
        if d[0] != "0":
            d2 = int("".join(d))
            d = d2
            r = d2 % 3
            while not r:
                d2, r = divmod(d2, 3)
            l.append((d2, d))
    l.sort()
    yield from (b for a, b in l)


def A259831_gen(startvalue=2):  # generator of terms
    for n in count(max(startvalue, 2)):
        s = format(n, "0b")
        for l in range(1, len(s)):
            n1, n2 = int(s[:l], 2), int(s[l:], 2)
            if n2 > 0 and n == (divisor_sigma(n1) - n1) * (divisor_sigma(n2) - n2):
                yield n
                break


def A259832_gen(startvalue=2):  # generator of terms
    for n in count(max(startvalue, 2)):
        s, k = format(n, "0b"), divisor_sigma(n)
        for l in range(1, len(s)):
            n1, n2 = int(s[:l], 2), int(s[l:], 2)
            if n2 > 0 and k == (divisor_sigma(n1) - n1) * (divisor_sigma(n2) - n2):
                yield n
                break


def A262091_gen():  # generator of terms
    for m in count(2):
        for c in combinations_with_replacement(range(10), m + 1):
            n = sum(d**m for d in c)
            r = sum(int(q) ** m for q in str(n))
            rlist = sorted(int(d) for d in str(r))
            rlist = [0] * (m + 1 - len(rlist)) + rlist
            if n < r and rlist == list(c):
                yield n


def A262092_gen():  # generator of terms
    for m in count(2):
        for c in combinations_with_replacement(range(10), m + 1):
            n = sum(d**m for d in c)
            r = sum(int(q) ** m for q in str(n))
            rlist = sorted(int(d) for d in str(r))
            rlist = [0] * (m + 1 - len(rlist)) + rlist
            if n < r and rlist == list(c):
                yield r


def A262958_helper1(n):
    s = gmpy2digits(n, 3)
    m = len(s)
    for i in range(m):
        if s[i] == "0":
            return int(s[:i] + "1" * (m - i), 3)
    return n


def A262958_helper2(n):
    s = gmpy2digits(n, 4)
    m = len(s)
    for i in range(m):
        if s[i] == "0":
            return int(s[:i] + "1" * (m - i), 4)
        if s[i] == "2":
            return int(s[:i] + "3" + "1" * (m - i - 1), 4)
    return n


def A262958_gen():  # generator of terms
    n = 1
    while True:
        m = A262958_helper2(A262958_helper1(n))
        while m != n:
            n, m = m, A262958_helper2(A262958_helper1(m))
        yield m
        n += 1


def A263314_gen(startvalue=0):  # generator of terms
    for i in count(max(startvalue, 0)):
        s = str(i)
        for d in s:
            j = int(d)
            if j:
                for e in s:
                    if int(e) % j:
                        break
                else:
                    yield i
                    break


def A263856(n):
    return 1 + sorted(format(prime(i), "b")[::-1] for i in range(1, n + 1)).index(
        format(prime(n), "b")[::-1]
    )


def A267821_gen():
    return (
        int(d, 9)
        for d in (str(i**2) for i in count(1))
        if max(d) < "9" and isprime(int(d, 9))
    )


def A267875(n):
    return int((mpz(2) ** 74207281 - 1) // mpz(10) ** (44677235 - n) % 10)


def A268476_gen():
    return (
        p
        for p in (prime(i) for i in count(1))
        if not len(list(filter(bool, format(p, "b").split("0")))) % 2
    )


def A268477_gen():
    return (
        p
        for p in (prime(i) for i in count(1))
        if len(list(filter(bool, format(p, "b").split("0")))) % 2
    )


def A271497(n):
    return (
        int("".join(sorted(bin(n)[2:])), 2)
        + int("".join(sorted(bin(n)[2:], reverse=True)), 2)
        if n % 3
        else n // 3
    )


def A271591_gen():  # generator of terms
    a, b, c = 0, 1, 1
    while True:
        a, b, c = b, c, a + b + c
        yield int(bin(c)[3])


def A272363(n):
    return (
        1
        if n == 0
        else sum(
            1
            for p in multiset_partitions(list(range(1, 2 * n + 1)), n)
            if max(len(d) for d in p) == 2
            and len(set([sum(d) for d in p])) + len(set([abs(d[0] - d[1]) for d in p]))
            == 2 * n
        )
    )


def A272654_gen():
    return (
        int(b + "".join(s))
        for b in (bin(n)[2:] for n in count(1))
        for s in multiset_permutations(sorted(b))
    )


def A272655_gen():
    return (
        int(str(n) + "".join(s))
        for n in count(1)
        for s in multiset_permutations(sorted(str(n)))
    )


def A273245_gen():
    (
        int(m)
        for m in (bin(n)[2:] for n in count(1))
        if m != m[::-1] and m.rstrip("0") == m[::-1].lstrip("0")
    )


def A276863(n):
    return 1 + isqrt(5 * n**2) - isqrt(5 * (n - 1) ** 2)


def A278585_gen():
    return (
        4 * q - 4
        for q in (prime(i) for i in count(1))
        if isprime(4 * q - 3)
        and isprime(2 * q - 1)
        and (not (4 * q - 1) % 3)
        and isprime((4 * q - 1) // 3)
    )


def A280934_gen():  # generator of terms
    yield from [1, 1, 4, 36]
    b = 36
    for i in count(4):
        b += 4 * divisor_count(i + 1) + 8
        yield b


@lru_cache(maxsize=None)
def A283207(n):
    return 2 if n <= 2 else A283207(n // A283207(n - 1)) + A283207(n // A283207(n - 2))


def A290323(n):
    f = factorint(n)
    m = f[2] if 2 in f else 0
    a, b = divmod(m, 3)
    c = 2 if m == 1 else 3 ** (b * (b + 1) % 5) * 5 ** (a - (b % 2))
    return c * prod(((d + 1) // 2) ** f[d] for d in f if d != 2)


def A290434_gen(startvalue=2):
    return (
        n
        for n in count(max(startvalue, 2))
        if sum(factorint(n).values()) == 2
        and isprime(1 + sum(factorint(n).keys()) * (3 - len(factorint(n))))
    )


def A298946(n):
    c = composite(n)
    return comb(2 * c - 1, c - 1) % c**4


def A301278(n):
    return (
        (Fraction(int(comb(2 * n, n))) / n - Fraction(4**n) / (n * (n + 1))).numerator
        if n > 0
        else 0
    )


def A301279(n):
    return (
        (Fraction(int(comb(2 * n, n))) / n - Fraction(4**n) / (n * (n + 1))).denominator
        if n > 0
        else 1
    )


def A301336(n):
    return sum(2 * bin(i).count("1") - len(bin(i)) + 2 for i in range(n + 1))


def A306305(n):
    m, k = 0, n
    while True:
        s = str(k)
        for i in range(1, len(s)):
            if s[i] == s[i - 1]:
                return m
        m += 1
        k *= 2


@lru_cache(maxsize=None)
def A309288(n):
    if n <= 1:
        return n
    c, j = 0, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += ((j2 - j) % 2) * (1 - 2 * (j % 2)) * A309288(k1)
        j, k1 = j2, n // j2
    return c + ((n + 1 - j) % 2) * (1 - 2 * (j % 2))


def A318935(n):
    return (((n & -n) ** 3 << 3) - 1) // 7


def A320039(n):
    return int(
        "".join(
            d + "1" for d in split("(0+)|(1+)", bin(n)[2:]) if d != "" and d != None
        ),
        2,
    )


def A320940(n):
    return sum(
        divisor_sigma(d) * (n // d) ** (n + 1) for d in divisors(n, generator=True)
    )


def A321440(n):
    if n == 0:
        return 1
    c = 0
    for i in range(n):
        mi = i * (i + 1) // 2 + n
        for j in range(i + 1, n + 1):
            k = mi - j * (j + 1) // 2
            if k < 0:
                break
            if not k % j:
                c += 1
    return c


def A321797(n):
    return int("0" + "".join(d if str(n).count(d) != 1 else "" for d in str(n)))


def A321800(n):
    return (lambda x: int(x) if x != "" else -1)(
        "".join(d if str(n).count(d) != 1 else "" for d in str(n))
    )


def A322781_gen():  # generator of terms
    for k in count(1):
        fk, fv = zip(*list(factorint(4 * k + 1).items()))
        if (
            sum(fv) == len(fk) == 2
            and fk[0] % 4 == fk[1] % 4 == 1
            and legendre_symbol(fk[0], fk[1]) == -1
        ):
            yield 4 * k + 1


def A323271_gen():  # generator of terms
    for k in count(1):
        fk, fv = zip(*list(factorint(4 * k + 1).items()))
        if (
            sum(fv) == len(fk) == 3
            and fk[0] % 4 == fk[1] % 4 == fk[2] % 4 == 1
            and legendre_symbol(fk[0], fk[1])
            == legendre_symbol(fk[0], fk[2])
            == legendre_symbol(fk[1], fk[2])
            == -1
        ):
            yield 4 * k + 1


def A325231_gen(startvalue=6):
    return (
        n
        for n in count(max(startvalue, 6))
        if ((not n % 2) and isprime(n // 2))
        or (bin(n)[2:4] == "11" and bin(n).count("1") == 2)
    )


def A325459(n):
    return (
        0
        if n == 0
        else (
            lambda m: 2 * (sum(n // k for k in range(1, m + 1)) - n) + (1 - m) * (1 + m)
        )(isqrt(n))
    )


def A331771(n):
    return 4 * (
        (n - 1) * (2 * n - 1)
        + sum(totient(i) * (n - i) * (2 * n - i) for i in range(2, n))
    )


def A332596(n):
    return (
        0
        if n == 1
        else (
            (n - 1) * (n - 4)
            - sum(
                totient(i) * (n + 1 - i) * (2 * n + 2 - 7 * i)
                for i in range(2, n // 2 + 1)
            )
            + sum(
                totient(i) * (n + 1 - i) * (2 * n + 2 - i)
                for i in range(n // 2 + 1, n + 1)
            )
        )
        // 2
    )


def A332867(n):
    m, k = int("".join(str(d) for d in range(1, n + 1))), 1
    i = n + k
    i2, l = i % m, len(str(i))
    t = 10**l
    t2, r = t % m, i % m
    while r != 0:
        k += 1
        i += 1
        i2 = (i2 + 1) % m
        if i >= t:
            l += 1
            t *= 10
            t2 = (10 * t2) % m
        r = (r * t2 + i2) % m
    return k


def A341701(n):
    k, m = n, n - 1
    while not isprime(k) and m > 0:
        k = int(str(k) + str(m))
        m -= 1
    return m + 1 if isprime(k) else -1


def A341702(n):
    k, m = n, n - 1
    while not isprime(k) and m > 0:
        k = int(str(k) + str(m))
        m -= 1
    return n - m - 1 if isprime(k) else -1


def A342410(n):
    if n == 0:
        return 0
    for i, d in enumerate(bin(n)[2:].split("0")[::-1]):
        if d != "":
            return int(d + "0" * i, 2)


def A343996(n):
    fs = factorint(2 * n)
    plist = [p ** fs[p] for p in fs]
    x = min(
        k
        for k in (crt(plist, d)[0] for d in product([0, -1], repeat=len(plist)))
        if k > 0
    )
    return x + 1 - x % 2


def A345427(n):
    return sum(
        v
        for u, v, w in (igcdex(x, y) for x in range(1, n + 1) for y in range(1, n + 1))
    )


def A345433(n):
    return sum(
        abs(v)
        for u, v, w in (igcdex(x, y) for x in range(1, n + 1) for y in range(1, n + 1))
    )


def A345694(n):
    zlist = [
        z
        for z in (igcdex(x, y) for x in range(1, n + 1) for y in range(1, n + 1))
        if z[2] == 1
    ]
    return pvariance(len(zlist) * abs(u) for u, v, w in zlist)


def A345882_helper(n):
    if n == 1:
        return {1}
    else:
        s = A345882_helper(n - 1)
        c = set(s)
        for x in s:
            for i in range(2, n + 1):
                c.add(i * x)
        return c


def A345882(n):
    return len(A345882_helper(n))


def A346006(n):
    i = (4 - n) % 4
    return comb(4, i + 1) * ((n + i) // 4) ** (i + 1)


def A347323(n):
    return int("".join("0" if d == "0" else str(n % int(d)) for d in str(n)))


def A347409(n):
    m, r = n, 0
    while m > 1:
        if m % 2:
            m = 3 * m + 1
        else:
            s = bin(m)[2:]
            c = len(s) - len(s.rstrip("0"))
            m //= 2**c
            r = max(r, c)
    return r


def A347607(n):
    return partition(n**n)


def A007356_gen(startvalue=0):
    return (k for k in count(max(startvalue, 0)) if "666" in str(2**k))


def A008349(n):
    return (
        n
        * (
            n
            * (n * (n * (n * (n * (n * (57 * n + 108) + 210) + 504) + 273) + 252) + 300)
            - 24
        )
        // 7
        + 1
    )


def A011967_gen():
    yield 4
    blist, b = [5, 7, 10, 15], 15
    while True:
        blist = list(accumulate([b] + blist))
        b = blist[-1]
        yield blist[-5]


def A018142(n):
    i, j = iroot_rem(10**n, 5)
    return int(i) + int(32 * j >= 10 * i * (4 * i * (2 * i * (i + 1) + 1) + 1) + 1)


def A023969(n):
    i, j = isqrt_rem(n)
    return int(4 * (j - i) >= 1)


def A027603(n):
    return n * (n * (4 * n + 18) + 42) + 36


def A036994_gen(startvalue=0):  # generator of terms
    for n in count(max(startvalue, 0)):
        s = bin(n)[2:]
        c, l = 0, len(s)
        for i in range(l):
            c += int(s[l - i - 1])
            if 2 * c <= i + 1:
                break
        else:
            yield n


def A028337_gen():
    return filter(is_pal, (n * (n + 1) for n in count(1)))


def A028553_gen():
    return filter(lambda n: is_pal(n * (n + 3)), count(0))


def A028554_gen():
    return filter(is_pal, (n * (n + 3) for n in count(0)))


def A030668(n):
    d, nd = 10, 10 * n
    while True:
        x = (integer_nthroot(nd - 1, 3)[0] + 1) ** 3
        if x < nd + d:
            return x
        d *= 10
        nd *= 10


def A031688_gen():
    (
        n
        for n, s in ((i, continued_fraction_periodic(0, 1, i)[-1]) for i in count(1))
        if isinstance(s, list) and len(s) % 2 and s[(len(s) - 1) // 2] == 100
    )


def A038129(n):
    return integer_nthroot(2 * n**3, 3)[0]


def A038585(n):
    return int(bin(n)[2:].replace("0", ""))


def A048340_gen():
    return chain(
        (0,), (int(d * l, 16) for l in range(1, 10) for d in "123456789abcdef")
    )


def A048343(n):
    y, plist = 0, []
    for i in range(10 ** (n - 1), 10**n):
        s1 = str(i)
        s2 = s1[::-1]
        if s1 != s2:
            p = i * int(s2)
            if not p in plist:
                sp = str(p)
                if sp == sp[::-1]:
                    plist.append(p)
                    y += 1
    return y


def A048344_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        s = str(n)
        s2 = str(n)[::-1]
        if s != s2:
            s3 = str(n * int(s2))
            if s3 == s3[::-1]:
                yield n


def A048611(n):
    d = divisors((10**n - 1) // 9)
    l = len(d)
    return (d[l // 2] + d[(l - 1) // 2]) // 2


def A051256(n):
    return sum(0 if ~n & k else factorial(k + 1) for k in range(n + 1))


def A053095(n):
    return sum(
        1
        for d in multiset_permutations("".join(str(prime(m + 1)) for m in range(n)))
        if isprime(int("".join(d)))
    )


def A053872_gen():  # generator of terms
    m, s = 4, 4
    for n in count(1):
        if isprime(s):
            yield s
        m += 1
        if isprime(m):
            m += 1
        s += m


def A056582_gen():  # generator of terms
    n = 1
    for i in range(2, 201):
        m = i**i
        yield gcd(n, m)
        n *= m


def A057333_helper(w, dir):
    if dir == 1:
        for s in w:
            for t in range(int(s[-1]) + 1, 10):
                yield s + str(t)
    else:
        for s in w:
            for t in range(0, int(s[-1])):
                yield s + str(t)


def A057333(n):
    c = 0
    for d in "123456789":
        x = d
        for i in range(1, n):
            x = A057333_helper(x, (-1) ** i)
        c += sum(1 for p in x if isprime(int(p)))
        if n > 1:
            y = d
            for i in range(1, n):
                y = A057333_helper(y, (-1) ** (i + 1))
            c += sum(1 for p in y if isprime(int(p)))
    return c


def A057630_gen(startvalue=2):  # generator of terms
    dlist, p = tuple(str(d) * d for d in range(10)), max(nextprime(startvalue - 1), 2)
    while True:
        if isprime(int("".join(dlist[int(d)] for d in str(p)))):
            yield p
        p = nextprime(p)


def A058993_gen():  # generator of terms
    m = 5
    for k in count(1):
        if isprime(int(str(m)[::-1])):
            yield k
        m *= 5


def A059247(n):
    return n // gcd(
        n, (lambda m: 2 * sum(n // k for k in range(1, m + 1)) - m * m)(isqrt(n))
    )


def A062067_gen():  # generator of terms
    yield 1
    a = 1
    while True:
        a += 1
        b = 2 * a * (a - 1) + 1
        while not isprime(b):
            b += 4 * (a + 1)
            a += 2
        yield a**2


def A062550(n):
    return (lambda m: 2 * sum(2 * n // k for k in range(1, m + 1)) - m * m)(
        isqrt(2 * n)
    )


def A064940_gen():  # generator of terms
    p, d, n, r = 2, -1, 0, False
    while True:
        pn, k = p - n, d if r else -d
        if 0 < k <= pn:
            yield n + k - 1
        d += -pn if r else pn
        r, n, p = not r, p, nextprime(p)


def A068186(n):
    if n == 1:
        return 1
    pf = factorint(n)
    ps = sorted(pf.keys(), reverse=True)
    if ps[0] > 7:
        return 0
    s = ""
    for p in ps:
        s += str(p) * (n * pf[p])
    return int(s)


@lru_cache(maxsize=None)
def A064960(n):
    return (
        1 if n == 1 else composite(A064960(n - 1)) if n % 2 else prime(A064960(n - 1))
    )


def A068831_gen():
    return (
        p
        for p in (
            int("".join(d)) for l in range(1, 9) for d in product("13579", repeat=l)
        )
        if isprime(p)
        and set(str(nextprime(p, 1))) <= {"1", "3", "5", "7", "9"}
        and set(str(nextprime(p, 2))) <= {"1", "3", "5", "7", "9"}
        and set(str(nextprime(p, 3))) <= {"1", "3", "5", "7", "9"}
    )


def A073633_gen():  # generator of terms
    m = 1
    for n in count(1):
        m *= 3
        if m // 2**n % n == 0:
            yield n


def A073799(n):
    return 2 if n == 1 else prime(2**n)


def A073956_gen():
    return filter(
        lambda n: is_pal(sum(antidivisors(n, generator=True))),
        islice(pal10_gen(), 1, None),
    )


def A074100_gen():
    return (n**3 for n in count(1) if set(str(n**3)) <= set("12357"))


def A075904_gen(startvalue=0):
    return filter(lambda k: str(k) in str(k**4), count(max(startvalue, 0)))


def A075905_gen(startvalue=0):
    return filter(lambda k: str(k) in str(k**5), count(max(startvalue, 0)))


def A078431(n):
    return sum(
        1
        for p in permutations(range(1, n + 1))
        if (lambda x: isprime(x.p) and isprime(x.q))(continued_fraction_reduce(p))
    )


def A078432(n):
    return sum(
        1
        for p in permutations(range(1, n + 1))
        if isprime(continued_fraction_reduce(p).q)
    )


def A078433(n):
    return sum(
        1
        for p in permutations(range(1, n + 1))
        if isprime(continued_fraction_reduce(p).p)
    )


def A079475(n):
    s = str(n)
    l = len(s)
    if l % 2:
        s = s[:-1] + "1" + s[-1]
    return int("".join(s[i + 1] * int(s[i]) for i in range(0, l, 2)))


def A080343(n):
    i, j = isqrt_rem(2 * n)
    return int(4 * (j - i) >= 1)


def A082060_gen(startvalue=1):
    return (n for n in count(max(startvalue, 1)) if set(str(totient(n))) == set(str(n)))


def A082916_gen():  # generator of terms
    b = 1
    for n in count(0):
        if gcd(n, b) == 1:
            yield n
        b = b * (4 * n + 2) // (n + 1)


def A085300(n):
    p = prime(n)
    q = p
    while True:
        m = int(str(q)[::-1])
        if isprime(m):
            return m
        q *= p


def A349823(n):
    return (lambda f: sum(f[p] for p in f) * sum(p * f[p] for p in f))(factorint(n))


@lru_cache(maxsize=None)
def A091369(n):
    if n == 0:
        return 0
    c, j = 0, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * (2 * A091369(k1) - (k1 * (k1 - 1) + 1))
        j, k1 = j2, n // j2
    return n * (n - 1) - (c - j) // 2


@lru_cache(maxsize=None)
def A092149(n):
    if n == 1:
        return 1
    c, j = n + 1, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * A092149(k1)
        j, k1 = j2, n // j2
    return j - c


def A096485(n):
    return len(continued_fraction(sqrt((10**n - 1) // 9))[-1])


def A096687(n):
    if n > 0:
        for i in range(1, 2**n):
            q, r = divmod(8 * int(bin(i)[2:]), n)
            if not r:
                return q
    return 1


def A105093_gen():
    plist = [2, 3, 5, 7]
    while True:
        m = plist[0] + plist[3]
        if m == plist[1] + plist[2]:
            yield m
        plist = plist[1:] + [nextprime(plist[-1])]


def A113496(n):
    m = composite(n)
    k = m + 1
    while gcd(k, m) != 1 or isprime(k):
        k += 1
    return k


def A120389(n):
    compositepi(prime(n) ** 2)


def A055874(n):
    for m in count(1):
        if n % m:
            return m - 1


def A120624_gen():
    b = 1
    for n in count(1):
        if not b % (2 * n):
            yield n
        b = b * (4 * n + 2) // (n + 2)


def A127118(n):
    return 2 if n == 1 else prime(n) * composite(n - 1)


def A128438(n):
    return harmonic(n).q // n


def A130232_gen():  # generator of terms
    b, c = 0, 1
    while True:
        yield b
        b += c
        c += str(b).count("0")


def A344104_gen():  # generator of terms
    b, c = 10, 1
    while True:
        yield b
        b *= c
        c += str(b).count("0")


def A138173(n):
    d, nd = 1, n**2
    while True:
        x = integer_nthroot(nd - 1, 3)[0] + 1
        if x**3 < nd + d:
            return x
        d *= 10
        nd *= 10


def A147771(n):
    i, j = isqrt_rem(n**n)
    return int(i + int(4 * (j - i) >= 1))


def A151413(n):
    if n <= 2:
        return n
    else:
        l1, m, b = 2, 1, {1, 2}
        for j in count(3):
            i = m
            while True:
                if not i in b:
                    if i == n:
                        return j
                    l1, m = i, l1 // gcd(l1, i)
                    b.add(i)
                    break
                i += m


def A153823(n):
    return divisor_count(factorial(n)) - 1


def A155011_gen():  # generator of terms
    a, b, a2, b2 = 0, 1, 1, 3
    while True:
        if isprime(b) and isprime(b2):
            yield b
        a, b, a2, b2 = b, a + b, b2, a2 + b2 - 1


def A158796_gen():  # generator of terms
    for i in count(3):
        n = i**3
        m = n // 3
        pm, nm = prevprime(m), nextprime(m)
        k = n - pm - nm
        if isprime(m):
            if m == k:
                yield primepi(pm)
        else:
            if nextprime(nm) == k:
                yield primepi(pm)
            elif prevprime(pm) == k:
                yield primepi(pm) - 1


def A161501(n):
    s = bin(n)[2:]
    if s == s[::-1]:
        return n
    for i in range(1, len(s)):
        if s[i:] == s[-1 : i - 1 : -1]:
            return int(s + s[i - 1 :: -1], 2)


def A166923(n):
    return 1 + (prime(n) ** 2 - 1) % 9


def A167508(n):
    return len(set(re.sub("[^a-z]", "", unidecode(num2words(n, lang="fr")))))


def A173071_gen():  # generator of terms
    for l in count(1):
        for i in combinations("23456789", l):
            s = "1" + "".join(i)
            p = int(s + s[l - 1 :: -1])
            if is_prime(p):
                yield p


def A182577(n):
    m, tlist, s = factorial(n), [1, 2], 0
    while tlist[-1] + tlist[-2] <= m:
        tlist.append(tlist[-1] + tlist[-2])
    for d in tlist[::-1]:
        if d <= m:
            s += 1
            m -= d
    return s


def A185635_gen():  # generator of terms
    yield from [1, 2]
    l1, m, b = 2, 2, {1, 2}
    for n in count(3):
        i = m
        while True:
            if not i in b:
                if n == i:
                    yield i
                l1, m = i, i // gcd(l1, i)
                b.add(i)
                break
            i += m


@lru_cache(maxsize=None)
def A185670(n):  # based on second formula in A018805
    if n == 0:
        return 0
    c, j = 2, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * (k1 * (k1 - 1) + 1 - 2 * A185670(k1))
        j, k1 = j2, n // j2
    return (c - j) // 2


def A187395(n):
    return 4 * n + isqrt(10 * n**2)


def A187396(n):
    return isqrt(10 * n**2) - 2 * n


def A188090(n):
    return int(isqrt(3 * (n + 5) ** 2) - isqrt(3 * n**2)) - 8


def A188221(n):
    return isqrt(5 * (n + 1) ** 2) - isqrt(5 * n**2) - 2


def A188383_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if isqrt((n + 3) ** 2 // 2) - isqrt(n**2 // 2) == 3
    )


def A191647_gen(startvalue=3):
    return (
        n
        for n in count(max(startvalue, 3))
        if isprime(
            int(
                "".join(
                    [
                        str(d)
                        for d in range(2, n)
                        if n % d and 2 * n % d in [d - 1, 0, 1]
                    ]
                )
            )
        )
    )


def A350457(n):
    return (
        1
        if n == 0
        else max(
            prod(1 + symbolx ** prime(i) for i in range(1, n + 1)).as_poly().coeffs()
        )
    )


def A193890_gen():  # generator of terms
    for l in count(1):
        for d in product("0123", repeat=l):
            p = int("".join(d))
            if d[0] != "0" and d[-1] in ("1", "3") and isprime(p):
                for i in range(len(d)):
                    d2 = list(d)
                    d2[i] = str(3 * int(d[i]))
                    if not is_prime(int("".join(d2))):
                        break
                else:
                    yield p


def A194145(n):
    return isqrt(6 * n**2) - n


def A210205_gen():  # generator of terms
    for i in count(3):
        n = i**3
        p2 = prevprime(n // 3)
        p1, p3 = prevprime(p2), nextprime(p2)
        q = p1 + p2 + p3
        while q <= n:
            if q == n:
                yield p1
            p1, p2, p3 = p2, p3, nextprime(p3)
            q = p1 + p2 + p3


def A210546_gen():  # generator of terms
    for l in count(1):
        q = (10**l - 1) // 9
        for i in range(l):
            for p in [2, 3, 5, 7]:
                r = q + (p - 1) * 10**i
                s, t = str(r), str(r)[::-1]
                if s != t and isprime(r) and isprime(int(t)):
                    yield r


def A211203_gen():
    return (
        p
        for p in (prime(n) for n in count(1))
        if p == 2 or p == 3 or pow(2, 2 * p - 1, p - 1) == 2
    )


def A211889(n):
    if n == 1:
        return 1
    delta = primorial(primepi(n))
    p, d = prime(n), delta
    while True:
        q = p
        for _ in range(n):
            q += d
            if not isprime(q):
                break
        else:
            return d
        d += delta


def A212875_gen(startvalue=2):  # generator of terms
    for n in count(max(startvalue, 2)):
        if not isprime(n):
            x = sorted(chain.from_iterable([p] * e for p, e in factorint(n).items()))
            y = sum(x)
            while y < n:
                x, y = x[1:] + [y], 2 * y - x[0]
            if y == n:
                yield n


def A216384_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        ndsum = nd = sum(int(n * e / p) for p, e in factorint(n).items())
        while ndsum <= n and nd > 1:
            nd = sum(int(nd * e / p) for p, e in factorint(nd).items())
            ndsum += nd
            if ndsum == n:
                yield n


def A217165(n):
    if n == 1:
        return 0
    else:
        l, y, x = tuple(str(d) * n for d in range(10)), 0, 1
        for m in count(1):
            s = str(x)
            for k in l:
                if k in s:
                    return m
            y, x = x, y + x


def A217166(n):
    if n == 1:
        return 0
    else:
        l, y, x = tuple(str(d) * n for d in range(10)), 2, 1
        for m in count(1):
            s = str(x)
            for k in l:
                if k in s:
                    return m
            y, x = x, y + x


def A217466_gen():
    return (p for p in (prime(n) for n in count(1)) if pow(2, p, p * (p + 1)) == 2)


def A227510_gen():
    return (
        int(n)
        for n in (str(x) for x in count(1))
        if not n.count("0") and str(prod(int(d) for d in n)) in n
    )


def A232111(n):
    return min(
        x
        for x in (
            sum(d[i] * Fraction(1, i + 1) for i in range(n))
            for d in product((1, -1), repeat=n)
        )
        if x >= 0
    ).numerator


def A232112(n):
    if n <= 1:
        return 1
    m = lcm(*range(2, n + 1))
    mtuple = tuple(m // i for i in range(2, n + 1))
    return m // gcd(
        m,
        min(
            abs(m + sum(d[i] * mtuple[i] for i in range(n - 1)))
            for d in product((-1, 1), repeat=n - 1)
        ),
    )


def A232175(n):
    n3 = n**3
    ds = divisors(n3)
    for i in range(len(ds) // 2 - 1, -1, -1):
        x = ds[i]
        y = n3 // x
        a, b = divmod(y - x, 2)
        if not b:
            return a
    return 0


def A235540_gen(startvalue=1):  # generator of terms
    for i in count(max(startvalue, 1)):
        if not is_prime(i):
            d = 2 * i * (2 * i + 1)
            n = (pow(4, i, d) - pow(2, i, d) + 8 * i * i - 2) % d
            if not n:
                yield i


def A235808_gen(startvalue=0):
    return filter(lambda n: len(set(str(n**3))) == 6, count(max(startvalue, 0)))


def A235810_gen(startvalue=0):
    return filter(lambda n: len(set(str(n**3))) == 8, count(max(startvalue, 0)))


def A236246_gen():  # generator of terms
    n = 1
    for m in A229037_gen():
        if m == 1:
            yield n
        n += 1


def A239103_gen():  # generator of terms
    for n in count(0):
        for k in range(n, -1, -1):
            c, d0 = 0, ["0"] * (n + k)
            for x in combinations(range(n + k), n):
                d = list(d0)
                for i in x:
                    d[i] = "1"
                if not "1011101" in "".join(d):
                    c += 1
            yield c


def A242473(n):
    return comb(2 * (p := prime(n)) - 1, p - 1) % (p**4)


def A242966_gen():
    return filter(
        lambda n: all(isprime(d) for d in antidivisors(n, generator=True)),
        (composite(n) for n in count(1)),
    )


def A244440_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if max(set(s := str(totient(n) + n))) == "1" and s.count("1") == 1
    )


def A245576_gen():
    return (
        p
        for p in (prime(i) for i in count(1))
        if not (str(p).count("0") or str(p**2).count("0"))
    )


def A245802_gen(startvalue=1):
    return (
        n for n in count(max(startvalue, 1)) if not n % sum(int(d) for d in oct(n)[2:])
    )


def A246428_gen():
    return (
        int(n)
        for n in (str(prime(x)) for x in count(1))
        if isprime(int(str(sum([int(d) for d in n])) + n))
    )


def A246503_gen(startvalue=1):  # generator of terms
    if startvalue <= 1:
        yield 1
    for i in count(max(startvalue, 2)):
        d, n = i * i, 1
        for _ in range(i):
            n = (2 * n) % d
            if n == 1:
                yield i
                break


def A246520(n):
    return max(int(bin(n - k)[2:] + bin(n + k)[2:], 2) for k in range(n + 1))


def A246600(n):
    return sum(1 for d in divisors(n) if n | d == n)


def A246831(n):
    return int(bin(n)[2:] + bin(3 * n)[2:], 2)


def A246839_gen():  # generator of terms
    p5 = 0
    for n in count(5, 5):
        yield from [p5] * 5
        p5 += multiplicity(5, n) * n


def A247363(n):
    return sorted((b + 1) ** ((2 * n - 1) - b) for b in range(2 * n - 1))[n - 1]


def A247875_gen(startvalue=0):
    return (n for n in count(max(startvalue, 0)) if not n % 2 or "00" in bin(n))


def A249357_gen():  # generator of terms
    yield from [1, 2, 3]
    l1, l2 = 3, 2
    while True:
        i = l1 + l2
        while True:
            if gcd(i, l1) == 1 and gcd(i, l2) > 1:
                yield i
                l2, l1 = l1, i
                break
            i += 1


def A249515_gen():  # generator of terms
    yield 0
    for g in count(1):
        xp, ylist = [], []
        for i in range(9 * g, -1, -1):
            x = set(str(i))
            if not x in xp:
                xv = [int(d) for d in x]
                imin = int("".join(sorted(str(i))))
                if max(xv) * (g - len(x)) >= imin - sum(xv) and i - sum(xv) >= min(
                    xv
                ) * (g - len(x)):
                    xp.append(x)
                    for y in product(x, repeat=g):
                        if (
                            y[0] != "0"
                            and set(y) == x
                            and set(str(sum([int(d) for d in y]))) == x
                        ):
                            ylist.append(int("".join(y)))
        yield from sorted(ylist)


def A249751_gen(startvalue=3):
    return (n for n in count(max(startvalue, 3)) if n == 3 or pow(n, n, n - 2) == n - 4)


def A249902_gen():
    return chain(
        (2,),
        (
            n
            for n in (d**2 for d in count(1))
            if isprime(2 * n - 1) and isprime(divisor_sigma(n))
        ),
    )


def A251411_gen():  # generator of terms
    n = 1
    for m in A098550_gen():
        if m == n:
            yield n
        n += 1


def A251413_gen():  # generator of terms
    yield from [1, 3, 5]
    l1, l2, s, b = 5, 3, 7, {}
    while True:
        i = s
        while True:
            if not i in b and gcd(i, l1) == 1 and gcd(i, l2) > 1:
                yield i
                l2, l1, b[i] = l1, i, True
                while s in b:
                    b.pop(s)
                    s += 2
                break
            i += 2


def A251414_gen():  # generator of terms
    yield from [1, 2, 3]
    l1, l2, s, b = 5, 3, 7, {}
    while True:
        i = s
        while True:
            if not i in b and gcd(i, l1) == 1 and gcd(i, l2) > 1:
                yield (i + 1) // 2
                l2, l1, b[i] = l1, i, True
                while s in b:
                    b.pop(s)
                    s += 2
                break
            i += 2


def A251415_gen():  # generator of terms
    yield 1
    l1, l2, s, u, l, b = 3, 2, 4, 1, 1, {}
    for n in count(4):
        i = s
        while True:
            if not i in b and gcd(i, l1) == 1 and gcd(i, l2) > 1:
                l2, l1, b[i] = l1, i, 1
                while s in b:
                    b.pop(s)
                    s += 1
                if u * n < i * l:
                    yield i
                    u, l = i, n
                break
            i += 1


def A251554_gen():  # generator of terms
    yield from [1, 2, 5]
    l1, l2, s, b = 5, 2, 3, {5}
    while True:
        i = s
        while True:
            if not i in b and gcd(i, l1) == 1 and gcd(i, l2) > 1:
                yield i
                l2, l1 = l1, i
                b.add(i)
                while s in b:
                    b.remove(s)
                    s += 1
                break
            i += 1


def A251561(n):
    if n == 2:
        return 4
    q, r = divmod(n, 2)
    if r:
        if isprime(n):
            return 2 * n
        return n
    if isprime(q):
        return q
    return n


def A251862_gen(startvalue=0):
    return (n for n in count(max(startvalue, 0)) if pow(-3, n, n + 3) == 3)


def A253051_gen():  # generator of terms
    yield 1
    c, l1, l2, s, b = 1, 2, 1, 3, set()
    while True:
        i = s
        while True:
            if not (i in b or i & l1) and i & l2:
                if i & 1:
                    yield c
                    c = 0
                else:
                    c += 1
                l2, l1 = l1, i
                b.add(i)
                while s in b:
                    b.remove(s)
                    s += 1
                break
            i += 1


def A253147_gen():
    return filter(
        lambda n: n >= 256 and is_pal(intbase(sympydigits(n, 256)[-1:0:-1], 256)),
        pal10_gen(),
    )


def A253148_gen():
    return filter(lambda n: n >= 256 and is_pal(n, 256), pal10_gen())


def A253149_gen():
    return filter(
        lambda n: n >= 256 and isprime(intbase(sympydigits(n, 256)[-1:0:-1], 256)),
        (prime(n) for n in count(1)),
    )


def A254073(n):
    ndict = {}
    for i in range(n):
        m = pow(i, 3, n)
        if m in ndict:
            ndict[m] += 1
        else:
            ndict[m] = 1
    count = 0
    for i in ndict:
        ni = ndict[i]
        for j in ndict:
            k = (1 - i - j) % n
            if k in ndict:
                count += ni * ndict[j] * ndict[k]
    return count


def A254231_gen():  # generator of terms
    yield 1
    a, b, c, d = 0, 0, 1, 1
    while True:
        a, b, c = b, c, a + b + c
        d *= c
        yield d


def A254315(n):
    return len(
        set(
            x
            for l in (
                [d for d in str(p)] + [d for d in str(e) if d != "1"]
                for p, e in factorint(n).items()
            )
            for x in l
        )
    )


def A254756_gen():  # generator of terms
    for n in count(16):
        s = format(n, "x")
        for i in range(1, len(s)):
            if not (is_prime(int(s[i:], 16)) and is_prime(int(s[:-i], 16))):
                break
        else:
            yield n


def A255500(n):
    return (p := prime(n)) ** 4 * (p * (p * (p * (p * (p + 5) + 4) - 1) - 5) + 2) // 6


def A255501(n):
    return n**4 * (n * (n * (n * (n * (n + 5) + 4) - 1) - 5) + 2) // 6


def A256437_gen(startvalue=0):
    (
        i
        for i in count(max(startvalue, 0))
        if str(i**2 + int(str(i)[::-1]) ** 2)
        == str(i**2 + int(str(i)[::-1]) ** 2)[::-1]
    )


def A256481(n):
    if n in (6930, 50358, 56574, 72975):
        return 0
    if n == 0:
        return 2
    sn = str(n)
    for i in count(1):
        for j in range(1, 10, 2):
            si = str(j) * i
            p = int(sn + si)
            if isprime(p):
                return int(p)


def A256967_gen():  # generator of terms
    x, d, f1, f2 = 1, 1, 1, 0
    while True:
        for i in range(f1):
            yield x
            x += d
        d += 1
        f1, f2 = f1 + f2, f1


def A256968_gen():  # generator of terms
    count, bn, bd = 0, 1, 1
    for k in count(1):
        p = prime(k)
        bn *= p
        bd *= p - 1
        while bn >= count * bd:
            yield k
            count += 1


def A257341_gen():  # generator of terms
    m = 2
    for i in count(2):
        for j in range(1, i):
            x = Fraction(j, i)
            if x.denominator == i:
                yield int(m * x) % 2
                m *= 2


def A257552_gen():  # generator of terms
    p = 2
    while True:
        q = p**2 - 2
        if isprime(q):
            r = q**2 - 2
            if isprime(r):
                s = r**2 - 2
                if isprime(s):
                    yield p
        p = nextprime(p)


def A257831(n):
    return int("".join((format(int(d), "b") for d in str(n))))


def A257901_gen(startvalue=1):  # generator of terms
    l = []
    for d in permutations("0123456789", 10):
        if d[0] != "0":
            d2 = int("".join(d))
            if d2 >= startvalue:
                d = d2
                r = d2 % 5
                while not r:
                    d2, r = divmod(d2, 5)
                l.append((d2, d))
    l.sort()
    yield from (b for a, b in l)


def A258103(n):
    """requires 2 <= n <= 62"""
    if n & 1 and (~(m := n - 1 >> 1) & m - 1).bit_length() & 1:
        return 0
    t = "".join(gmpy2digits(d, n) for d in range(n))
    k = mpz("".join(gmpy2digits(d, n) for d in range(n - 1, -1, -1)), n)
    k2 = mpz(t, n)
    c = 0
    start = isqrt(k2)
    end = isqrt(k)
    d = (n * (n - 1) >> 1) % (n - 1)
    for r in sqrt_mod_iter(d, n - 1):
        e = start % (n - 1)
        start2 = start
        if e != r:
            start2 += (r - e) % (n - 1)
        for i in range(start2, end + 1, n - 1):
            j = i**2
            s = "".join(sorted(gmpy2digits(j, n)))
            if s == t:
                c += 1
    return c


def A258774(n):
    return (lambda x: x * (x + 1) + 1)(divisor_sigma(n))


def A260373_gen():  # generator of terms
    yield 1
    g = 1
    for i in count(1):
        g *= i
        s = isqrt(g)
        t = s**2
        return t if g - t - s <= 0 else t + 2 * s + 1


def A260636_gen():  # generator of terms
    b = 3
    for n in count(1):
        yield b % n
        b = b * 3 * (3 * n + 2) * (3 * n + 1) // ((2 * n + 2) * (2 * n + 1))


def A260640_gen():  # generator of terms
    b = 3
    for n in count(1):
        if not b % n:
            yield n
        b = b * 3 * (3 * n + 2) * (3 * n + 1) // ((2 * n + 2) * (2 * n + 1))


def A260674_gen():
    return (p for p in (prime(n) for n in count(1)) if gcd(2**p + 1, 3**p + 1) > 1)


def A261011_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if not n % (lambda x: x[0] + (0 if x[1] else 1))(integer_nthroot(n, 3))
    )


def A261328_gen():  # generator of terms
    bset = set()
    for i in count(1):
        c = i**3
        for d in divisors(c, generator=True):
            d2 = c // d
            if d >= d2:
                m, r = divmod(d + d2, 2)
                if not r:
                    n = m - d2
                    if n > 0 and (m, n) not in bset and is_square(c * m + d2 * n**2):
                        bset.add((m, n))
                        yield m


def A261296_gen():  # generator of terms
    bset = set()
    for i in count(1):
        c = i**3
        for d in divisors(c, generator=True):
            d2 = c // d
            if d >= d2:
                m, r = divmod(d + d2, 2)
                if not r:
                    n = m - d2
                    if n > 0 and (m, n) not in bset and is_square(c * m + d2 * n**2):
                        bset.add((m, n))
                        yield n


def A262069_gen():
    return filter(lambda n: is_pal(n, 60), pal10_gen())


def A264600(n):
    return sorted(str(i)[::-1] for i in range(n + 1)).index(str(n)[::-1])


def A266727_gen():  # generator of terms
    blist = [0, 1, 7]
    bset = set(blist)
    yield from blist
    for i in count(0):
        n, flag = blist[-1] + 1, False
        while True:
            for j in range(i + 2, 0, -1):
                m = 2 * blist[j] - n
                if m in bset:
                    break
                if m < 0:
                    flag = True
                    break
            else:
                blist.append(n)
                bset.add(n)
                yield n
                break
            if flag:
                blist.append(n)
                bset.add(n)
                yield n
                break
            n += 1


def A267310(n):
    m = sum(d * divisor_sigma(d) ** (n // d) for d in divisors(n, generator=True))
    return m // gcd(m, n)


def A267764_gen():
    return (int(d, 4) for d in (str(i**2) for i in range(10**6)) if max(d) < "4")


def A267768_gen():
    return (int(s, 8) for s in (str(i**2) for i in range(10**6)) if max(s) < "8")


def A268383_gen():  # generator of terms
    b = 0
    yield 0
    for i in count(1):
        b += 1 - len(list(filter(bool, format(i, "b").split("0")))) % 2
        yield b


def A268982(n):
    return n // gcd(
        n, sum(d * divisor_sigma(d) ** (n // d) for d in divisors(n, generator=True))
    )


def A269723_gen():  # generator of terms
    blist = [0]
    yield 0
    while True:
        x = blist + [1 - d for d in blist] * 2
        blist += x
        yield from x


def A271901(n):
    p = prime(n)
    i, a, b, c = 1, 1, 1, 2 % p
    while a != 1 or b != 1 or c != 1:
        i += 1
        a, b, c = b, c, (a + c) % p
    return i


def A272670_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if bin(n)[2:] != bin(n)[:1:-1]
        and bin(n)[2:].rstrip("0") == bin(n)[:1:-1].lstrip("0")
    )


def A272680(n):
    if n == 0:
        return 0
    else:
        d, nd = 1, n
        while True:
            x = (isqrt(nd - 1) + 1) ** 2
            if x < nd + d:
                return int(x)
            d *= 2
            nd *= 2


def A272681(n):
    if n == 0:
        return 0
    else:
        d, nd = 1, n
        while True:
            x = (isqrt(nd - 1) + 1) ** 2
            if x < nd + d:
                return int(bin(x)[2:])
            d *= 2
            nd *= 2


def A273190(n):
    return isqrt(2 * n - 1) - isqrt(n - 1) if n > 0 else 0


def A273372_gen():
    return ((10 * n + m) ** 2 for n in count(0) for m in (1, 9))


def A274944_gen():
    return (
        j * 10 ** (i + 1) + 10 * (j**2 + k**2) + k
        for i in count(1)
        for j in range(1, 10)
        for k in range(10)
        if 10 ** (i - 1) <= j**2 + k**2 < 10**i
    )


def A274945_gen():
    return (
        j * 10 ** (i + 1) + 10 * (j**2 + k**2) + k
        for i in count(1)
        for j in range(1, 10)
        for k in range(10)
        if j**2 + k**2 < 10**i
    )


def A274962_gen():
    return chain(
        (2,),
        (
            n
            for n, s in ((d**2, divisor_sigma(d**2)) for d in count(1))
            if isprime(s) and isprime(s + 2)
        ),
    )


def A274963_gen():
    return (
        n
        for n, s in ((d**2, divisor_sigma(d**2)) for d in count(1))
        if isprime(s) and isprime(s - 2)
    )


def A274967_gen(startvalue=3):  # generator of terms
    for n in count(max(startvalue + 1 - startvalue % 2, 3), 2):
        if not isprime(n):
            k = 3
            while k * (k + 1) <= 2 * n:
                if not (2 * (k * (k - 2) + n)) % (k * (k - 1)):
                    break
                k += 1
            else:
                yield n


def A274968_gen(startvalue=4):  # generator of terms
    for n in count(max(startvalue + startvalue % 2, 4), 2):
        k = 3
        while k * (k + 1) <= 2 * n:
            if not (2 * (k * (k - 2) + n)) % (k * (k - 1)):
                break
            k += 1
        else:
            yield n


def A277624_gen(startvalue=2):  # generator of terms
    for n in count(max(startvalue, 2)):
        if not is_prime(n):
            for p in primefactors(n):
                if isqrt(p) * p > n:
                    yield n
                    break


def A279610(n):
    return int(
        "".join(str(d) for d in range((n - 1) * (n - 2) // 2 + 1, n * (n - 1) // 2 + 2))
    )


def A280879_gen():  # generator of terms
    t = 1
    for n in count(1):
        n += 1
        h = totient(n)
        t2 = t + h
        if n % 2 and n % 6 != 3 and 2 * (n * (h * n - 2 * t2 + 1) + t2) < 1:
            yield n
        t = t2


def A286415_gen():  # generator of terms
    for l in count(1):
        for d in "123456789":
            for w in product("1379", repeat=l):
                s = d + "".join(w)
                n = int(s)
                for i in range(l):
                    if not isprime(int(s)):
                        break
                    s = s[-1] + s[:-1]
                else:
                    if not isprime(int(s)):
                        yield n


def A286900(n):
    m = nextprime(n)
    return (m + n) * (m - n + 1) // 2


def A287198_gen(startvalue=2):  # generator of terms
    for n in count(max(startvalue, 2)):
        s = str(n)
        if not is_prime(n) and "0" not in s:
            k = n
            for i in range(len(s) - 1):
                s = s[1:] + s[0]
                m = mpz(s)
                if is_prime(m) or gcd(k, m) > 1:
                    break
                k *= m
            else:
                yield n


def A287653_gen():  # generator of terms
    pq, qr, rs, s = 6, 15, 35, 7
    while True:
        n = pq + qr + rs
        if isprime(n):
            yield n
        t = nextprime(s)
        pq, qr, rs, s = qr, rs, s * t, t


def A296104_gen(startvalue=2):
    return (n for n in count(max(startvalue, 2)) if pow(2, n, n - 1) == 3 % (n - 1))


@lru_cache(maxsize=None)
def A298406(n):
    if n <= 2:
        return 1
    c, j = 2 * A298406(n - 1) - A298406(n - 3), 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * A298406(k1)
        j, k1 = j2, n // j2
    return c + n - j + 1


@lru_cache(maxsize=None)
def A298407(n):
    if n <= 2:
        return n + 1
    c, j = 2 * A298407(n - 1) - A298407(n - 3), 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * A298407(k1)
        j, k1 = j2, n // j2
    return c + 2 * (n - j + 1)


@lru_cache(maxsize=None)
def A298408(n):
    if n <= 2:
        return 1
    c, j = 2 * A298408(n - 1) - A298408(n - 3), 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 * (j2 - 1) - j * (j - 1)) * A298408(k1) // 2
        j, k1 = j2, n // j2
    return c + (n * (n + 1) - j * (j - 1)) // 2


@lru_cache(maxsize=None)
def A298409(n):
    if n <= 2:
        return n + 1
    c, j = 2 * A298409(n - 1) - A298409(n - 3), 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 * (j2 - 1) - j * (j - 1)) * A298409(k1) // 2
        j, k1 = j2, n // j2
    return c + 2 * (n * (n + 1) - j * (j - 1)) // 2


def A300062_gen():  # generator of terms
    yield 1
    s, j = 1, 1
    for i in count(2):
        j, si = j + 1, str(i)
        while si not in str(s + j):
            j += 1
        yield j
        s += j


def A300078(n):
    zr, zc, c = Fraction(0, 1), Fraction(0, 1), 0
    cr, cc = Fraction(-5, 4) - Fraction(1, 10 ** (2 * n)), Fraction(1, 10**n)
    zr2, zc2 = zr**2, zc**2
    while zr2 + zc2 <= 4:
        zr, zc = zr2 - zc2 + cr, 2 * zr * zc + cc
        zr2, zc2 = zr**2, zc**2
        c += 1
    return c


def A301912_gen():  # generator of terms
    n = 0
    for k in count(0):
        if n % 10 ** (len(str(k))) == k:
            yield k
        n += (k + 1) ** 3


def A269266(n):
    return pow(2, n, 31)


def A308194(n):
    c, x = 0, n
    while x != 5:
        d = divisors(x)
        l = len(d)
        x = d[(l - 1) // 2] + d[l // 2]
        c += 1
    return c


def A308736_gen():  # generator of terms
    mlist = [False] * 4
    for n in count(3, 2):
        if mlist[0] and mlist[1] and mlist[2] and mlist[3]:
            yield n
        n += 2
        f = factorint(n + 6)
        mlist = mlist[1:] + [(len(f), sum(f.values())) == (2, 3)]


def A319302_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        for d in split("1+", bin(n)[2:]):
            if isprime(len(d)):
                yield n
                break


def A319419(n):
    s = "".join(
        d[:-1] for d in split("(0+)|(1+)", bin(n)[2:]) if d not in {"", "0", "1", None}
    )
    return -1 if s == "" else int(s, 2)


def A320129(n):
    return (
        1
        if n == 0
        else sum(
            1
            for p in multiset_partitions(list(range(1, 2 * n + 1)), n)
            if max(len(d) for d in p) == 2 and len(set(sum(d) for d in p)) == n
        )
    )


def A320261(n):
    return int(
        "".join(
            "1" + d for d in split("(0+)|(1+)", bin(n)[2:]) if d != "" and d != None
        ),
        2,
    )


def A321294(n):
    return sum(totient(d) * (n // d) ** (n + 1) for d in divisors(n, generator=True))


def A321441(n):
    if n == 0:
        return 1
    c = 0
    for i in range(n):
        mi = n + i * (i + 1) // 2
        for j in range(i, n):
            mj = mi + j * (j + 1) // 2
            for k in range(j + 1, n + 1):
                r = mj - k * k
                if r < 0:
                    break
                if not r % k:
                    c += 1
    return c


def A321536(n):
    return int(
        "".join(
            d + d[0]
            for d in split("(0+)|(1+)|(2+)|(3+)|(4+)|(5+)|(6+)|(7+)|(8+)|(9+)", str(n))
            if d != "" and d != None
        )
    )


def A321537(n):
    return int(
        "0"
        + "".join(
            d[:-1]
            for d in split("(0+)|(1+)|(2+)|(3+)|(4+)|(5+)|(6+)|(7+)|(8+)|(9+)", str(n))
            if d != "" and d != None
        )
    )


def A323711_gen(startvalue=9):
    return (
        n
        for n in count(max(9, startvalue + (9 - startvalue % 9) % 9, 9))
        if sorted(str(n)) == sorted(str(2 * n)) == sorted(str(3 * n))
    )


def A323835(n):
    mset, m, c = set(), n, 0
    while True:
        if m == 0 or m == 1:
            return c
        m = int(
            "0" + "".join(d if str(2 * m).count(d) == 1 else "" for d in str(2 * m))
        )
        if m in mset:
            return -1
        mset.add(m)
        c += 1


def A325230_gen(startvalue=2):
    return (
        n
        for n, m in ((n, factorint(n)) for n in count(max(startvalue, 2)))
        if len(m) == 2 and m[min(m)] == 1
    )


def A327171(n):
    return totient(n) * numbercore(n)


def A328330(n):
    c, m = 1, sum((6, 2, 5, 5, 4, 5, 6, 3, 7, 6)[int(d)] for d in str(n))
    while m != n:
        c += 1
        n, m = m, sum((6, 2, 5, 5, 4, 5, 6, 3, 7, 6)[int(d)] for d in str(m))
    return c


def A331889_T(n, k):
    if k == 1:
        return n * (n + 1) // 2
    if n == 1:
        return int(factorial(k))
    if k == 2:
        return n * (n + 1) * (2 * n + 1) // 3
    nk = n * k
    nktuple = tuple(range(1, nk + 1))
    nkset = set(nktuple)
    count = int(factorial(nk))
    for firsttuple in combinations(nktuple, n):
        nexttupleset = nkset - set(firsttuple)
        for s in permutations(sorted(nexttupleset), nk - 2 * n):
            llist = sorted(nexttupleset - set(s), reverse=True)
            t = list(firsttuple)
            for i in range(0, k - 2):
                itn = i * n
                for j in range(n):
                    t[j] *= s[itn + j]
            t.sort()
            v = 0
            for i in range(n):
                v += llist[i] * t[i]
            if v < count:
                count = v
    return count


def A332300(n):
    x = abs(bernoulli(2 * n).p)
    return 1 if x == 1 else min(primefactors(x))


def A332597(n):
    return (
        8
        if n == 1
        else 4 * (n - 1) * (8 * n - 1)
        + 8 * sum(totient(i) * (n + 1 - i) * (n + i + 1) for i in range(2, n // 2 + 1))
        + 8
        * sum(
            totient(i) * (n + 1 - i) * (2 * n + 2 - i) for i in range(n // 2 + 1, n + 1)
        )
    )


def A332598(n):
    return (
        22 * n - 17
        if n <= 2
        else 4 * (n - 1) * (3 * n - 1)
        + 12 * sum(totient(i) * (n + 1 - i) * i for i in range(2, n // 2 + 1))
        + 4
        * sum(
            totient(i) * (n + 1 - i) * (2 * n + 2 - i) for i in range(n // 2 + 1, n + 1)
        )
    )


def A332612(n):
    return sum(totient(i) * (n - i) * (2 * n - i) for i in range(2, n)) // 2


def A333072(n):
    f = 1
    for i in range(1, n + 1):
        f = lcm(f, i)
    f, glist = int(f), []
    for i in range(1, n + 1):
        glist.append(f // i)
    m = 1 if n < 2 else primorial(n, nth=False) // primorial(n // 2, nth=False)
    k = m
    while True:
        p, ki = 0, k
        for i in range(1, n + 1):
            p = (p + ki * glist[i - 1]) % f
            ki = (k * ki) % f
        if p == 0:
            return k
        k += m


def A333196(n):
    fs = factorint(harmonic(n).q)
    return (
        1
        if len(fs) == 0
        else prod(p ** (fs[p] // n + 1 if fs[p] % n else fs[p] // n) for p in fs)
    )


def A333269_gen(startvalue=1):
    return (n for n in count(max(startvalue, 1)) if n == 1 or pow(17, n, n) == 2)


@lru_cache(maxsize=None)
def A333450(n):
    c, j = 2 * (n + 1) - prime(n), 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * A333450(k1)
        j, k1 = j2, n // j2
    return 2 * j - c


def A333876(n):
    for i in range(n):
        q = 2**n - 1
        for d in multiset_permutations("0" * i + "1" * (n - 1 - i)):
            p = q - int("".join(d), 2)
            if isprime(p):
                return p


def A333877(n):
    for i in range(n - 1, -1, -1):
        q = 2**n - 1
        for d in multiset_permutations("0" * i + "1" * (n - 1 - i)):
            p = q - int("".join(d), 2)
            if isprime(p):
                return p


def A334045(n):
    m = n | (n - 1)
    return 2 ** (len(bin(m)) - 2) - 1 - m


def A334074(n):
    b = comb(2 * n, n)
    return sum(
        Fraction(1, p) for p in range(2, n + 1) if b % p != 0 and isprime(p)
    ).numerator


def A334075(n):
    b = comb(2 * n, n)
    return sum(
        Fraction(1, p) for p in range(2, n + 1) if b % p != 0 and isprime(p)
    ).denominator


def A336018(n):
    return len(bin(n**n // (2 ** ((len(bin(n)) - 3) * n)))) - 3


def A336614(n):
    c = 0
    for d in product((0, 1), repeat=n * n):
        M = Matrix(d).reshape(n, n)
        if M * M == M.T:
            c += 1
    return c


def A337175(n):
    return divisor_count(n) ** 2 // 4


def A337449_gen():  # generator of terms
    p, q = 2, 1
    for k in count(0):
        if p % sum(int(d) for d in str(p)) == 0:
            yield k
        p, q = q, p + q


def A338136(n):
    k, n2, m = 2, n**2, (n + 1) ** 2
    while True:
        nj = n2
        while nj < m:
            r = m % nj
            if r > 1 and is_power(r):
                return k
            nj *= n
        k += 1
        m *= n + 1


def A338267(n):
    p, q, r = prime(n) ** 2, prime(n + 1) ** 2, prime(n + 2) ** 2
    return (isqrt(4 * p * q - (p + q - r) ** 2) + 2) // 4


def A340013(n):
    f = factorial(n)
    return (nextprime(f) - prevprime(f)) // 2


def A340869_gen():  # generator of terms
    plist = [2, 3, 5, 7, 11, 13, 17, 19, 23]
    for k in count(1):
        d = Matrix(plist).reshape(3, 3).det()
        if d >= 0 and integer_nthroot(d, 2)[1]:
            yield k
        plist = plist[1:] + [nextprime(plist[-1])]


def A341319(n):
    return min(
        (d // 2 + 1) * (e // 2 + 1)
        for d, e in ((v, n**2 // v) for v in divisors(n**2) if v <= n)
    )


def A341578(n):
    c = min(
        (d // 2 + 1) * (n**2 // (2 * d) + 1)
        for d in divisors(n**2, generator=True)
        if d <= n
    )
    return c if n % 2 else min(c, (n // 2 + 1) ** 2 - 1)


def A341709(n):
    m, c = 1, 0
    while n > 0:
        n, b = divmod(n, 2)
        c += b * int(str(m)[::-1])
        m *= 2
    return c


def A341721(n):
    return min(
        (d + 2 - (d % 2)) * (e + 2 - (e % 2)) // 4 + int((d % 2) or (e % 2)) - 1
        for d, e in ((v, n // v) for v in divisors(n) if v * v <= n)
    )


def A342023(n):
    f = factorint(n)
    for p in f:
        if p <= f[p]:
            return 1
    return 0


def A342121(n):
    a, b = sorted([n, int(bin(n)[:1:-1], 2)])
    return b % a if n > 0 else 0


def A342122(n):
    return int(bin(n)[:1:-1], 2) % n if n > 0 else 0


def A342123(n):
    return n % int(bin(n)[:1:-1], 2) if n > 0 else 0


def A342126(n):
    s = bin(n)[2:]
    i = s.find("0")
    return n if i == -1 else (2**i - 1) * 2 ** (len(s) - i)


def A342260(n):
    k = 1
    while sympydigits(k**2, n).count(n - 1) != n:
        k += 1
    return k


def A342545(n):
    for a in range(1, n):
        p, q = integer_nthroot(a * n**n, 2)
        if q:
            return p
    l = 1
    while True:
        cmax = n ** (l + n + 1)
        for a in range(1, n):
            c = cmax
            for b in product(range(1, n), repeat=l):
                for d in multiset_permutations((0,) * n + b):
                    p, q = integer_nthroot(reduce(lambda c, y: c * n + y, [a] + d), 2)
                    if q:
                        c = min(c, p)
            if c < cmax:
                return c
        l += 1


def A342950_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        if n % 10:
            m = n
            for p in (2, 3, 5, 7):
                q, r = divmod(m, p)
                while r == 0:
                    m = q
                    q, r = divmod(m, p)
            if m == 1:
                yield n


def A342996(n):
    return partition(primorial(n)) if n > 0 else 1


def A343206(n):
    return sum(stirling(n, i, signed=True) * bernoulli(i) for i in range(n + 1)).p


def A343675_helperf(w):
    for s in w:
        for t in range(int(s[-1]) + 1, 10, 2):
            yield s + str(t)


def A343675_helperg(w):
    for s in w:
        for t in range(1 - int(s[-1]) % 2, int(s[-1]), 2):
            yield s + str(t)


def A343675_gen():  # generator of terms
    yield from [2, 3, 5, 7]
    for l in count(1):
        for d in "1379":
            x = d
            for i in range(1, l + 1):
                x = A343675_helperg(x) if i % 2 else A343675_helperf(x)
            yield from (int(p + p[-2::-1]) for p in x if isprime(int(p + p[-2::-1])))
            y = d
            for i in range(1, l + 1):
                y = A343675_helperf(y) if i % 2 else A343675_helperg(y)
            yield from (int(p + p[-2::-1]) for p in y if isprime(int(p + p[-2::-1])))


def A343676(n):
    c = 0
    for d in "123456789":
        x = d
        for i in range(1, n):
            x = A343675_helperg(x) if i % 2 else A343675_helperf(x)
        c += sum(1 for p in x if isprime(int(p)))
        if n > 1:
            y = d
            for i in range(1, n):
                y = A343675_helperf(y) if i % 2 else A343675_helperg(y)
            c += sum(1 for p in y if isprime(int(p)))
    return c


def A343677(n):
    if n == 0:
        return 4
    c = 0
    for d in "1379":
        x = d
        for i in range(1, n + 1):
            x = A343675_helperg(x) if i % 2 else A343675_helperf(x)
        c += sum(1 for p in x if isprime(int(p + p[-2::-1])))
        y = d
        for i in range(1, n + 1):
            y = A343675_helperf(y) if i % 2 else A343675_helperg(y)
        c += sum(1 for p in y if isprime(int(p + p[-2::-1])))
    return c


def A343999(n):
    fs = factorint(2 * n)
    plist = [p ** fs[p] for p in fs]
    return int(
        min(
            k
            for k in (crt(plist, d)[0] for d in product([0, -1], repeat=len(plist)))
            if k > 0
        )
        % 2
    )


def A344589(n):
    m = A011772(n)
    return sum(1 for d in divisors(n) if A011772(d) < m)


def A345419(n):
    return igcdex(3, prime(n))[0]


def A345423(n):
    return sum(
        u
        for u, v, w in (igcdex(x, y) for x in range(1, n + 1) for y in range(1, n + 1))
        if w == 1
    )


def A345424(n):
    return sum(
        v
        for u, v, w in (igcdex(x, y) for x in range(1, n + 1) for y in range(1, n + 1))
        if w == 1
    )


def A345425(n):
    return sum(
        u + v
        for u, v, w in (igcdex(x, y) for x in range(1, n + 1) for y in range(1, n + 1))
        if w == 1
    )


def A345426(n):
    return sum(
        u
        for u, v, w in (igcdex(x, y) for x in range(1, n + 1) for y in range(1, n + 1))
    )


def A345430(n):
    return sum(
        abs(v)
        for u, v, w in (igcdex(x, y) for x in range(1, n + 1) for y in range(1, n + 1))
        if w == 1
    )


def A345431(n):
    return sum(
        u**2 + v**2
        for u, v, w in (igcdex(x, y) for x in range(1, n + 1) for y in range(1, n + 1))
        if w == 1
    )


def A345432(n):
    return sum(
        abs(u)
        for u, v, w in (igcdex(x, y) for x in range(1, n + 1) for y in range(1, n + 1))
    )


def A345695(n):
    zlist = [
        z
        for z in (igcdex(x, y) for x in range(1, n + 1) for y in range(1, n + 1))
        if z[2] == 1
    ]
    return pvariance(len(zlist) * abs(v) for u, v, w in zlist)


def A344005(n):
    if n == 1:
        return 1
    plist = tuple(p**q for p, q in factorint(n).items())
    return (
        n - 1
        if len(plist) == 1
        else int(
            min(
                min(crt((m, n // m), (0, -1))[0], crt((n // m, m), (0, -1))[0])
                for m in (
                    prod(d)
                    for l in range(1, len(plist) // 2 + 1)
                    for d in combinations(plist, l)
                )
            )
        )
    )


def A346598(n):
    return sum(1 for m in range(1, n * (n + 1) + 1) if A344005(m) == n)


def A346622(n):
    return (
        0
        if n <= 2
        else A346622(n - 1) + (1 if n % 2 and len(primefactors(n)) == 2 else 0)
    )


def A346623(n):
    return (
        0
        if n <= 2
        else A346623(n - 1) + (n if n % 2 and len(primefactors(n)) == 2 else 0)
    )


def A346942_gen():
    return (
        100 * n
        for n in count(99)
        if n % 10 and (lambda x: x[0] == x[1] == x[2] == x[3] != x[4])(str(n**2))
    )


def A347308_gen():  # generator of terms
    yield 1
    nset, m, c, j, i = {1}, 2, 0, 2, 1
    while True:
        i += 1
        k = m
        while k == j or gcd(k, j) == 1 or k in nset:
            k += 1
        if k > c:
            c = k
            yield i
        j = k + 1
        nset.add(k)
        while m in nset:
            m += 1


def A347319(n):
    return n * (n**2 * (2 * n - 3) + 3) + 1


def A350518(n):
    q = 2
    while True:
        a, b = integer_nthroot(q * (n + 1) - n, 2)
        if b and isprime(a):
            return q
        q = nextprime(q)


def A350517(n):
    p = 2
    while True:
        a, b = divmod(p**2 + n, n + 1)
        if not b and isprime(a):
            return p
        p = nextprime(p)


def A347755_gen():  # generator of terms
    yield 1
    nset, m, j = {1}, 2, 2
    while True:
        k = m
        while k == j or gcd(k, j) == 1 or k in nset:
            k += 1
        j = k + 1
        nset.add(k)
        yield m
        while m in nset:
            m += 1


def A347757_gen():  # generator of terms
    yield 1
    nset, m, j, i = {1}, 2, 2, 1
    while True:
        i += 1
        k = m
        while k == j or gcd(k, j) == 1 or k in nset:
            k += 1
        j = k + 1
        nset.add(k)
        if k == m:
            yield i
        while m in nset:
            m += 1


def A348295(n):
    return sum(-1 if (isqrt(2 * k * k) - k) % 2 else 1 for k in range(1, n + 1))


def A349190_gen():
    return filter(lambda n: prod(accumulate(int(d) for d in str(n))) == n, count(1))


def A004287(n):
    if n > 0:
        for i in range(1, 2**n):
            s = bin(i)[2:]
            if not int(s, 7) % n:
                return int(s)
    return 0


def A004288(n):
    if n > 0:
        for i in range(1, 2**n):
            s = bin(i)[2:]
            if not int(s, 8) % n:
                return int(s)
    return 0


def A010338_gen():
    (
        n
        for n, s in ((i, continued_fraction_periodic(0, 1, i)[-1]) for i in count(1))
        if isinstance(s, list) and len(s) == 7
    )


def A010902_gen():  # generator of terms
    a, b = 14, 23
    yield from [a, b]
    while True:
        c, d = divmod(b**2, a)
        a, b = b, c + (0 if 2 * d < a else 1)
        yield b


def A015945_gen(startvalue=2):
    return (
        n
        for n in count(max(startvalue + startvalue % 2, 2), 2)
        if pow(2, n, n) == n // 2 - 1
    )


def A023273_gen():
    return (
        p
        for p in (prime(n) for n in count(1))
        if isprime(2 * p + 3) and isprime(4 * p + 9) and isprime(8 * p + 21)
    )


def A023804_gen():
    return filter(
        lambda n: len(set(s := gmpy2digits(n, 9))) == len(s), range(0, 381367045)
    )


def A027580_gen():  # generator of terms
    for i in count(1, 2):
        s = str(5 * (i * (i + 4) + 6))
        if s == s[::-1]:
            yield int(s)


def A029735_gen():  # generator of terms
    j = 0
    for i in count(0):
        s = format(j, "x")
        if s == s[::-1]:
            yield i
        j += 3 * i * (i + 1) + 1


def A029736_gen():  # generator of terms
    j = 0
    for i in count(0):
        s = format(j, "x")
        if s == s[::-1]:
            yield j
        j += 3 * i * (i + 1) + 1


def A030688(n):
    d, nd = 10, 10 * n**2
    while True:
        x = isqrt(nd - 1) + 1
        if not x % 10:
            x += 1
        x = x**2
        if x < nd + d:
            return x
        d *= 10
        nd *= 10


def A030697(n):
    d, nd = 10, 10 * n**3
    while True:
        x = integer_nthroot(nd - 1, 3)[0] + 1
        if not x % 10:
            x += 1
        x = x**3
        if x < nd + d:
            return x
        d *= 10
        nd *= 10


def A031598_gen():
    return (
        n
        for n, s in ((i, continued_fraction_periodic(0, 1, i)[-1]) for i in count(1))
        if isinstance(s, list) and len(s) % 2 == 0 and s[len(s) // 2 - 1] == 100
    )


def A031997_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue + 1 - startvalue % 2, 1), 2)
        if max(str(n**3)) <= "3"
    )


def A033861_gen():  # generator of terms
    x = 316
    while True:
        yield x
        x += int("".join(sorted(str(x))))


def A034874_gen():  # generator of terms
    a = 1
    for n in count(2):
        yield a
        a = n * int(str(a)[::-1])


def A035057_gen(startvalue=1):
    return (n for n in count(max(startvalue, 1)) if "1" not in str(2**n))


def A036433_gen(startvalue=1):  # generator of terms
    for i in count(max(startvalue, 1)):
        d = divisor_count(i)
        if d < 10 and str(d) in str(i):
            yield i


def A037255(n):
    return n * (n * (n * (n - 2) + 7) + 2) // 8


def A048055(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        s = sum(divisors(n))
        if not s % 2 and 2 * n <= s and (s - 2 * n) / 2 == sum(primefactors(n)):
            yield n


def A048335_gen():
    return chain((0,), (int(d * l, 11) for l in count(1) for d in "123456789a"))


def A048336_gen():
    return chain((0,), (int(d * l, 12) for l in count(1) for d in "123456789ab"))


def A048337_gen():
    return chain((0,), (int(d * l, 13) for l in count(1) for d in "123456789abc"))


def A048338_gen():
    return chain((0,), (int(d * l, 14) for l in count(1) for d in "123456789abcd"))


def A048339_gen():
    return chain((0,), (int(d * l, 15) for l in count(1) for d in "123456789abcde"))


def A048889_gen():
    return (
        m
        for m in (
            int(e + "".join(d))
            for l in count(1)
            for e in "1689"
            for d in product("01689", repeat=l)
        )
        if m % 10
        and not isprime(m)
        and isprime(int(str(m)[::-1].translate("".maketrans("69", "96"))))
    )


def A051640(n):
    m = 0
    while True:
        for b in range(2, n + 1):
            if b - 1 not in sympydigits(m, b)[1:]:
                break
        else:
            return m
        m += 1


def A052191(n):
    k = 0
    while True:
        k += n
        x = split("(0+|1+|2+|3+|4+|5+|6+|7+|8+|9+)", str(k))
        for d in x:
            if len(d) == 1:
                break
        else:
            return k


def A053547(n):
    s = int("".join(str(m) for m in range(n, 0, -1)))
    for i in count(1):
        s *= 10
        for j in range(1, 10**i, 2):
            x = s + j
            if isprime(x):
                return x


def A055227(n):
    return s if (f := factorial(n)) - (s := isqrt(f)) * (s + 1) <= 0 else s + 1


def A055227_gen():  # generator of terms
    yield 1
    g = 1
    for i in count(1):
        g *= i
        s = isqrt(g)
        yield s if g - s * (s + 1) <= 0 else s + 1


def A056825_gen():  # generator of terms
    nset = set()
    for n in count(1):
        cf = continued_fraction_periodic(0, 1, n)
        if len(cf) > 1:
            pal = tuple(cf[1][:-1])
            if pal not in nset:
                yield n
                nset.add(pal)


def A057683_gen(startvalue=0):
    return (
        n
        for n in count(max(startvalue, 0))
        if isprime(n**2 + n + 1) and isprime(n**3 + n + 1) and isprime(n**4 + n + 1)
    )


def A059000_gen():  # generator of terms
    for i in count(0):
        if i % 10:
            p = int(str(i**5)[::-1])
            if isprime(p):
                yield p


def A060474(n):
    return (n + 1) // gcd(n + 1, totient(n))


def A062936_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        s = str(n * int(str(n)[::-1]))
        if s == s[::-1]:
            yield n


def A063569(n):
    m, k, s = 1, 6, str(n)
    while s not in str(k):
        m += 1
        k *= 6
    return m


def A063570(n):
    m, k, s = 1, 7, str(n)
    while s not in str(k):
        m += 1
        k *= 7
    return m


def A065914(n):
    pm = primorial(n)
    return primepi(3 * pm // 2 - 1) - primepi(pm // 2 - 1)


def A066713(n):
    m = 2**n
    return int("".join(sorted(str(m + int(str(m)[::-1])))))


def A067770_gen():  # generator of terms
    yield from [1, 1]
    c = 1
    for n in count(2):
        c = c * (4 * n - 2) // (n + 1)
        yield c % (n + 2)


def A071837_gen(startvalue=2):  # generator of terms
    for n in count(max(startvalue, 2)):
        fp, fe = zip(*factorint(n).items())
        if sum(fp) == sum(fe) and isprime(sum(fe)) and all([isprime(e) for e in fe]):
            yield n


def A073931_gen(startvalue=1):
    return filter(lambda n: antidivisor_sigma(n) == 2 * n, count(max(startvalue, 1)))


def A076634(n):
    y = Poly(prod(2 * symbolx + i for i in range(1, n + 1))).all_coeffs()[::-1]
    return y.index(max(y))


def A077441(n):
    if n > 0:
        k = 0
        while True:
            m = k
            for i in range(n):
                s = gmpy2digits(m, 4)
                if s == s[::-1]:
                    break
                m += int(s[::-1], 4)
            else:
                s = gmpy2digits(m, 4)
                if s == s[::-1]:
                    return k
            k += 1
    else:
        return 0


def A078266(n):
    s = "".join(str(i) for i in range(1, n + 1))
    return sum(int(d) for d in s) * (10 ** len(s) - 1) // (9 * len(s))


def A083178(n):
    return (
        1
        if n == 1
        else (2 * 10 ** ((n + 2) // 3) + (63 * (n % 3) ** 2 - 129 * (n % 3) - 2)) // 6
    )


def A083289(n):
    a, b = divmod(n, 2)
    c, d = 10**n, 10**a
    if b == 0:
        return nextprime(d) ** 2 - c
    k = 0
    while True:
        fs = factorint(c + k, multiple=True)
        if len(fs) == 2 and min(fs) >= d:
            return k
        k += 1


def A085647_gen(startvalue=2):
    return filter(
        lambda n: len(f := factorint(n)) == 2 == sum(f.values())
        and len(str((s := list(f.keys()))[0])) == len(str(s[1])),
        count(max(startvalue, 2)),
    )


def A087304(n):
    i, p = 2, prod(int(d) for d in str(n) if d != "0")
    while (max(str(i)) == "1" and str(i).count("1") == 1) or prod(
        int(d) for d in str(i * n) if d != "0"
    ) != p:
        i += 1
    return i * n


def A090392(n):
    return n * (n * (n * (n * (n * (n + 45) + 925) + 11475) + 92314) + 413640) // 720


def A090393(n):
    return (
        n
        * (
            n * (n * (n * (n * (n * (n + 63) + 1855) + 34125) + 438424) + 3980172)
            + 20946960
        )
        // 5040
    )


def A090394(n):
    return (
        n
        * (
            n
            * (
                n * (n * (n * (n * (n * (n + 84) + 3346) + 84840) + 1550689) + 21632436)
                + 224782284
            )
            + 1377648720
        )
        // 40320
    )


def A092679_gen(startvalue=0):
    return filter(lambda k: antidivisor_count(3 * 2**k) == 1, count(max(startvalue, 0)))


def A092680_gen():
    return filter(lambda n: antidivisor_count(n) == 1, (3 * 2**k for k in count(0)))


def A096357(n):
    return lcm(*antidivisors(n, generator=True))


def A097228_gen():
    return chain(
        (27, 38),
        (1000 * (10**k - 1) // 9 + d for k in count(0) for d in (127, 138, 289, 298)),
    )


def A104174(n):
    return (lambda x: x.p % x.q)(harmonic(n))


def A109350_gen(startvalue=3):
    return filter(lambda n: isprime(antidivisor_sigma(n)), count(max(startvalue, 3)))


def A110068_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if nextprime(10 ** (n - 1)) - 10 ** (n - 1) == primepi(n)
    )


def A113484(n):
    for k in count(n + 1):
        if gcd(k, n) == 1 and not isprime(k):
            return k


def A116988(n):
    return sum(int(d) for d in str(factorial(10**n)))


def A117057_gen():
    return filter(
        lambda p: "0" not in (s := str(p)) and p % prod(int(d) for d in s) == 0,
        pal10_gen(),
    )


def A349325(n):
    x, c, n2, n3 = n, 1, 2 * n, 3 * n
    while x > 1:
        if x % 2:
            c += int(n3 > 3 * x >= n2)
            x = (3 * x + 1) // 2
        else:
            c += int(n < x < n2)
            x //= 2
    return c


def A350514(n):
    return (
        1
        if n == 0
        else max(
            prod(1 - symbolx ** prime(i) for i in range(1, n + 1)).as_poly().coeffs()
        )
    )


def A117769_gen():  # generator of terms
    a, b = 2, 1
    for i in count(0):
        if prod(int(d) for d in str(b)) in {0, 1, 2, 3, 5, 8, 21, 144}:
            yield b
        a, b = b, a + b


def A117770_gen():  # generator of terms
    yield 0
    a, b = 1, 1
    for i in count(0):
        if prod(int(d) for d in str(b)) in {0, 1, 2, 3, 5, 8, 21, 144}:
            yield b
        a, b = b, a + b


def A350278(n):
    for m in count(1):
        if A349325(m) == n:
            return m


def A350277_gen():  # generator of terms
    c = 0
    for n in count(1):
        m = A349325(n)
        if m > c:
            yield n
            c = m


def A127741_gen():  # generator of terms
    blist, b = [1], 1
    for n in count(1):
        blist = list(accumulate([b] + blist))
        b = blist[-1]
        yield blist[-2] * n


def A128437(n):
    return harmonic(n).p // n


def A132174(n):
    if n == 1:
        return 1
    if n == 2:
        return 5
    h, m = divmod(n - 3, 5)
    return (
        (382 * 2 ** (5 * h + m) - 10 * 2**m) // 31
        - 7 * h
        - m
        - (1 if m == 3 else (-1 if m == 4 else 2))
    )


def A136845_gen():  # generator of terms
    yield from [0, 1]
    for l in count(0):
        for a in ("1", "3", "5", "8"):
            for b in product("01358", repeat=l):
                for c in ("0", "1", "5"):
                    n = int("".join([a] + list(b) + [c]))
                    if set(str(n * n)) <= {"0", "1", "3", "5", "8"}:
                        yield n


def A137146_gen():
    return (
        n
        for n in (
            int("".join(d)) for l in range(1, 6) for d in product("5678", repeat=l)
        )
        if set(str(n**2)) <= set("5678")
    )


def A137401(n):
    ndict = {}
    for i in range(1, n):
        m = pow(i, 3, n)
        if m in ndict:
            ndict[m] += 1
        else:
            ndict[m] = 1
    count = 0
    for i in ndict:
        ni = ndict[i]
        for j in ndict:
            k = (i + j) % n
            if k in ndict:
                count += ni * ndict[j] * ndict[k]
    return count


def A138091_gen():  # generator of terms
    m = [
        6227020800,
        44068147200,
        181142438400,
        564307430400,
        1475073815040,
        3408641107200,
        7182564530400,
        14081919023520,
        26048741640120,
        45924510262992,
        77755456075656,
        127171611204708,
        201851662963039,
        312086923782438,
    ]
    for n in count(1):
        for i in range(13):
            m[i + 1] += m[i]
        if isprime(m[-1]):
            yield n


def A141263_gen():  # generator of terms
    p = 1
    while True:
        p = nextprime(p)
        ps = int(str(p)[::-1])
        if p <= ps and isprime(ps):
            yield p


@lru_cache(maxsize=None)
def A143443(n):
    if n == 0:
        return 0
    c, j = n, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * A143443(k1) // k1
        j, k1 = j2, n // j2
    return n * (j - c)


def A145643(n):
    return (
        1
        if n <= 1
        else prod(p ** (e % 3) for p, e in factorint(prod(range(n, 0, -2))).items())
    )


def A155148_gen():  # generator of terms
    m = [24, -36, 14, -1, 0]
    for n in count(1):
        for i in range(4):
            m[i + 1] += m[i]
        if len(set(str(m[-1]))) == 2:
            yield n


def A155149_gen(startvalue=1):
    return (n for n in count(max(startvalue, 1)) if len(set(str(n**4))) == 3)


def A156200_gen():
    return (
        int("".join(d))
        for l in count(4)
        for d in product("0689", repeat=l)
        if d[0] != "0" and len(set(d)) == 4 and is_prime(int("".join(d)))
    )


def A157712(n):
    if n == 1:
        return 11
    if n == 2:
        return 0
    p = prime(n)
    l = p
    while True:
        for i in combinations(range(l), l - p):
            s = ["1"] * l
            for x in i:
                s[x] = "0"
            q = int("".join(s))
            if isprime(q):
                return q
        l += 1


def A158214_gen():  # generator of terms
    for i in count(2):
        if i % 6 == 1 or i % 6 == 5:
            i2 = i // 2
            l = i2
            flag = True
            while flag:
                dlist = "0" * (l - i2) + "1" * i2
                for d in multiset_permutations(dlist):
                    s = "".join(d)
                    n = int(s + "1" + s[::-1])
                    if isprime(n):
                        yield n
                        flag = False
                        break
                else:
                    l += 1


def A161502(n):
    s = bin(n)[2:]
    if s == s[::-1]:
        return 0
    for i in range(1, len(s)):
        if s[i:] == s[-1 : i - 1 : -1]:
            return i


def A161721_gen(startvalue=2):
    p = max(nextprime(startvalue - 1), 2)
    while True:
        q = int(str(p)[::-1])
        if is_pal(p * q) and isprime(q):
            yield p
        p = nextprime(p)


def A162555_gen():  # generator of terms
    bset, s = set(), 0
    for i in count(1):
        j, si = 1, str(i)
        while si not in str(s + j) or j in bset:
            j += 1
        yield j
        bset.add(j)
        s += j


@lru_cache(maxsize=None)
def A162943(n):
    if n == 0:
        return 2
    c, j = n, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * (4 - len(bin(A162943(k1))))
        j, k1 = j2, n // j2
    return 2 ** (1 + c - j)


def A163498_gen():
    return (
        prime(n) for n in count(1) if isprime(int(bin(prime(n)).replace("1", "01"), 2))
    )


def A163499_gen():
    return (
        int(bin(prime(n)).replace("1", "01"), 2)
        for n in count(1)
        if isprime(int(bin(prime(n)).replace("1", "01"), 2))
    )


def A173207_gen():  # generator of terms
    a, b = 1, 2
    while True:
        if max(factorint(b).values()) == 2:
            yield b
        a, b = b, a + b


def A175017_gen(startvalue=2):  # generator of terms
    p = max(nextprime(startvalue - 1), 2)
    while True:
        s = str(p)
        if "13" in s and sum(int(d) for d in s) == 13:
            yield p
        p = nextprime(p)


def A175345_gen():  # generator of terms
    (c,) = 1
    for k in count(1):
        if is_square(c):
            yield k
        c += divisor_count(k)


def A180481(n):
    p = prime(n)
    q = nextprime(p)
    while True:
        if (
            isprime(p * (q - p) + q)
            and isprime(p * (q - p) - q)
            and isprime(q * (q - p) + p)
            and isprime(q * (q - p) - p)
        ):
            return q
        n += 1
        q = nextprime(q)


def A180484_gen():
    return (
        int(n)
        for n in (str(x) for x in count(1))
        if not (n.count("0") or int(n) ** 2 * len(n) % prod(int(d) for d in n) ** 2)
    )


def A181373(n):
    if n == 1 or n == 3:
        return 0
    p, c, q, a, b = prime(n), 0, 1, 10, 10
    for m in count(1):
        if m >= b:
            a = 10 * a % p
            b *= 10
        c = (c * a + m) % p
        q = q * a % p
        if not (c or (q - 1) % p):
            return m


def A186774(n):
    if sum(int(d) for d in str(n)) == 1:
        return 0
    sn, k = str(n + 1), 1
    while sn not in str(k):
        k *= n
    return k


def A187394(n):
    return 4 * n - 1 - isqrt(8 * n**2)


def A188061_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if pow(
            isqrt(n) if is_square(n) else n,
            int(divisor_sigma(n, 0)) // (1 if is_square(n) else 2),
            int(divisor_sigma(n, 1)),
        )
        == 1
    )


def A188082(n):
    return isqrt(3 * (n + 1) ** 2) - isqrt(3 * n**2) - 1


def A192273_gen(startvalue=3):  # generator of terms
    for n in count(max(startvalue, 3)):
        d = antidivisors(n)
        s = sum(d)
        if not s % 2 and max(d) <= s // 2:
            for x in range(1, 2 ** len(d)):
                if sum(Subset.unrank_binary(x, d).subset) == s // 2:
                    yield n
                    break


def A194152(n):
    return 5 * n + isqrt(20 * n**2)


def A198244_gen():  # generator of terms
    m = [
        3628800,
        -15966720,
        28828800,
        -27442800,
        14707440,
        -4379760,
        665808,
        -42240,
        682,
        0,
        1,
    ]
    for n in count(1):
        for i in range(10):
            m[i + 1] += m[i]
        if not isprime(n) and isprime(m[-1]):
            yield m[-1]


def A199303_gen():
    return (
        n
        for n in (
            int(t + "".join(s))
            for l in count(0)
            for t in "13"
            for s in product("013", repeat=l)
        )
        if isprime(n) and isprime(int(str(n)[::-1]))
    )


def A199328_gen():
    return (
        n
        for n in (
            int(t + "".join(s))
            for l in count(0)
            for t in "18"
            for s in product("018", repeat=l)
        )
        if isprime(n) and isprime(int(str(n)[::-1]))
    )


def A199302_gen():
    return (
        n
        for n in (
            int(t + "".join(s))
            for l in count(0)
            for t in "12"
            for s in product("012", repeat=l)
        )
        if isprime(n) and isprime(int(str(n)[::-1]))
    )


def A349862(n):
    return max(comb(n - 2 * k, k) for k in range(n // 3 + 1))


def A210698(n):
    if n % 3 == 0:
        return 11 * n**4 // 27
    elif n % 3 == 1:
        return (11 * n**4 - 8 * n**3 + 6 * n**2 + 4 * n + 14) // 27
    else:
        return (11 * n**4 - 16 * n**3 + 24 * n**2 + 32 * n + 8) // 27


def A211071(n):
    if n % 3 == 0:
        return 8 * n**4 // 27
    elif n % 3 == 1:
        return (8 * n**4 + 4 * n**3 - 3 * n**2 - 2 * n - 7) // 27
    else:
        return (8 * n**4 + 8 * n**3 - 12 * n**2 - 16 * n - 4) // 27


def A213239_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if sum(
            sum(int(x) for x in str(d))
            for d in range(2, n)
            if n % d and 2 * n % d in [d - 1, 0, 1]
        )
        == sum(int(x) for x in str(n))
    )


def A350473(n):
    return fibonacci(n + 1) ** 3 - fibonacci(n - 1) ** 3


def A214648_gen():  # generator of terms
    s, c, d = 0, 0, -1
    while True:
        k = 2
        q = 4 * (k * (k * (k + c) + d)) // 3 + 1
        while not is_square(q):
            k += 1
            q = 4 * (k * (k * (k + c) + d)) // 3 + 1
        yield k
        s += k
        c, d = 3 * s, 3 * s**2 - 1


def A214697(n):
    k, a1, a2, m = 2, 36 * n, 36 * n**2 - 12, n * (72 * n + 144) + 81
    while int(round(sqrt(m))) ** 2 != m:
        k += 1
        m = k * (k * (12 * k + a1) + a2) + 9
    return k


def A216394(n):
    if n == 1:
        return 1
    c = 0
    for i in range(2 ** (n - 1) + 1, 2**n):
        s1, s2 = sorted(str(i)), sorted(str(totient(i)))
        if len(s1) == len(s2) and s1 == s2:
            c += 1
    return c


def A217175(n):
    if n == 1:
        return 0
    else:
        l, y, x = [str(d) * n for d in range(10)], 0, 1
        for m in count(1):
            s = str(x)
            for k in range(10):
                if l[k] in s:
                    return k
            y, x = x, y + x


def A217176(n):
    if n == 1:
        return 2
    else:
        l, y, x = [str(d) * n for d in range(10)], 2, 1
        for m in count(1):
            s = str(x)
            for k in range(10):
                if l[k] in s:
                    return k
            y, x = x, y + x


def A218035(n):
    return (
        4
        if n == 1
        else (
            (n**3 - 9 * n**2 + 59 * n - 3) // 24
            if n % 2
            else (n**3 - 6 * n**2 + 32 * n + 48) // 48
        )
    )


def A343098(n):
    return (
        1
        if n == 0
        else (
            n * (n * (n * (6 * n - 52) + 510) + 904)
            + 1491
            + (-1 if n % 2 else 1) * (n * (n * (42 - 4 * n) - 296) + 45)
        )
        // 768
    )


def A224252_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if n != int(str(n)[::-1])
        and primefactors(n) == primefactors(int(str(n)[::-1]))
        and sorted(factorint(n).values())
        == sorted(factorint(int(str(n)[::-1])).values())
    )


def A253631_gen():
    return filter(
        lambda n: isprime(n) and is_pal(n**2), (int(bin(m)[2:]) for m in pal_gen(b=2))
    )


def A227491(n):
    return (
        2**n * (2**n * (526338 * n**2 - 2685555 * n + 4790367) - 5719932) // 8 + 116340
    )


def A229134_gen():  # generator of terms
    for i in count(0):
        m, m2, j, k = 2, 4, 4 * i**2 + 1, 2 * i**2
        while k >= m2 + m:
            if is_square(j - m2):
                yield i**2
                break
            m2 += 2 * m + 1
            m += 1


def A229972_gen(startvalue=1):
    return (
        i
        for i in count(max(startvalue, 1))
        if not isprime(i) and (integer_nthroot(i, 3)[1] or divisor_count(i) % 3 == 2)
    )


def A236359_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        d = divisors(n)
        d.pop()
        ld = len(d)
        if sum(d) >= n:
            s, j = d[0], 1
            for i in range(ld - 1):
                while s < n and j < ld:
                    s += d[j]
                    j += 1
                if s == n:
                    yield n
                    break
                j -= 1
                s -= d[i] + d[j]


def A236513(n):
    l, k, c = n - 1, 2**n, 0
    while True:
        for d in combinations(range(l - 1, -1, -1), l - n + 1):
            m = k - 1 - sum(2 ** (e) for e in d)
            if isprime(m):
                c += 1
                if c == n:
                    return m
        l += 1
        k *= 2


def A240924_gen():
    return (1 + (n * n - 1) % 9 for n in count(1, 2) if n % 3 and n % 5)


def A240983_gen():
    (2**p * p * p for p in (prime(n) for n in count(1)) if isprime(p + 2))


def A241989_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if not n % sum(int(d, 16) for d in hex(n)[2:])
    )


def A242018_gen():  # generator of terms
    blist = [0, 0, 1]
    yield from blist
    while True:
        x = blist[len(blist) // 2 :]
        yield from x
        blist += x


def A242107_gen():  # generator of terms
    blist = [0, 1, 1, 1, 1, -1]
    yield from blist
    for n in count(6):
        blist = blist[1:] + [
            (-blist[-1] * blist[-4] + blist[-2] * blist[-3]) // blist[-5]
        ]
        yield blist[-1]


def A242108_gen():
    return (abs(n) for n in A242107_gen())


def A243102_gen(startvalue=1):
    return (
        int(n)
        for n in (str(x) for x in count(max(startvalue, 1)))
        if not n.count("0")
        and sorted(str(int(n) + prod(int(d) for d in n))) == sorted(n)
    )


def A243318_gen():  # generator of terms
    m = [
        3628800,
        -16692480,
        31651200,
        -31827600,
        18163440,
        -5826240,
        971232,
        -69720,
        1362,
        -2,
        -1,
    ]
    for n in count(1):
        for i in range(10):
            m[i + 1] += m[i]
        if isprime(m[-1]):
            yield n


def A244423_gen():
    return filter(
        lambda p: not isprime(p) and is_pal(divisor_prod(p)), islice(pal_gen(), 1, None)
    )


def A244428_gen(startvalue=1):
    return (
        i
        for i in count(max(startvalue, 1))
        if (integer_nthroot(i, 3)[1] or not divisor_sigma(i, 0) % 3)
        and integer_nthroot(int(divisor_sigma(i, 1)), 3)[1]
    )


def A007955(n):
    return divisor_prod(n)


def A244466_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if n == 1
        or (
            not isprime(n)
            and max(factorint(totient(n)).values()) < 2
            and (-1) ** len(primefactors(totient(n))) == 1
        )
    )


def A244551_gen():  # generator of terms
    for p in pal_gen():
        l = len(str(p))
        for i in range(1, l * 9 + 1):
            n = p - i
            if n > 0:
                if sum((int(d) for d in str(n))) == i:
                    s = str(n - i)
                    if s == s[::-1]:
                        yield n


def A244915_gen():  # generator of terms
    yield 1
    bset, c = set(), 1
    while True:
        a, b = 1, 1 + c**2
        while not isprime(b) or b in bset:
            b += 2 * a + 1
            a += 1
        bset.add(b)
        yield a
        c = a


def A244959(n):
    if n > 0:
        for i in range(1, 2**n):
            x = int(bin(i)[2:], 8)
            if not x % n:
                return x
    return 0


def A245042_gen():
    return filter(isprime, ((k**2 + 4) // 5 for k in count(0) if (k**2 + 4) % 5 == 0))


def A245045_gen():
    return filter(isprime, ((k**2 + 2) // 6 for k in count(0) if (k**2 + 2) % 6 == 0))


def A245085(n):
    p, f, fv = prime(n), 1, {}
    for i in range(2, p):
        f = (f * i) % p
        if f in fv:
            return i - 1
        else:
            fv[f] = i
    return p - 1


def A245644_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if not sum(divisors(n**3)) % divisor_count(n**3)
    )


def A245763_gen():
    return (
        int(n)
        for n in (str(prime(x)) for x in count(1))
        if isprime(int(str(sum(int(d) for d in n)) + n))
        and isprime(int(n + str(sum(int(d) for d in n))))
    )


def A245909(n):
    return len(primefactors(prime(n) ** 3 - 1))


def A246135_gen():  # generator of terms
    blist = []
    for n in range(1, 9):
        for m in range(n - 1, -1, -1):
            l = "".join(str(d) for d in range(n, m - 1, -1))
            p = int(l + l[-2::-1], 9)
            if isprime(p):
                blist.append(p)
        for m in range(n + 1, 9):
            l = "".join(str(d) for d in range(n, m + 1))
            p = int(l + l[-2::-1], 9)
            if isprime(p):
                blist.append(p)
    yield from sorted(blist)


def A246136_gen():  # generator of terms
    blist = []
    for n in range(1, 8):
        for m in range(n - 1, -1, -1):
            l = "".join(str(d) for d in range(n, m - 1, -1))
            p = int(l + l[-2::-1], 8)
            if isprime(p):
                blist.append(p)
        for m in range(n + 1, 8):
            l = "".join(str(d) for d in range(n, m + 1))
            p = int(l + l[-2::-1], 8)
            if isprime(p):
                blist.append(p)
    yield from sorted(blist)


def A246337_gen():
    return (
        n
        for n, s in ((n, hex(n)[2:]) for n in islice(pal_gen(16), 1, None))
        if "0" not in s
        and not ((n % sum(int(d, 16) for d in s)) or (n % prod(int(d, 16) for d in s)))
    )


def A246338_gen():
    return (
        n
        for n, s in ((n, oct(n)[2:]) for n in islice(pal_gen(8), 1, None))
        if "0" not in s
        and not ((n % sum(int(d, 8) for d in s)) or (n % prod(int(d, 8) for d in s)))
    )


def A246601(n):
    return sum(d for d in divisors(n, generator=True) if n | d == n)


def A246701(n):
    return max(
        int(bin(n + 1 - k)[2:] + bin(n + 1 + k)[2:], 2) for k in range(n + 2)
    ) - max(int(bin(n - k)[2:] + bin(n + k)[2:], 2) for k in range(n + 1))


def A092517(n):
    return divisor_count(n) * divisor_count(n + 1)


def A246817_gen():  # generator of terms
    p5 = 0
    for n in count(5, 5):
        yield p5
        p5 += multiplicity(5, n) * n


def A246874_gen():
    return (
        p
        for p in (prime(n) for n in count(1))
        if all(isprime(p - m * m) for m in range(2, 10, 2))
    )


def A246971_gen():  # generator of terms
    for n in count(0):
        for k in range(n, -1, -1):
            c, d0 = 0, ["0"] * (n + k)
            for x in combinations(range(n + k), n):
                d = list(d0)
                for i in x:
                    d[i] = "1"
                if not "0100010" in "".join(d):
                    c += 1
            yield c


def A247128_gen(startvalue=1):
    return (n for n in count(max(startvalue, 1)) if (n % 22) in {0, 5, 9, 13, 17})


def A247221_gen(startvalue=0):
    return (
        n for n in count(max(startvalue, 0)) if pow(2, n, 2 * n * n + 1) == 2 * n * n
    )


def A247348_gen():
    return (
        p
        for p in (5 * prime(n) + 4 for n in count(1))
        if not ((p - 1) % 2 or (p - 2) % 3 or (p - 3) % 4)
        and isprime(p)
        and isprime((p - 1) // 2)
        and isprime((p - 2) // 3)
        and isprime((p - 3) // 4)
    )


def A247855(n):
    return hermite(10, n)


def A247850(n):
    return hermite(5, n)


def A247854(n):
    return hermite(9, n)


def A247853(n):
    return hermite(8, n)


def A247852(n):
    return hermite(7, n)


def A247851(n):
    return hermite(6, n)


def A163323(n):
    return hermite(4, n)


def A163322(n):
    return hermite(3, n)


def A348634(n):
    return (
        n
        * (n - 2)
        * (n - 1)
        * (
            n * (n * (n * (n * (n * (n * (n - 17) + 167) - 965) + 3481) - 7581) + 9060)
            - 4608
        )
        // 120
    )


def A248323_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if len(
            list(
                re.finditer(
                    "(?=" + str(n) + ")", "".join([str(d) for d in divisors(n)])
                )
            )
        )
        > 1
    )


def A248889_gen():
    return (n for n in pal10_gen() if is_pal(n, 18))


def A249517_gen():  # generator of terms
    yield 0
    for g in count(1):
        xp, ylist = [], []
        for i in range(9 * g, -1, -1):
            x = set(str(i))
            if not (("0" in x) or (x in xp)):
                xv = [int(d) for d in x]
                imin = int("".join(sorted(str(i))))
                if max(xv) * (g - len(x)) >= imin - sum(xv) and i - sum(xv) >= min(
                    xv
                ) * (g - len(x)):
                    xp.append(x)
                    for y in product(x, repeat=g):
                        if set(y) == x:
                            yd = [int(d) for d in y]
                            if set(str(sum(yd))) == x == set(str(prod(yd))):
                                ylist.append(int("".join(y)))
        yield from sorted(ylist)


def A249689_gen():  # generator of terms
    l1, l2, s, b = 2, 1, 3, set()
    for n in count(3):
        i = s
        while True:
            if not i in b and gcd(i, l1) == 1 and gcd(i, l2) == 1:
                l2, l1 = l1, i
                b.add(i)
                if l2 > l1 and n % 3 == 1:
                    yield (n - 1) // 3
                while s in b:
                    b.remove(s)
                    s += 1
                break
            i += 1


def A249780(n):
    return max(p := primefactors(2**n - 1)) * min(p)


def A249951_gen():  # generator of terms
    m = [362880, -1229760, 1607760, -1011480, 309816, -40752, 1584, -4, 1]
    for n in count(1):
        for i in range(8):
            m[i + 1] += m[i]
        if isprime(m[-1]):
            yield n


def A250127_gen():  # generator of terms
    yield 1
    l1, l2, s, u, l, b = 3, 2, 4, 1, 1, {}
    for n in count(4):
        i = s
        while True:
            if not i in b and gcd(i, l1) == 1 and gcd(i, l2) > 1:
                l2, l1, b[i] = l1, i, 1
                while s in b:
                    b.pop(s)
                    s += 1
                if u * n < i * l:
                    yield n
                    u, l = i, n
                break
            i += 1


def A250984_gen():  # generator of terms
    m = -1
    for i in count(3):
        if (v := A247190(i)) > m:
            yield v
            m = v


def A250985_gen():  # generator of terms
    m = -1
    for i in count(3):
        if (v := A247190(i)) > m:
            yield i
            m = v


def A251360_gen():  # generator of terms
    p = 3
    for n in count(2):
        q, fn = prime(n + 1), factorint(n)
        m = int("".join(str(d) * fn[d] for d in sorted(fn)))
        if p <= m < q:
            yield m
        p = q


def A251756_gen():  # generator of terms
    yield 0
    l, s, b = 0, 1, {}
    while True:
        i = s
        while True:
            if not i in b:
                m = gcd(i, l)
                if not (m == 1 or isprime(m)):
                    yield i
                    l, b[i] = i, True
                    while s in b:
                        b.pop(s)
                        s += 1
                    break
            i += 1


def A252606_gen(startvalue=0):
    return (n for n in count(max(startvalue, 0)) if pow(2, n, n + 2) == n)


def A253047(n):
    if n <= 2:
        return n
    if n == 3:
        return 7
    q2, r2 = divmod(n, 2)
    if r2:
        q3, r3 = divmod(n, 3)
        if r3:
            if isprime(n):
                m = primepi(n)
                if isprime(m):
                    return prime(2 * m)
                x, y = divmod(m, 2)
                if not y:
                    if isprime(x):
                        return prime(x)
            return n
        if isprime(q3):
            return 2 * prevprime(q3)
        return n
    if isprime(q2):
        return 3 * nextprime(q2)
    return n


def A253084_T(n, k):
    return int(not (~(n + k) & (n - k)) | (~n & k))


def A253264_gen():  # generator of terms
    p = 2
    while True:
        q = p**2 - 2
        if isprime(q):
            r = q**2 - 2
            if isprime(r):
                s = r**2 - 2
                if isprime(s) and isprime(s**2 - 2):
                    yield p
        p = nextprime(p)


def A253576_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if set(str(n)) & set(str(n**7)) == set() and isprime(n)
    )


def A253577_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if set(str(n)) & set(str(n**8)) == set() and isprime(n)
    )


def A253606_gen(startvalue=1):
    return (
        n for n in count(max(startvalue, 1)) if set(str(n)) & set(str(n**8)) == set()
    )


def A254232_gen():  # generator of terms
    yield 2
    a, b, c, d = 3, 0, 2, 2
    while True:
        a, b, c = b, c, a + b
        d *= c
        yield d


def A254687(n):
    y, x, n2 = 0, 2, 2 * n
    while x < n:
        if isprime(n2 - x) and isprime(n2 - 2 * x - 1):
            y += 1
        x = nextprime(x)
    return y


def A254688(n):
    y, x, n2 = 0, 2, 2 * n
    while x < n:
        if isprime(n2 - x) and isprime(n2 - 2 * x + 1):
            y += 1
        x = nextprime(x)
    return y


def A255132_gen():  # generator of terms
    yield from [1, 1]
    c, s = {}, 3
    for n in count(2):
        for p, e in factorint(4 * n - 2).items():
            if p in c:
                c[p] += e
            else:
                c[p] = e
        for p, e in factorint(n + 1).items():
            if c[p] == e:
                del c[p]
            else:
                c[p] -= e
        if n == s:
            c2 = prod(e + 1 for e in c.values())
            yield c2
            s = 2 * s + 1


def A255133_gen():  # generator of terms
    yield from [1, 1]
    c, s = {}, 3
    for n in count(2):
        for p, e in factorint(4 * n - 2).items():
            if p in c:
                c[p] += e
            else:
                c[p] = e
        for p, e in factorint(n + 1).items():
            if c[p] == e:
                del c[p]
            else:
                c[p] -= e
        if n == s:
            c2 = 2 ** len(c)
            yield c2
            s = 2 * s + 1


def A255194_gen():  # generator of terms
    p, p2 = 2, 3
    for n in count(1):
        if p2 - p > 6:
            for i in range(1, 7):
                fs = factorint(p + i)
                if len(fs) > 3 or sum(list(fs.values())) != 3:
                    break
            else:
                yield n
        p, p2 = p2, nextprime(p2)


def A255244_gen():  # generator of terms
    for n in count(1):
        s0 = s2 = 1
        for p, e in factorint(n).items():
            s0 *= e + 1
            s2 *= (p ** (2 * (e + 1)) - 1) // (p**2 - 1)
        q, r = divmod(s2, s0)
        if not (r or q % n):
            yield n


def A255245_gen():  # generator of terms
    for n in count(2):
        s0 = s2 = 1
        for p, e in factorint(n).items():
            s0 *= e + 1
            s2 *= (p ** (2 * (e + 1)) - 1) // (p**2 - 1)
        q, r = divmod(s2 - n**2, s0 - 1)
        if not (r or q % n):
            yield n


def A255484(n):
    return prod(0 if ~n & k else prime(k + 1) for k in range(n + 1))


def A256048(n):
    sn = str(n)
    for p in pal10_odd_range_gen(len(sn) + 2):
        if sn in str(p)[1:-1] and isprime(p):
            return p


def A256112_helper(n, b):
    if n == 1:
        t = list(range(b))
        for i in range(1, b):
            u = list(t)
            u.remove(i)
            yield i, u
    else:
        for d, v in A256112_helper(n - 1, b):
            for g in v:
                k = d * b + g
                if not k % n:
                    u = list(v)
                    u.remove(g)
                    yield k, u


def A256112_gen():
    return (a * k + b[0] for k in count(2) for a, b in A256112_helper(k - 1, k))


def A256480(n):
    sn = str(n)
    if not (n % 2 and n % 5):
        return 0
    for i in count(1):
        for j in range(1, 10):
            si = gmpy2digits(j, 10) * i
            p = int(si + sn)
            if isprime(p):
                return p


def A256635(n):
    k = 1
    while sum(int(d) for d in str(divisor_sigma(k))) != n:
        k += 1
    return k


def A257299_gen():  # generator of terms
    blist = []
    for n in permutations("123456789", 9):
        x = 0
        for d in n:
            q, r = divmod(x, int(d))
            if r:
                break
            x = int(d + str(q))
        else:
            blist.append(x)
    yield from sorted(blist)


def A257864_gen():  # generator of terms
    g, h = 105, 128
    for i in count(9, 2):
        g *= i
        if isprime(g - h):
            yield i


def A257342(n):
    (
        m,
        y,
        t,
    ) = (
        2,
        Fraction(0, 1),
        10 ** (n + 1),
    )
    for i in count(2):
        for j in range(1, i):
            x = Fraction(j, i)
            if x.denominator == i:
                y += Fraction(int(m * x) % 2, m)
                m *= 2
        if m > 10000 * t:
            break
    return int(y * t) % 10


def A258574_gen():  # generator of terms
    a, b = 0, 2
    for n in count(0):
        if max(factorint(b).values()) <= 1:
            yield n
        a, b = b, a + b


def A258660_gen():  # generator of terms
    for l in count(1):
        if not isprime(l):
            fs = divisors(l)
            a, b = isqrt_rem(10 ** (l - 1))
            if b > 0:
                a += 1
            for n in range(a, isqrt(10**l - 1) + 1):
                n2 = n**2
                ns = str(n2)
                for g in fs:
                    y = 0
                    for h in range(0, l, g):
                        y += int(ns[h : h + g])
                    if not is_square(y):
                        break
                else:
                    yield n2


def A350329(n):
    a, b, c = 2**n, n * (n + 1), 2 ** (n + 1)
    while (x := divmod(c - a, b))[1] != 0:
        c *= 2
    return x[0]


def A350576(n):
    return n // (m := A055874(n)) - m


def A350509(n):
    return n // A055874(n)


def A259629_gen():  # generator of terms
    plist, p = [10, 15], 5
    yield from plist
    while True:
        r = nextprime(p)
        plist = [plist[-1] * 2 * r // p] + [d * r for d in plist]
        p = r
        yield from plist


def A259673(n):
    return divisor_sigma(n, prime(n))


def A259836_gen(startvalue=0):  # generator of terms
    for n in count(max(startvalue, 0)):
        m = n**3 + (n + 1) ** 3
        for x in divisors(m):
            x2 = x**2
            if x2 > m:
                break
            if x != (2 * n + 1) and m < x * x2 and is_square(12 * m // x - 3 * x2):
                yield n
                break


def A259877_gen():  # generator of terms
    yield 1
    a = 1
    for n in count(2):
        a = 6 * a // (n - 1) if n % 2 else a * n * (n + 1) // 6
        yield a


def A259981(n):
    b, c = A002808(n), 0
    for x in range(1, b):
        for y in range(1, b):
            if x != y:
                w = b * (x - y)
                for z in range(1, b):
                    if x != z:
                        if z * w == y * (x - z):
                            c += 1
    return c


def A260224_gen():
    return (
        int("".join(x))
        for n in count(1)
        for x in product("135", repeat=n)
        if is_prime(mpz("".join(x)))
    )


def A260351(n):  # assume 0 <= n <= 62
    r, c = set(gmpy2digits(d, n) for d in range(n)), 0
    dc = set(gmpy2digits(c, n))
    while len(dc) < n - 1 or "0" in dc:
        c += max(int(d, n) for d in r - dc)
        dc = set(gmpy2digits(c, n))
    return c


def A260374_gen():  # generator of terms
    yield 0
    g = 1
    for i in count(1):
        g *= i
        s = isqrt(g)
        t = g - s**2
        yield int(t if t - s <= 0 else 2 * s + 1 - t)


def A261010(n):
    return sum(int(d) for d in gmpy2digits(5**n, 3))


def A261182_gen():
    return (
        int("".join(d))
        for l in count(1)
        for d in product("279", repeat=l)
        if isprime(int("".join(d)))
    )


def A262963_helperf1(n):
    s = gmpy2digits(n, 3)
    m = len(s)
    for i in range(m):
        if s[i] == "0":
            return int(s[:i] + "1" * (m - i), 3)
    return n


def A262963_helperf2(n):
    s = gmpy2digits(n, 4)
    m = len(s)
    for i in range(m):
        if s[i] in ["0", "1"]:
            return int(s[:i] + "2" * (m - i), 4)
    return n


def A262963_gen():  # generator of terms
    n = 1
    while True:
        m = A262963_helperf2(A262963_helperf1(n))
        while m != n:
            n, m = m, A262963_helperf2(A262963_helperf1(m))
        yield m
        n += 1


def A263133_gen(startvalue=0):
    return (m for m in count(max(startvalue, 0)) if not ~(4 * m + 3) & m)


def A263299_gen():
    return (
        n
        for n in (int("1" * k + str(k * (k + 1) + 1) + "1" * k) for k in count(0))
        if isprime(n)
    )


def A265433(n):
    if n == 1:
        return 0
    if n == 3:
        return 1
    if (n % 3) == 0:
        return 0
    else:
        pmaxlist = (
            ["3" * (n // 3) + "2"]
            if (n % 3 == 2)
            else ["3" * (n // 3 - 1) + "22", "3" * (n // 3 - 1) + "4"]
        )
        return sum(
            1
            for p in pmaxlist
            for k in multiset_permutations(p)
            if isprime(int("".join(k)))
        )


def A267077(n):
    if n == 0:
        return 1
    u, v, t, w = max(8, 2 * n), max(4, n) ** 2 - 9, 4 * n * (n + 1), n**2
    while True:
        m, r = divmod(v, t)
        if not r and is_square(m * w + 1):
            return m
        v += u + 1
        u += 2


def A267765_gen():
    return (int(d, 5) for d in (str(i**2) for i in count(0)) if max(d) < "5")


def A267766_gen():
    return (int(d, 6) for d in (str(i**2) for i in count(0)) if max(d) < "6")


def A267819_gen():
    return (
        int(d, 5)
        for d in (str(i**2) for i in count(1))
        if max(d) < "5" and isprime(int(d, 5))
    )


def A267820_gen():
    return (
        int(d, 6)
        for d in (str(i**2) for i in count(1))
        if max(d) < "6" and isprime(int(d, 6))
    )


def A268083_gen():  # generator of terms
    b = 1
    for n in count(1):
        if len(factorint(n)) > 1 and gcd(b, n) == 1:
            yield n
        b = b * 2 * (2 * n + 1) // (n + 1)


def A268983_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if not sum(
            d * pow(int(divisor_sigma(d)), n // d, n) % n
            for d in divisors(n, generator=True)
        )
        % n
    )


def A269483(n):
    return (
        n
        * (
            n**2 * (n * (n**2 * (n**2 * (n * (n**2 * (n - 1) + 1) - 1) + 1) - 1) + 1)
            - 1
        )
        + 1
    )


def A269483_gen():  # generator of terms
    m = [
        479001600,
        -2674425600,
        6386688000,
        -8501915520,
        6889478400,
        -3482100720,
        1080164160,
        -194177280,
        17948256,
        -666714,
        5418,
        0,
        1,
    ]
    while True:
        yield m[-1]
        for i in range(12):
            m[i + 1] += m[i]


def A270225_gen():
    return (
        p
        for p in (prime(i) for i in count(2))
        if p % 8 not in {5, 7} and isprime(p + 2)
    )


def A270808_gen():  # generator of terms
    a = 1
    while True:
        b = a // (max(primefactors(a) + [1])) + 1
        yield b // 2
        a += b


if sys.version_info >= (3, 10):

    def A271499_gen(startvalue=1):
        return (n for n in count(max(startvalue, 1)) if n.bit_count().bit_count() != 1)

else:

    def A271499_gen(startvalue=1):
        return (
            n
            for n in count(max(startvalue, 1))
            if bin(bin(n).count("1")).count("1") != 1
        )


def A272328(n):
    m = totient(n)
    return sum(1 for k in range(1, n + 1) if m == totient(n + k))


def A274093_gen():
    return chain((0,), (i for n in count(1) for i in (-n if n % 2 else n,) * n))


def A274094_gen():
    return chain((0,), (i for n in count(1) for i in (n if n % 2 else -n,) * n))


def A274213_gen():  # generator of terms
    blist = [1, 2, 3]
    yield from blist
    while True:
        blist.append(blist[-blist[-3]] + 3)
        yield blist[-1]


def A275573_gen():  # generator of terms
    q = 0
    for i in count(1):
        q += Fraction(int(str(i)[::-1]), 10 ** len(str(i)))
        if q.denominator == 1:
            yield q + i * (i + 1) // 2


def A276399(n):
    a = factorial(n - 1)
    return a // gcd(n ** (n - 1) - 1, a)


def A276400(n):
    a = n ** (n - 1) - 1
    return a // gcd(factorial(n - 1), a)


def A276689(n):
    x = continued_fraction_periodic(0, 1, n)
    return min(x[1]) if len(x) > 1 else 0


def A276919(n):
    ndict = {}
    for i in range(n):
        i3 = pow(i, 3, n)
        for j in range(i + 1):
            j3 = pow(j, 3, n)
            m = (i3 + j3) % n
            if m in ndict:
                if i == j:
                    ndict[m] += 1
                else:
                    ndict[m] += 2
            else:
                if i == j:
                    ndict[m] = 1
                else:
                    ndict[m] = 2
    count = 0
    for i in ndict:
        j = (1 - i) % n
        if j in ndict:
            count += ndict[i] * ndict[j]
    return count


def A276920(n):
    ndict = {}
    for i in range(n):
        i3 = pow(i, 3, n)
        for j in range(i + 1):
            j3 = pow(j, 3, n)
            m = (i3 + j3) % n
            if m in ndict:
                if i == j:
                    ndict[m] += 1
                else:
                    ndict[m] += 2
            else:
                if i == j:
                    ndict[m] = 1
                else:
                    ndict[m] = 2
    count = 0
    for i in ndict:
        j = (-i) % n
        if j in ndict:
            count += ndict[i] * ndict[j]
    return count


def A277285_gen():
    return chain(
        (1,),
        (j for j in (i**2 for i in count(1)) if pow(2, j, int(divisor_count(j))) == 1),
    )


def A277685(n):  # output differs from sequence at n=14 due to multiple spellings.
    return ord(unidecode.unidecode(num2words(n, lang="pt")).lower()[0]) - 96


def A281363(n):
    m, q = 1, 4 * n**2 - 1
    p = pow(2, 2 * n, q)
    r = p
    while r != 1:
        m += 1
        r = (r * p) % q
    return m


def A282384_gen(startvalue=1):
    return (i for i in count(max(startvalue, 1)) if str(i + 1) in str(i**2))


def A286261_gen(startvalue=0):
    return (n for n in count(max(startvalue, 0)) if not is_cubefree_string(bin(n)[2:]))


def A286298(n):
    if n <= 1:
        return n
    a, b = divmod(n, 2)
    return A286298(a) + 1 + b + (-1) ** b * (a % 2)


def A286333_gen():  # generator of terms
    for l in count(0):
        for w in product("1379", repeat=l):
            for d in "0123456789":
                for t in "1379":
                    s = "".join(w) + d + t
                    n = int(s)
                    for i in range(l + 1):
                        if not isprime(int(s)):
                            break
                        s = s[1:] + s[0]
                    else:
                        if n > 10 and not isprime(int(s)):
                            yield n


def A286901(n):
    m = prevprime(n)
    return (m + n) * (n - m + 1) // 2


def A287550_gen():  # generator of terms
    p = 2
    q, r, s = p + 72, p + 144, p + 216
    while True:
        np = nextprime(p)
        if (
            np == q
            and isprime(r)
            and isprime(s)
            and nextprime(q) == r
            and nextprime(r) == s
        ):
            yield p
        p, q, r, s = np, np + 72, np + 144, np + 216


def A288184(n):
    d = 1
    while True:
        s = continued_fraction_periodic(0, 1, d)[-1]
        if isinstance(s, list) and len(s) == n:
            return d
        d += 2


def A288185(n):
    d = 2
    while True:
        s = continued_fraction_periodic(0, 1, d)[-1]
        if isinstance(s, list) and len(s) == n:
            return d
        d += 2


def A288939_gen(startvalue=0):
    return (
        n
        for n in count(max(startvalue, 0))
        if not isprime(n)
        and isprime(n * (n * (n * (n * (n * (n + 1) + 1) + 1) + 1) + 1) + 1)
    )


def A289660(n):
    return (
        0
        if n == 1
        else int("".join(map(lambda x: str(x[0]) * x[1], sorted(factorint(n).items()))))
        - n
    )


def A290126(n):
    i = 1
    while len(divisors(i)) < n or not isprime(sum(divisors(i)[-n:])):
        i += 1
    return i


def A290435_gen(startvalue=2):
    return (
        n
        for n in count(max(startvalue, 2))
        if sum(factorint(n).values()) == len(factorint(n)) == 2
        and isprime(1 + sum(factorint(n).keys()))
    )


def A291460_gen(startvalue=1):
    return (
        2 * x
        for x in count(max(startvalue // 2 + startvalue % 2, 1))
        if str(int(bin(x).rstrip("0"), 2)) in str(2 * x)
    )


def A292931_gen(startvalue=0):
    return (
        n for n in count(max(startvalue, 0)) if not sum(int(d) for d in str(3**n)) % 7
    )


def A296012_gen():  # generator of terms
    p = 2
    while True:
        k = (p - 2) // 3
        if not (isprime(k) or isprime(k + 2)):
            yield p
        p = nextprime(p)


def A297574(n):
    m = n + 1
    mn = m * n
    while pow(2, m, mn) != pow(2, n, mn):
        m += 1
        mn += n
    return m


def A033307_gen():
    return chain.from_iterable(sympydigits(m, 10)[1:] for m in count(1))


def A031076_gen():
    return chain.from_iterable(sympydigits(m, 9)[1:] for m in count(1))


def A054634_gen():
    return chain.from_iterable(sympydigits(m, 8)[1:] for m in count(0))


def A031035_gen():
    return (d for m in count(1) for d in sympydigits(m, 8)[1:])


def A030998_gen():
    return chain.from_iterable(sympydigits(m, 7)[1:] for m in count(0))


def A030548_gen():
    return chain.from_iterable(sympydigits(m, 6)[1:] for m in count(1))


def A031219_gen():
    return chain.from_iterable(sympydigits(m, 5)[1:] for m in count(1))


def A030373_gen():
    return chain.from_iterable(sympydigits(m, 4)[1:] for m in count(1))


def A054635_gen():
    return chain.from_iterable(sympydigits(m, 3)[1:] for m in count(0))


def A003137_gen():
    return (d for m in count(1) for d in sympydigits(m, 3)[1:])


def A030190_gen():
    return (int(d) for m in count(0) for d in bin(m)[2:])


def A298312_gen():  # generator of terms
    n, m = 1, 30
    while True:
        k = prevprime(m // 3)
        k2 = nextprime(k)
        if prevprime(k) + k + k2 == m or k + k2 + nextprime(k2) == m:
            yield n * (3 * n - 2)
        n += 1
        m += 18 * n + 3


def A298313_gen():  # generator of terms
    n, m = 1, 30
    while True:
        k = prevprime(m // 3)
        k2 = prevprime(k)
        k3 = nextprime(k)
        if k2 + k + k3 == m:
            yield k2
        elif k + k3 + nextprime(k3) == m:
            yield k
        n += 1
        m += 18 * n + 3


@lru_cache(maxsize=None)
def A298356(n):
    if n <= 2:
        return 1
    c, j = A298356(n - 1) + A298356(n - 2), 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * A298356(k1)
        j, k1 = j2, n // j2
    return c + n - j + 1


@lru_cache(maxsize=None)
def A298357(n):
    if n <= 2:
        return n + 1
    c, j = A298357(n - 1) + A298357(n - 2), 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * A298357(k1)
        j, k1 = j2, n // j2
    return c + 2 * (n - j + 1)


@lru_cache(maxsize=None)
def A298369(n):
    if n <= 2:
        return 1
    c, j = A298369(n - 1) + A298369(n - 2), 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 * (j2 - 1) - j * (j - 1)) * A298369(k1) // 2
        j, k1 = j2, n // j2
    return c + (n * (n + 1) - j * (j - 1)) // 2


@lru_cache(maxsize=None)
def A298370(n):
    if n <= 2:
        return n + 1
    c, j = A298370(n - 1) + A298370(n - 2), 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 * (j2 - 1) - j * (j - 1)) * A298370(k1) // 2
        j, k1 = j2, n // j2
    return c + 2 * (n * (n + 1) - j * (j - 1)) // 2


def A298827(n):
    return n_order(3, 3**n + 2)


def A301631(n):
    return (
        Fraction(comb(2 * n, n)) / (n + 1) - Fraction(4**n) / (n + 1) ** 2
    ).numerator


def A301861(n):
    return int(sum(mpz(d) for d in gmpy2digits(fac(fac(n)))))


def A301943(n):
    return sum(1 for i in range(1, 10 ** (n - 1) + 1) if isprime(100 * i**2 + 1))


def A302021_gen():  # generator of terms
    klist = [isprime(i**2 + 1) for i in range(6)]
    for k in count(0):
        i = isprime((k + 6) ** 2 + 1)
        if klist[0] and klist[2] and i:
            yield k
        klist = klist[1:] + [i]


def A302087_gen():  # generator of terms
    klist = [isprime(i**2 + 1) for i in range(6)]
    for k in count(0):
        i = isprime((k + 6) ** 2 + 1)
        if klist[0] and i:
            yield k
        klist = klist[1:] + [i]


def A302294(n):
    s = set()
    for i in range(1, (n + 3) // 2):
        for j in divisors(i):
            for k in divisors(n - i):
                if j != k:
                    s.add((min(j, k), max(j, k)))
    return 3 * divisor_count(n) + 2 * len(s) - 1


def A302552(n):
    return sum((6, 2, 5, 5, 4, 5, 6, 3, 7, 6)[int(d)] for d in str(prime(n)))


def A303108_gen():  # generator of terms
    blist = [2, 5]
    yield from blist
    for n in count(3):
        blist = [blist[1], 3 * (n - 1) * blist[-1] - (2 * n - 3) * (n - 2) * blist[-2]]
        yield blist[-1]


def A303109_gen():  # generator of terms
    blist = [0, 1]
    yield from blist
    for n in count(2):
        blist = [
            blist[1],
            (3 * n * (n - 1) + 1) * blist[-1] - (2 * n - 3) * (n - 1) ** 3 * blist[-2],
        ]
        yield blist[-1]


@lru_cache(maxsize=None)
def A304212_helper(n, i):
    return (
        1
        if n == 0 or i == 1
        else A304212_helper(n, i - 1) + A304212_helper(n - i, min(i, n - i))
    )


def A304212(n):
    return A304212_helper(n**3 - n**2, n**2)


def A305377(n):
    m, tlist, s = prime(n), [1, 2, 4], 0
    while tlist[-1] + tlist[-2] + tlist[-3] <= m:
        tlist.append(tlist[-1] + tlist[-2] + tlist[-3])
    for d in tlist[::-1]:
        s *= 2
        if d <= m:
            s += 1
            m -= d
    return s


def A305380(n):
    m, tlist, s = 2**n, [1, 2, 4], 0
    while tlist[-1] + tlist[-2] + tlist[-3] <= m:
        tlist.append(tlist[-1] + tlist[-2] + tlist[-3])
    for d in tlist[::-1]:
        s *= 2
        if d <= m:
            s += 1
            m -= d
    return s


def A305876(n):
    m, tlist, s = 2**n, [1, 2], 0
    while tlist[-1] + tlist[-2] <= m:
        tlist.append(tlist[-1] + tlist[-2])
    for d in tlist[::-1]:
        s *= 2
        if d <= m:
            s += 1
            m -= d
    return s


def A306392(n):
    return int(
        "".join("1" if d == "2" else ("2" if d == "1" else d) for d in str(2**n))
    )


def A306494(n):
    k = n
    for m in count(0):
        s = str(k)
        for i in range(1, len(s)):
            if s[i] == s[i - 1]:
                return m
        k *= 3


def A307535(n):
    r = 2**n
    m, k = 2**r + 1, 0
    w = m
    while not isprime(w):
        k += 1
        w += r
    return k


def A308395_gen():  # generator of terms
    w = 0
    for y in count(1):
        w += y
        z = 0
        for x in range(1, y + 1):
            z += x
            if is_square(8 * (w + z) + 1):
                yield y
                break


def A318358_gen():  # generator of terms
    yield 2
    bset, p, q = {2}, 2, 4
    while True:
        r = sorted(
            next(zip(*diop_quadratic(symbolx**2 + q - p * symboly - symbolx * symboly)))
        )
        for a in r[bisect.bisect_right(r, 0) :]:
            if a not in bset:
                yield a
                bset.add(a)
                break
        p += a
        q += a**2


def A320059(n):
    c1, c2 = 1, 1
    for p, a in factorint(n).items():
        c1 *= (p ** (2 * a + 1) - 1) // (p - 1)
        c2 *= (p ** (a + 1) - 1) // (p - 1)
    return c1 - c2


def A320262(n):
    return int(
        "".join(
            d + "0" for d in split("(0+)|(1+)", bin(n)[2:]) if d != "" and d != None
        ),
        2,
    )


def A320263(n):
    return int(
        "".join(
            "0" + d for d in split("(0+)|(1+)", bin(n)[2:]) if d != "" and d != None
        ),
        2,
    )


def A320890_gen():  # generator of terms
    b = 11
    yield b
    while True:
        a0, a1, s = 0, 0, ""
        for d in str(b):
            if d == "0":
                a0 += 1
                s += bin(a0)[2:]
            else:
                a1 += 1
                s += bin(a1)[2:]
        b = int(s)
        yield b


def A322183_gen():
    return (int(str(d), 2) for d in A320890_gen())


def A321210_gen():  # generator of terms
    for i in count(0):
        s = bin(i)[2:]
        s += s[-2::-1]
        p = int(s) + int("02" * (len(s) // 2) + "0")
        q = 6 * p + 1
        t = str(q)
        if t == t[::-1] and isprime(p) and isprime(q):
            yield q


def A321443(n):
    if n == 0:
        return 1
    c = 0
    for i in range(n):
        mi = i * (i + 1) + n
        for j in range(i + 1, n + 1):
            k = mi - j * j
            if k < 0:
                break
            if not k % j:
                c += 1
    return c


def A321803(n):
    return int(
        "0"
        + "".join(
            d if len(d) != 1 else ""
            for d in split("(0+)|(1+)|(2+)|(3+)|(4+)|(5+)|(6+)|(7+)|(8+)|(9+)", str(n))
            if d != "" and d != None
        )
    )


def A321804(n):
    return (lambda x: int(x) if x != "" else -1)(
        "".join(
            d if len(d) != 1 else ""
            for d in split("(0+)|(1+)|(2+)|(3+)|(4+)|(5+)|(6+)|(7+)|(8+)|(9+)", str(n))
            if d != "" and d != None
        )
    )


def A322609_gen(startvalue=1):
    return (
        k
        for k in count(max(startvalue, 1))
        if sum(
            d
            for d in divisors(k, generator=True)
            if max(factorint(d).values(), default=1) >= 2
        )
        == 2 * k
    )


def A323192_gen():  # generator of terms
    for k in count(0):
        n = isqrt(2 ** (2 * k + 1))
        if n * (n - 1) + 2 ** (len(bin(n)) - 2) - 2 ** (len(bin(n**2)) - 2) > 0:
            yield n


def A328291(n):
    if n > 9876543210 or n % 100 == 0:
        return 0
    k = 9876543210 // n
    m = k * n
    s = str(m)
    while len(set(s)) != len(s):
        k -= 1
        m -= n
        s = str(m)
    return k


@lru_cache(maxsize=None)
def A328967(n):
    if n == 0:
        return 1
    c, j = n - 1, 1
    k1 = (n - 1) // j
    while k1 > 1:
        j2 = (n - 1) // k1 + 1
        c += (j2 - j) * A328967(k1)
        j, k1 = j2, (n - 1) // j2
    return j - c


def A329792(n):
    if n % 10:
        m, s = 1, set("12345")
        while not set(str(m * n)) <= s:
            m += 1
        return m
    else:
        return -1


def A329793(n):
    if n % 10:
        m, s = n, set("12345")
        while not set(str(m)) <= s:
            m += n
        return m
    else:
        return -1


def A331759(n):
    return (2 * n + 1) ** 2 + sum(
        totient(i) * (2 * n + 2 - i) * (4 * n + 4 - i) for i in range(2, 2 * n + 2)
    )


def A331760(n):
    return (
        n**2
        + sum(
            totient(i) * (2 * n + 1 - i) * (4 * n + 2 - i) for i in range(2, 2 * n + 1)
        )
        // 4
    )


def A333034(n):
    return sum(int(d) for i in range(10 ** (n - 1), 10**n) for d in str(i**2))


def A333073(n):
    f = 1
    for i in range(1, n + 1):
        f = lcm(f, i)
    f = int(f)
    glist = []
    for i in range(1, n + 1):
        glist.append(f // i)
    m = 1 if n < 2 else primorial(n, nth=False) // primorial(n // 2, nth=False)
    k = m
    while True:
        p, ki = 0, -k
        for i in range(1, n + 1):
            p = (p + ki * glist[i - 1]) % f
            ki = (-k * ki) % f
        if p == 0:
            return k
        k += m


def A333074(n):
    f, g = int(factorial(n)), []
    for i in range(n + 1):
        g.append(int(f // factorial(i)))
    m = 1 if n < 2 else prod(primefactors(n))
    k = m
    while True:
        p, ki = 0, 1
        for i in range(n + 1):
            p = (p + ki * g[i]) % f
            ki = (-k * ki) % f
        if p == 0:
            return k
        k += m


def A333420_T(n, k):  # T(n,k) for A333420
    if k == 1:
        return int(factorial(n))
    if n == 1:
        return k * (k + 1) // 2
    if k % 2 == 0 or (k >= n - 1 and n % 2 == 1):
        return (k * (k * n + 1) // 2) ** n
    if k >= n - 1 and n % 2 == 0 and k % 2 == 1:
        return ((k**2 * (k * n + 1) ** 2 - 1) // 4) ** (n // 2)
    nk = n * k
    nktuple = tuple(range(1, nk + 1))
    nkset = set(nktuple)
    count = 0
    for firsttuple in combinations(nktuple, n):
        nexttupleset = nkset - set(firsttuple)
        for s in permutations(sorted(nexttupleset), nk - 2 * n):
            llist = sorted(nexttupleset - set(s), reverse=True)
            t = list(firsttuple)
            for i in range(0, k - 2):
                itn = i * n
                for j in range(n):
                    t[j] += s[itn + j]
            t.sort()
            w = 1
            for i in range(n):
                w *= llist[i] + t[i]
            if w > count:
                count = w
    return count


def A333446_T(n, k):  # T(n,k) for A333446
    c, l = 0, list(range(1, k * n + 1, k))
    lt = list(l)
    for i in range(n):
        for j in range(1, k):
            lt[i] *= l[i] + j
        c += lt[i]
    return c


def A333463(n):
    return sum(
        (2 * sum(d // k for k in range(1, isqrt(d) + 1)) - isqrt(d) ** 2)
        * totient(n // d)
        for d in divisors(n, generator=True)
    )


def A333577(n):
    if n == 2:
        return 0
    p = prime(n)
    q, r = nextprime(p), 10 ** len(str(p))
    return p * q * mod_inverse(q, r) % (q * r)


def A334841(n):
    return 2 * bin(n)[-1:1:-2].count("1") - (len(bin(n)) - 1) // 2 if n > 0 else 0


def A335233_gen():  # generator of terms
    f = 1
    for k in count(1):
        f *= k
        g = 1
        for i in range(1, k + 1):
            g += f
            if isprime(g):
                break
        else:
            yield k


def A335402_gen():
    return chain((0, 1, 2, 4), (prime(i) for i in count(3)))


def A336298(n):
    return prevprime(prime(n) // 2 + 1)


def A337106(n):
    return 0 if n <= 1 else divisor_count(factorial(n)) - 2


def A337174(n):
    return (divisor_count(n) + 1) ** 2 // 4


def A337988_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        for d in divisors(n):
            if 2 * d * d >= n:
                break
            a, b = integer_nthroot(n - d * d, 2)
            if b and n % a == 0:
                yield n
                break


def A338577_gen():  # generator of terms
    p, q, r = 2, 3, 5
    while True:
        if (q - p) * (r - p) > p:
            yield p
        p, q, r = q, r, nextprime(r)


def A339485(n):
    c, primeset2 = n, set(prime(i) for i in range(1, n))
    primeset = primeset2 | {prime(n)}
    for l in range(2, n + 1):
        for d in combinations(primeset, l):
            a, b = divmod(sum(d), l)
            if b == 0 and a in primeset2:
                c += 1
    return c


@lru_cache(maxsize=None)
def A339507(n):
    pallist = set(i for i in range(1, n * (n + 1) // 2 + 1) if str(i) == str(i)[::-1])
    return (
        1
        if n == 0
        else A339507(n - 1)
        + sum(
            sum(d) + n in pallist
            for i in range(n)
            for d in combinations(range(1, n), i)
        )
    )


def A339573(n):
    return n * (n + 1) // 6 - 1


def A340667(n):
    return 0 if n == 0 else int(bin(n)[2:].replace("0", "0" * n), 2)


def A340835(n):
    if n == 0:
        return 0
    s = str(n)
    for i, x in enumerate(s):
        if x != "9":
            break
    else:
        return n
    s1, s2 = s[: i + 1], s[i + 1 :]
    if s2 == "":
        if s1[-1] == "0":
            return int(str(n + 1)[::-1])
        else:
            return int(s[::-1])
    if int(s2) <= 1:
        return int("1" + s2[-2::-1] + s1[::-1])
    else:
        return int("1" + "0" * (len(s2) - 1) + str(int(s1) + 1)[::-1])


def A340836(n):
    if n == 0:
        return 0
    s = bin(n)[2:]
    i = s.find("0")
    if i == -1:
        return n
    s1, s2 = s[: i + 1], s[i + 1 :]
    if s2 == "":
        return n + 1
    if int(s2) <= 1:
        return int("1" + s2[-2::-1] + s1[::-1], 2)
    else:
        return int("1" + "0" * (len(s2) - 1) + bin(int(s1, 2) + 1)[:1:-1], 2)


def A340868_gen():  # generator of terms
    p, q, r, s = 2, 3, 5, 7
    for k in count(1):
        if pow(p, q, r) == s % r:
            yield k
        p, q, r, s = q, r, s, nextprime(s)


def A340967(n):
    c, x = 0, n
    while x > 1:
        c += 1
        x = n % sum(p * e for p, e in factorint(x).items())
    return c


def A341280_gen():  # generator of terms
    k2, d = 3, 2
    for k in count(1):
        if d % k == 0:
            yield k
        if isprime(k):
            d -= k
        if isprime(k2):
            d += k2
        k2 += 2


def A341718(n):
    return int(str(2**n)[::-1]) - 1


def A341931(n):
    k, m, r = n, n - 1, n if isprime(n) else -1
    while m > 0:
        k = int(str(k) + str(m))
        if isprime(k):
            r = m
        m -= 1
    return r


def A341934_gen():  # generator of terms
    p, q, r, s = (
        2,
        3,
        5,
        7,
    )
    while True:
        if isprime(2 * q * (p - r) + r * s):
            yield p
        p, q, r, s = q, r, s, nextprime(s)


def A342024(n):
    f = factorint(n)
    for p in f:
        if primepi(p) < f[p]:
            return 1
    return 0


def A342040(n):
    s = bin(n)[2:]
    return int(s + s[-2::-1])


def A342131(n):
    return (3 * n + 1) // 2 if n % 2 else n // 2 + n // 4


def A342280(n):
    return 4 * n + 2 + isqrt(8 * n * (n + 1) + 2)


def A342281(n):
    return isqrt(8 * n * (n + 1) + 2)


def A342288_gen():  # generator of terms
    yield 2
    b = 2
    for n in count(1):
        b = b * 4 * (2 * n - 1) * (2 * n + 3) // ((n + 1) * (n + 3))
        yield b


def A342387_gen():  # generator of terms
    yield 20
    xlist, ylist, x, y = [4, 20, 39], [1, 6, 12], 39, 12
    while True:
        if len(str(x + 1)) == len(str(y + 1)) + 1:
            yield x
        x, y = 19 * xlist[-3] + 60 * ylist[-3] + 39, 6 * xlist[-3] + 19 * ylist[-3] + 12
        xlist, ylist = xlist[1:] + [x], ylist[1:] + [y]


def A342388_gen():  # generator of terms
    yield 6
    xlist, ylist, x, y = [4, 20, 39], [1, 6, 12], 39, 12
    while True:
        if len(str(x + 1)) == len(str(y + 1)) + 1:
            yield y
        x, y = 19 * xlist[-3] + 60 * ylist[-3] + 39, 6 * xlist[-3] + 19 * ylist[-3] + 12
        xlist, ylist = xlist[1:] + [x], ylist[1:] + [y]


def A342455(n):
    return primorial(n) ** 5 if n >= 1 else 1


@lru_cache(maxsize=None)
def A342600(n, m=None):  # A342600(n) = A342600(n,n)
    if m == None:
        m = n
    return (
        max(m, n)
        if m < 2 or n < 2
        else A342600(n - 1, m - 1) + A342600(n - 1, m - 2) + A342600(n - 2, m - 1)
    )


def A342810_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if n == 1 or ((n % 9) + 1) * pow(10, n // 9, n) % n == 1
    )


def A342956(n):
    return (
        sum(factorint(sum(p * e for p, e in factorint(n).items())).values())
        if n > 1
        else 0
    )


def A343197_gen(startvalue=2):
    return (
        n
        for n in count(max(startvalue, 2))
        if isprime(
            sum(sum(p * e for p, e in factorint(i).items()) for i in range(2, n + 1))
        )
    )


@lru_cache(maxsize=None)
def A343511(n):
    return 1 + sum(A343511(d) ** 2 for d in divisors(n) if d < n)


def A343524_gen():  # generator of terms
    yield 0
    for l in count(1):
        for d in combinations("123456789", l):
            s = "".join(d)
            yield int(s + s[-2::-1])
        for d in combinations("123456789", l):
            s = "".join(d)
            yield int(s + s[::-1])


def A343728_gen():
    return (
        n
        for n in (2 * int(gmpy2digits(d, 5)) for d in count(0))
        if set(str(n**2)[:-1]) <= set("13579")
    )


def A343813(n):
    p = prime(n)
    pset = set(sieve.primerange(2, p + 1))
    return sum(1 for d in partitions(p) if len(set(d) & pset) > 0)


def A343943(n):
    fs = factorint(n)
    return len(
        set(sum(d) for d in multiset_combinations(fs, (sum(fs.values()) + 1) // 2))
    )


def A343995(n):
    plist = [p**q for p, q in factorint(2 * (2**n - 1)).items()]
    return min(
        k
        for k in (crt(plist, d)[0] for d in product([0, -1], repeat=len(plist)))
        if k > 0
    )


def A343998(n):
    fs = factorint(2 * n)
    plist = [p ** fs[p] for p in fs]
    return (
        1
        + min(
            k
            for k in (crt(plist, d)[0] for d in product([0, -1], repeat=len(plist)))
            if k > 0
        )
    ) // 2


def A344057(n):
    return 1 if n == 0 else 2 * n**2 * (2 * n - 1) * factorial(n - 1) ** 2


def A344983(n):
    return int((mpz(2) ** 77232917 - 1) // mpz(10) ** (46498849 - n) % 10)


def A344984(n):
    return int((mpz(2) ** 82589933 - 1) // mpz(10) ** (49724095 - n) % 10)


def A345421(n):
    return igcdex(7, prime(n))[0]


def A345429(n):
    return sum(
        abs(u)
        for u, v, w in (igcdex(x, y) for x in range(1, n + 1) for y in range(1, n + 1))
        if w == 1
    )


def A346120(n):
    s, k, f = str(n), 0, 1
    while s not in str(f):
        k += 1
        f *= k
    return k


def A346527(n):
    a, b, k, k2, m, r = -6 * (n + 1) ** 2, (n + 1) ** 4, 2, 4, 1, 0
    while 2 * m + a < 0 or m * (m + a) + b < 0:
        if isqrt(2 * m) - isqrt(m - 1) == n:
            r = m
        k += 1
        k2 += 2 * k - 1
        m = (k2 - 1) // 2
    return r


def A346621(n):
    return 0 if n <= 2 else A346621(n - 1) + (n if len(primefactors(n)) == 2 else 0)


def A346970(n):
    c, ps = 2, primorial(n)
    while True:
        m = ps // gcd(ps, c)
        if m == 1:
            return c
        p = max(primefactors(m))
        for a in range(p, c, p):
            if a * (c - a) % m == 0:
                return c
        c += 1


def A346971(n):
    c, nlist = 1, list(range(1, n + 1))
    while True:
        mlist = [m for m in nlist if c % m]
        if len(mlist) == 0:
            return c
        p = max(mlist)
        for a in range(p, c, p):
            for m in mlist:
                if a % m and (c - a) % m:
                    break
            else:
                return c
        c += 1


def A346988(n):
    k, kn = n + 1, 1
    while True:
        if pow(n, kn, k) == 1:
            return k
        k += 1
        kn += 1


def A347346(n):
    if n % 10 == 0:
        return 0
    s = str(n)
    if s == s[::-1]:
        return n
    for i in range(1, len(s)):
        if s[:-i] == s[-i - 1 :: -1]:
            return int(s[: -i - 1 : -1] + s)


def A347347(n):
    if n % 2 == 0:
        return 0
    s = bin(n)[2:]
    if s == s[::-1]:
        return n
    for i in range(1, len(s)):
        if s[:-i] == s[-i - 1 :: -1]:
            return int(s[: -i - 1 : -1] + s, 2)


def A347089(n):
    return gcd(
        divisor_count(n), sum(gcd(d, n // d) for d in divisors(n, generator=True))
    )


def A348296(n):
    c, k = 0, 0
    while c != n:
        k += 1
        c += -1 if (isqrt(2 * k * k) - k) % 2 else 1
    return k


def A348412_gen(startvalue=2):
    return (
        2 * n
        for n in count(max(startvalue // 2 + startvalue % 2, 1))
        if (lambda x, y: 2 * gcd(x, y * n) >= x)(divisor_sigma(n), divisor_sigma(n, 0))
    )


def A000075(n):
    return (
        0
        if n == 0
        else len(
            set(
                2 * x**2 + 3 * y**2
                for x in range(1 + isqrt(2 ** (n - 1)))
                for y in range(1 + isqrt((2**n - 2 * x**2) // 3))
                if 0 < 2 * x**2 + 3 * y**2 <= 2**n
            )
        )
    )


def A008506_gen():  # generator of terms
    m = [13, -65, 221, -494, 793, -923, 793, -494, 221, -65, 13, 0, 1]
    while True:
        yield m[-1]
        for i in range(12):
            m[i + 1] += m[i]


@lru_cache(maxsize=None)
def A015613(n):
    if n == 0:
        return 0
    c, j = 0, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * (2 * (A015613(k1) + k1) - 1)
        j, k1 = j2, n // j2
    return (n * (n - 3) - c + j) // 2


def A015942_gen(startvalue=2):
    return (
        n
        for n in count(max(startvalue + startvalue % 2, 2), 2)
        if pow(2, n, n) == n // 2 + 1
    )


def A018166(n):
    i, j = iroot_rem(18**n, 5)
    return int(i) + int(32 * j >= 10 * i * (4 * i * (2 * i * (i + 1) + 1) + 1) + 1)


def A020418_gen():
    return (
        n
        for n, s in ((i, continued_fraction_periodic(0, 1, i)[-1]) for i in count(1))
        if isinstance(s, list) and len(s) == 79
    )


def A020430_gen():
    return (
        n
        for n, s in ((i, continued_fraction_periodic(0, 1, i)[-1]) for i in count(1))
        if isinstance(s, list) and len(s) == 91
    )


def A031557_gen():
    return (
        n
        for n, s in ((i, continued_fraction_periodic(0, 1, i)[-1]) for i in count(1))
        if isinstance(s, list) and len(s) % 2 == 0 and s[len(s) // 2 - 1] == 59
    )


def A031597_gen():
    return (
        n
        for n, s in ((i, continued_fraction_periodic(0, 1, i)[-1]) for i in count(1))
        if isinstance(s, list) and len(s) % 2 == 0 and s[len(s) // 2 - 1] == 99
    )


def A031702_gen():
    return (
        n
        for n, s in ((i, continued_fraction_periodic(0, 1, i)[-1]) for i in count(1))
        if isinstance(s, list) and min(s) == 24
    )


def A031713_gen():
    return (
        n
        for n, d in ((n, continued_fraction_periodic(0, 1, n)[-1]) for n in count(1))
        if isinstance(d, list) and min(d) == 35
    )


def A031775_gen():
    return (
        n
        for n, d in ((n, continued_fraction_periodic(0, 1, n)[-1]) for n in count(1))
        if isinstance(d, list) and min(d) == 97
    )


def A031777_gen():
    return (
        n
        for n, d in ((n, continued_fraction_periodic(0, 1, n)[-1]) for n in count(1))
        if isinstance(d, list) and min(d) == 99
    )


def A030082_gen():  # generator of terms
    for i in count(1):
        p = prime(i)
        q = p**3
        if set(str(p)) <= set(str(q)):
            yield q


def A030087_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if set(str(n)) & set(str(n**3)) == set() and isprime(n)
    )


def A031415_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        cf = continued_fraction_periodic(0, 1, n)
        if (
            len(cf) > 1
            and len(cf[1]) > 1
            and len(cf[1]) % 2
            and cf[1][len(cf[1]) // 2] == 2
        ):
            yield n


def A035523_gen():  # generator of terms
    yield 1
    l = 1
    while True:
        l += reversedigits(l, 3)
        yield l


def A037967(n):
    return comb(comb(2 * n, n) + 1, 2)


def A044460_gen(startvalue=0):
    return (
        n
        for n in count(max(startvalue, 0))
        if "02" in gmpy2digits(n, 5) and "02" not in gmpy2digits(n + 1, 5)
    )


def A045541_gen():  # generator of terms
    yield 2
    l = 2
    while True:
        l = int("".join(d for d in str(l**2) if not d in set(str(l))))
        yield l


def A046380_gen():  # generator of terms
    for x in pal10_gen():
        a = factorint(x)
        if sum(list(a.values())) == 6 and all(map(is_pal, a.keys())):
            yield x


def A045572(n):
    return 2 * (n + (n + 1) // 4) - 1


def A348480(n):
    if n == 1:
        return 1
    xn = 2 * (n + (n + 1) // 4) - 1
    for l in count(xn - 1):
        for d in multiset_permutations(["0"] * (l - xn + 1) + ["1"] * (xn - 1)):
            s = "1" + "".join(d)
            if gcd(int(s), int(s[::-1])) == xn:
                return int(s, 2)


def A046705_gen():
    return (
        n
        for n in (
            (10 ** (2 * l + 1) - 1) // 9 + d * 10**l
            for l in count(0)
            for d in (1, 2, 4, 6)
        )
        if isprime(n)
    )


def A051202_gen():  # generator of terms
    a2, a1 = 1, 1
    for n in count(3):
        a = abs(a1 + 2 * a2 - n)
        if a == 0:
            yield n
        a1, a2 = a, a1


def A053964_gen():  # generator of terms
    for l in count(1):
        for p in product(*["479"] * l):
            a, b = integer_nthroot(int("".join(p)), 2)
            if b:
                yield a


def A053965_gen():  # generator of terms
    for l in count(1):
        for p in product(*["479"] * l):
            n = int("".join(p))
            if is_square(n):
                yield n


def A054793(n):
    a, b = integer_nthroot(n, 4)
    return (
        n
        if n <= 1
        else A054793(a) ** 4 if b else n + 1 if (n - a**4) % 2 else (n - 1) ** 4
    )


def A059402_gen(startvalue=2):
    return (
        n
        for n in count(max(startvalue, 2))
        if n % 10
        and len(factorint(n)) > 1
        and all(str(a**b) in str(n) for a, b in factorint(n).items())
    )


def A061051(n):
    if n == 0:
        return 0
    nstart = 10 ** (n - 1)
    nend = 10 * nstart
    for i in range(nstart, nend):
        k = int(str(i) * 2)
        if is_square(k):
            return k
    for i in range(nstart, nend):
        si = str(i) * 2
        for sj in "014569":
            k = int(si + sj)
            if is_square(k):
                return k


def A062935_gen():  # generator of terms
    n = 1
    for i in count(1):
        n *= i
        s = str(n + 1)
        if s == s[::-1]:
            yield n + 1


def A065899(n):
    return compositepi(factorial(composite(n)) // primorial(primepi(composite(n))))


def A066467_gen(startvalue=1):
    return (n for n in count(max(startvalue, 1)) if antidivisor_count(n) == 2)


def A066469_gen(startvalue=1):
    return (n for n in count(max(startvalue, 1)) if antidivisor_count(n) == 4)


def A066472_gen(startvalue=1):
    return (n for n in count(max(startvalue, 1)) if antidivisor_count(n) == 6)


def A073954_gen(startvalue=1):
    return (n for n in count(max(startvalue, 1)) if antidivisor_sigma(n) > 2 * n)


def A074713_gen(startvalue=1):
    return (n for n in count(max(startvalue, 1)) if antidivisor_sigma(n) == totient(n))


def A074730_gen():
    return (n for n in (i**2 for i in count(1)) if is_square(antidivisor_sigma(n)))


def A076642(n):
    y = Poly(rf(6 * symbolx + 1, n)).all_coeffs()[::-1]
    return y.index(max(y))


def A350595(n):
    return sum(
        (-1 if (n + k) % 2 else 1) * comb(2 * n, k) ** n for k in range(2 * n + 1)
    )


def A082439_gen():  # generator of terms
    yield 3
    for i in count(1):
        s = str(i)
        n = int(s + "3" + s[::-1])
        if isprime(n):
            yield n


def A082617_gen():  # generator of terms
    yield 1
    a = 1
    while True:
        p = 2
        b = p * a
        bs = str(b)
        while bs != bs[::-1] or max(factorint(b).values()) > 1:
            p = nextprime(p)
            b = p * a
            bs = str(b)
        yield b
        a = b


def A082646_gen():  # generator of terms
    for i in count(1):
        p = str(prime(i))
        h = [p.count(d) for d in "0123456789" if d in p]
        if min(h) == max(h):
            yield int(p)


def A085375_gen():  # generator of terms
    b = 1
    for n in count(0):
        yield b
        b = b * 2 * (n + 5) * (2 * n + 3) // ((n + 1) * (n + 2))


def A090850_gen():  # generator of terms
    yield 0
    f, blist = 6, [0]
    while True:
        blist = [blist[0] + f] + list(map(add, blist[:-1], blist[1:])) + [1]
        yield from blist


def A096217_gen():  # generator of terms
    yield 1
    blist = [1]
    for n in count(2):
        b = sum(x for x in blist if gcd(x, n) == 1)
        blist.append(b)
        yield b


def A096488(n):
    return len(set(continued_fraction(sqrt((10**n - 1) // 9))[-1]))


def A097963_gen():
    return chain(
        (1,),
        accumulate(
            repeat(15),
            lambda x, _: x
            + 2
            + len(num2words(x, to="ordinal").replace(" and ", " ").replace(", ", " ")),
        ),
    )


def A101701_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if n == sum(int(d) for d in (str(x)[::-1] for x in divisors(n)))
    )


def A104476(n):
    return comb(n + 7, 7) * comb(n + 11, 7)


def A104476_gen():  # generator of terms
    m = [3432, -1716, 660, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330]
    while True:
        yield m[-1]
        for i in range(14):
            m[i + 1] += m[i]


def A105252(n):
    return comb(n + 5, n) * comb(n + 9, n)


def A105252_gen():  # generator of terms
    m = [2002, -4433, 3487, -1133, 127, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    while True:
        yield m[-1]
        for i in range(14):
            m[i + 1] += m[i]


def A105253(n):
    return comb(n + 6, n) * comb(n + 10, n)


def A105253_gen():  # generator of terms
    m = [8008, -22022, 23023, -11297, 2563, -209] + [1] * 11
    while True:
        yield m[-1]
        for i in range(16):
            m[i + 1] += m[i]


def A105943(n):
    return comb(n + 7, n) * comb(n + 10, 7)


def A105943_gen():  # generator of terms
    m = [3432, -3432, 1320, 0] + [120] * 11
    while True:
        yield m[-1]
        for i in range(14):
            m[i + 1] += m[i]


def A107337_gen():  # generator of terms
    yield 1
    blist, c = [1], 1
    while True:
        blist = list(
            chain.from_iterable(
                (
                    [1, 2, 1, 3, 2, 3, 1] if d == 1 else [3] if d == 2 else [1]
                    for d in blist
                )
            )
        )
        yield from blist[c:]
        c = len(blist)


def A107908_gen():  # generator of terms
    m = [21, -13, 3] + [1] * 5
    yield m[-1]
    while True:
        for i in range(7):
            m[i + 1] += m[i]
        yield m[-1]


def A108646_gen():  # generator of terms
    m = [77, -85, 28, -1, 1, 1, 1, 1]
    while True:
        yield m[-1]
        for i in range(7):
            m[i + 1] += m[i]


def A109351_gen(startvalue=2):
    return (
        n
        for n in count(max(startvalue, 2))
        if integer_nthroot(sum(antidivisors(n)), 3)[1]
    )


def A110690_gen():  # generator of terms
    m = [62, -65, 20, 0, 1, 1, 1, 1, 1]
    while True:
        yield m[-1]
        for i in range(8):
            m[i + 1] += m[i]


def A110693_gen():  # generator of terms
    m = [450, -816, 508, -121, 10, 1, 1, 1, 1, 1]
    while True:
        yield m[-1]
        for i in range(9):
            m[i + 1] += m[i]


def A113009(n):
    return sum(int(d) for d in str(n)) ** len(str(n))


def A113010(n):
    return len(str(n)) ** sum(int(d) for d in str(n))


def A115286_gen():  # generator of terms
    m = [120, -300, 272, -96, 8, 0, 0]
    while True:
        yield m[-1]
        for i in range(6):
            m[i + 1] += m[i]


def A116054_gen():  # generator of terms
    k, m = 1, 2
    for n in count(0):
        for i in range(k, m):
            s = str(i * n)
            if s == s[::-1]:
                yield i
        k, m = m, nextprime(m)


def A117790_gen():  # generator of terms
    yield 1
    a, b = 1, 3
    while True:
        if isprime(sum(int(d) for d in str(b))):
            yield b
        a, b = b, a + b


def A118548_gen():
    return (
        n
        for n in (x**2 for x in count(1))
        if not (str(n).count("0") or n % prod(int(d) for d in str(n)))
    )


def A118575_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if (m := A031347(n))
        and not (
            str(n).count("0")
            or n % ((1 + (n - 1) % 9))
            or n % m
            or n % sum(int(d) for d in str(n))
            or n % prod(int(d) for d in str(n))
        )
    )


def A350578_gen():  # generator of terms
    yield 0
    b, bcounter = 0, Counter({0})
    for n in count(1):
        b += -n if b - n >= 0 and bcounter[b - n] <= bcounter[b + n] else n
        bcounter[b] += 1
        yield b


def A350579(n):
    b, bcounter = 0, Counter({0})
    for m in count(1):
        if bcounter[b] == n:
            return b
        b += -m if b - m >= 0 and bcounter[b - m] <= bcounter[b + m] else m
        bcounter[b] += 1


def A122004_gen():  # generator of terms
    p = 2
    while True:
        if (
            0
            == sum(pow(prime(i), prime(j), p) for i in range(1, p) for j in range(1, p))
            % p
        ):
            yield p
        p = nextprime(p)


def A123373(n):
    return sum(prime(i) ** prime(j) for i in range(1, n + 1) for j in range(1, n + 1))


def A086787(n):
    return (
        1
        - digamma(n)
        - EulerGamma
        + sum(Fraction(i ** (n + 1), i - 1) for i in range(2, n + 1))
    )


def A128287_gen():  # generator of terms
    yield 1
    x, s = 1, 2
    for i in count(2):
        x = x * (4 * i - 2) // (i + 1)
        s += x
        if not (isprime(i) or s % i):
            yield i


def A130870_gen():  # generator of terms
    for i in pal10_odd_range_gen():
        if (
            i > 2
            and isprime(i)
            and max(factorint(i - 1).values()) > 1
            and max(factorint(i + 1).values()) > 1
        ):
            yield i


def A132365(n):
    a, b, m, s = 2, 1, 0, str(n)
    while True:
        if s in str(a):
            return m
        m += 1
        a, b = b, a + b


def A134009_gen():  # generator of terms
    yield 1
    b = 1
    while True:
        i, j = isqrt_rem(3 * b**2)
        b = i + int(4 * (j - i) >= 1)
        yield int(b)


def A135923_gen():  # generator of terms
    m = [1680, -840, -1380, -240, 641, 393, -209, -10, 0]
    yield m[-1]
    while True:
        for i in range(8):
            m[i + 1] += m[i]
        yield m[-1]


def A137079_gen():
    return (
        int("".join(a) + b)
        for l in count(0)
        for a in product("2356", repeat=l)
        for b in ("5", "6")
        if set(str(int("".join(a) + b) ** 2)) <= {"2", "3", "5", "6"}
    )


def A137093_gen():
    return (
        int("".join(a))
        for l in range(1, 10)
        for a in product("2456", repeat=l)
        if set(str(int("".join(a)) ** 2)) <= {"2", "4", "5", "6"}
    )


def A138584_gen():  # generator of terms
    for l in count(0):
        for d in product("35", repeat=l):
            s = "".join(d)
            n = int(s + "3" + s[::-1])
            if isprime(n):
                yield n
            n += 2 * 10**l
            if isprime(n):
                yield n


@lru_cache(maxsize=None)
def A140466(n):
    if n == 0:
        return 0
    c, j = 0, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * (A140466(k1) // 2 - 1)
        j, k1 = j2, n // j2
    return 2 * (n * (n - 1) - c + j)


def A145203_gen():
    return (
        primepi(3 * n * (n + 1) + 1) for n in count(0) if isprime(3 * n * (n + 1) + 1)
    )


def A145285(n):
    return (5, 8, 12, 16, 20, 25, 28, 32)[n - 1] if n <= 8 else 4 * n + 1


def A147773(n):
    i, j = iroot_rem(n**n, 3)
    return int(i + int(8 * j >= 6 * i * (2 * i + 1) + 1))


def A158215(n):
    if n == 1:
        return 11
    if n == 2:
        return 0
    p2 = prime(n) // 2
    l = p2
    while True:
        for i in combinations(range(l), l - p2):
            s = ["1"] * l
            for x in i:
                s[x] = "0"
            s = "".join(s)
            q = int(s + "1" + s[::-1])
            if isprime(q):
                return q
        l += 1


def A153568(n):
    (
        a,
        b,
    ) = (
        0,
        1,
    )
    for _ in range(n):
        a, b = b, a + b
    return (lambda m: 2 * sum(a // k for k in range(1, m + 1)) - m * m)(isqrt(a))


def A158962(n):
    m = 1
    while True:
        for i in range(n):
            if not isprime(int(str(m) * (i + 1)) - 1):
                break
        else:
            return m
        m += 1


def A160828_gen():  # generator of terms
    m = [96, 0, 80, 80, 98]
    while True:
        yield m[-1]
        for i in range(4):
            m[i + 1] += m[i]


def A160943(n):
    return n + sum(int(d) for d in str(n - 1)) + sum(int(d) for d in str(n + 1))


def A161354_gen():
    return (m for m in (n**3 for n in count(1)) if isprime(int(str(m)[::-1])))


@lru_cache(maxsize=None)
def A162459(n):
    if n == 0:
        return 0
    c, j = n, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * A162459(k1) // 2 ** (k1 - 1)
        j, k1 = j2, n // j2
    return 2 ** (n - 1) * (j - c)


def A167218_gen():  # generator of terms
    for l in count(1):
        plist = []
        l1, l2 = 10 ** (l - 1), 10**l
        m = isqrt(l1)
        if m**2 + 1 < l1:
            m += 1
        while (k := m**2 + 1) < l2:
            if k % 10:
                p = int(str(k)[::-1])
                if isprime(p):
                    plist.append(p)
            m += 1
        yield from sorted(plist)


def A167807_gen():  # generator of terms
    for i in count(3):
        n = i * (i + 1) * (2 * i + 1) // 6
        p2 = prevprime(n // 3)
        p1, p3 = prevprime(p2), nextprime(p2)
        q = p1 + p2 + p3
        while q <= n:
            if q == n:
                yield n
            p1, p2, p3 = p2, p3, nextprime(p3)
            q = p1 + p2 + p3


def A171642_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        d = divisors(n)
        s = sum(d)
        if s % 2 and 2 * n <= s and s == 3 * sum(x for x in d if x % 2):
            yield n


def A173102(n):
    return (9 * n**2 - (n % 2)) // 4


def A173208_gen():  # generator of terms
    yield 2
    a, b = 2, 3
    while True:
        if (
            max(factorint(b).values()) <= 1
            and max(factorint(b - 1).values()) <= 1
            and max(factorint(b + 1).values()) <= 1
        ):
            yield b
        a, b = b, a + b


@lru_cache(maxsize=None)
def A175549(n):
    if n == 0:
        return 0
    c, j = 0, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * A175549(k1)
        j, k1 = j2, n // j2
    return 4 * n * (n - 1) * (2 * n + 5) - c + 26 * (j - 1)


def A175583_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        d = divisors(n)
        s = sum(d)
        if not s % 2 and max(d) <= s // 2 and isprime(s // 2 - n):
            for x in range(1, 2 ** len(d)):
                if sum(Subset.unrank_binary(x, d).subset) == s // 2:
                    yield n
                    break


def A182578(n):
    m, tlist, s = n**n, [1, 2], 0
    while tlist[-1] + tlist[-2] <= m:
        tlist.append(tlist[-1] + tlist[-2])
    for d in tlist[::-1]:
        if d <= m:
            s += 1
            m -= d
    return s


def A185173(n):
    c = n * (n + 1) // 2
    for i in range(2, n + 1):
        for j in range(i + 1, n + 1):
            pset = set(range(2, n + 1)) - {i, j}
            for p in permutations(pset):
                q, rset, rl = [j, 1, i] + list(p), set(), 0
                for k in range(n):
                    r = 0
                    for l in range(n):
                        r += q[(k + l) % n]
                        if r not in rset:
                            rset.add(r)
                            rl += 1
                        if rl >= c:
                            break
                    else:
                        continue
                    break
                else:
                    c = rl
    return c


def A185267(n):
    p = prime(n)
    s = str(p)
    if s == s[::-1]:
        return p
    for i in range(1, len(s)):
        if s[i:] == s[-1 : i - 1 : -1]:
            return int(s + s[i - 1 :: -1])


def A185695(n):
    p, k, m = 2, 61**n, 10
    q, m2 = p % k, m % k
    while True:
        p = nextprime(p)
        while p >= m:
            m *= 10
            m2 = m % k
        q = (q * m2 + p) % k
        if q == 0:
            return p


def A185698(n):
    p, k, m = 2, 67**n, 10
    q, m2 = p % k, m % k
    while True:
        p = nextprime(p)
        while p >= m:
            m *= 10
            m2 = m % k
        q = (q * m2 + p) % k
        if q == 0:
            return p


def A187975_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if isqrt(2 * (n + 5) ** 2) - isqrt(2 * n**2) == 8
    )


def A188089_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if isqrt(3 * (n + 4) ** 2) - isqrt(3 * n**2) == 6
    )


def A188290_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if isqrt(5 * (n + 4) ** 2) - isqrt(5 * n**2) == 8
    )


def A192272_gen(startvalue=3):  # generator of terms
    for n in count(max(startvalue, 3)):
        if (n * antidivisor_count(n)) % sum(antidivisors(n, generator=True)) == 0:
            yield n


def A192276_gen(startvalue=3):
    return (
        n
        for n in count(max(startvalue, 3))
        if not n % sum(1 for d in range(2, n) if n % d and 2 * n % d in (d - 1, 0, 1))
    )


def A192892(n):
    return (
        1
        if n == 0
        else sum(
            1
            for m in product([0, 1], repeat=n**2)
            if (lambda x: x.det() == x.per())(Matrix(n, n, m))
        )
    )


def A194112(n):
    return sum(isqrt(8 * j**2) for j in range(1, n + 1))


def A194116(n):
    return sum(isqrt(13 * j**2) for j in range(1, n + 1))


def A194137(n):
    return sum(isqrt(6 * j**2) for j in range(1, n + 1))


def A194140(n):
    return n * (n + 1) // 2 + sum(isqrt(3 * j**2) for j in range(1, n + 1))


def A195349_gen():  # generator of terms
    s, p = 0, 1
    for k in count(1):
        d = divisor_count(k)
        s += d
        p *= d
        if p % s == 0:
            yield k


def A197194_gen():  # generator of terms
    m, k = [1] * 10, 1
    while True:
        yield k * m[-1]
        k *= 9
        for i in range(9):
            m[i + 1] += m[i]


def A198193(n):
    return sum((n - i) * int(j) for i, j in enumerate(bin(n)[2:]))


def A201009_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if primefactors(n)
        == primefactors(
            sum(int(n * e / p) for p, e in factorint(n).items()) if n > 1 else 0
        )
    )


def A205770(n):
    m = 100**n
    i = integer_nthroot(m, 5)[0]
    return i + int(32 * m >= (1 + 2 * i) ** 5)


def A038103_gen():
    return (
        int(s)
        for s in (gmpy2digits(n, 3) for n in count(0))
        if s in gmpy2digits(int(s), 3)
    )


def A350573_gen():
    return (n for n in count(0) if (s := gmpy2digits(n, 3)) in gmpy2digits(int(s), 3))


def A214332_gen():  # generator of terms
    yield 0
    blist, c = [0], 1
    while True:
        blist = list(
            chain.from_iterable(
                ([0, 1] if d == 0 else [2, 0, 2] if d == 1 else [] for d in blist)
            )
        )
        yield from blist[c:]
        c = len(blist)


def A216395(n):
    if n == 1:
        return 1
    c = 0
    for i in range(2 ** (n - 1) + 1, 2**n):
        s1, s2 = sorted(str(i)), sorted(str(divisor_sigma(i)))
        if len(s1) == len(s2) and s1 == s2:
            c += 1
    return c


def A216396(n):
    c = 0
    for i in range(2 ** (n - 1) + 1, 2**n):
        s1, s2 = sorted(str(i)), sorted(str(divisor_sigma(i) - i))
        if len(s1) == len(s2) and s1 == s2:
            c += 1
    return c


def A216873_gen():  # generator of terms
    n = 1
    for i in count(0):
        s = str(n)
        if sum(isprime(s.count(d)) for d in "0123456789") >= 9:
            yield i
        n *= 2


def A217186(n):
    l, x = [str(d) * n for d in range(10)], 1
    for m in count(0):
        s = str(x)
        for k in l:
            if k in s:
                return len(s)
        x *= 3


def A217191(n):
    if n == 1:
        return 1
    else:
        l, y, x = [str(d) * n for d in range(10)], 0, 1
        for m in count(1):
            s = str(x)
            for k in l:
                if k in s:
                    return len(s)
            y, x = x, y + x


def A217192(n):
    if n == 1:
        return 1
    else:
        l, y, x = [str(d) * n for d in range(10)], 2, 1
        for m in count(1):
            s = str(x)
            for k in l:
                if k in s:
                    return len(s)
            y, x = x, y + x


def A349576_gen():  # generator of terms
    blist = [1, 5]
    yield from blist
    while True:
        blist = [blist[1], sum(blist) // gcd(*blist) + 1]
        yield blist[-1]


def A225864_gen():  # generator of terms
    for l in count(1):
        plist, q = [p for p in [2, 3, 5, 7] if isprime(l - 1 + p)], (10**l - 1) // 9
        for i in range(l):
            for p in plist:
                r = q + (p - 1) * 10**i
                if not isprime(r):
                    yield r


def A226019_gen():  # generator of terms
    yield 2
    for l in count(1):
        plist = []
        l1, l2 = 10 ** (l - 1), 10**l
        m = isqrt(l1)
        if m**2 < l1:
            m += 1
        while (k := m**2) < l2:
            if k % 2:
                p = int(bin(k)[-1:1:-1], 2)
                if isprime(p):
                    plist.append(p)
            m += 1
        yield from sorted(plist)


def A228000(n):
    return min(factorint(144396166620968 * n + 1))


def A228295(n):
    return 0 if n == 0 else 1 + integer_nthroot(12 * n**4, 4)[0]


def A235164_helper(n, b):
    if n == 1:
        t = list(range(1, b))
        for i in range(1, b):
            u = list(t)
            u.remove(i)
            yield i, u
    else:
        for d, v in A235164_helper(n - 1, b):
            for g in v:
                k = d * b + g
                if not k % n:
                    u = list(v)
                    u.remove(g)
                    yield k, u


def A235164_gen():
    return (a for n in count(2, 2) for a, b in A235164_helper(n - 1, n))


def A239437(n):  # requires 3 <= n <= 62
    m = n
    while True:
        s = "".join(gmpy2digits(i, m) for i in range(m))
        for d in permutations(s, m):
            if d[0] != "0":
                c = mpz("".join(d), m)
                for b in range(3, n):
                    if len(set(gmpy2digits(c, b))) == b:
                        break
                else:
                    return int(c)
        m += 1


def A239638_gen():  # generator of terms
    p = 5
    while True:
        if (p % 6) == 5:
            n = (p - 1) // 2
            if pow(2, n, p) == 1 and isprime((2**n - 1) // p):
                yield n
        p = nextprime(p)


def A239942(n):
    return factorial(prime(n)) - factorial(prime(n - 1))


def A240975(n):
    return len(primefactors(n**3 - 1))


def A242028_gen():
    return filter(lambda n: lcm(*antidivisors(n)) < n, count(3))


def A242092_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if primefactors(n) == primefactors(int(str(prime(n))[::-1]))
    )


def A242347_gen():
    yield 1
    l = 2
    while True:
        l = int(bin(l)[2:])
        yield len(str(l))


def A242930_gen():
    return filter(
        isprime, (a for a, b in (divmod(k**2 + 7, 11) for k in count(1)) if b == 0)
    )


def A243097_gen():  # generator of terms
    for n in count(1):
        if n % 10:
            s1 = str(n)
            s2 = s1[::-1]
            if s1 != s2 and not n % int(s2):
                yield sum(int(d) for d in s1)


def A243112_gen():  # generator of terms
    yield 0
    a = 0
    for n in count(1):
        s = bin(n)[2:]
        b = sum(s[i:].count("0") for i, d in enumerate(s, start=1) if d == "1")
        if b > a:
            yield n
            a = b


def A243298_gen():  # generator of terms
    m = [362880, -1491840, 2464560, -2082240, 945000, -220248, 22560, -680, 1, -1]
    for n in count(1):
        for i in range(9):
            m[i + 1] += m[i]
        if isprime(m[-1]):
            yield n


def A244444_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if len(set(str(n + sum(divisors(n))))) == 1
        and str(n + sum(divisors(n)))[0] == "1"
    )


def A245048_gen():
    return filter(lambda p: isprime(p**2 + 28), (prime(n) for n in count(1)))


def A245061_gen():
    return (p for n, p in enumerate(prime(n) for n in count(1)) if is_square(p - n - 1))


def A245199_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if is_square(int(divisor_count(n))) and is_square(int(totient(n)))
    )


def A245202_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if is_square(int(divisor_count(n) + totient(n)))
    )


def A245270(n):
    return int("".join(bin(y)[2:] for x in sorted(factorint(n).items()) for y in x), 2)


def A246666_gen(startvalue=1):
    return (
        n for n in count(max(startvalue, 1)) if isprime(3 * n * (n * (n + 4) + 10) + 28)
    )


def A246757(n):
    for i in range(10**n - 1, int("1" * n) - 1, -1):
        pd = prod(int(d) for d in str(i))
        if pd and not i % pd:
            return i


def A246763_gen():
    yield 1
    c = 1
    for n in count(2):
        c = c * (4 * n - 2) // (n + 1)
        yield c**2 % prime(n)


def A247000(n):
    maxcount = 0
    for i in range(2 ** (n - 1), 2**n):
        s = format(i, "0" + str(n) + "b")
        s, plist = s + s[:-1], []
        for j in range(n):
            for k in range(n):
                t = s[j : j + k + 1]
                if t == t[::-1] and not t in plist:
                    plist.append(t)
        if len(plist) > maxcount:
            maxcount = len(plist)
    return maxcount


def A247048_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        if not (isprime(n) or isprime(n + 2)):
            m = sum(p * e for p, e in factorint(n).items())
            if isprime(m):
                m2 = sum(p * e for p, e in factorint(n + 2).items())
                if ((m2 == m + 2) or (m == m2 + 2)) and isprime(m2):
                    yield n


def A247108_gen():  # generator of terms
    yield 1
    blist = [1]
    while True:
        blist = list(accumulate([-blist[-1]] + blist))
        yield from blist


def A247213_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if n <= 1 or not prod((p + 2) ** e for p, e in factorint(n).items()) % n
    )


def A247592_gen():  # generator of terms
    blist, m, c = [2], 2, 2
    for n in count(1):
        m += 2 * n + 1
        if is_prime(m):
            if is_square(m % blist[-1]):
                yield c
            blist.append(m)
            c += 1


def A247650_gen():  # generator of terms
    yield 1
    blist, g, f = (
        [1],
        1,
        (
            (1 / symbolx**2 + 1 / symbolx + 1 + symbolx + symbolx**2)
            * (1 / symboly**2 + 1 / symboly + 1 + symboly + symboly**2)
        ).expand(modulus=2),
    )
    for n in count(1):
        s = [int(d, 2) for d in bin(n)[2:].split("00") if d != ""]
        g = (g * f).expand(modulus=2)
        if len(s) == 1:
            blist.append(g.subs([(symbolx, 1), (symboly, 1)]))
        else:
            blist.append(prod(blist[d] for d in s))
        yield blist[-1]


def A248587_gen():  # generator of terms
    for i in count(3):
        n = i**3
        p3 = prevprime(n // 4)
        p2, p4 = prevprime(p3), nextprime(p3)
        p1 = prevprime(p2)
        q = p1 + p2 + p3 + p4
        while q <= n:
            if q == n:
                yield p1
            p1, p2, p3, p4 = p2, p3, p4, nextprime(p4)
            q = p1 + p2 + p3 + p4


def A248705_gen():  # generator of terms
    x, m = 0, [6, -6, 1, 0]
    while True:
        for i in range(3):
            m[i + 1] += m[i]
        xn = prod(int(d) for d in str(m[-1]))
        if xn > x:
            x = xn
            yield m[-1]


def A249586_gen():  # generator of terms
    yield 0
    m = [
        119750400,
        -658627200,
        1546776000,
        -2020606560,
        1602266400,
        -789354720,
        237304980,
        -40965390,
        3576156,
        -120849,
        784,
        0,
        0,
    ]
    while True:
        for i in range(12):
            m[i + 1] += m[i]
        yield m[-1]


def A350037(n):
    return pow(n, 2, (m := isqrt(n)) + int(4 * n >= (2 * m + 1) ** 2))


def A350046_gen():  # generator of terms
    f = Counter()
    for m in count(2):
        f += Counter(factorint(m))
        e = sorted(f.items())
        if all(
            d <= 1 or isprime(d)
            for d in (abs(e[i + 1][1] - e[i][1]) for i in range(len(e) - 1))
        ):
            yield m


def A249610_gen():  # generator of terms
    m = [48, -56, 13, 1]
    while True:
        for i in range(3):
            m[i + 1] += m[i]
        if isprime(m[-1]):
            yield m[-1]


def A249627(n):
    return min(fs := factorint((10**n - 1) // 9)) * max(fs)


def A249875_gen():  # generator of terms
    x = 1
    while True:
        yield 2 * sum(divmod(isqrt(2 * x), 2)) ** 2 + x
        x *= 4


def A251853_gen():
    (
        int("".join(d))
        for d in product("02468", repeat=4)
        if not sum(int(y) for y in str(sum(int(x) for x in d))) % 2
    )


def A253295_gen():  # generator of terms
    yield 8
    b = 8
    while True:
        b = int("".join((str(e) + str(p) for p, e in sorted(factorint(b).items()))))
        yield b


def A253549(n):
    p = prime(n)
    for b in range(2, 17):
        x, y, z = p, 0, 1
        while x >= b:
            x, r = divmod(x, b)
            y += r * z
            z *= 16
        y += x * z
        if isprime(y):
            return y


def A253575_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if set(str(n)) & set(str(n**6)) == set() and isprime(n)
    )


def A253578_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if set(str(n)) & set(str(n**10)) == set() and isprime(n)
    )


def A253671_gen():  # generator of terms
    yield 1
    blist, l1, l2 = (0, 1), 1, 1
    while True:
        l2, l1 = l1, (blist := tuple(accumulate(reversed(blist), initial=0)))[-1]
        yield l1 // l2


def A253769(n):
    return (lambda m, p: 2 * sum(p // k for k in range(1, m + 1)) - m * m)(
        isqrt(prime(n)), prime(n)
    )


def A253912_gen():
    return (n for n in (i**4 for i in range(10**6)) if isprime(int(str(n)[::-1])))


def A254058(n):
    b, a1, a2, t = 1, 0, n, 2**n
    while b < t:
        a2 += 1
        a1 += 1
        b = (b * a2) // a1
    return a2


def A254625_gen():  # generator of terms
    c0, c1, c2 = 1, 8, 27
    for n in count(1):
        if max(c0, c1, c2) < n:
            yield n
        c0, c1, c2 = c1, c2, A007913(n + 3) ** 3


def A254648_gen(startvalue=10):  # generator of terms
    for n in count(max(startvalue, 10)):
        m = str(n**2)
        for a in combinations(range(1, len(m)), 2):
            x, y, z = int(m[: a[0]]), int(m[a[0] : a[1]]), int(m[a[1] :])
            if y != 0 and z != 0 and x + y + z == n:
                yield n
                break


def A254746_gen():  # generator of terms
    yield 1
    c, s, s2 = {}, 2, 4
    for n in count(2):
        for p, e in factorint(4 * n - 2).items():
            if p in c:
                c[p] += e
            else:
                c[p] = e
        for p, e in factorint(n + 1).items():
            if c[p] == e:
                del c[p]
            else:
                c[p] -= e
        if n == s2:
            d, ps = 1, prime(s)
            for p, e in c.items():
                d = (d * pow(p, e, ps)) % ps
            yield d
            s2 += 2 * s + 1
            s += 1


def A254999_gen():
    return (
        n
        for n, m in (
            (4 * k + 2, divisor_sigma_mod(4 * k + 2, 4 * k + 2)) for k in count(0)
        )
        if m and not n % m
    )


def A255400(n):
    f, i, s = 1, 0, re.compile("[0-9]*[1-9]0{" + str(n) + "}[1-9][0-9]*")
    while s.match(str(f) + "1") is None:
        i += 1
        f *= i
    return i


def A255911_gen():  # generator of terms
    blist, c, m = [], 0, 0
    for i in count(1):
        d = divisor_count(i)
        if d > m:
            m = d
            blist.append(i)
            for j in range(c - 1, -1, -1):
                q, r = divmod(i, blist[j])
                if not r:
                    yield q
                    break
            c += 1


def A256370_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if is_prime(5 * n * (n * (n * (n + 8) + 36) + 80) + 354)
    )


def A256969_gen():  # generator of terms
    c, bn, bd = 0, 1, 1
    for k in count(1):
        p = prime(k)
        bn *= p
        bd *= p - 1
        while bn > c * bd:
            yield k
            c += 1


def A256985(n):
    ilist, k = [1] * (n + 1), 1
    jlist = [d % 10 for d in accumulate(ilist)]
    jlist = [jlist[-1]] + jlist[:-1]
    while ilist != jlist:
        k += 1
        jlist = [d % 10 for d in accumulate(jlist)]
        jlist = [jlist[-1]] + jlist[:-1]
    return k


def A257002_gen():
    return (p for p in (prime(n) for n in count(1)) if pow(p, p, p + 2) == p)


def A258231_gen(startvalue=0):
    return (
        n for n in count(max(startvalue, 0)) if n % 10 and set(str(n)) == set(str(n**2))
    )


def A258456_gen(startvalue=1):
    return (
        i
        for i in count(max(startvalue, 1))
        if not integer_nthroot(i, 4)[1] and divisor_count(i) % 4
    )


def A258786_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if sorted(str(n)) == sorted(str(sum(antidivisors(n))))
    )


def A260031(n):
    return int(gmpy2digits(n**n, 12).rstrip("0")[-1], 12)


def A260375_gen():  # generator of terms
    yield 0
    g = 1
    for i in count(1):
        g *= i
        s = isqrt(g)
        t = g - s**2
        if is_square(t if t - s <= 0 else 2 * s + 1 - t):
            yield i


def A260534_T(n, k):
    return sum(0 if ~(k - j) & j else n**j for j in range(k + 1))


def A260597_gen():  # generator of terms
    bset = set()
    for n in count(1):
        m = primefactors(
            int(
                "".join(
                    [str(d) for d in range(1, n + 1)]
                    + [str(d) for d in range(n - 1, 0, -1)]
                )
            )
        )
        for p in m:
            if not p in bset:
                bset.add(p)
                yield p


def A260796_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if isprime(sum(int(d) for d in str(prime(n)) + str(prime(n + 1))))
    )


def A261175_gen():  # generator of terms
    n = 1
    for i in count(0):
        n *= i**i
        yield len(str(n))


def A261534_gen():  # generator of terms
    for m in pal_gen(3):
        n = int(gmpy2digits(m, 3))
        if n > 0 and not isprime(n) and (s := str(divisor_prod(n))) == s[::-1]:
            yield n


def A261593_gen():  # generator of terms
    for l in count(10):
        for c in multiset_permutations("0" * (l - 10) + "1" * 10, l):
            n = 2 * int("1" + "".join(c), 2)
            if sum(int(d) for d in format(n * (n + 2), "b")) == 11:
                yield n + 1


def A261694_gen():  # generator of terms
    (
        a,
        b,
    ) = (
        0,
        1,
    )
    while True:
        yield a
        a, b = b, (a + b) % 21


def A261749_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if sorted(str(n**2)) == sorted(str((n + 2) ** 2))
    )


def A262776(n):
    if n < 2:
        return 0
    a, b, m = 0, 1, factorial(fibonacci(n))
    for i in range(factorial(n) - 1):
        b, a = (b + a) % m, b
    return b


def A350577_gen():  # generator of terms
    p = 2
    while True:
        s = bin(p)[2:]
        c, l = 0, len(s)
        for i in range(l):
            c += int(s[l - i - 1])
            if 2 * c <= i:
                break
        else:
            yield p
        p = nextprime(p)


def A262814_gen(startvalue=1):  # generator of terms
    for k in count(max(startvalue, 1)):
        n = k**k
        if not n % k:
            s = str(n)
            for i in range(len(s) - 1):
                s = s[1:] + s[0]
                if int(s) % k:
                    break
            else:
                yield k


def A263400(n):
    b, a = fib2(n)
    s, m = gmpy2digits(b), n
    while True:
        a, b, m = b, a + b, m + 1
        t = gmpy2digits(b)
        if b > a and s in t:
            return m


def A263457_gen(startvalue=1):  # generator of terms
    s = 0
    for n in count(1):
        s += divisor_count(n)
        if is_square(8 * s + 1):
            yield n


def A266001_gen():
    return (
        j
        for j in (
            int(format(i, "b"), 3) + (3**n - 1) // 2
            for n in range(1, 10)
            for i in range(2**n)
        )
        if "0" not in gmpy2digits(j, 4)
    )


def A267140(n):
    u, r, k, m = 2 * n + 1, 4 * n * (n + 1) + 1, 0, 2 * n + 1
    while True:
        if is_square(8 * m + r):
            return m
        k += 2
        m += u + k


def A267767_gen():
    return (int(s, 7) for s in (str(i**2) for i in count(0)) if max(s) < "7")


def A267818_gen():
    return (
        int(d, 4)
        for d in (str(i**2) for i in count(1))
        if max(d) < "4" and isprime(int(d, 4))
    )


def A267982_gen():  # generator of terms
    yield 0
    b = 4
    for n in count(1):
        yield b
        b = b * 4 * (n + 1) * (2 * n + 1) ** 2 // (n * (n + 2) ** 2)


def A268045(n):
    if n == 0:
        return 2
    flist, k = Counter(factorint((n + 2) * (n + 1) // 2)), 2
    while max(flist.values()) >= 2:
        k += 1
        flist += Counter(factorint(n + k))
        flist -= Counter(factorint(k))
    return k


def A268140(n):
    p, n2 = 2, 2**n + 1
    while True:
        for i in range(1, n2):
            if isprime(p + i):
                p += i
                break
        else:
            return p


def A268304_gen():  # generator of terms
    b, m1, m2 = (
        15,
        [
            21941965946880,
            -54854914867200,
            49244258396160,
            -19011472727040,
            2933960577120,
            -126898662960,
            771887070,
            385943535,
            385945560,
        ],
        [
            10569646080,
            -25763512320,
            22419210240,
            -8309145600,
            1209116160,
            -46992960,
            415800,
            311850,
            311850,
        ],
    )
    for n in count(0):
        if b % 8 == 7:
            yield 2 * n + 1
        b = b * m1[-1] // m2[-1]
        for i in range(8):
            m1[i + 1] += m1[i]
            m2[i + 1] += m2[i]


def A269903_gen():  # generator of terms
    p = 1
    for i in count(2):
        p = (p * prime(i)) % 8
        if p == 7:
            yield i


def A269927_gen():  # generator of terms
    yield 0
    blist, c = [0], 1
    while True:
        ylist = [1 - d for d in blist]
        zlist = list(blist)
        for i in blist:
            if i:
                zlist += blist
            else:
                zlist += ylist
        blist = zlist
        yield from blist[c:]
        c = len(blist)


def A270440_gen():  # generator of terms
    b = 8
    for n in count(0):
        q, r = integer_nthroot(b + 1, 2)
        yield (q + 1) // 2 + (0 if r else 1)
        b = b * 2 * (2 * n + 1) // (n + 1)


def A271327_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        p, a, b = prime(n), 1, 1
        for i in range(n):
            if not a:
                yield n
                break
            a, b = b, (a + b) % p


def A271899_gen():  # generator of terms
    m = [88, -128, 61, -8] + [1] * 5
    while True:
        yield m[-1]
        for i in range(8):
            m[i + 1] += m[i]


def A272383_gen(startvalue=78):  # generator of terms
    for i in count(max(startvalue + (78 - startvalue % 78) % 78, 78), 78):
        for d in divisors(i):
            if d not in (1, 2, 6, 78) and isprime(d + 1):
                break
        else:
            yield i


def A272673_gen():
    return chain(
        (0,),
        (
            int(str(m**2)[1:]) if sum(int(d) for d in str(m**2)[1:]) != 1 else 0
            for m in count(4)
            if str(m**2)[0] == "1"
        ),
    )


def A272890_gen(startvalue=3):
    return (
        n
        for n in count(max(startvalue, 3))
        if sum(Fraction(n, a) for a in antidivisors(n)).denominator == 1
    )


def A274951_gen():  # generator of terms
    a, b = 8, 12
    yield from [a, b]
    for i in count(0):
        c, d = divmod(b**2, a)
        a, b = b, c + (0 if 2 * d < a else 1)
        yield b


def A275465(n):
    p = min(primefactors(n))
    return p ** (n // p)


def A275544_gen():  # generator of terms
    yield 1
    c = [Fraction(0, 1)]
    while True:
        c = set(e for d in c for e in (3 * d + 1, d / 2))
        yield len(c)


def A275628_gen():  # generator of terms
    a, b = 31, 51
    yield from [a, b]
    for i in count(0):
        c, d = divmod(b**2, a)
        a, b = b, c + (0 if 2 * d < a else 1)
        yield b


def A276389_gen():  # generator of terms
    yield 0
    m = 1
    for n in count(1):
        m *= n
        s, h = str(m), hex(m)
        if not len(s) - len(s.rstrip("0")) + len(h.rstrip("0")) - len(h):
            yield n


def A276460_gen():  # generator of terms
    yield 0
    for m in count(0):
        k = m**2 + 1
        for d in divisors(k):
            if d > m:
                yield k
                break
            if not is_square(k // d - d):
                break


def A276756_gen():
    return chain(
        (1,),
        (
            n
            for n in count(2)
            if max(factorint(n).values()) <= 1
            and sum(Fraction(p, 10 ** len(str(p))) for p in primefactors(n)).denominator
            == 1
        ),
    )


def A277692(n):
    return (
        sum(1 for c in divisors(n - 1) if c < n - 1 and not (n * (n - 1) // 2) % c)
        if n != 2
        else 1
    )


def A277937(n):
    return sum(1 for d in bin(n)[2:].split("0") if len(d) == 1)


@lru_cache(maxsize=None)
def A278049(n):
    if n == 0:
        return -1
    c, j = 0, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * (2 * A278049(k1) - 1) // 3
        j, k1 = j2, n // j2
    return 3 * (n * (n - 1) - c + j) // 2 - 1


def A280056(n):
    return (n**2 - (n % 2)) * (n - 1) * (n - 2) // 2


def A280660(n):
    m, k, l = 10**n, 1, 2
    while True:
        if 2 * str(l).count("9") >= n:
            return k
        k += 1
        l = (l * 2) % m


def A280717_gen():  # generator of terms
    yield 3
    n = 3
    while True:
        for i in range(1, n // 2 + 1):
            j = i**2 + n * (n - i)
            if isprime(j):
                n = j
                yield n
                break


def A286328(n):
    p, area = prime(n), 0
    k, q, kq = (p + 1) // 2, (p**2 - 1) // 2, (p - 1) * (p + 1) ** 2 // 4
    while True:
        area += kq
        if is_square(area):
            return k
        k += 1
        kq += q


def A287298(n):  # assumes 2 <= n <= 62
    m = isqrt(mpz("".join(gmpy2digits(i, n) for i in range(n - 1, -1, -1)), n))
    m2 = m**2
    d = gmpy2digits(m2, n)
    while len(set(d)) < len(d):
        m -= 1
        m2 -= 2 * m + 1
        d = gmpy2digits(m2, n)
    return m2


def A287609_gen():  # generator of terms
    p, q, r = 2, 3, 5
    while True:
        n = p * (q + r) + q * r
        m = n // 3
        pm, nm = prevprime(m), nextprime(m)
        k = n - pm - nm
        if isprime(m):
            if m == k:
                yield n
        else:
            if nextprime(nm) == k or prevprime(pm) == k:
                yield n
        p, q, r = q, r, nextprime(r)


def A287686_gen():  # generator of terms
    p2, q2, r2, r = 4, 9, 25, 5
    while True:
        n = p2 + q2 + r2
        m = n // 3
        pm, nm = prevprime(m), nextprime(m)
        k = n - pm - nm
        if isprime(m):
            if m == k:
                yield n
        else:
            if nextprime(nm) == k or prevprime(pm) == k:
                yield n
        s = nextprime(r)
        p2, q2, r2, r = q2, r2, s**2, s


def A288507(n):
    k, p, q = 1, 2, 3
    while True:
        if sum(factorint(q - p).values()) == n and sum(factorint(q + p).values()) == n:
            return k
        k += 1
        p, q = q, nextprime(q)


def A289829_gen(startvalue=0):  # generator of terms
    a, b = integer_nthroot(startvalue, 2)
    for n in count(max(a + (1 - int(b)), 0)):
        m = n**2 - 1
        for d in divisors(m):
            if d * d >= m:
                break
            r = m // d
            if not r % 2:
                r = r // 2
                if not isprime(r):
                    p, q = prevprime(r), nextprime(r)
                    if m == (q - p) * (q + p):
                        yield n**2
                        break


def A291175_gen():  # generator of terms
    a, b, c = 1, 1, 2
    for n in count(3):
        if c == a + b:
            yield n
        a, b, c = b, c, reduced_totient(n + 1)


def A291199_gen():  # generator of terms
    p = 3
    while True:
        if is_square(8 * (p - 1) * totient((p + 1) // 2) + 1):
            yield p
        p = nextprime(p)


def A292995(n):
    return sum(int(d) for d in str(3**n)) // 9


def A294092_gen():  # generator of terms
    m = 59
    for k in count(119, 120):
        if pow(2, m, k) == 1 and pow(3, m, k) == 1 and pow(5, m, k) == 1:
            yield k
        m += 60


def A295430(n):
    m = 2 * n
    while True:
        if str(m)[0] == "3":
            return m
        m += n


def A295900_gen(startvalue=1):
    return (n for n in count(max(startvalue, 1)) if "2357" in str(n**3))


def A296516(n):
    P, Q = {(1, 0)}, {(0, 1)}
    for _ in range(n):
        P, Q = P | Q, set((p[0] + q[0], p[1] + q[1]) for p in P for q in Q)
    return len(Q)


def A297624_gen():  # generator of terms
    b, c, aflag = 1, 2, False
    for k in count(1):
        cflag = isprime(c)
        if aflag and cflag:
            yield k
        b, c, aflag = b + c, b + 2 * c, cflag


def A297815(n):
    f = factorial(n)
    return sum(
        f // prod(factorial(d.count(a)) for a in set(d))
        for d in combinations_with_replacement(range(1, 10), n)
        if prod(d) == sum(d)
    )


def A298077_gen():
    return (
        m
        for m in (n * (n + 1) for n in count(3))
        if prevprime(m // 2) + nextprime(m // 2) == m
    )


def A298940(n):
    if n == 1:
        return 1
    try:
        return discrete_log(3**n - 2, -1, 3)
    except ValueError:
        return 0


def A299300_gen():  # generator of terms
    p, d, n, r = 2, -1, 0, False
    while True:
        pn, k = p - n, d if r else -d
        if 0 < k <= pn:
            yield n + k
        d += -pn if r else pn
        r, n, p = not r, p, nextprime(p)


def A300817(n):
    p, n2 = 2, n**2
    if n % 2:
        return 2 if isprime(2 + n2) else 0
    while not isprime(p + n2):
        p = nextprime(p)
    return p


def A300902_gen():  # generator of terms
    yield 1
    m = 1
    for n in count(1):
        m *= n
        yield m
        if isprime(n):
            m //= n


def A302292(n):
    s = set()
    for i in range(1, (n + 3) // 2):
        for j in divisors(i):
            for k in divisors(n - i):
                if j != k:
                    s.add((min(j, k), max(j, k)))
    return divisor_count(n) + 2 * len(s) - 1


def A302293(n):
    s = set()
    for i in range(1, n):
        for j in divisors(i):
            if integer_nthroot(j, 2)[1]:
                for k in divisors(n - i):
                    s.add((j, k))
    return len(s)


def A304290_gen(startvalue=0):
    return (k for k in count(max(startvalue, 0)) if str(k - 1) in str(k**2))


def A305378(n):
    m, tlist, s = 2 * n + 1, [1, 2, 4], 0
    while tlist[-1] + tlist[-2] + tlist[-3] <= m:
        tlist.append(tlist[-1] + tlist[-2] + tlist[-3])
    for d in tlist[::-1]:
        s *= 2
        if d <= m:
            s += 1
            m -= d
    return s


def A305884_gen():  # generator of terms
    blist, n, m = [], 1, 1
    while True:
        for l in range(1, len(blist) + 1):
            for d in multiset_combinations(blist, l):
                if integer_nthroot(sum(d) + m, 2)[1]:
                    break
            else:
                continue
            break
        else:
            blist.append(m)
            yield m
            continue
        n += 1
        m += 2 * n - 1


def A306043_gen():  # generator of terms
    blist, n, m = [], 1, 1
    while True:
        for l in range(1, len(blist) + 1):
            for d in combinations(blist, l):
                if integer_nthroot(sum(d) + m, 2)[1]:
                    break
            else:
                continue
            break
        else:
            blist.append(m)
            yield m
        n += 1
        m += 2 * n - 1


def A306384(n):
    mset, m, c = set(), n, 0
    while True:
        if m == 1 or m == 0 or m == 5:
            return c
        m = int(
            "0"
            + "".join(
                d
                for d in split(
                    "(0+)|(1+)|(2+)|(3+)|(4+)|(5+)|(6+)|(7+)|(8+)|(9+)", str(2 * m)
                )
                if d != "" and d != None and len(d) == 1
            )
        )
        if m in mset:
            return -1
        mset.add(m)
        c += 1


def A306540(n):
    if n == 1 or n == 10:
        return 1
    k, nk = 1, n
    while True:
        s = str(nk)
        if s[:2] == "99" or s[:3] == "100":
            return k
        k += 1
        nk *= n


def A306572_gen():
    return (
        n
        for n, p in enumerate(primepi(k) for k in count(0))
        if n > 0 and n % 10 ** len(str(p)) == p
    )


def A307636_gen():
    return filter(
        lambda n: all(
            len(set(s[0]) & set(s[1])) == 0
            for s in combinations((str(d) for d in divisors(n, generator=True)), 2)
        ),
        count(1),
    )


def A308438(n):
    l, p = 1, nextprime(n)
    while True:
        q = nextprime(p)
        if q - p == 2 * n:
            return p
        p = q
        if p >= (n + 1) * l:
            l *= 10
            p = nextprime(n * l)


def A308439(n):
    return min(
        primefactors(
            1 + prod(prime(i + 1) for i, j in enumerate(bin(n)[:1:-1]) if j == "1")
        )
    )


def A308575(n):
    n2, t1 = 2 ** (n - 1), 0
    k = n2 - 1
    kp = primepi(k)
    kp2 = primepi(k + n2) - kp
    while kp2 < kp or t1 >= kp:
        k += n2
        t1, t2 = kp, kp2
        kp2 = primepi(k + n2) - kp2
        kp = t2
    return 2 * kp


def A308777(n):
    if n == 1:
        return 1
    c, p = 0, prime(n)
    p2, x = p**2, [prevprime(p), p, nextprime(p)]
    while x[1] <= p2:
        if x[1] - x[0] == 2 or x[2] - x[1] == 2:
            c += 1
        x = x[1:] + [nextprime(x[2])]
    return c


def A308935(n):
    n2, m, m2 = (
        n**2 * (n**2 + 1),
        n + 1,
        ((n + 1) ** 2 * ((n + 1) ** 2 + 1)) % (n**2 * (n**2 + 1)),
    )
    while m2:
        m2, m = (m2 + 2 * (2 * m + 1) * (m**2 + m + 1)) % n2, (m + 1) % n2
    return m


def A309388_gen():  # generator of terms
    y, w = 1, 0
    while True:
        w += y
        z = 0
        for x in range(1, y + 1):
            z += x
            if is_square(8 * (w + z) + 1):
                break
        else:
            yield y
        y += 1


def A309387(n):
    return gcd(n**2, harmonic(n - 1).p)


def A309851_gen():
    return (m for m in (int(str(n) + str(2 * n - 1)) for n in count(1)) if isprime(m))


def A317977(n):
    m = 2**n - 1
    c = 4 % m
    for _ in range(n - 2):
        c = (c**2 - 2) % m
    return c


def A318157_gen():  # generator of terms
    for n in count(2):
        if not (isprime(n) or isprime(n + 1) or isprime(n + 2) or isprime(n + 3)):
            if isprime(4 * n + 5):
                yield 4 * n + 5
            if isprime(4 * n + 7):
                yield 4 * n + 7


def A318972(n):
    return (
        (7 * n + 1) // 4 if n % 4 == 1 else (7 * n - 1) // 4 if n % 4 == 3 else n // 2
    )


def A319228(n):
    c, b, b2, n10 = 0, 1, 3, 10**n
    while b <= n10:
        if isprime(b2):
            c += 1
        b += 1
        b2 += 2 * b
    return c


def A320909_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if isprime(int(str(n**2)[::-1])) and isprime(int(str(n**3)[::-1]))
    )


def A320920(n):
    w, m = int(factorial(n)), n
    bc = [comb(n - 1, i) % w for i in range(n + 1)]
    while True:
        bc[n] = (bc[n - 1] + bc[n]) % w
        if bc[n] == 0:
            return m
        for i in range(n - 1, 0, -1):
            bc[i] = (bc[i - 1] + bc[i]) % w
        m += 1


def A321685(n):
    return Matrix(n, n, [composite(i) for i in range(1, n**2 + 1)]).det()


def A322250(n):
    s = bin(2 * n - 1)[2:].rstrip("1")
    return int(s, 2) if s != "" else 1


def A322743(n):
    i = 4 if n <= 1 else 2**n + 1
    j = 1 if n <= 2 else 2
    while True:
        if not isprime(i):
            c = 0
            for m in range(len(bin(i)) - 2):
                if isprime(i ^ (2**m)):
                    c += 1
                if c > n:
                    break
            if c == n:
                return i
        i += j


def A323026_gen():
    return (
        n
        for n in (
            int("".join(s)) for l in count(9) for s in permutations("123456789", l)
        )
        if isprime(n - 1) and isprime(n + 1)
    )


def A323062_gen(startvalue=1):
    return (
        k
        for k in count(max(startvalue, 1))
        if (2 * isqrt(2 ** (2 * k - 1)) - 1) ** 2 > 1 + 4 * (2 ** (2 * k - 1) - 2**k)
    )


def A323278_gen():  # generator of terms
    p, nmax = 2, -1
    while True:
        n = divisor_count(p**2 - 1)
        if n > nmax:
            nmax = n
            yield p**2 - 1
        p = nextprime(p)


def A324309(n):
    m, k = 2, 2**n
    while True:
        s = str(k)
        for i in range(1, len(s)):
            if s[i] == s[i - 1]:
                return m
        m += 1
        if m % 10 == 0:
            m += 1
        k = m**n


def A328131(n):
    s, tlist = str(n), ("2468", "369", "468", "5", "689", "7", "8", "9")
    dset = set(
        "0"
        + "".join(
            t if t[0] in s and sum(s.count(d) for d in t) > 1 else "" for t in tlist
        )
    )
    return int("0" + "".join(d for d in s if d not in dset))


def A328375_gen(startvalue=0):
    return (k for k in count(max(startvalue, 0)) if "777" in str(2**k))


def A328947_geh():
    return (n for n in (int(bin(m)[2:]) for m in count(0)) if not n % 7)


def A330243_gen(startvalue=0):
    return (n for n in count(0) if str(2**n)[0] == "7")


@lru_cache(maxsize=None)
def A330503(n):
    if n == 0:
        return 0
    c, j = 0, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * (2 * A330503(k1) // (k1 + 1) - 1)
        j, k1 = j2, n // j2
    return (n + 1) * (n * (n - 1) - c + j) // 2


def A331988_T(n, k):  # compute T(n,k)
    if k == 1:
        count = 1
        for i in range(1, n):
            count *= i + 1
        return count
    ntuple, count = tuple(range(1, n + 1)), 0
    for s in combinations_with_replacement(permutations(ntuple, n), k - 2):
        t = list(ntuple)
        for d in s:
            for i in range(n):
                t[i] += d[i]
        t.sort()
        w = 1
        for i in range(n):
            w *= (n - i) + t[i]
        if w > count:
            count = w
    return count


def A332842(n):
    m, k = 1, 1
    for i in range(2, n + 1):
        k *= i
        m *= k
    return int(str(m)[0])


def A333445_T(n, k):  # compute T(n,k)
    c, l = 1, list(range(1, k * n + 1, k))
    lt = list(l)
    for i in range(n):
        for j in range(1, k):
            lt[i] += l[i] + j
        c *= lt[i]
    return c


def A333596_gen():
    return accumulate(A334841(n) for n in count(0))


def A333975_gen():  # generator of terms
    yield from [1, 2]
    blist, bset, m = [1, 2], set(), 2
    for i in count(3):
        for j in range(i - 2):
            bset.add(m | blist[j])
        m += 1
        while m in bset:
            m += 1
        blist.append(m)
        yield m


def A334042(n):
    return 2 ** (len(bin(n**2)) - 2) - 1 - n**2


def A334076(n):
    m = n | (2 * n)
    return 0 if n == 0 else 2 ** (len(bin(m)) - 2) - 1 - m


def A334116_helper(w, m):
    a, p, s, vv = m, 0, w, []
    while a < 2 * m:
        p += 1
        s = S.One / (s - floor(s))
        a = floor(s)
        if a < 2 * m:
            vv.append(a)
    j = (p - 1) // 2
    v = [0, 1, 1] if p % 2 else [1, 0, vv[j]]
    for i in range(j - 1, -1, -1):
        h = vv[i]
        v = [v[0] + h * v[2], v[2], 2 * h * v[0] + v[1] + h**2 * v[2]]
    return v


def A334116(n):
    w = sqrt(n)
    m = floor(w)
    if w == m:
        return n
    else:
        x, y, z = A334116_helper(w, m)
        if z % 2:
            x *= 2
        else:
            z //= 2
            y //= 2
        return (m + z) ** 2 + x + (x * m + y) // z


@lru_cache(maxsize=None)
def A334535(n):
    if n <= 2:
        return n
    i, a, b = 2, A334535(n - 1), A334535(n - 2)
    q = b
    while q >= n:
        i += 1
        q = A334535(n - i)
    return 2 * A334535(q) + a - b


def A335306(n):
    p = prime(n)
    for m in range(max(4, 2 * p - 4), p**2 + 1):
        if sum(primefactors(m)) == p:
            return m


def A335313(n):
    m = 2 ** (3 * 2**n)
    p = prevprime(m)
    while not isprime((p - 1) // 2):
        p = prevprime(p)
    return m - p


def A335940(n):
    if isprime(n):
        return n
    else:
        pf = primefactors(n)
        return max(pf) - min(pf)


def A336257_gen():  # generator of terms
    yield from [0, 1]
    c = 1
    for n in count(2):
        c = c * (4 * n - 2) // (n + 1)
        yield c % (2 * n + 1)


def A337098(n):
    k = 1
    while True:
        if n == sum(
            1
            for x in combinations((d**3 for d in divisors(k)), 4)
            if sum(x[:-1]) == x[-1]
        ):
            return k
        k += 1


def A337212(n):
    x, y, k, r, m = (3**n - 3) // 2, (3**n - 3) // 2, (n - 1) % 3, 3 ** (n - 1), 0
    while True:
        m += 1
        a, b = divmod(x, 3)
        x, k = a + k * r, (k + k - b) % 3
        if y == x:
            return m


def A339566_gen():  # generator of terms
    p = 2
    while True:
        if int(bin(p)[2:]) % p == 1:
            yield p
        p = nextprime(p)


def A340290_gen():
    return (
        int(s)
        for s in (gmpy2digits(prime(i), 3) for i in count(1))
        if isprime(int(s, 4))
    )


def A340479(n):
    s = str(n)
    return int(s[::-1]) + sum(int(d) for d in s)


def A340768(n):
    return divisors(composite(n))[2]


def A350093_gen():  # generator of terms
    a, b = divisor_count(1), divisor_count(2)
    for k in count(1):
        if a + b == 6:
            yield k
        a, b = b, divisor_count(k + 2)


def A340876_gen():  # generator of terms
    p, q, r, s = 2, 3, 5, 7
    for k in count(1):
        if pow(p, q, s) == r:
            yield k
        p, q, r, s = q, r, s, nextprime(s)


def A341115_gen():  # generator of terms
    m, l, n = 2**101, 2**101 + 1, 10**100
    for k in count(1):
        if pow(10, n, l) == l - 1:
            yield k
        l += m


def A341276(n):
    return (
        1
        + 3 * n * (n + 1)
        - 2 * sum(n // k for k in range(1, isqrt(n) + 1))
        + isqrt(n) ** 2
    )


def A341700(n):
    s, m = 0, nextprime(n)
    while m <= 2 * n:
        s += m
        m = nextprime(m)
    return s


def A342025(n):
    f = factorint(n)
    return int(
        sum(b for a, b in f.items() if a % 4 == 3)
        == sum(b for a, b in f.items() if a % 4 == 1)
    )


def A342081_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if len([p for p in primefactors(n) if p > 2 and p * p <= n]) == 0
    )


def A342082_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if len([p for p in primefactors(n) if p > 2 and p * p <= n]) > 0
    )


def A342175(n):
    m = composite(n)
    k = m + 1
    while gcd(k, m) != 1 or isprime(k):
        k += 1
    return k - m


def A342308_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if set(str(n**5)) == {"1", "2", "3", "4", "5", "6", "7", "8", "9"}
    )


def A342403(n):
    return 1 if n == 1 else -sum(d * A342403(d) for d in divisors(n) if d < n)


def A342601_gen():  # generator of terms
    m, s = 2, str(2**10)
    for k in count(1):
        if s in str(m):
            yield k
        m *= 2


def A342851_gen(startvalue=0):
    return (n for n in count(max(startvalue, 0)) if n == 0 or n % 10)


def A342871(n):
    c = 0
    for k in range(1, n + 1):
        m = integer_nthroot(n, k)[0]
        if m == 1:
            return c + n - k + 1
        else:
            c += m
    return c


def A342892(n):
    s = bin(n)[2:]
    m = len(s)
    i = s[::-1].find("1")
    return 1 - int(s[m - i - 3]) if m - i - 3 >= 0 else 1


def A342906(n):
    return 2 ** (2 * n - 2) - catalan(n)


def A343128_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if n % 2 and n % 5 and prime(prime(prime(n))) % 10 ** (len(str(n))) == n
    )


def A343145(n):
    k = 1
    while True:
        m = k
        for _ in range(n):
            m = prime(m)
        if m % 10 ** (len(str(k))) == k:
            return k
        k += 1
        while not (k % 2 and k % 5):
            k += 1


@lru_cache(maxsize=None)
def A343493(n):
    return 1 - sum(A343493(d - 1) for d in divisors(n) if d < n)


def A343507(n):
    k, f = 0, Fraction(1, int(factorial(n)) ** 2)
    while f.denominator != 1:
        k += 1
        f *= Fraction(2 * k * (2 * k - 1), (k + n) ** 2)
    return k


def A343536_gen():  # generator of terms
    s = "1"
    for k in count(1):
        if str(k**2) in s:
            yield k
        s += str(k + 1)


def A343727_gen():
    return (
        n
        for n in (int("".join(d)) for l in count(1) for d in product("13579", repeat=l))
        if set(str(n**2)[:-1]) <= set("02468")
    )


def A343731_gen():  # generator of terms
    yield 0
    c = 0
    for n in count(2):
        x = prod(n * d + 1 for d in factorint(n).values())
        if x > c:
            c = x
            yield n


def A343780(n):
    q = 1
    while True:
        s, c = [1] * n + [0] * n, 0
        for i in range(n):
            c = (c + q) % (2 * n - i)
            if s[c]:
                break
            s = s[:c] + s[c + 1 :]
        else:
            return q + 1
        q += 1


def A343802(n):
    s, c = 0, 0
    while s < 10**n:
        c += 1
        s += totient(c)
    return c


def A344013_gen():  # generator of terms
    yield 1
    b = 1
    while True:
        b = sum(ord(s) - 96 for s in unidecode(num2words(b, lang="fr")) if s.isalpha())
        yield b


def A344421(n):
    return sum(
        floor(n * sin(x * pi / n)) - int((n * sin(x * pi / n)).is_integer == True)
        for x in range(1, n)
    )


def A344478(n):
    fs = factorint(n)
    return 0 if len(fs) == 0 or max(fs.values()) > 1 else len(fs)


def A344856(n):
    return prime(n) ^ n**2


def A344888(n):
    b, m = 2, n
    while True:
        m, x = divmod(m, b)
        m, y = divmod(m, b)
        while m > 0:
            m, z = divmod(m, b)
            if z != x:
                break
            if m > 0:
                m, z = divmod(m, b)
                if z != y:
                    break
            else:
                return b
        else:
            return b
        b += 1
        m = n


def A344949(n):
    return min(d[1] ** 2 for d in diop_DN(4 * n + 2, 1)) // 4


def A344985(n):
    s, c, b = bin(n)[2:], 0, 0
    for x in s:
        b += 1 if x == "1" else -1
        c += abs(b)
    return c


def A345299(n):
    return sum(p ** primepi(p) for p in primefactors(n))


def A345301(n):
    return sum(p ** primepi(n // p) for p in primefactors(n))


def A345348_gen():
    return (
        n
        for n in (m * (m + 1) // 2 for m in count(0))
        if len(bin(n)) - 2 == 2 * bin(n).count("1")
    )


def A345420(n):
    return igcdex(5, prime(n))[0]


def A345696(n):
    zlist = [
        z
        for z in (igcdex(x, y) for x in range(1, n + 1) for y in range(1, n + 1))
        if z[2] == 1
    ]
    return pvariance(len(zlist) * (u**2 + v**2) for u, v, w in zlist)


def A345724(n):
    return pvariance(
        n**2 * (u + v)
        for u, v, w in (igcdex(x, y) for x in range(1, n + 1) for y in range(1, n + 1))
    )


def A345725(n):
    zlist = [
        z
        for z in (igcdex(x, y) for x in range(1, n + 1) for y in range(1, n + 1))
        if z[2] == 1
    ]
    return pvariance(len(zlist) * (u + v) for u, v, w in zlist)


def A346147_gen():  # generator of terms
    p, q = 2, 3
    while True:
        if isprime(p * q % (p + q)) and isprime(p * q // (p + q)):
            yield p
        p, q = q, nextprime(q)


def A346203(n):
    m, k, p, s = 1, 0, 1, str(n)
    while s not in str(m):
        k += 1
        p = nextprime(p)
        m *= p
    return k


def A346528(n):
    if n == 1:
        return 17
    a, b, k, k2, m, r, s = -6 * (n + 1) ** 2, (n + 1) ** 4, 2, 4, 1, 0, 0
    while 2 * m + a < 0 or m * (m + a) + b < 0:
        if isqrt(2 * m) - isqrt(m - 1) == n:
            r = m
        if s == 0 and isqrt(2 * m + 2) - isqrt(m) == n:
            s = m
        k += 1
        k2 += 2 * k - 1
        m = (k2 - 1) // 2
    return r - s


def A347274(n):
    return 1 if n == 1 else n**2 * (n**n - n) // (n - 1) ** 2


def A347275(n):
    return (
        2 * n + 1
        if n <= 1
        else 2 * (n + sum(n // k for k in range(1, isqrt(n) + 1))) - isqrt(n) ** 2 - 1
    )


def A347304(n):
    return factorial(n) // factorial(n // 2) // factorial(n // 3) // factorial(n // 6)


def A347314_gen():  # generator of terms
    yield 1
    nset, m, j = {1}, 2, 2
    for i in count(2):
        k = m
        while k == j or gcd(k, j) == 1 or k in nset:
            k += 1
        if i == k:
            yield i
        j = k + 1
        nset.add(k)
        while m in nset:
            m += 1


def A347815_gen():
    return (
        p
        for p in (prime(n) for n in count(3))
        if legendre_symbol(30, p) == legendre_symbol(105, p) == -1
    )


def A347816_gen():
    return (
        p
        for p in (prime(n) for n in count(3))
        if legendre_symbol(15, p) == legendre_symbol(85, p) == -1
    )


def A348017_gen(startvalue=0):
    return (
        k
        for k in count(max(startvalue, 0))
        if isprime((lambda x: x.p % x.q)(harmonic(k)))
    )


def A022510_gen():  # generator of terms
    yield 6
    l = "6"
    while True:
        l = "".join(
            str(len(d)) + d[0]
            for d in split("(0+|1+|2+|3+|4+|5+|6+|7+|8+|9+)", l[::-1])
            if d
        )
        yield int(l)


def A058994_gen():  # generator of terms
    m = 7
    for k in count(1):
        if isprime(int(str(m)[::-1])):
            yield k
        m *= 7


def A058995_gen():  # generator of terms
    m = 13
    for k in count(1):
        if isprime(int(str(m)[::-1])):
            yield k
        m *= 13


def A093502_gen():  # generator of terms
    yield 2
    p, q = 2, 1
    while True:
        r = p + q
        p, q = prime(r), r
        yield p


def A108860_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if not sum(int(d) for d in str((2 * n) ** n)) % n
    )


def A109675_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if not sum([int(d) for d in str(n**n - 1)]) % n
    )


def A112258_gen(startvalue=1):
    return (
        n for n in count(max(startvalue, 1)) if n % 10 and len(set(str(n**26))) < 10
    )


def A123911_gen():  # generator of terms
    plist = [0] + [prime(i) for i in range(1, 10)]
    for l in count(1):
        L = 10 ** (l - 1)
        H = 10 * L
        for c in combinations_with_replacement(range(1, 10), l):
            n = prod(plist[i] for i in c) + sum(c)
            if L <= n < H and sorted(int(d) for d in str(n)) == list(c):
                yield n


def A126703_gen(startvalue=1):
    return (n for n in count(max(startvalue, 1)) if isprime(pow(n, n, 10**n)))


def A137019_gen():
    return (
        n
        for n in (int("".join(d)) for l in count(1) for d in product("1279", repeat=l))
        if set(str(n**2)) <= set("1279")
    )


def A143992_gen(startvalue=2):
    return (
        n
        for n in count(max(startvalue, 2))
        if n != 4
        and not isprime(n)
        and str(sum(a * b for a, b in factorint(n).items())) in str(n)
    )


def A155012_gen():  # generator of terms
    a, b, a2, b2 = 0, 1, 2, 5
    while True:
        if isprime(b) and isprime(b2):
            yield b
        a, b, a2, b2 = b, a + b, b2, a2 + b2 - 2


def A175975_gen(startvalue=0):
    return (n for n in count(max(startvalue, 0)) if str(n**n).count("1") == 2)


def A246421_gen(startvalue=1):
    for n in count(max(startvalue, 1)):
        s = str(n)
        if not s.count("0"):
            s2 = sorted(s)
            if s2 == sorted(str(n + sum(int(d) for d in s))) and s2 == sorted(
                str(n + prod(int(d) for d in s))
            ):
                yield n


def A247047_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if len(set(str(n**3))) == 3 and len(set(str(n**2))) == 2
    )


def A248135_gen(startvalue=1):
    for n in count(max(startvalue, 1)):
        if not isprime(n):
            a = sum([int(n * e / p) for p, e in factorint(n).items()]) if n > 1 else 0
            if not sum(a % i for i in range(1, a)) % n:
                yield n


def A255669_gen():  # generator of terms
    p1, p2, l = 2, 3, 10
    for n in count(0):
        p3 = nextprime(p2)
        if p3 >= l:  # this test is sufficient due to Bertrand-Chebyshev theorem
            l *= 10
        if not ((p2 % p1) * l + p3) % p1:
            yield p1
        p1, p2 = p2, p3


def A259630_gen():  # generator of terms
    bset, k = set(), 0
    while True:
        n, m = 0, 1
        k += m
        while n in bset or not isprime(k):
            n += 1
            k += m
            m *= 2
        bset.add(n)
        yield n


def A260097_gen(startvalue=11):  # generator of terms
    for n in count(max(startvalue, 11)):
        s = str(n)
        for l in range(1, len(s)):
            m = int(s[:l]) * int(s[l:])
            if m > 0 and n == divisor_sigma(m):
                yield n
                break


def A261459_gen(startvalue=0):
    return (
        k
        for k in count(max(startvalue, 0))
        if is_prime(int("1" * k + str(k * (k + 1) + 1) + "1" * k))
    )


def A264725_gen():  # generator of terms
    c, n, m, k = 3, 7, 29927007, 10**8
    while True:
        if isprime(n):
            yield c
        c += 8
        n = n * k + m


def A268511_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue + 1 - startvalue % 2, 1), 2):
        m = factorint(3**n + 5**n)
        for d in m:
            if d % 4 == 3 and m[d] % 2:
                break
        else:
            yield n


def A268517_gen():  # generator of terms
    yield 321
    a = 321
    for i in count(0):
        a = (
            ((a + 1 + (2 - i) % 3) % 10) * 100
            + ((a // 100 + 1 + (-i) % 3) % 10) * 10
            + ((a // 10 + 1 + (1 - i) % 3) % 10)
        )
        yield a


def A270538_gen():
    return (
        n**2
        for n in range(10**6)
        if n == sum(int(a) ** (b + 1) for b, a in enumerate(str(n**2)))
    )


def A276718_gen():  # generator of terms
    q = 0
    for i in count(1):
        s = str(i)
        q += Fraction(int(s[::-1]), 10 ** len(s))
        if q.denominator == 1:
            yield i


def A291340_gen():  # generator of terms
    yield 2
    p = 3
    while True:
        if is_square(8 * (p - 1) * totient((p - 1) // 2) + 1):
            yield p
        p = nextprime(p)


def A297710_gen():  # generator of terms
    for i in count(1):
        n = npartitions(i)
        s = [int(d) for d in str(n)]
        for j in range(len(s) - 1):
            if not (s[j] + s[j + 1]) % 2:
                break
        else:
            yield n


def A306666_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if is_square(n * (n * (n * (n * (n - 9) + 33) - 58) + 42))
    )


def A318189(n):
    r, q = n % 2, 2
    while True:
        c, m = 0, q
        for i in range(n + 1):
            c += m
            m = prime(m)
        if is_prime(r + c):
            return q
        q = nextprime(q)


def A322047_gen(startvalue=0):
    return (n for n in count(max(startvalue, 0)) if "e" not in num2words(n, lang="fi"))


def A311481(n):
    return ord(unidecode.unidecode(num2words(n, to="ordinal")).lower()[0]) - 96


def A311482(n):
    return ord(unidecode.unidecode(num2words(n, lang="nl")).lower()[0]) - 96


def A311498(n):
    return ord(unidecode.unidecode(num2words(n, lang="fr")).lower()[0]) - 96


def A332242_gen():  # generator of terms
    n = 1
    for i in count(0):
        s = str(n)
        if len(s) - s.count("0") == i:
            yield i
        n *= i + 1


def A333122_gen():  # generator of terms
    plist = [2, 3, 5, 7, 11, 13]
    while True:
        m = plist[0] + plist[5]
        if m == plist[1] + plist[4]:
            yield m
        plist = plist[1:] + [nextprime(plist[-1])]


def A333390_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if isprime(primorial(2 * n, nth=False) * 2**n - 1)
    )


def A335361_gen():  # generator of terms
    p = 2
    while True:
        f, g = factorial(p), 1
        for i in range(1, p + 1):
            g += f
            if isprime(g):
                break
        else:
            yield p
        p = nextprime(p)


def A337508_gen():  # generator of terms
    p = 11
    while True:
        s = str(p)
        l = len(s) // 2
        if not (isprime(int(s[:l])) or isprime(int(s[-l:]))):
            yield p
        p = nextprime(p)


def A339174_gen():  # generator of terms
    yield 2
    a = 2
    while True:
        c, b = 1, (a - 1) * a
        for k in count(1):
            c += b
            if isprime(c):
                yield k
                a = c
                break


def A340431_gen():  # generator of terms
    p = 2
    while True:
        q = nextprime(p)
        if q > p + 2:
            pq = p + q
            if pow(q, p, pq) == q and pow(p, q, pq) == p:
                yield p
        p = q


def A340466_gen():
    return (
        p
        for p in (prime(n) for n in count(1))
        if len(bin(p)) - 2 < 2 * bin(p).count("1") < 2 * len(bin(p)) - 4
    )


def A000201(n):
    return n + isqrt(5 * n**2) >> 1


def A185381(n):
    return fibonacci(n + isqrt(5 * n**2) >> 1)


def A350678(n):
    return sum(fibonacci(i + isqrt(5 * i**2) >> 1) for i in range(n + 1))


def A342118_gen():  # generator of terms
    plist = [Fraction(1, totient(i)) for i in range(1, 7)]
    p = sum(plist)
    for k in count(1):
        if p.numerator == 1:
            yield k
        p -= plist[0]
        plist = plist[1:] + [Fraction(1, totient(k + 6))]
        p += plist[-1]


def A342221_gen(startvalue=1):  # generator of terms
    for k in count(max(startvalue, 1)):
        if k % 3 != 1:
            m, l = (10**k - 1) // 9, 2
            for i in range(k):
                if isprime(m + l):
                    break
                l *= 10
            else:
                yield k


def A342349_gen():
    p = 2
    while True:
        q = p**3
        C1, C2 = Counter(s := str(p)), Counter(str(q))
        if all(C1[d] <= C2[d] for d in s):
            yield q
        p = nextprime(p)


def A342503_gen(startvalue=1):
    return (
        k
        for k in count(max(startvalue, 1))
        if sum(k % i for i in range(1, k // 2 + 1) if gcd(i, k) == 1) % k == 0
    )


def A342809_gen(startvalue=1):
    return (
        k
        for k in count(max(startvalue, 1))
        if isprime(k - 1) and isprime(k // 5 + int(k % 5 > 2))
    )


def A343011_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if (divisor_sigma(n, 0) * divisor_sigma(n, 2) - divisor_sigma(n, 1) ** 2)
        % divisor_sigma(n, 0) ** 2
        == 0
    )


def A343732_gen(startvalue=2):
    return (
        n
        for n in count(max(startvalue, 2))
        if len(factorint(prod(n * d + 1 for d in factorint(n).values()))) == 1
    )


def A344202_gen():  # generator of terms
    p = 5
    while True:
        if gcd(n_order(2, p), n_order(3, p)) == 1:
            yield p
        p = nextprime(p)


def A000040(n):
    return prime(n)


def A000079(n):
    return 1 << n


def A000142(n):
    return factorial(n)


def A001222(n):
    return sum(factorint(n).values())


def A007318_T(n, k):
    return comb(n, k)


def A001221(n):
    return len(factorint(n))


def A001358_gen(startvalue=2):
    return (n for n in count(max(startvalue, 2)) if A001222(n) == 2)


def A000720(n):
    return primepi(n)


def A002110(n):
    return 1 if n == 0 else primorial(n)


def A034386(n):
    return 1 if n == 0 else primorial(n, nth=False)


def A008683(n):
    return mobius(n)


def A000032(n):
    return lucas(n)


def A000225(n):
    return (1 << n) - 1


def A002275(n):
    return (10**n - 1) // 9


def A005408(n):
    return (n << 1) + 1


def A006530(n):
    return 1 if n == 1 else max(primefactors(n))


def A020639(n):
    return 1 if n == 1 else min(primefactors(n))


def A000984(n):
    return comb(n << 1, n)


def A000292(n):
    return comb(n + 2, 3)


def A000290(n):
    return n**2


def A000244(n):
    return 3**n


def A002378(n):
    return n * (n + 1)


def A005843(n):
    return n << 1


def A000129_gen():  # generator of terms
    a, b = 0, 1
    yield from [a, b]
    while True:
        a, b = b, a + 2 * b
        yield b


def A000041(n):
    return npartitions(n)


def A001045_gen():  # generator of terms
    a, b = 0, 1
    yield from [a, b]
    while True:
        a, b = b, 2 * a + b
        yield b


def A000043_gen():
    return (p for p in (prime(n) for n in count(1)) if isprime(2**p - 1))


def A008277_T(n, k):
    return stirling(n, k)


def A000396_gen():
    return filter(lambda n: divisor_sigma(n) == n << 1, count(1))


def A010060_gen():  # generator of terms
    yield 0
    blist = [0]
    while True:
        c = [1 - d for d in blist]
        blist += c
        yield from c


def A000312(n):
    return n**n


def A000326(n):
    return n * (3 * n - 1) // 2


def A000302(n):
    return 1 << (n << 1)


def A001065(n):
    return divisor_sigma(n) - n


def A000330(n):
    return n * (n + 1) * (2 * n + 1) // 6


def A001405(n):
    return comb(n, n >> 1)


def A001405_gen():  # generator of terms
    yield 1
    a = 1
    for i in count(1):
        a = 2 * a * i // (i + 1) if i & 1 else 2 * a
        yield a


def A001764(n):
    return comb(3 * n, n) // (2 * n + 1)


def A000124(n):
    return (n * (n + 1) >> 1) + 1


def A350536(n):
    m = 2 * n + 1
    for l in count(len(str(m))):
        for s in product("13579", repeat=l):
            k = int("".join(s))
            if k > m and k % m == 0:
                return k


def A350538(n):
    for l in count(len(str(n)) - 1):
        for a in "2468":
            for b in product("02468", repeat=l):
                k = int(a + "".join(b))
                if k > n and k % n == 0:
                    return k


def A350654(n):
    for m in count(2):
        c = 0
        for d in divisors(m, generator=True):
            if not (
                ((m - 1) % (d - 1) if d > 1 else True)
                and (m - 1) % (d + 1)
                and ((m + 1) % (d - 1) if d > 1 else True)
                and (m + 1) % (d + 1)
            ):
                c += 1
                if c > n:
                    break
        if c == n:
            return m


def A078221(n):
    return 2 * n - 1 if n < 3 else 10 ** (2 ** (n - 3)) - 1


def A350540(n):
    return min(sqrt_mod(17, 2**n, all_roots=True))


def A350549(n):
    return 1 if n == 0 else Matrix(n, n, lambda i, j: (j - i + 1) // 2).per()


def A350603_gen():  # generator of terms
    s = {0}
    while True:
        yield from sorted(s)
        s = set(chain.from_iterable((x + 1, 2 * x) for x in s))


def A000203(n):
    return divisor_sigma(n)


def A027641(n):
    return bernoulli(n).p


def A027642(n):
    return bernoulli(n).q


def A122554_gen():  # generator of terms
    s = {1}
    while True:
        yield len(s)
        s = set(chain.from_iterable((x, x + 2, 2 * x) for x in s))


def A123212_gen():  # generator of terms
    s = {1}
    while True:
        yield sum(s)
        s = set(chain.from_iterable((x, 2 * x, x**2) for x in s))


def A123247_gen():  # generator of terms
    s = {1}
    while True:
        yield len(s)
        s = set(chain.from_iterable((x, x + 1, 2 * x, 3 * x) for x in s))


def A350604_gen():  # generator of terms
    s = {1}
    while True:
        yield from sorted(s)
        s = set(chain.from_iterable((x, 2 * x, 3 * x) for x in s))


def A350605_gen():  # generator of terms
    s = {1}
    while True:
        yield from sorted(s)
        s = set(chain.from_iterable((x, 2 * x + 1, 3 * x + 1) for x in s))


def A350606_gen():  # generator of terms
    s = {1}
    while True:
        yield len(s)
        s = set(chain.from_iterable((x, 2 * x + 1, 3 * x + 1) for x in s))


def A000272(n):
    return 1 if n <= 1 else n ** (n - 2)


def A001157(n):
    return divisor_sigma(n, 2)


@lru_cache(maxsize=None)
def A002033(n):
    if n <= 1:
        return 1
    return sum(A002033(i - 1) for i in divisors(n + 1, generator=True) if i <= n)


def A005834(n):
    return 2 * n


def A350246_gen():  # generator of terms
    yield 11
    s = "11"
    while True:
        for k in count(3, 3):
            t = str(k)
            m = int(t + s)
            if isprime(m) and isprime(m + 2):
                yield k
                break
        s = t + s


def A350691_helper(
    n, m
):  # generator in order of numbers with n decimal digits and m 1's. leading zeros are allowed.
    if n >= m:
        if n == 1:
            if m == 1:
                yield 1
            else:
                yield 0
                yield from range(2, 10)
        elif n == m:
            yield (10**m - 1) // 9
        else:
            for b in A350691_helper(n - 1, m):
                yield b
            r = 10 ** (n - 1)
            for b in A350691_helper(n - 1, m - 1):
                yield r + b
            for a in range(2, 10):
                k = a * r
                for b in A350691_helper(n - 1, m):
                    yield k + b


def A350691(n):
    for l in count(n):
        r = 10 ** (l - 1)
        for a in range(1, 10):
            n2 = n - 1 if a == 1 else n
            k = a * r
            for s in A350691_helper(l - 1, n2):
                m = k + s
                if bin(m)[2:].count("1") == n:
                    return m


def A350692_helper(
    n, m
):  # generator in order of numbers with n decimal digits and m 0's. leading zeros are allowed.
    if n >= m:
        if n == 1:
            if m == 1:
                yield 0
            else:
                yield from range(1, 10)
        elif n == m:
            yield 0
        else:
            for b in A350692_helper(n - 1, m - 1):
                yield b
            r = 10 ** (n - 1)
            for a in range(1, 10):
                k = a * r
                for b in A350692_helper(n - 1, m):
                    yield k + b


def A350692(n):
    if n == 1:
        return 0
    for l in count(n):
        r = 10 ** (l - 1)
        for a in range(1, 10):
            k = a * r
            for s in A350692_helper(l - 1, n):
                m = k + s
                if bin(m)[2:].count("0") == n:
                    return m


@lru_cache(maxsize=None)
def A000364(n):
    return (
        1
        if n == 0
        else (1 if n % 2 else -1)
        * sum((-1 if i % 2 else 1) * A000364(i) * comb(2 * n, 2 * i) for i in range(n))
    )


def A000688(n):
    return prod(map(npartitions, factorint(n).values()))


def A000262_gen():  # generator of terms
    a, b = [1, 1]
    yield from [1, 1]
    for n in count(2):
        a, b = b, (2 * n - 1) * b - (n - 1) * (n - 2) * a
        yield b


def A000262(n):
    return hyperexpand(hyper((-n + 1, -n), [], 1))


@lru_cache(maxsize=None)
def A001462(n):
    return 1 if n == 1 else 1 + A001462(n - A001462(A001462(n - 1)))


def A005100_gen(startvalue=1):
    return filter(lambda n: divisor_sigma(n) < 2 * n, count(max(startvalue, 1)))


def A005101_gen(startvalue=1):
    return filter(lambda n: divisor_sigma(n) > 2 * n, count(max(startvalue, 1)))


@lru_cache(maxsize=None)
def A001190(n):
    if n <= 1:
        return n
    m = sum(divmod(n, 2))
    return (
        sum(A001190(i + 1) * A001190(n - 1 - i) for i in range(m - 1))
        + (1 - n % 2) * A001190(m) * (A001190(m) + 1) // 2
    )


def A008292_T(n, k):
    return sum(
        (-1 if j % 2 else 1) * (k - j) ** n * comb(n + 1, j) for j in range(k + 1)
    )


@lru_cache(maxsize=None)
def A000081(n):
    return (
        n
        if n <= 1
        else sum(
            sum(d * A000081(d) for d in divisor_tuple(k)) * A000081(n - k)
            for k in range(1, n)
        )
        // (n - 1)
    )


def A350738(n):
    return Poly(
        sum(
            (-1 if k % 2 else 1)
            * symbolx ** (k**2)
            * prod(1 + symbolx**j for j in range(1, k + 1))
            for k in range(isqrt(n + 1) + 1)
        )
    ).all_coeffs()[-n - 1]


def A014258_gen():  # generator of terms
    a, b = 0, 1
    yield 0
    while True:
        yield b
        a, b = b, int(str(a + b)[::-1])


def A350079_gen():  # generator of terms
    a, b = 0, 1
    for n in count(1):
        if b < a:
            yield n
        a, b = b, int(str(a + b)[::-1])


def A350782(n):
    m, p, c = factorial(n), 3, 0
    while p <= m:
        if isprime(2 * m - p):
            c += 1
        p = nextprime(p)
    return c


def A350743(n):
    f = list(factorint(n).items())
    return sum(
        1
        for k in range(1, n + 1)
        if prod(p ** ((q + 1) * k) - 1 for p, q in f)
        // prod(p**k - 1 for p, q in f)
        % k
        == 0
    )


def A018819_gen():  # generator of terms
    aqueue, f, b, a = deque([2]), True, 1, 2
    yield from (1, 1, 2, 2, 4, 4)
    while True:
        a += b
        yield from (2 * a,) * 2
        aqueue.append(a)
        if f:
            b = aqueue.popleft()
        f = not f


@lru_cache(maxsize=None)
def A018819(n):
    return 1 if n == 0 else A018819(n - 1) + (0 if n % 2 else A018819(n // 2))


def A000123_gen():  # generator of terms
    aqueue, f, b, a = deque([2]), True, 1, 2
    yield from (1, 2, 4)
    while True:
        a += b
        yield 2 * a
        aqueue.append(a)
        if f:
            b = aqueue.popleft()
        f = not f


def A350493(n):
    return pow(isqrt(prime(n)), 2, n)


def A054108(n):
    return (1 if n % 2 else -1) * sum(
        (-1 if k % 2 else 1) * comb(2 * k, k) for k in range(n + 2)
    )


def A054108_gen():  # generator of terms
    b = 1
    for n in count(1):
        b = comb(2 * n, n) - b
        yield b


def A349554(n):
    return (1 if n % 2 else -1) * (
        sum((-1 if k % 2 else 1) * comb(2 * k, k) for k in range(n + 2)) - 4
    )


def A349554_gen():  # generator of terms
    b = 5
    for n in count(2):
        b = comb(2 * n, n) - b
        yield b


def A350459(n):
    return sum(
        1
        for d in range(1, n + 1)
        for c in range(1, n + 1)
        for b in range(1, d + 1)
        for a in range(1, b + 1)
        if (a * d) ** 2 + (b * c) ** 2 == (c * d) ** 2
    )


def A350247_gen(startvalue=3):  # generator of terms
    for n in count(max(3, startvalue + (3 - startvalue % 3) % 3), 3):
        if isprime(100 * n + 11) and isprime(100 * n + 13):
            yield n


def A010051(n):
    return int(isprime(n))


def A052075_gen():
    return filter(
        lambda p: str(nextprime(p)) in str(p**3), (prime(n) for n in count(1))
    )


def A321796_gen():
    return filter(
        lambda p: str(prevprime(p)) in str(p**3), (prime(n) for n in count(2))
    )


def A003136_gen():
    return (
        n
        for n in count(0)
        if all(e % 2 == 0 for p, e in factorint(n).items() if p % 3 == 2)
    )


def A000045(n):
    return fibonacci(n)


def A000045_gen():  # generator of terms
    a, b = 0, 1
    yield a
    while True:
        yield b
        a, b = b, a + b


def A122045(n):
    return euler(n)


@lru_cache(maxsize=None)
def A000219(n):
    return (
        1
        if n == 0
        else (
            divisor_sigma(n, 2)
            + sum(divisor_sigma(k + 1, 2) * A000219(n - k - 1) for k in range(n - 1))
        )
        // n
    )


def A039834_gen():  # generator of terms
    a, b = 1, 1
    yield a
    while True:
        yield b
        a, b = b, a - b


def A039834(n):
    return fibonacci(-n)


@lru_cache(maxsize=None)
def A001970_helper(n):
    return sum(d * npartitions(d) for d in divisors(n, generator=True))


@lru_cache(maxsize=None)
def A001970(n):
    return (
        1
        if n <= 1
        else (
            A001970_helper(n)
            + A001970_helper(n - 1)
            + sum(A001970_helper(k + 1) * A001970(n - k - 1) for k in range(n - 2))
        )
        // n
    )


def A350858(n):
    return (
        1
        if n == 0
        else min(
            Matrix(n, n, p).per()
            for p in permutations(prime(m) for m in range(1, n**2 + 1))
        )
    )


def A350859(n):
    return (
        1
        if n == 0
        else max(
            Matrix(n, n, p).per()
            for p in permutations(prime(m) for m in range(1, n**2 + 1))
        )
    )


def A350565(n):
    return (
        1
        if n == 0
        else min(Matrix(n, n, p).per() for p in permutations(range(1, n**2 + 1)))
    )


def A350566(n):
    return (
        1
        if n == 0
        else max(Matrix(n, n, p).per() for p in permutations(range(1, n**2 + 1)))
    )


def A350230_gen(startvalue=1):
    return (
        n
        for n in count(max(startvalue, 1))
        if all((isprime(n + d + n // d) for d in divisors(n) if d * d <= n))
    )


def A254926(n):
    return prod(p**e - (p ** (e - 3) if e >= 3 else 0) for p, e in factorint(n).items())


def A349309_gen(startvalue=1):  # generator of terms >= startvalue
    a = prod(
        p**e - (p ** (e - 3) if e >= 3 else 0)
        for p, e in factorint(max(startvalue, 1)).items()
    )
    for k in count(max(startvalue, 1)):
        b = prod(
            p**e - (p ** (e - 3) if e >= 3 else 0) for p, e in factorint(k + 1).items()
        )
        if a == b:
            yield k
        a = b


def A350179_gen():
    return (
        p for p in (prime(n) for n in count(1)) if max(factorint(p**3 - 1).values()) < 3
    )


def A328727_gen(startvalue=0):  # generator of terms
    for n in count(max(startvalue, 0)):
        s = gmpy2digits(n, 3)
        for i in range(len(s) - 1):
            if "0" not in s[i : i + 2]:
                break
        else:
            yield n


def A350868(n):
    if n < 2:
        return 2 + n
    qlist = [prime(i) - 2 for i in range(2, n + 2)]
    p = prime(n + 1)
    mlist = [2 * k**2 for k in range(1, n + 1)]
    while True:
        if qlist == mlist:
            return p - mlist[-1]
        qlist = [q - qlist[0] for q in qlist[1:]]
        r = nextprime(p)
        qlist.append(r - p + qlist[-1])
        p = r


def A095258_gen():  # generator of terms
    bset, s = {1}, 3
    yield 1
    while True:
        for d in divisors(s):
            if d not in bset:
                yield d
                bset.add(d)
                s += d
                break


def A308751_gen():  # generator of terms
    bset, s = {1}, 3
    yield 2
    while True:
        for d in divisors(s):
            if d not in bset:
                yield s // d
                bset.add(d)
                s += d
                break


def A350741_gen():  # generator of terms
    bset, c, s = {1}, 1, 3
    yield 1
    while True:
        for d in divisors(s):
            if d not in bset:
                if d > c:
                    yield d
                    c = d
                bset.add(d)
                s += d
                break


def A253415_gen():  # generator of terms, first term is a(2)
    bset, m, s = {1}, 2, 3
    while True:
        for d in divisors(s):
            if d not in bset:
                bset.add(d)
                while m in bset:
                    m += 1
                yield m
                s += d
                break


def A253425_gen():  # generator of terms
    bset, l, m, s = {1}, 0, 2, 3
    while True:
        for d in divisors(s):
            if d not in bset:
                bset.add(d)
                if m in bset:
                    yield l
                    l = 1
                    while m in bset:
                        m += 1
                else:
                    l += 1
                s += d
                break


def A350701(n):
    return 0 if n <= 1 else (lambda x: isqrt(x[0] - 1) - isqrt(x[1]))(fib2(n + 1))


def A350701_gen():  # generator of terms
    yield from [0, 0]
    a, b = 1, 2
    while True:
        yield isqrt(b - 1) - isqrt(a)
        a, b = b, a + b


def A324151(n):
    return 2 * multinomial_coefficients(3, 3 * n)[(n, n, n)] // (n + 1) // (n + 2)


def A066750(n):
    return gcd(n, sum(int(d) for d in str(n)))


def A348192_gen():  # generator of terms
    blist = [0]
    yield 0
    for n in count(1):
        blist.append(1 + blist[n - gcd(n, sum(int(d) for d in str(n)))])
        yield blist[-1]


def A306354(n):
    return gcd(n, sum(int(d) ** len(str(n)) for d in str(n)))


def A348591(n):
    return (lambda x, y: int(x[0] * x[1] % y))(lucas2(n + 1), fib(n + 2))


def A350932(n):
    return min(
        Matrix([p[n - 1 - i : 2 * n - 1 - i] for i in range(n)]).det()
        for p in permutations(prime(i) for i in range(1, 2 * n))
    )


def A350933(n):
    return max(
        Matrix([p[n - 1 - i : 2 * n - 1 - i] for i in range(n)]).det()
        for p in permutations(prime(i) for i in range(1, 2 * n))
    )


def A350930(n):
    return min(
        Matrix([p[n - 1 - i : 2 * n - 1 - i] for i in range(n)]).det()
        for p in permutations(range(1, 2 * n))
    )


def A350931(n):
    return max(
        Matrix([p[n - 1 - i : 2 * n - 1 - i] for i in range(n)]).det()
        for p in permutations(range(1, 2 * n))
    )


def A350937(n):
    return (
        1
        if n == 0
        else min(
            Matrix([p[n - 1 - i : 2 * n - 1 - i] for i in range(n)]).per()
            for p in permutations(range(1, 2 * n))
        )
    )


def A350938(n):
    return (
        1
        if n == 0
        else max(
            Matrix([p[n - 1 - i : 2 * n - 1 - i] for i in range(n)]).per()
            for p in permutations(range(1, 2 * n))
        )
    )


def A350939(n):
    return (
        1
        if n == 0
        else min(
            Matrix([p[n - 1 - i : 2 * n - 1 - i] for i in range(n)]).per()
            for p in permutations(prime(i) for i in range(1, 2 * n))
        )
    )


def A350940(n):
    return (
        1
        if n == 0
        else max(
            Matrix([p[n - 1 - i : 2 * n - 1 - i] for i in range(n)]).per()
            for p in permutations(prime(i) for i in range(1, 2 * n))
        )
    )


def A350956(n):
    return max(
        Matrix([p[i:0:-1] + p[0 : n - i] for i in range(n)]).det()
        for p in permutations(prime(i) for i in range(1, n + 1))
    )


def A350955(n):
    return min(
        Matrix([p[i:0:-1] + p[0 : n - i] for i in range(n)]).det()
        for p in permutations(prime(i) for i in range(1, n + 1))
    )


def A350954(n):
    return max(
        Matrix([p[i:0:-1] + p[0 : n - i] for i in range(n)]).det()
        for p in permutations(range(1, n + 1))
    )


def A350953(n):
    return min(
        Matrix([p[i:0:-1] + p[0 : n - i] for i in range(n)]).det()
        for p in permutations(range(1, n + 1))
    )


def A348891(n):
    return min(
        d
        for d in (
            abs(Matrix([p[i:0:-1] + p[0 : n - i] for i in range(n)]).det())
            for p in permutations(prime(i) for i in range(1, n + 1))
        )
        if d > 0
    )


def A347718(n):
    return prod(
        (q ** (r + 1) - 1) // (q - 1)
        for q, r in sum(
            (
                Counter(factorint((p ** (n * (e + 1)) - 1) // (p**n - 1)))
                for p, e in factorint(n).items()
            ),
            Counter(),
        ).items()
    )


def A064165(n):
    return prod(
        r + 1
        for q, r in sum(
            (
                Counter(factorint((p ** (n * (e + 1)) - 1) // (p**n - 1)))
                for p, e in factorint(n).items()
            ),
            Counter(),
        ).items()
    )


def A351021(n):
    return (
        1
        if n == 0
        else min(
            Matrix([p[i:0:-1] + p[0 : n - i] for i in range(n)]).per()
            for p in permutations(prime(i) for i in range(1, n + 1))
        )
    )


def A351022(n):
    return (
        1
        if n == 0
        else max(
            Matrix([p[i:0:-1] + p[0 : n - i] for i in range(n)]).per()
            for p in permutations(prime(i) for i in range(1, n + 1))
        )
    )


def A351020(n):
    return (
        1
        if n == 0
        else max(
            Matrix([p[i:0:-1] + p[0 : n - i] for i in range(n)]).per()
            for p in permutations(range(1, n + 1))
        )
    )


def A351019(n):
    return (
        1
        if n == 0
        else min(
            Matrix([p[i:0:-1] + p[0 : n - i] for i in range(n)]).per()
            for p in permutations(range(1, n + 1))
        )
    )


def A351114(n):
    f = factorint(n)
    return int(
        not prod(p * (p ** (e + 1) - 1) for p, e in f.items())
        % (n * prod((p - 1) ** 2 for p in f))
    )


def A005230_gen():  # generator of terms
    blist = [1]
    for n in count(1):
        yield blist[-1]
        blist.append(sum(blist[-i] for i in range(1, (isqrt(8 * n) + 3) // 2)))


def A002024(n):
    return isqrt(n << 3) + 1 >> 1


def A005130(n):
    return prod(factorial(3 * k + 1) for k in range(n)) // prod(
        factorial(n + k) for k in range(n)
    )


def A049503(n):
    return (
        prod(factorial(3 * k + 1) for k in range(n))
        // prod(factorial(n + k) for k in range(n))
    ) ** 2


def A000140(n):
    return (
        1
        if n == 1
        else max(
            Poly(
                prod(sum(symbolx**i for i in range(j + 1)) for j in range(n))
            ).all_coeffs()
        )
    )


def A000055(n):
    return (
        1
        if n == 0
        else A000081(n)
        - sum(A000081(i) * A000081(n - i) for i in range(1, n // 2 + 1))
        + (0 if n % 2 else (A000081(n // 2) + 1) * A000081(n // 2) // 2)
    )


def A217420(n):
    return sum(A000081(i) * A000081(n - 1 - i) for i in range(1, (n - 1) // 2 + 1)) - (
        (A000081((n - 1) // 2) + 1) * A000081((n - 1) // 2) // 2 if n % 2 else 0
    )


def A336039_gen(startvalue=1):
    return (k for k in count(max(startvalue, 1)) if not A000081(k) % k)


def A036361(n):
    return int(n * (n - 1) * (2 * n - 3) ** (n - 4) // 2)


def A036506(n):
    return int(n * (n - 3) * (n - 2) * (n - 1) * (4 * n - 15) ** (n - 6) // 24)


def A036362(n):
    return int(n * (n - 2) * (n - 1) * (3 * n - 8) ** (n - 5) // 6)


def A145071(n):
    return 2 ** (n + 1) + n - 2


def A060477(n):
    return sum(mobius(n // d) * (2**d + 1) for d in divisors(n, generator=True)) // n


def A001037(n):
    return (
        1
        if n == 0
        else sum(mobius(n // d) * 2**d for d in divisors(n, generator=True)) // n
    )


def A027375(n):
    return sum(mobius(n // d) * 2**d for d in divisors(n, generator=True))


def A000740(n):
    return sum(mobius(n // d) * 2 ** (d - 1) for d in divisors(n, generator=True))


def A059966(n):
    return sum(mobius(n // d) * (2**d - 1) for d in divisors(n, generator=True)) // n


def A343318(n):
    return (2**n + 1) ** 3


def A333474_gen(startvalue=0):  # generator of terms
    m = 2 ** (s := max(startvalue, 0))
    n = m + 1
    for k in count(s):
        if not n % sum(int(d) for d in str(n)):
            yield k
        m *= 2
        n = m + 1


def A023578(n):
    return min((p for p in factorint(prime(n) + 3) if p > 2), default=1)


def A078701(n):
    return min((p for p in factorint(n) if p > 2), default=1)


@lru_cache(maxsize=None)
def A008472(n):
    return sum(primefactors(n))


@lru_cache(maxsize=None)
def A000607(n):
    return (
        1 if n == 0 else sum(A008472(k) * A000607(n - k) for k in range(1, n + 1)) // n
    )


def A007778(n):
    return n ** (n + 1)


def A007830(n):
    return (n + 3) ** n


def A008785(n):
    return (n + 4) ** n


def A008786(n):
    return (n + 5) ** n


def A008787(n):
    return (n + 6) ** n


def A008788(n):
    return n ** (n + 2)


def A008789(n):
    return n ** (n + 3)


def A008790(n):
    return n ** (n + 4)


def A008791(n):
    return n ** (n + 5)


def A000169(n):
    return n ** (n - 1)


def A329723(n):
    return 1 if n <= 1 else lucas(n - 2)


def A278159(n):
    return RLT(n, primorial)


def A246674(n):
    return RLT(n, lambda m: 2**m - 1)


def A001317(n):
    return int("".join(str(int(not (~n & k))) for k in range(n + 1)), 2)


def A247282(n):
    return RLT(
        n, lambda m: int("".join(str(int(not (~(m - 1) & k))) for k in range(m)), 2)
    )


def A286575(n):
    return RLT(n, lambda m: 2 ** (bin(m).count("1")))


def A286574(n):
    return len(bin(RLT(n, lambda m: 2 ** (bin(m).count("1"))))) - 3


def A246685(n):
    return RLT(n, lambda m: 1 if m <= 1 else 2 ** (2 ** (m - 2)) + 1)


def A000007(n):
    return int(n == 0)


def A046523(n):
    return prod(
        prime(i + 1) ** e
        for i, e in enumerate(sorted(factorint(n).values(), reverse=True))
    )


def A056040(n):
    return factorial(n) // factorial(n // 2) ** 2


def A246661(n):
    return RLT(n, lambda m: factorial(m) // factorial(m // 2) ** 2)


def A245564(n):
    return RLT(n, lambda m: fibonacci(m + 2))


def A185017(n):
    return int(n == 7)


def A185016(n):
    return int(n == 6)


def A185015(n):
    return int(n == 5)


def A185014(n):
    return int(n == 4)


def A185013(n):
    return int(n == 3)


def A185012(n):
    return int(n == 2)


def A063524(n):
    return int(n == 1)


@lru_cache(maxsize=None)
def A346422(n):
    return (
        1
        if n <= 1
        else A346422(int((s := bin(n)[2:])[1:], 2))
        * (1 + sum(len(d) - 1 for d in split("0+", s) if d != ""))
    )


def A245565(n):
    return RLT(n, lambda m: next(islice(A000129_gen(), m + 1, None)))


def A329722(n):
    return RLT(n, lambda m: 1 if m <= 1 else lucas(m - 2))


def A278161(n):
    return RLT(n, lambda m: m // 2 + 1)


def A000930_gen():  # generator of terms
    blist = [1] * 3
    while True:
        yield blist[0]
        blist = blist[1:] + [blist[0] + blist[2]]


def A329720(n):
    return RLT(n, lambda m: next(islice(A000930_gen(), m, None)))


def A106737(n):
    return RLT(n, lambda m: m + 1)


def A277561(n):
    return RLT(n, lambda m: 1 if m == 0 else 2)


def A246028(n):
    return RLT(n, lambda m: fibonacci(m + 1))


def A001316(n):
    return 2 ** A000120(n)


def A102376(n):
    return 4 ** A000120(n)


def A036044(n):
    return -int((s := bin(n)[-1:1:-1]), 2) - 1 + 2 ** len(s)


def A059894(n):
    return n if n <= 1 else -int((s := bin(n)[-1:2:-1]), 2) - 1 + 2 ** (len(s) + 1)


def A284799(n):
    return -int((s := gmpy2digits(n, 4)[::-1]), 4) - 1 + 4 ** len(s)


def A284797(n):
    return -int((s := gmpy2digits(n, 3)[::-1]), 3) - 1 + 3 ** len(s)


def A284798_gen():
    return (
        n
        for n in count(0)
        if not n + int((s := gmpy2digits(n, 3)[::-1]), 3) + 1 - 3 ** len(s)
    )


def A159006(n):
    return -int((s := bin(prime(n))[-1:1:-1]), 2) - 1 + 2 ** len(s)


def A284807(n):
    return -int((s := oct(n)[-1:1:-1]), 8) - 1 + 8 ** len(s)


def A351198(n):
    return sum(p**10 for p in primefactors(n))


def A351197(n):
    return sum(p**9 for p in primefactors(n))


def A351196(n):
    return sum(p**8 for p in primefactors(n))


def A351262(n):
    return sum((n // p) ** 10 for p in primefactors(n))


def A351249(n):
    return sum((n // p) ** 9 for p in primefactors(n))


def A351248(n):
    return sum((n // p) ** 8 for p in primefactors(n))


def A069359(n):
    return sum(n // p for p in primefactors(n))


def A351219(n):
    return prod(fibonacci(e + 1) for e in factorint(n).values())


def A002371(n):
    return 0 if n == 1 or n == 3 else n_order(10, prime(n))


def A007732(n):
    return n_order(10, (n >> (~n & n - 1).bit_length()) // 5 ** multiplicity(5, n))


def A350814_gen(startvalue=1):
    return filter(
        lambda m: max(repeating_decimals_expr(Fraction(1, m), digits_only=True)) == "3",
        count(max(startvalue, 1)),
    )


def A072982_gen():
    return (
        p
        for p in (prime(n) for n in count(2))
        if p != 5 and bin(n_order(10, p))[2:].rstrip("0") == "1"
    )


def A051628(n):
    return max(multiplicity(2, n), multiplicity(5, n))


def A341383_gen(startvalue=1):  # generator of terms
    for m in count(max(startvalue, 1)):
        m2, m5 = multiplicity(2, m), multiplicity(5, m)
        if max(str(10 ** (max(m2, m5) + n_order(10, m // 2**m2 // 5**m5)) // m)) == "2":
            yield m


def A333236(n):
    m2, m5 = multiplicity(2, n), multiplicity(5, n)
    return int(max(str(10 ** (max(m2, m5) + n_order(10, n // 2**m2 // 5**m5)) // n)))


def A333442(n):
    if n == 1:
        return 0
    m2, m5 = multiplicity(2, n), multiplicity(5, n)
    r = max(m2, m5) + n_order(10, n // 2**m2 // 5**m5)
    s = str(10**r // n).zfill(r)
    return s.index(max(s)) + 1


def A333237_gen(startvalue=1):  # generator of terms
    for m in count(max(startvalue, 1)):
        m2, m5 = multiplicity(2, m), multiplicity(5, m)
        if max(str(10 ** (max(m2, m5) + n_order(10, m // 2**m2 // 5**m5)) // m)) == "9":
            yield m


def A351139(n):
    if n == 2:
        return 14
    for r in count(1):
        if (
            k := continued_fraction_reduce(
                [r, list(range(1, n + 1)) + list(range(n - 1, 0, -1)) + [2 * r]]
            )
            ** 2
        ).is_integer:
            return k


def A350562_gen():  # generator of terms
    bdict = {1: 1}
    yield 1
    b = 0
    for n in count(3):
        yield b
        c = (n - bdict[b]) * b if b in bdict else 1
        bdict[b], b = n - 1, c


def A350574_gen():  # generator of terms
    for l in count(1):
        rlist = []
        for a in combinations_with_replacement("123456789", l):
            s = "".join(a)
            p, q = int(s), int(s[::-1])
            if p != q and isprime(p) and isprime(q):
                for b in multiset_permutations(a):
                    r = int("".join(b))
                    if p < r < q and isprime(r):
                        rlist.append(r)
                        break
        yield from sorted(rlist)


def A075188(n):
    m = lcm(*range(1, n + 1))
    mlist = tuple(m // i for i in range(1, n + 1))
    k = sum(mlist)
    c = 0
    for l in range(0, n // 2 + 1):
        for p in combinations(mlist, l):
            s = sum(p)
            r, t = s // gcd(s, m), (k - s) // gcd(k - s, m)
            if isprime(r):
                if 2 * l != n:
                    c += 1
            if isprime(t):
                c += 1
    return c


def A351470_gen(startvalue=1):  # generator of terms
    for m in count(max(startvalue, 1)):
        m2, m5 = multiplicity(2, m), multiplicity(5, m)
        if max(str(10 ** (max(m2, m5) + n_order(10, m // 2**m2 // 5**m5)) // m)) == "4":
            yield m


def A351471_gen(startvalue=1):  # generator of terms
    for m in count(max(startvalue, 1)):
        m2, m5 = multiplicity(2, m), multiplicity(5, m)
        if max(str(10 ** (max(m2, m5) + n_order(10, m // 2**m2 // 5**m5)) // m)) == "5":
            yield m


def A351472_gen(startvalue=1):  # generator of terms
    for m in count(max(startvalue, 1)):
        m2, m5 = multiplicity(2, m), multiplicity(5, m)
        if max(str(10 ** (max(m2, m5) + n_order(10, m // 2**m2 // 5**m5)) // m)) == "6":
            yield m


def A075226(n):
    m = lcm(*range(1, n + 1))
    c, mlist = 0, tuple(m // i for i in range(1, n + 1))
    for l in range(n, -1, -1):
        if sum(mlist[:l]) < c:
            break
        for p in combinations(mlist, l):
            s = sum(p)
            s //= gcd(s, m)
            if s > c and isprime(s):
                c = s
    return c


def A256221(n):
    m = lcm(*range(1, n + 1))
    fset, fibset, mlist = set(), set(), tuple(m // i for i in range(1, n + 1))
    a, b, k = 0, 1, sum(mlist)
    while b <= k:
        fibset.add(b)
        a, b = b, a + b
    for l in range(1, n // 2 + 1):
        for p in combinations(mlist, l):
            s = sum(p)
            if (t := s // gcd(s, m)) in fibset:
                fset.add(t)
            if 2 * l != n and (t := (k - s) // gcd(k - s, m)) in fibset:
                fset.add(t)
    if (t := k // gcd(k, m)) in fibset:
        fset.add(t)
    return len(fset)


def A256220(n):
    m = lcm(*range(1, n + 1))
    fibset, mlist = set(), tuple(m // i for i in range(1, n + 1))
    a, b, c, k = 0, 1, 0, sum(mlist)
    while b <= k:
        fibset.add(b)
        a, b = b, a + b
    for l in range(1, n // 2 + 1):
        for p in combinations(mlist, l):
            s = sum(p)
            if s // gcd(s, m) in fibset:
                c += 1
            if 2 * l != n and (k - s) // gcd(k - s, m) in fibset:
                c += 1
    return c + int(k // gcd(k, m) in fibset)


def A351532(n):
    return sum(
        1
        for d in diop_quadratic(
            n**2 + 3 * symbolx * symboly - 2 * n * (symbolx + symboly)
        )
        if 0 < d[0] < n and 0 < d[1] < n
    )


def A241883(n):
    c, w = 0, n + 1
    while 6 * n + w * (22 * n + w * (18 * n + w * (4 * n - w - 6) - 11) - 6) >= 0:
        x = max(w + 1, n * w // (w - n) + 1)
        wx = w * x
        while (
            2 * n * w
            + x
            * (2 * n + w * (6 * n - 2) + x * (3 * n + w * (3 * n - 3) + x * (n - w)))
            >= 0
        ):
            y = max(x + 1, w * x * n // (x * (w - n) - w * n) + 1)
            wxy = wx * y
            while (
                x * (n * w + y * (n + w * (2 * n - 1) + y * (n - w)))
                + y * (n * w * y + n * w)
                >= 0
            ):
                z, r = divmod(n * wxy, wxy - n * (x * y + w * (x + y)))
                if z > y and r == 0:
                    c += 1
                y += 1
                wxy += wx
            x += 1
            wx += w
        w += 1
    return c


def A347569(n):
    c, p = 0, n + 1
    while (
        120 * n
        + p
        * (
            548 * n
            + p
            * (
                675 * n
                + p * (340 * n + p * (75 * n + p * (6 * n - p - 15) - 85) - 225)
                - 274
            )
            - 120
        )
        >= 0
    ):
        q = max(p + 1, n * p // (p - n) + 1)
        pq = p * q
        while (
            p
            * (
                24 * n
                + q
                * (
                    100 * n
                    + q * (105 * n + q * (40 * n + q * (5 * n - q - 10) - 35) - 50)
                    - 24
                )
            )
            + q * (24 * n + q * (50 * n + q * (35 * n + q * (n * q + 10 * n))))
            >= 0
        ):
            r = max(q + 1, n * pq // (pq - n * (p + q)) + 1)
            pqr = pq * r
            while (
                p
                * (
                    q
                    * (
                        6 * n
                        + r * (22 * n + r * (18 * n + r * (4 * n - r - 6) - 11) - 6)
                    )
                    + r * (6 * n + r * (11 * n + r * (n * r + 6 * n)))
                )
                + q * r * (6 * n + r * (11 * n + r * (n * r + 6 * n)))
                >= 0
            ):
                s = max(r + 1, n * pqr // (pqr - n * (pq + r * (p + q))) + 1)
                pqrs = pqr * s
                while (
                    p
                    * (
                        q
                        * (
                            r * (2 * n + s * (6 * n + s * (3 * n - s - 3) - 2))
                            + s * (2 * n + s * (n * s + 3 * n))
                        )
                        + r * s * (2 * n + s * (n * s + 3 * n))
                    )
                    + q * r * s * (2 * n + s * (n * s + 3 * n))
                    >= 0
                ):
                    t = max(
                        s + 1,
                        n * pqrs // (pqrs - n * (pqr + pq * s + r * s * (p + q))) + 1,
                    )
                    pqrst = pqrs * t
                    while (
                        p
                        * (
                            q
                            * (
                                r * (s * (n + t * (2 * n - t - 1)) + t * (n * t + n))
                                + s * t * (n * t + n)
                            )
                            + r * s * t * (n * t + n)
                        )
                        + q * r * s * t * (n * t + n)
                        >= 0
                    ):
                        u, z = divmod(
                            n * pqrst,
                            pqrst
                            - n
                            * (
                                q * r * s * t
                                + p * r * s * t
                                + pq * s * t
                                + pqr * t
                                + pqrs
                            ),
                        )
                        if u > t and z == 0:
                            c += 1
                        t += 1
                        pqrst += pqrs
                    s += 1
                    pqrs += pqr
                r += 1
                pqr += pq
            q += 1
            pq += p
        p += 1
    return c


def A351372_gen():  # generator of terms
    for z in count(1):
        z2 = z**2
        for y in range(1, z + 1):
            a = isqrt(
                d := 3 * y**2 * (12 * z2 - 4 * z - 1) - 3 * z2 * (4 * y + 1) - 2 * y * z
            )
            if a**2 == d:
                x, r = divmod(12 * y * z - 2 * y - 2 * z - 2 * a, 4)
                if y <= x <= z and r == 0:
                    yield from (y, x, z)


def A351528_gen():  # generator of terms
    yield from (
        int(d[::-1], 2)
        for l in count(1)
        for d in sorted(bin(m)[:1:-1] for m in primerange(2 ** (l - 1), 2**l))
    )


def A104154_gen():  # generator of terms
    yield from (
        int(d[::-1])
        for l in count(1)
        for d in sorted(str(m)[::-1] for m in primerange(10 ** (l - 1), 10**l))
    )


def A098957(n):
    return int(bin(prime(n))[:1:-1], 2)


def A030101(n):
    return int(bin(n)[:1:-1], 2)


def A351105(n):
    return (
        n
        * (
            n
            * (
                n
                * (
                    n
                    * (
                        n * (n * (n * (n * (280 * n + 2772) + 10518) + 18711) + 14385)
                        + 1323
                    )
                    - 2863
                )
                - 126
            )
            + 360
        )
        // 45360
    )


def A347107(n):
    return (
        n
        * (n**2 * (n * (n * (n * (n * (21 * n + 36) - 42) - 84) + 21) + 56) - 8)
        // 672
    )


def A346642(n):
    return (
        n
        * (n**2 * (n * (n * (n * (n * (21 * n + 132) + 294) + 252) + 21) - 56) + 8)
        // 672
    )


def A333402_gen(startvalue=1):  # generator of terms
    for m in count(max(startvalue, 1)):
        k = 1
        while k <= m:
            k *= 10
        rset = {0}
        while True:
            k, r = divmod(k, m)
            if max(str(k)) > "1":
                break
            else:
                if r in rset:
                    yield m
                    break
            rset.add(r)
            k = r
            while k <= m:
                k *= 10


def A030302_gen():  # generator of terms
    return (int(d) for n in count(1) for d in bin(n)[2:])


def A351753(n):
    s1, s2 = tuple(), tuple()
    for i, s in enumerate(int(d) for n in count(1) for d in bin(n)[2:]):
        if i < n:
            s1 += (s,)
            s2 += (s,)
        else:
            s2 = s2[1:] + (s,)
            if s1 == s2:
                return i - n + 2


def A030303_gen():  # generator of terms
    return (
        i + 1 for i, s in enumerate(d for n in count(1) for d in bin(n)[2:]) if s == "1"
    )


def A003607_gen():  # generator of terms
    return (
        i for i, s in enumerate(d for n in count(0) for d in bin(n)[2:]) if s == "0"
    )


def A194472_gen(startvalue=1):  # generator of terms
    return (
        n
        for n in count(max(startvalue, 1))
        if any(s == n for s in accumulate(divisors(n)[:-2]))
    )


def A138591(n):
    return (n + n.bit_length() - 1).bit_length() + n - 1


def A094683(n):
    return isqrt(n**3 if n % 2 else n)


def A093112(n):
    return (2**n - 1) ** 2 - 2


def A088054_gen():  # generator of terms
    f = 1
    for k in count(1):
        f *= k
        if isprime(f - 1):
            yield f - 1
        if isprime(f + 1):
            yield f + 1


def A046760_gen():  # generator of terms
    return (
        n
        for n in count(1)
        if len(str(n))
        < sum(
            len(str(p)) + (len(str(e)) if e > 1 else 0) for p, e in factorint(n).items()
        )
    )


def A046758_gen():  # generator of terms
    return (
        n
        for n in count(1)
        if n == 1
        or len(str(n))
        == sum(
            len(str(p)) + (len(str(e)) if e > 1 else 0) for p, e in factorint(n).items()
        )
    )


def A034897_gen():  # generator of terms
    return (
        n
        for n in count(2)
        if not isprime(n) and (n - 1) % (divisor_sigma(n) - n - 1) == 0
    )


def A019279_gen():  # generator of terms
    return (n for n in count(1) if divisor_sigma(divisor_sigma(n)) == 2 * n)


def A014080_gen():  # generator of terms
    return (
        n
        for n in count(1)
        if sum((1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880)[int(d)] for d in str(n))
        == n
    )


def A007588(n):
    return n * (2 * n**2 - 1)


def A342162(n):
    s1, s2, m = tuple(int(d) for d in str(n)), tuple(), -1
    l = len(s1)
    for i, s in enumerate(int(d) for k in count(0) for d in str(k)):
        s2 = (s2 + (s,))[-l:]
        if s2 == s1:
            if m >= 0:
                return i - m
            m = i


def A337227(n):
    s1 = tuple(int(d) for d in str(n))
    s2 = s1
    for i, s in enumerate(int(d) for k in count(n + 1) for d in str(k)):
        s2 = s2[1:] + (s,)
        if s2 == s1:
            return i + 1


def A052486_gen(startvalue=1):  # generator of terms
    return (
        n
        for n in count(max(startvalue, 1))
        if (lambda x: all(e > 1 for e in x) and gcd(*x) == 1)(factorint(n).values())
    )


def A007850_gen(startvalue=2):  # generator of terms
    return filter(
        lambda x: not isprime(x)
        and all((x // p - 1) % p == 0 for p in primefactors(x)),
        count(max(startvalue, 2)),
    )


def A334409_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        ds = divisors(n)
        if any(
            s == 2 * n
            for s in accumulate(ds[i] + ds[-1 - i] for i in range((len(ds) - 1) // 2))
        ):
            yield n


def A334410_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        ds = divisors(n)
        s = sum(ds)
        if s % 2 == 0 and any(2 * a == s for a in accumulate(ds)):
            yield n


@lru_cache(maxsize=None)
def A350661(n):
    return 1 if n == 1 else A350661(prod(primefactors(n)) - 1) + n


def A351412(n):
    if n == 1:
        return 1
    q, r = divmod(n, 4)
    if r == 0:
        return n - q + 1
    elif r == 2:
        return n - q
    elif r == 1:
        return n + 2 * q - 1
    else:
        return n + 2 * q


def A106303(n):
    a = b = (0,) * 4 + (1 % n,)
    s = 1 % n
    for m in count(1):
        b, s = b[1:] + (s,), (s + s - b[0]) % n
        if a == b:
            return m


def A106304(n):
    a = b = (0,) * 4 + (1 % (p := prime(n)),)
    s = 1 % p
    for m in count(1):
        b, s = b[1:] + (s,), (s + s - b[0]) % p
        if a == b:
            return m


def A193994(n):
    a = b = (0,) * 4 + (1 % n,)
    c, s = 0, 1 % n
    for m in count(1):
        b, s = b[1:] + (s,), (s + s - b[0]) % n
        c += int(s == 0)
        if a == b:
            return c


def A106295(n):
    a = b = (4 % n, 1 % n, 3 % n, 7 % n)
    s = sum(b) % n
    for m in count(1):
        b, s = b[1:] + (s,), (s + s - b[0]) % n
        if a == b:
            return m


def A106297(n):
    a = b = (5 % n, 1 % n, 7 % n, 3 % n, 15 % n)
    s = sum(b) % n
    for m in count(1):
        b, s = b[1:] + (s,), (s + s - b[0]) % n
        if a == b:
            return m


def A106298(n):
    a = b = (5 % (p := prime(n)), 1 % p, 7 % p, 3 % p, 15 % p)
    s = sum(b) % p
    for m in count(1):
        b, s = b[1:] + (s,), (s + s - b[0]) % p
        if a == b:
            return m


def A068527(n):
    return 0 if n == 0 else (isqrt(n - 1) + 1) ** 2 - n


def A348596(n):
    return (isqrt(2 * n) + 1) ** 2 - 2 * n - 1


def A350962(n):
    return 0 if n == 0 else (isqrt(2 * n - 1) + 1) ** 2 - 2 * n


def A106290(n):
    bset, tset = set(), set()
    for t in product(range(n), repeat=5):
        t2 = t
        for c in count(1):
            t2 = t2[1:] + (sum(t2) % n,)
            if t == t2:
                bset.add(c)
                tset.add(t)
                break
            if t2 in tset:
                tset.add(t)
                break
    return len(bset)


def A351657_helper(n, pe):
    a = b = (0,) * (n - 1) + (1 % pe,)
    s = 1 % pe
    for m in count(1):
        b, s = b[1:] + (s,), (s + s - b[0]) % pe
        if a == b:
            return m


def A351657(n):
    return (
        1
        if n == 1
        else lcm(*(A351657_helper(n, p**e) for p, e in factorint(n).items()))
    )


def A143293_gen():  # generator of terms
    return accumulate(accumulate(chain((1,), (prime(n) for n in count(1))), mul))


def A225727_gen():  # generator of terms
    return (
        i + 1
        for i, m in enumerate(
            accumulate(accumulate(chain((1,), (prime(n) for n in count(1))), mul))
        )
        if m % (i + 1) == 0
    )


def A225841_gen():  # generator of terms
    return (
        i + 1
        for i, m in enumerate(accumulate(accumulate((prime(n) for n in count(1)), mul)))
        if m % (i + 1) == 0
    )


def A225728_gen():  # generator of terms
    return (
        prime(i + 1)
        for i, m in enumerate(
            accumulate(accumulate(chain((1,), (prime(n) for n in count(1))), mul))
        )
        if m % prime(i + 1) == 0
    )


def A045345_gen():  # generator of terms
    return (
        i + 1
        for i, m in enumerate(accumulate(prime(n) for n in count(1)))
        if m % (i + 1) == 0
    )


def A007504_gen():  # generator of terms
    return accumulate(prime(n) if n > 0 else 0 for n in count(0))


def A007504(n):
    return sum(primerange(prime(n) + 1)) if n else 0


@lru_cache(maxsize=None)
def A351889_T(n, k):  # computes the period of the n-step Fibonacci sequence mod k
    if len(fs := factorint(k)) <= 1:
        a = b = (0,) * (n - 1) + (1 % k,)
        s = 1 % k
        for m in count(1):
            b, s = b[1:] + (s,), (s + s - b[0]) % k
            if a == b:
                return m
    else:
        return lcm(*(A351889_T(n, p**e) for p, e in fs.items()))


def A351568(n):
    return prod(
        1 if e % 2 else (p ** (e + 1) - 1) // (p - 1) for p, e in factorint(n).items()
    )


def A351569(n):
    return prod(
        (p ** (e + 1) - 1) // (p - 1) if e % 2 else 1 for p, e in factorint(n).items()
    )


def A350389(n):
    return prod(p**e if e % 2 else 1 for p, e in factorint(n).items())


def A351808_gen():  # generator of terms
    return (
        q
        for q, r in (
            divmod(prod(int(d) for d in str(m**2)), prod(int(d) for d in str(m)))
            for m in count(1)
            if "0" not in str(m)
        )
        if r == 0
    )


def A351807_gen():  # generator of terms
    return (
        m
        for m in count(1)
        if "0" not in str(m)
        and prod(int(d) for d in str(m**2)) % prod(int(d) for d in str(m)) == 0
    )


def A046738(n):
    a = b = (0, 0, 1 % n)
    for m in count(1):
        b = b[1:] + (sum(b) % n,)
        if a == b:
            return m


def A106302(n):
    a = b = (0,) * 2 + (1 % (p := prime(n)),)
    for m in count(1):
        b = b[1:] + (sum(b) % p,)
        if a == b:
            return m


def A195199(n):
    f = Counter(factorint(n))
    d = prod(e + 1 for e in f.values())
    for m in count(2):
        if prod(e + 1 for e in (f + Counter(factorint(m))).values()) > 2 * d:
            return m * n


def A351126(n):
    f = Counter(factorint(n))
    d = prod(e + 1 for e in f.values())
    for m in count(2):
        if prod(e + 1 for e in (f + Counter(factorint(m))).values()) > 2 * d:
            return m


def A037276(n):
    return (
        1
        if n == 1
        else int("".join(str(d) for d in sorted(factorint(n, multiple=True))))
    )


def A351975_gen(startvalue=1):  # generator of terms
    for k in count(max(startvalue, 1)):
        c = 0
        for d in sorted(factorint(k, multiple=True)):
            c = (c * 10 ** len(str(d)) + d) % k
        if c == k - 1:
            yield k


def A349705_gen(startvalue=1):  # generator of terms
    for k in count(max(startvalue, 1)):
        c = 0
        for d in sorted(factorint(k, multiple=True)):
            c = (c * 10 ** len(str(d)) + d) % k
        if c == 1:
            yield k


def A347859(n):
    return (
        n // 2
        if n % 2 == 0 and isprime(n // 2)
        else 3 * (n - 1) // 2 if n % 2 and isprime((n - 1) // 2) else n
    )


def A340592(n):
    c = 0
    for d in sorted(factorint(n, multiple=True)):
        c = (c * 10 ** len(str(d)) + d) % n
    return c


def A001178(n):
    m = n
    for c in count(0):
        k = A001175(m)
        if k == m:
            return c
        m = k


def A351989(n):
    return fibonacci((p := prime(n)) - jacobi_symbol(p, 5)) % p**3


def A352038(n):
    return prod(
        (p ** (10 * (e + 1)) - 1) // (p**10 - 1)
        for p, e in factorint(n).items()
        if p > 2
    ) - (n**10 if n % 2 else 0)


def A352047(n):
    return (
        prod(
            p**e if p == 2 else (p ** (e + 1) - 1) // (p - 1)
            for p, e in factorint(n).items()
        )
        - n % 2
    )


def A351619(n):
    return (0 if n % 2 else 2) - len(primefactors(n))


def A352023_gen():  # generator of terms
    yield from (2, 3, 5)
    p = 7
    while True:
        if "9" not in str(10 ** (n_order(10, p)) // p):
            yield p
        p = nextprime(p)


def A187614_gen():  # generator of terms
    yield from (2, 3, 5)
    p = 7
    while True:
        if len(set("0" + str(10 ** (n_order(10, p)) // p))) < 10:
            yield p
        p = nextprime(p)


def A216664_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue + 1 - startvalue % 2, 1), 2):
        if 10 ** ((n + 1) // 2) // n % 10 == 9:
            yield n


def A351782(n):
    return n - 1 - int(n % 4 == 0)


def A050795_gen(startvalue=2):  # generator of terms
    for k in count(max(startvalue, 2)):
        if all(
            map(lambda d: d[0] % 4 != 3 or d[1] % 2 == 0, factorint(k**2 - 1).items())
        ):
            yield k


def A140612_gen(startvalue=0):  # generator of terms
    for k in count(max(startvalue, 0)):
        if all(
            starmap(
                lambda d, e: e % 2 == 0 or d % 4 != 3, factorint(k * (k + 1)).items()
            )
        ):
            yield k


def A351211(n):
    return integer_nthroot(3 * 10 ** (14 * (n - 1)), 14)[0] % 10


def A351210(n):
    return integer_nthroot(3 * 10 ** (13 * (n - 1)), 13)[0] % 10


def A351209(n):
    return integer_nthroot(3 * 10 ** (12 * (n - 1)), 12)[0] % 10


def A351208(n):
    return integer_nthroot(3 * 10 ** (11 * (n - 1)), 11)[0] % 10


def A246711(n):
    return integer_nthroot(3 * 10 ** (10 * (n - 1)), 10)[0] % 10


def A011273(n):
    return integer_nthroot(9 * 10 ** (19 * (n - 1)), 19)[0] % 10


def A352152(n):
    return int(
        "".join(
            "".join(list(g) if k else list(g)[::-1])
            for k, g in groupby(str(n), key=lambda x: x == "0")
        )
    )


@lru_cache(maxsize=None)
def A006165(n):
    return 1 if n <= 2 else A006165(n // 2) + A006165((n + 1) // 2)


@lru_cache(maxsize=None)
def A060973(n):
    return n - 1 if n <= 2 else A060973(n // 2) + A060973((n + 1) // 2)


@lru_cache(maxsize=None)
def A283187(n):
    return (
        n
        if n <= 1
        else (
            A283187(n // 2) + (-1 if A283187((n + 1) // 2) % 2 else 1)
            if n % 2
            else 2 * A283187(n // 2)
        )
    )


@lru_cache(maxsize=None)
def A087808(n):
    return 0 if n == 0 else A087808(n // 2) + (1 if n % 2 else A087808(n // 2))


def A352179_gen(startvalue=1):  # generator of terms
    k = max(startvalue, 1)
    k14 = 14**k
    while True:
        if str(k14)[:2] == "14":
            yield k
        k += 1
        k14 *= 14


def A352239_gen():  # generator of terms
    for l in count(0):
        k14 = 14 ** (14 * 10**l)
        for k in range(14 * 10**l, 15 * 10**l):
            if str(k14)[:2] == "14":
                yield k
            k14 *= 14


def A053646(n):
    return min(n - (m := 2 ** (len(bin(n)) - 3)), 2 * m - n)


def A350809(n):
    return len(set(p - n % p for p in primerange(2, n + 1)))


def A352232(n):
    return (2 ** n_order(2, p := prime(n)) - 1) // p


def A351985(n):
    return abs(sum((-1 if a % 2 else 1) * int(b) ** 3 for a, b in enumerate(str(n))))


def A352296(n):
    if n == 0:
        return 1
    pset, plist, pmax = {2}, [2], 4
    for m in count(2):
        if m > pmax:
            plist.append(nextprime(plist[-1]))
            pset.add(plist[-1])
            pmax = plist[-1] + 2
        c = 0
        for p in plist:
            if 2 * p > m:
                break
            if m - p in pset:
                c += 1
        if c == n:
            return m


def A014494(n):
    return (2 * n + 1) * (n + (n & 1))


def A352115(n):
    return (n << 1) * (n + 1) * (n + 2) // 3 + (n + 1) * (n & 1)


def A351653(n):
    return int("".join(str(len(list(g))) for k, g in groupby(str(n))))


def A318927(n):
    return int("".join(str(len(list(g))) for k, g in groupby(bin(n)[2:])))


def A318926(n):
    return int("".join(str(len(list(g))) for k, g in groupby(bin(n)[:1:-1])))


def A352187_gen():  # generator of terms
    bset, blist, mmax = {1, 2}, [1, 2], 3
    yield from blist
    while True:
        for m in count(mmax):
            if gcd(m, blist[-1]) > 1 and m not in bset:
                if (
                    all(blist[-2] % p == 0 for p in primefactors(blist[-1]))
                    or gcd(m, blist[-2]) == 1
                ):
                    yield m
                    blist = [blist[-1], m]
                    bset.add(m)
                    while mmax in bset:
                        mmax += 1
                    break


def A352191_gen():  # generator of terms
    bset, blist, mmax, c = {1, 2}, [1, 2], 3, 2
    yield from blist
    while True:
        for m in count(mmax):
            if gcd(m, blist[-1]) > 1 and m not in bset:
                if (
                    all(blist[-2] % p == 0 for p in primefactors(blist[-1]))
                    or gcd(m, blist[-2]) == 1
                ):
                    if m > c:
                        yield m
                        c = m
                    blist = [blist[-1], m]
                    bset.add(m)
                    while mmax in bset:
                        mmax += 1
                    break


def A352192_gen():  # generator of terms
    bset, blist, mmax, c = {1, 2}, [1, 2], 3, 2
    yield from blist
    for n in count(3):
        for m in count(mmax):
            if gcd(m, blist[-1]) > 1 and m not in bset:
                if (
                    all(blist[-2] % p == 0 for p in primefactors(blist[-1]))
                    or gcd(m, blist[-2]) == 1
                ):
                    if m > c:
                        yield n
                        c = m
                    blist = [blist[-1], m]
                    bset.add(m)
                    while mmax in bset:
                        mmax += 1
                    break


def A055085(n):  # assumes n <= 62
    dlist = tuple(gmpy2digits(d, n) for d in range(n))
    for l in count(n - 1):
        for t in product(dlist, repeat=l - n + 1):
            for d in range(1, n):
                for u in multiset_permutations(sorted(t + dlist[:d] + dlist[d + 1 :])):
                    m = mpz("".join((dlist[d],) + tuple(u)), n)
                    for b in range(n - 1, 1, -1):
                        if len(set(gmpy2digits(m, b))) < b:
                            break
                    else:
                        return int(m)


def A351426(n):  # assumes n <= 62
    if n == 2:
        return 1
    dlist = tuple(gmpy2digits(d, n) for d in range(n))
    for l in count(n - 2):
        for d in range(1, n):
            c = None
            for t in product(dlist, repeat=l - n + 2):
                for u in multiset_permutations(sorted(t + dlist[1:d] + dlist[d + 1 :])):
                    m = mpz("".join((dlist[d],) + tuple(u)), n)
                    for b in range(n - 1, 1, -1):
                        if len(set(gmpy2digits(m, b)) | {"0"}) < b:
                            break
                    else:
                        if c != None:
                            c = min(m, c)
                        else:
                            c = m
            if c != None:
                return int(c)


def A352447_gen():  # generator of terms
    yield 1
    a = Counter()
    for k in count(2):
        b = Counter(factorint(k - 1))
        if all(b[p] <= a[p] for p in b):
            yield k
        a += b


def A352142_gen(startvalue=1):  # generator of terms
    return filter(
        lambda k: all(
            map(lambda x: x[1] % 2 and primepi(x[0]) % 2, factorint(k).items())
        ),
        count(max(startvalue, 1)),
    )


def A352141_gen(startvalue=1):  # generator of terms
    return filter(
        lambda k: all(
            map(lambda x: not (x[1] % 2 or primepi(x[0]) % 2), factorint(k).items())
        ),
        count(max(startvalue, 1)),
    )


@lru_cache(maxsize=None)
def A109129(n):
    if n <= 2:
        return n - 1
    if isprime(n):
        return A109129(primepi(n))
    return sum(e * A109129(p) for p, e in factorint(n).items())


@lru_cache(maxsize=None)
def A061775(n):
    if n == 1:
        return 1
    if isprime(n):
        return 1 + A061775(primepi(n))
    return 1 + sum(e * (A061775(p) - 1) for p, e in factorint(n).items())


@lru_cache(maxsize=None)
def A196050(n):
    if n == 1:
        return 0
    if isprime(n):
        return 1 + A196050(primepi(n))
    return sum(e * A196050(p) for p, e in factorint(n).items())


@lru_cache(maxsize=None)
def A109082(n):
    if n == 1:
        return 0
    if isprime(n):
        return 1 + A109082(primepi(n))
    return max(A109082(p) for p in primefactors(n))


def A351928(n):
    kmax, m = 3**n, (3 ** (n - 1)).bit_length()
    k2 = pow(2, m, kmax)
    for k in count(m):
        a = k2
        while a > 0:
            a, b = divmod(a, 3)
            if b == 2:
                break
        else:
            return k
        k2 = 2 * k2 % kmax


def A351927(n):
    kmax, m = 3**n, (3 ** (n - 1)).bit_length()
    k2 = pow(2, m, kmax)
    for k in count(m):
        a = k2
        if 3 * a >= kmax:
            while a > 0:
                a, b = divmod(a, 3)
                if b == 0:
                    break
            else:
                return k
        k2 = 2 * k2 % kmax


def A030298_gen():  # generator of terms
    return chain.from_iterable(p for l in count(2) for p in permutations(range(1, l)))


def A061077(n):
    return sum(prod(int(d) for d in str(2 * i + 1)) for i in range(n))


def A061078(n):
    return sum(prod(int(d) for d in str(2 * i + 2)) for i in range(n))


def A061076(n):
    return sum(prod(int(d) for d in str(i)) for i in range(1, n + 1))


def A352329_gen():  # generator of terms
    for l in count(1):
        if (r := l * (l + 1) // 2 % 9) == 0 or r == 1 or r == 4 or r == 7:
            m = tuple(10 ** (l - i - 1) for i in range(l))
            for p in permutations(range(1, l + 1)):
                if integer_nthroot(n := sum(prod(k) for k in zip(m, p)), 2)[1]:
                    yield n


def A352346_gen():  # generator of terms
    n1, m1, n2, m2 = 1, 1, 2, 2
    while True:
        if m1 == m2:
            yield m1
        k = 0
        while k == 0:
            n1 += 2
            m1 += (k := prod(int(d) for d in str(n1)))
        while m2 < m1:
            n2 += 2
            m2 += prod(int(d) for d in str(n2))


def A352601(n):
    return rf(2 * n, n)


def A124320_T(n, k):
    return rf(n, k)


def A351826(n):
    for k in count(1, 2):
        c = 0
        for j in count(1):
            if k - 2**j < 2:
                break
            if isprime(k - 2**j) and isprime(k + 2**j):
                c += 1
            if c > n:
                break
        if c == n:
            return k


def A352420(n):
    return len(
        set().union(
            *(
                primefactors((p ** ((e + 1) * n) - 1) // (p**n - 1))
                for p, e in factorint(n).items()
            )
        )
    )


def A352535_gen(startvalue=0):  # generator of terms
    return filter(
        lambda m: not sum(
            int(d) ** 2 * (-1 if i % 2 else 1) for i, d in enumerate(str(m))
        ),
        count(max(startvalue, 0)),
    )


def A351319(n):
    return n if n <= 2 else int((k := isqrt(n)) ** 2 + k - n + 1 > 0)


def A352155_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        m2, m5 = multiplicity(2, n), multiplicity(5, n)
        k, m = 10 ** max(m2, m5), 10 ** (t := n_order(10, n // 2**m2 // 5**m5)) - 1
        c = k // n
        s = str(m * k // n - c * m).zfill(t)
        if s == "0" and min(str(c)) == "1":
            yield n
        elif "0" not in s and min(str(c).lstrip("0") + s) == "1":
            yield n


def A352156_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        m2, m5 = multiplicity(2, n), multiplicity(5, n)
        k, m = 10 ** max(m2, m5), 10 ** (t := n_order(10, n // 2**m2 // 5**m5)) - 1
        c = k // n
        s = str(m * k // n - c * m).zfill(t)
        if s == "0" and min(str(c)) == "2":
            yield n
        elif "0" not in s and min(str(c).lstrip("0") + s) == "2":
            yield n


def A352157_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        m2, m5 = multiplicity(2, n), multiplicity(5, n)
        k, m = 10 ** max(m2, m5), 10 ** (t := n_order(10, n // 2**m2 // 5**m5)) - 1
        c = k // n
        s = str(m * k // n - c * m).zfill(t)
        if "0" not in s and min(str(c).lstrip("0") + s) == "3":
            yield n


def A352158_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        m2, m5 = multiplicity(2, n), multiplicity(5, n)
        k, m = 10 ** max(m2, m5), 10 ** (t := n_order(10, n // 2**m2 // 5**m5)) - 1
        c = k // n
        s = str(m * k // n - c * m).zfill(t)
        if s == "0" and min(str(c)) == "4":
            yield n
        elif "0" not in s and min(str(c).lstrip("0") + s) == "4":
            yield n


def A352159_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        m2, m5 = multiplicity(2, n), multiplicity(5, n)
        k, m = 10 ** max(m2, m5), 10 ** (t := n_order(10, n // 2**m2 // 5**m5)) - 1
        c = k // n
        s = str(m * k // n - c * m).zfill(t)
        if s == "0" and min(str(c)) == "5":
            yield n
        elif "0" not in s and min(str(c).lstrip("0") + s) == "5":
            yield n


def A352160_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        m2, m5 = multiplicity(2, n), multiplicity(5, n)
        k, m = 10 ** max(m2, m5), 10 ** (t := n_order(10, n // 2**m2 // 5**m5)) - 1
        c = k // n
        s = str(m * k // n - c * m).zfill(t)
        if "0" not in s and min(str(c).lstrip("0") + s) == "6":
            yield n


if sys.version_info < (3, 10):

    def A352631(n):
        return (
            -1
            if n == 2
            else min(
                bin(k**2)[2:].count("0")
                for k in range(1 + isqrt(2 ** (n - 1) - 1), 1 + isqrt(2**n))
            )
        )

else:

    def A352631(n):
        return (
            -1
            if n == 2
            else min(
                n - (k**2).bit_count()
                for k in range(1 + isqrt(2 ** (n - 1) - 1), 1 + isqrt(2**n))
            )
        )


def A352375_gen():  # generator of terms
    a = 5
    while True:
        yield (s := sum(int(d) for d in str(a)))
        a += s


def A016096_gen():  # generator of terms
    a = 9
    while True:
        yield a
        a += sum(int(d) for d in str(a))


def A350813(n):
    m = prod(islice(filter(lambda p: p % 4 == 1, sieve), n))
    a = isqrt(m)
    d = max(filter(lambda d: d <= a, divisors(m, generator=True)))
    return (m // d - d) // 2


def A349708(n):
    m = primorial(n + 1) // 2
    a = isqrt(m)
    d = max(filter(lambda d: d <= a, divisors(m, generator=True)))
    return (m // d - d) // 2


def A352715_gen():  # generator of terms
    yield 1
    l1, s, b, bli = 1, 2, set(), 0
    while True:
        i = s
        while True:
            if not (i in b or bin(i & l1).count("1") != bli):
                yield i
                l1 = i
                bli = l1.bit_length() // 2
                b.add(i)
                while s in b:
                    b.remove(s)
                    s += 1
                break
            i += 1


def A352716_gen():  # generator of terms
    yield 1
    l1, s, b = 1, 2, set()
    while True:
        i = s
        while True:
            if not (i in b or bin(i & l1).count("1") % 2):
                yield i
                l1 = i
                b.add(i)
                while s in b:
                    b.remove(s)
                    s += 1
                break
            i += 1


def A000037_gen(startvalue=1):  # generator of terms
    k = isqrt(max(startvalue, 1))
    for m in count(k):
        yield from range(m**2 + 1, (m + 1) ** 2)


def A000217(n):
    return n * (n + 1) // 2


def A000196(n):
    return isqrt(n)


def A086849_gen():  # generator of terms
    c, k = 0, 1
    while True:
        for n in range(k**2 + 1, (k + 1) ** 2):
            c += n
            yield c
        k += 1


def A352738_gen():  # generator of terms
    c, k, ks, m, ms = 0, 1, 2, 1, 1
    while True:
        for n in range(ks, ks + 2 * k):
            c += n
            if c == ms:
                yield c
            elif c > ms:
                ms += 2 * m + 1
                m += 1
        ks += 2 * k + 1
        k += 1


def A308485(n):
    return sum(
        p * e
        for m in range(prime(n) + 1, prime(n + 1))
        for p, e in factorint(m).items()
    )


def A351855_gen():  # generator of terms
    c, k, ks, m, p, q = 0, 1, 2, 1, 4, 5
    while True:
        for n in range(ks, ks + 2 * k):
            c += n
            if c == m:
                yield c
            else:
                while c > m:
                    m += p
                    p += 1
                    if p == q:
                        q = nextprime(q)
                        p += 1
        ks += 2 * k + 1
        k += 1


def A352813(n):
    m = factorial(2 * n)
    return (
        0
        if n == 0
        else min(
            abs((p := prod(d)) - m // p)
            for d in combinations(range(2, 2 * n + 1), n - 1)
        )
    )


def A038667(n):
    m = factorial(n)
    return (
        0
        if n == 0
        else min(
            abs((p := prod(d)) - m // p)
            for l in range(n, n // 2, -1)
            for d in combinations(range(1, n + 1), l)
        )
    )


def A061057(n):
    k = factorial(n)
    m = max(d for d in divisors(k, generator=True) if d <= isqrt(k))
    return k // m - m


def A263292(n):
    m = factorial(n)
    return (
        1
        if n == 0
        else len(
            set(
                abs((p := prod(d)) - m // p)
                for l in range(n, n // 2, -1)
                for d in combinations(range(1, n + 1), l)
            )
        )
    )


def A200744(n):
    m = factorial(n)
    return min(
        (abs((p := prod(d)) - m // p), max(p, m // p))
        for l in range(n, n // 2, -1)
        for d in combinations(range(1, n + 1), l)
    )[1]


def A200743(n):
    m = factorial(n)
    return min(
        (abs((p := prod(d)) - m // p), min(p, m // p))
        for l in range(n, n // 2, -1)
        for d in combinations(range(1, n + 1), l)
    )[1]


def A351744(n):
    return int(str(n).translate({48: 49, 50: 51, 52: 53, 54: 55, 56: 57}))


def A106747(n):
    return int(
        str(n).translate(
            {49: 48, 50: 49, 51: 49, 52: 50, 53: 50, 54: 51, 55: 51, 56: 52, 57: 52}
        )
    )


def A107130(n):
    return int(str(n).translate({49: 48, 51: 49, 53: 50, 55: 51, 57: 52}))


def A306436(n):
    return int(
        str(n).translate(
            {
                48: 49,
                49: 48,
                50: 51,
                51: 50,
                52: 53,
                53: 52,
                54: 55,
                55: 54,
                56: 57,
                57: 56,
            }
        )
    )


def A107128(n):
    return int(str(n).translate({50: 49, 52: 50, 54: 51, 56: 52}))


def A352788_gen():  # generator of terms
    c, m, ms = 0, 1, 1
    for n in count(1):
        c += 1 if n <= 2 else n * totient(n) // 2
        if c == ms:
            yield c
        else:
            while c > ms:
                ms += 2 * m + 1
                m += 1


def A352148_gen():  # generator of terms
    yield 0
    for l in count(0):
        for d in range(1, 10):
            for m in range(2**l, 2 ** (l + 1)):
                a, b = integer_nthroot(8 * d * int(bin(m)[2:]) + 1, 2)
                if b:
                    yield (a - 1) // 2


def A353243_gen():  # generator of terms
    k, c = Fraction(), 0
    for n in count(1):
        k += Fraction(1, n)
        if c < (m := max(continued_fraction(k))):
            c = m
            yield n


def A353244_gen():  # generator of terms
    k, c = Fraction(), 0
    for n in count(1):
        k += Fraction(1, n)
        if c < (m := max(continued_fraction(k))):
            yield (c := m)


def A023896(n):
    return 1 if n == 1 else n * totient(n) // 2


def A103181(n):
    return int("".join(str(int(d) % 2) for d in str(n)))


def A352881(n):
    from sympy.abc import y, z

    zc = Counter()
    for x in range(1, 10**n + 1):
        for d in diophantine(z * (x + y) - x * y):
            if x <= d[0] <= 10 ** n and d[1] >= 0:
                zc[d[1]] += 1
    return sorted(zc.items(), key=lambda x: (-x[1], x[0]))[0][0]


def A352635(n):
    cset, iset = set(), set()
    for i in range(n):
        if i not in iset:
            j, jset, jlist = i, set(), []
            while j not in jset:
                jset.add(j)
                jlist.append(j)
                iset.add(j)
                j = (j**2 + 1) % n
            cset.add(min(jlist[jlist.index(j) :]))
    return len(cset)


@lru_cache(maxsize=None)
def A352969_set(n):
    if n == 0:
        return {1}
    return set(
        sum(x) for x in combinations_with_replacement(A352969_set(n - 1), 2)
    ) | set(prod(x) for x in combinations_with_replacement(A352969_set(n - 1), 2))


def A353969(n):
    return len(A352969_set(n))


def A263995(n):
    return len(
        set(sum(x) for x in combinations_with_replacement(range(1, n + 1), 2))
        | set(prod(x) for x in combinations_with_replacement(range(1, n + 1), 2))
    )


def A352040(n):
    k = 10 * n - 1 + int(ceiling((10 * n - 1) * log(5, 2)))
    s = str(c := 2**k)
    while any(s.count(d) < n for d in "0123456789"):
        c *= 2
        k += 1
        s = str(c)
    return k


@lru_cache(maxsize=None)
def A352289(n):
    return 1 if n == 1 else 2 * prime(A352289(n - 1))


def A064989(n):
    return prod(
        prevprime(p) ** e for p, e in factorint(n >> (~n & n - 1).bit_length()).items()
    )


def A252463(n):
    return A064989(n) if n & 1 else n >> 1


def A353412(n):
    return int(
        bin(
            prod(1 if p == 2 else prevprime(p) * e for p, e in factorint(n).items())
            if n & 1
            else n >> 1
        )[2:].rstrip("0"),
        2,
    )


def A051064(n):
    c = 1
    a, b = divmod(n, 3)
    while b == 0:
        a, b = divmod(a, 3)
        c += 1
    return c


def A352992(n):
    n10, n7 = 10**n, (10**n - 1) * 7 // 9
    for m in count(1):
        a, b = divmod(m**3, n10)
        if b == n7 and a % 10 != 7:
            return m


def A351374_gen():  # generator of terms
    for k in range(1, 157):
        a = tuple(i**k for i in range(20))
        yield from (
            x[0]
            for x in sorted(
                filter(
                    lambda x: x[0] > 0
                    and tuple(sorted(sympydigits(x[0], 20)[1:])) == x[1],
                    (
                        (sum(map(lambda y: a[y], b)), b)
                        for b in combinations_with_replacement(range(20), k)
                    ),
                )
            )
        )


def A010354_gen():  # generator of terms
    for k in range(1, 30):
        a = tuple(i**k for i in range(8))
        yield from (
            x[0]
            for x in sorted(
                filter(
                    lambda x: x[0] > 0
                    and tuple(int(d, 8) for d in sorted(oct(x[0])[2:])) == x[1],
                    (
                        (sum(map(lambda y: a[y], b)), b)
                        for b in combinations_with_replacement(range(8), k)
                    ),
                )
            )
        )


def A161953_gen():  # generator of terms
    for k in range(1, 74):
        a = tuple(i**k for i in range(16))
        yield from (
            x[0]
            for x in sorted(
                filter(
                    lambda x: x[0] > 0
                    and tuple(int(d, 16) for d in sorted(hex(x[0])[2:])) == x[1],
                    (
                        (sum(map(lambda y: a[y], b)), b)
                        for b in combinations_with_replacement(range(16), k)
                    ),
                )
            )
        )


def A352065(n):
    plist = [prime(k) for k in range(1, 2 * n + 2)]
    pd = prod(plist)
    while True:
        mlist = [nextprime(pd // (2 * n + 1) - 1)]
        for _ in range(n):
            mlist = [prevprime(mlist[0])] + mlist + [nextprime(mlist[-1])]
        if sum(mlist) <= pd:
            while (s := sum(mlist)) <= pd:
                if s == pd:
                    return plist[0]
                mlist = mlist[1:] + [nextprime(mlist[-1])]
        else:
            while (s := sum(mlist)) >= pd:
                if s == pd:
                    return plist[0]
                mlist = [prevprime(mlist[0])] + mlist[:-1]
        pd //= plist[0]
        plist = plist[1:] + [nextprime(plist[-1])]
        pd *= plist[-1]


def A353073_gen(startvalue=3):  # generator of terms
    q = nextprime(max(startvalue, 3) - 1)
    p, r = prevprime(q), nextprime(q)
    while True:
        if integer_nthroot(q - p, 2)[1] and integer_nthroot(r - q, 2)[1]:
            yield q
        t = q
        for i in count(1):
            t += 2 * i - 1
            if t >= r:
                break
            if integer_nthroot(r - t, 2)[1]:
                yield t
        p, q, r = q, r, nextprime(r)


def A007918(n):
    return nextprime(n - 1)


def A353088_gen():  # generator of terms
    p, q, g, h = 3, 5, True, False
    while True:
        if g and h:
            yield p
        p, q = q, nextprime(q)
        g, h = h, integer_nthroot(q - p, 2)[1]


def A353087(n):
    k, m, r = 1, 1, 10 ** (10 * n - 1)
    while m < r:
        k += 1
        m *= k
    s = str(m)
    while any(s.count(d) < n for d in "0123456789"):
        k += 1
        m *= k
        s = str(m)
    return k


def A353054_gen():  # generator of terms
    for l in count(1):
        a, b = 10**l - 2, 10 ** (l - 1) - 2
        for m in range(1, 10):
            q, r = divmod(m * a - 1, 19)
            if r == 0 and b <= q - 2 <= a:
                yield 10 * q + m


def A034180_gen():  # generator of terms
    for l in count(1):
        clist = []
        for k in range(1, 10):
            a, b = 10**l - k, 10 ** (l - 1) - k
            for m in range(1, 10):
                q, r = divmod(m * a - 1, 10 * k - 1)
                if r == 0 and b <= q - k <= a:
                    clist.append(10 * q + m)
        yield from sorted(clist)


def A035126_gen():  # generator of terms
    for l in count(0):
        l1, l2 = 10 ** (l + 1), 10**l
        yield from sorted(
            set(
                x**2
                for z in (diop_DN(10, m * (1 - l1)) for m in range(10))
                for x, y in z
                if l1 >= x**2 >= l2
            )
        )


def A035127_gen():  # generator of terms
    for l in count(0):
        l1, l2 = 10 ** (l + 1), 10**l
        yield from sorted(
            set(
                y**2
                for z in (diop_DN(10, m * (1 - l1)) for m in range(10))
                for x, y in z
                if l1 >= x**2 >= l2
            )
        )


def A045877_gen():  # generator of terms
    for l in count(0):
        l1, l2 = 10 ** (l + 1), 10**l
        yield from sorted(
            set(
                abs(x)
                for z in (diop_DN(10, m * (1 - l1)) for m in range(10))
                for x, y in z
                if l1 >= x**2 >= l2
            )
        )


def A045878_gen():  # generator of terms
    for l in count(0):
        l1, l2 = 10 ** (l + 1), 10**l
        yield from sorted(
            set(
                abs(y)
                for z in (diop_DN(10, m * (1 - l1)) for m in range(10))
                for x, y in z
                if l1 >= x**2 >= l2
            )
        )


def A353220(n):
    return reduce(lambda x, _: (3 * x + 1) // 2, range(n), n)


def A353215(n):
    return reduce(lambda x, _: (3 * x - 1) // 2, range(n), n)


def A353613_gen(startvalue=1):  # generator of terms
    for m in count(max(startvalue, 1)):
        m2, m5 = multiplicity(2, m), multiplicity(5, m)
        if set(
            str(10 ** (max(m2, m5) + n_order(10, m // 2**m2 // 5**m5)) // m)
        ) <= {"0", "2", "4", "6", "8"}:
            yield m


def A353614_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        m2, m5 = multiplicity(2, n), multiplicity(5, n)
        k, m = 10 ** max(m2, m5), 10 ** (t := n_order(10, n // 2**m2 // 5**m5)) - 1
        c = k // n
        s = str(m * k // n - c * m).zfill(t)
        if set(str(c).lstrip("0") + ("" if int(s) == 0 else s)) <= {
            "1",
            "3",
            "5",
            "7",
            "9",
        }:
            yield n


def A338754(n):
    return int("".join(d * 2 for d in str(n)))


def A338086(n):
    return int("".join(d * 2 for d in gmpy2digits(n, 3)), 3)


def A351501(n):
    return comb(m := n**2 + n - 1, n) // m


def A099306(n):
    return A003415(A003415(A003415(n)))


def A068346(n):
    return A003415(A003415(n))


def A353691_helper(n):
    f = factorint(n).items()
    return prod(p**e * (p - 1) * (e + 1) for p, e in f), prod(
        p ** (e + 1) - 1 for p, e in f
    )


def A353691(n):
    Hnp, Hnq = A353691_helper(n)
    g = gcd(Hnp, Hnq)
    Hnp //= g
    Hnq //= g
    k = n + 1
    Hkp, Hkq = A353691_helper(k)
    while (Hkp * Hnq) % (Hkq * Hnp):
        k += 1
        Hkp, Hkq = A353691_helper(k)
    return k


def A352940(n):
    return (isqrt(n**2 * (n * (2 * n - 4) + 2) + 1) - 1) // 2


def A353709_gen():  # generator of terms
    s, a, b, c, ab = {0, 1}, 0, 1, 2, 1
    yield from (0, 1)
    while True:
        for n in count(c):
            if not (n & ab or n in s):
                yield n
                a, b = b, n
                ab = a | b
                s.add(n)
                while c in s:
                    c += 1
                break


def A000005(n):
    return divisor_count(n)


def A000010(n):
    return totient(n)


def A000027(n):
    return n


def A005117_gen(startvalue=1):
    return filter(
        lambda n: all(x == 1 for x in factorint(n).values()), count(max(startvalue, 1))
    )


if sys.version_info >= (3, 10):

    def A000069_gen(startvalue=0):
        return filter(lambda n: n.bit_count() % 2, count(max(startvalue, 0)))

    def A001969_gen(startvalue=0):
        return filter(lambda n: not n.bit_count() % 2, count(max(startvalue, 0)))

else:

    def A000069_gen(startvalue=0):
        return filter(lambda n: bin(n).count("1") % 2, count(max(startvalue, 0)))

    def A001969_gen(startvalue=0):
        return filter(lambda n: not bin(n).count("1") % 2, count(max(startvalue, 0)))


def A002654(n):
    return prod(
        1 if p == 2 else (e + 1 if p & 3 == 1 else (e + 1) & 1)
        for p, e in factorint(n).items()
    )


def A004018(n):
    return (
        prod(
            1 if p == 2 else (e + 1 if p & 3 == 1 else (e + 1) & 1)
            for p, e in factorint(n).items()
        )
        << 2
        if n
        else 1
    )


def A353710_gen():  # generator of terms
    s, a, b, c, ab = {0, 1}, 0, 1, 2, 1
    yield from (0, 1)
    while True:
        for n in count(c):
            if not (n & ab or n in s):
                yield c
                a, b = b, n
                ab = a | b
                s.add(n)
                while c in s:
                    c += 1
                break


def A353718_gen():  # generator of terms
    s, a, b, c, ab, k = {0, 1}, 0, 1, 2, 1, 1
    yield from (1, 1)
    while True:
        for n in count(c):
            if not (n & ab or n in s):
                a, b = b, n
                ab = a | b
                s.add(n)
                if c in s:
                    yield k
                    k = 0
                    while c in s:
                        c += 1
                k += 1
                break


def A048785(n):
    return 0 if n == 0 else prod(3 * e + 1 for e in factorint(n).values())


def A353551(n):
    return sum(prod(3 * e + 1 for e in factorint(k).values()) for k in range(1, n + 1))


def A061503(n):
    return sum(prod(2 * e + 1 for e in factorint(k).values()) for k in range(1, n + 1))


def A353789(n):
    return prod(
        (q := nextprime(p)) ** (e - 1) * p**e * (q - 1) for p, e in factorint(n).items()
    )


def A003961(n):
    return prod(nextprime(p) ** e for p, e in factorint(n).items())


def A353906(n):
    return sum(
        (-1 if i % 2 else 1) * int(j) for i, j in enumerate(str(n)[::-1])
    ) ** len(str(n))


def A055017(n):
    return sum((-1 if i % 2 else 1) * int(j) for i, j in enumerate(str(n)[::-1]))


def A002997_gen():  # generator of terms
    p, q = 3, 5
    while True:
        for n in range(p + 2, q, 2):
            f = factorint(n)
            if max(f.values()) == 1 and not any((n - 1) % (p - 1) for p in f):
                yield n
        p, q = q, nextprime(q)


def A352970_gen():  # generator of terms
    p, q = 3, 5
    while True:
        for n in range(p + 11 - ((p + 2) % 10), q, 10):
            f = factorint(n)
            if max(f.values()) == 1 and not any((n - 1) % (p - 1) for p in f):
                yield n
        p, q = q, nextprime(q)


def A011782(n):
    return 1 if n == 0 else 2 ** (n - 1)


def A353715_gen():  # generator of terms
    s, a, b, c, ab = {0, 1}, 0, 1, 2, 1
    yield 1
    while True:
        for n in count(c):
            if not (n & ab or n in s):
                yield b + n
                a, b = b, n
                ab = a | b
                s.add(n)
                while c in s:
                    c += 1
                break


def A353724_gen():  # generator of terms
    s, a, b, c, ab = {0, 1}, 0, 1, 2, 1
    yield 0
    while True:
        for n in count(c):
            if not (n & ab or n in s):
                yield len(t := bin(b + n)) - len(t.rstrip("0"))
                a, b = b, n
                ab = a | b
                s.add(n)
                while c in s:
                    c += 1
                break


def A070939(n):
    return 1 if n == 0 else n.bit_length()


if sys.version_info >= (3, 10):

    def A353986_gen():  # generator of terms
        a, b, k, ah = 1, 1, 1, 1
        while True:
            if ah == (bh := b.bit_count()):
                yield k
            a, b, ah = b, a + b, bh
            k += 1

    def A353987_gen():  # generator of terms
        b, c, k, ah, bh = 1, 2, 1, 1, 1
        while True:
            if ah == (ch := c.bit_count()) == bh:
                yield k
            b, c, ah, bh = c, b + c, bh, ch
            k += 1

else:

    def A353986_gen():  # generator of terms
        a, b, k, ah = 1, 1, 1, 1
        while True:
            if ah == (bh := bin(b).count("1")):
                yield k
            a, b, ah = b, a + b, bh
            k += 1

    def A353987_gen():  # generator of terms
        b, c, k, ah, bh = 1, 2, 1, 1, 1
        while True:
            if ah == (ch := bin(c).count("1")) == bh:
                yield k
            b, c, ah, bh = c, b + c, bh, ch
            k += 1


def A353728_gen():  # generator of terms
    yield 1
    l1, s, b = 1, 2, set()
    while True:
        i = s
        while True:
            if i & l1 and not i in b:
                yield int(bin(i)[2:])
                l1 = i
                b.add(i)
                while s in b:
                    b.remove(s)
                    s += 1
                break
            i += 1


if sys.version_info >= (3, 10):

    def A352202_gen():  # generator of terms
        yield 1
        l1, s, b = 1, 2, set()
        while True:
            i = s
            while True:
                if i & l1 and not i in b:
                    yield i.bit_count()
                    l1 = i
                    b.add(i)
                    while s in b:
                        b.remove(s)
                        s += 1
                    break
                i += 1

else:

    def A352202_gen():  # generator of terms
        yield 1
        l1, s, b = 1, 2, set()
        while True:
            i = s
            while True:
                if i & l1 and not i in b:
                    yield bin(i).count("1")
                    l1 = i
                    b.add(i)
                    while s in b:
                        b.remove(s)
                        s += 1
                    break
                i += 1


def A352979(n):
    return (
        n**2
        * (
            n
            * (
                n
                * (
                    n
                    * (
                        n
                        * (
                            n
                            * (
                                n
                                * (n * (n * (n * (35 * n + 450) + 2293) + 5700) + 6405)
                                + 770
                            )
                            - 3661
                        )
                        - 240
                    )
                    + 2320
                )
                + 40
            )
            - 672
        )
        // 13440
    )


def A353021(n):
    return (
        n
        * (
            n
            * (
                n
                * (
                    n
                    * (
                        n
                        * (
                            n
                            * (
                                n
                                * (
                                    n
                                    * (
                                        8
                                        * n
                                        * (n * (70 * n * (5 * n + 84) + 40417) + 144720)
                                        + 2238855
                                    )
                                    + 2050020
                                )
                                + 207158
                            )
                            - 810600
                        )
                        - 58505
                    )
                    + 322740
                )
                + 7956
            )
            - 45360
        )
        // 5443200
    )


def A353618_gen():  # generator of terms
    for b in count(1):
        q, c = 2, 8
        while c < b:
            d = (b - c) ** 2 * (b + c)
            s, t = divmod(d, c)
            if t == 0:
                a, r = integer_nthroot(s, 2)
                if r and b - c < a < b + c and gcd(a, b, q) == 1:
                    yield from (a, b, c)
            c += q * (3 * q + 3) + 1
            q += 1


def A353729_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        s = str(n)
        if not (
            "0" in s
            or any(int("0" + s[:i] + s[i + 1 :]) % int(s[i]) for i in range(len(s)))
        ):
            yield n


def A268631(n):
    return (
        1
        - 2 * n
        + prod(p ** (e - 1) * ((p - 1) * e + p) for p, e in factorint(n).items())
    )


def A006579(n):
    return prod(p ** (e - 1) * ((p - 1) * e + p) for p, e in factorint(n).items()) - n


def A352980(n):
    return (
        n**2
        * (
            n
            * (
                n
                * (
                    n
                    * (
                        n
                        * (
                            n
                            * (
                                n * (n * (n * (n * (35 * n - 30) - 347) + 180) + 1365)
                                - 350
                            )
                            - 2541
                        )
                        + 240
                    )
                    + 2160
                )
                - 40
            )
            - 672
        )
        // 13440
    )


def A045584_gen(startvalue=1):  # generator of terms
    kstart = max(startvalue, 1)
    k3, k4 = 3**kstart, 4**kstart
    for k in count(kstart):
        if (k3 + k4) % k == 0:
            yield k
        k3 *= 3
        k4 *= 4


def A088534(n):
    c = 0
    for y in range(n + 1):
        if y**2 > n:
            break
        for x in range(y + 1):
            z = x * (x + y) + y**2
            if z > n:
                break
            elif z == n:
                c += 1
    return c


def A198775_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        c = 0
        for y in range(n + 1):
            if c > 4 or y**2 > n:
                break
            for x in range(y + 1):
                z = x * (x + y) + y**2
                if z > n:
                    break
                elif z == n:
                    c += 1
                    if c > 4:
                        break
        if c == 4:
            yield n


def A335951_T(n, k):
    z = (
        simplify(
            (bernoulli(2 * n, (sqrt(8 * symbolx + 1) + 1) / 2) - bernoulli(2 * n, 1))
            / (2 * n)
        )
        .as_poly()
        .all_coeffs()
    )
    return z[n - k] * lcm(*(d.q for d in z))


def A335951_gen():  # generator of terms
    yield from (A335951_T(n, k) for n in count(0) for k in range(n + 1))


def A335952(n):
    return lcm(
        *(
            d.q
            for d in simplify(
                (
                    bernoulli(2 * n, (sqrt(8 * symbolx + 1) + 1) / 2)
                    - bernoulli(2 * n, 1)
                )
                / (2 * n)
            )
            .as_poly()
            .all_coeffs()
        )
    )


if sys.version_info >= (3, 10):

    def A354112(n):
        return sum(d.bit_count() for d in divisors(2**n - 1, generator=True))

else:

    def A354112(n):
        return sum(bin(d).count("1") for d in divisors(2**n - 1, generator=True))


def A353943(n):
    return (
        2**10 + 1
        if n == 1
        else int(nthroot_mod(1, (p := prime(n)) - 1, p**10, True)[1])
    )


def A353942(n):
    return (
        2**9 + 1 if n == 1 else int(nthroot_mod(1, (p := prime(n)) - 1, p**9, True)[1])
    )


def A353941(n):
    return (
        2**8 + 1 if n == 1 else int(nthroot_mod(1, (p := prime(n)) - 1, p**8, True)[1])
    )


def A353940(n):
    return (
        2**7 + 1 if n == 1 else int(nthroot_mod(1, (p := prime(n)) - 1, p**7, True)[1])
    )


def A353939(n):
    return (
        2**6 + 1 if n == 1 else int(nthroot_mod(1, (p := prime(n)) - 1, p**6, True)[1])
    )


def A353938(n):
    return (
        2**5 + 1 if n == 1 else int(nthroot_mod(1, (p := prime(n)) - 1, p**5, True)[1])
    )


def A353937(n):
    return (
        2**4 + 1 if n == 1 else int(nthroot_mod(1, (p := prime(n)) - 1, p**4, True)[1])
    )


def A249275(n):
    return (
        2**3 + 1 if n == 1 else int(nthroot_mod(1, (p := prime(n)) - 1, p**3, True)[1])
    )


def A034939(n):
    return int(sqrt_mod(-1, 5**n))


def A257833_T(n, k):
    return (
        2**k + 1 if n == 1 else int(nthroot_mod(1, (p := prime(n)) - 1, p**k, True)[1])
    )


def A257833_gen():  # generator of terms
    yield from (A257833_T(n, i - n + 2) for i in count(1) for n in range(i, 0, -1))


def A352395(n):
    return sum(
        Fraction(-1 if k % 2 else 1, 2 * k + 1) for k in range(n + 1)
    ).denominator


def A263445(n):
    return (2 * n + 1) * factorial(n + 1) * bernoulli(2 * n)


def A039678(n):
    return (
        2**2 + 1 if n == 1 else int(nthroot_mod(1, (p := prime(n)) - 1, p**2, True)[1])
    )


def A185103(n):
    z = nthroot_mod(1, n - 1, n**2, True)
    return int(z[0] + n**2 if len(z) == 1 else z[1])


def A256517(n):
    z = nthroot_mod(1, (c := composite(n)) - 1, c**2, True)
    return int(z[0] + c**2 if len(z) == 1 else z[1])


def A255885(n):
    for b in count(1):
        if n == sum(
            1 for c in range(2, b + 1) if not isprime(c) and pow(b, c - 1, c**2) == 1
        ):
            return b


def A255885_gen():  # generator of terms
    A255885_dict, n = {}, 1
    for b in count(1):
        d = sum(
            1 for c in range(2, b + 1) if not isprime(c) and pow(b, c - 1, c**2) == 1
        )
        if d not in A255885_dict:
            A255885_dict[d] = b
        if n in A255885_dict:
            yield A255885_dict[n]
            n += 1


def A255901(n):
    for b in count(1):
        if n == sum(1 for p in primerange(2, b + 1) if pow(b, p - 1, p**2) == 1):
            return b


def A255901_gen():  # generator of terms
    A255901_dict, n = {}, 1
    for b in count(1):
        c = sum(1 for p in primerange(2, b + 1) if pow(b, p - 1, p**2) == 1)
        if c not in A255901_dict:
            A255901_dict[c] = b
        if n in A255901_dict:
            yield A255901_dict[n]
            n += 1


def A287147_gen():  # generator of terms
    c, p = 5, 3
    yield 2
    while True:
        d = nthroot_mod(1, p - 1, p**2, True)[1]
        if d > c:
            c = d
            yield p
        p = nextprime(p)


def A353730_gen():  # generator of terms
    aset, aqueue, c, f = {2}, deque([2]), 1, True
    yield 2
    while True:
        for m in count(c):
            if m not in aset and all(gcd(m, a) == 1 for a in aqueue):
                yield m
                aset.add(m)
                aqueue.append(m)
                if f:
                    aqueue.popleft()
                f = not f
                while c in aset:
                    c += 1
                break


def A247665_gen():  # generator of terms
    aset, aqueue, c, f = {2}, deque([2]), 3, True
    yield 2
    while True:
        for m in count(c):
            if m not in aset and all(gcd(m, a) == 1 for a in aqueue):
                yield m
                aset.add(m)
                aqueue.append(m)
                if f:
                    aqueue.popleft()
                f = not f
                while c in aset:
                    c += 1
                break


def A249559_gen():  # generator of terms
    aset, aqueue, c, f = {3}, deque([3]), 2, True
    yield 3
    while True:
        for m in count(c):
            if m not in aset and all(gcd(m, a) == 1 for a in aqueue):
                yield m
                aset.add(m)
                aqueue.append(m)
                if f:
                    aqueue.popleft()
                f = not f
                while c in aset:
                    c += 1
                break


def A352808_gen():  # generator of terms
    aset, aqueue, c, m, f = {0}, deque(), 1, 0, False
    yield 0
    for n in count(1):
        if f:
            m = aqueue.popleft()
        f = not f
        for a in count(c):
            if not (a & m or a in aset):
                yield a
                aset.add(a)
                aqueue.append(a)
                while c in aset:
                    c += 1
                break


def A354210(n):
    return int(isqrt(prod(fib2(n + 1))))


def A001654(n):
    return prod(fib2(n + 1))


def A353051(n):
    while n > 1 and len(f := factorint(n, multiple=True)) > 1:
        n -= sum(f)
    return n


def A075255(n):
    return n - sum(factorint(n, multiple=True))


def A351396_gen(startvalue=1):  # generator of terms
    return filter(
        lambda d: not (
            isprime(d)
            or (
                p := n_order(
                    10, d // 2 ** multiplicity(2, d) // 5 ** multiplicity(5, d)
                )
            )
            <= 1
            or (d - 1) % p
        ),
        count(max(startvalue, 1)),
    )


def A350220_gen():  # generator of terms
    pset = set()
    for d in count(1):
        if not (
            isprime(d)
            or (
                p := n_order(
                    10, d // 2 ** multiplicity(2, d) // 5 ** multiplicity(5, d)
                )
            )
            <= 1
            or (d - 1) % p
            or p in pset
        ):
            yield d
            pset.add(p)


def A350598_gen():  # generator of terms
    pset = set()
    for d in count(1):
        if not isprime(d):
            m2, m5 = multiplicity(2, d), multiplicity(5, d)
            r = max(m2, m5)
            k, m = 10**r, 10 ** (t := n_order(10, d // 2**m2 // 5**m5)) - 1
            c = k // d
            s = str(m * k // d - c * m).zfill(t)
            if not (t <= 1 or (d - 1) % t or s in pset):
                yield d
                pset.add(s)


def A353507(n):
    return (
        0 if n == 1 else prod(len(list(g)) for k, g in groupby(factorint(n).values()))
    )


def A353503_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: n == 1
        or prod((f := factorint(n)).values())
        == prod(primepi(p) ** e for p, e in f.items()),
        count(max(startvalue, 1)),
    )


def A353397(n):
    return prod(prime(2 ** primepi(p)) ** e for p, e in factorint(n).items())


def A090252_gen():  # generator of terms
    aset, aqueue, c, b, f = {1}, deque([1]), 2, 1, True
    yield 1
    while True:
        for m in count(c):
            if m not in aset and gcd(m, b) == 1:
                yield m
                aset.add(m)
                aqueue.append(m)
                if f:
                    aqueue.popleft()
                b = lcm(*aqueue)
                f = not f
                while c in aset:
                    c += 1
                break


def A354255_gen():  # generator of terms
    aset, aqueue, c, plist, f = {1}, deque([1]), 2, [], True
    yield 1
    while True:
        for m in count(c):
            if m not in aset and all(m % p for p in plist):
                if not m % 2:
                    yield m
                aset.add(m)
                aqueue.append(m)
                if f:
                    aqueue.popleft()
                plist = list(set().union(*(primefactors(a) for a in aqueue)))
                f = not f
                while c in aset:
                    c += 1
                break


def A319571_gen():  # generator of terms
    for n in count(0):
        for m in range(n + 1):
            yield from (m, n - m) if n % 2 else (n - m, m)


def A353029(n):
    return 2**n * n * (n * (n * (n * (n * (n - 6) + 11) - 4) - 6) + 4) // 6


def A351632(n):
    return 2**n * n * (n * (n * (n * (n - 7) + 17) - 17) + 6) // 6


def A234848_gen():
    return chain(
        (0,),
        (
            n
            for n in (
                int("".join(i))
                for l in count(1)
                for i in combinations_with_replacement("123456789", l)
            )
            if integer_nthroot(8 * n + 1, 2)[1]
        ),
    )


def A004647(n):
    return int(oct(2**n)[2:])


def A354256_gen():  # generator of terms
    for l in count(2, 2):
        for m in (1, 4, 5, 6, 9):
            for k in range(
                1 + isqrt(m * 10 ** (l - 1) - 1), 1 + isqrt((m + 1) * 10 ** (l - 1) - 1)
            ):
                if k % 10 and integer_nthroot(int(str(k * k)[::-1]), 2)[1]:
                    yield k * k


def A353990_gen():  # generator of terms
    yield 1
    a, s, b = 1, 2, set()
    while True:
        for i in count(s):
            if not (i == a + 1 or i & a or gcd(i, a) > 1 or i in b):
                yield i
                a = i
                b.add(i)
                while s in b:
                    s += 1
                break


def A114112(n):
    return n + (0 if n <= 2 else -1 + 2 * (n % 2))


def A114113(n):
    return 1 if n == 1 else (m := n // 2) * (n + 1) + (n + 1 - m) * (n - 2 * m)


def A033999(n):
    return -1 if n & 1 else 1


def A354008(n):
    return (
        1
        if n == 1
        else (k := (m := n // 2) * (n + 1) + (n + 1 - m) * (n - 2 * m)) // gcd(k, n)
    )


def A141310(n):
    return 2 if n & 1 else n + 1


def A130883(n):
    return n * (2 * n - 1) + 1


def A128918(n):
    return (n * (n + 1) if n & 1 else n * (n - 1) + 2) >> 1


def A131179(n):
    return n * (n + 1) // 2 + (1 - n) * (n & 1)


def A008836(n):
    return -1 if sum(factorint(n).values()) & 1 else 1


def A354334(n):
    return sum(Fraction(1, factorial(2 * k)) for k in range(n + 1)).numerator


def A354335(n):
    return sum(Fraction(1, factorial(2 * k)) for k in range(n + 1)).denominator


def A354332(n):
    return sum(
        Fraction(-1 if k % 2 else 1, factorial(2 * k + 1)) for k in range(n + 1)
    ).numerator


def A354333(n):
    return sum(
        Fraction(-1 if k % 2 else 1, factorial(2 * k + 1)) for k in range(n + 1)
    ).denominator


def A354211(n):
    return sum(Fraction(1, factorial(2 * k + 1)) for k in range(n + 1)).numerator


def A354331(n):
    return sum(Fraction(1, factorial(2 * k + 1)) for k in range(n + 1)).denominator


def A352962_gen():  # generator of terms
    a = 2
    yield a
    for n in count(2):
        yield (a := min(n, a) if gcd(n, a) == 1 else n + 2)


def A354354(n):
    return int(not n % 6 & 3 ^ 1)


def A120325(n):
    return int(not (n + 3) % 6 & 3 ^ 1)


def A232991(n):
    return int(not (n + 1) % 6 & 3 ^ 1)


def A000035(n):
    return n & 1


def A059841(n):
    return n & 1 ^ 1


def A000034(n):
    return 1 + (n & 1)


def A011655(n):
    return int(bool(n % 3))


def A088911(n):
    return int(n % 6 < 3)


def A010702(n):
    return 3 + (n & 1)


def A010718(n):
    return 5 + 2 * (n & 1)


def A010883(n):
    return 1 + (n & 3)


def A132429(n):
    return 3 - 2 * (n & 3)


def A010887(n):
    return 1 + (n & 7)


def A354404(n):
    return sum(
        Fraction(1 if k & 1 else -1, k * factorial(k)) for k in range(1, n + 1)
    ).denominator


def A354402(n):
    return sum(
        Fraction(1 if k & 1 else -1, k * factorial(k)) for k in range(1, n + 1)
    ).numerator


def A353545(n):
    return sum(Fraction(1, k * factorial(k)) for k in range(1, n + 1)).numerator


def A354401(n):
    return sum(Fraction(1, k * factorial(k)) for k in range(1, n + 1)).denominator


def A353848_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: n == 1
        or (
            sum((f := factorint(n)).values()) > 1
            and len(set(primepi(p) * e for p, e in f.items())) <= 1
        ),
        count(max(startvalue, 1)),
    )


def A000179(n):
    return (
        1
        if n == 0
        else sum(
            (-2 * n if k & 1 else 2 * n)
            * comb(m := 2 * n - k, k)
            * factorial(n - k)
            // m
            for k in range(n + 1)
        )
    )


def A354432(n):
    f = factorint(n)
    return (
        Fraction(
            prod(p ** (e + 1) - 1 for p, e in f.items()), prod(p - 1 for p in f) * n
        )
        - sum(Fraction(1, p) for p in f)
    ).numerator


def A354433(n):
    f = factorint(n)
    return (
        Fraction(
            prod(p ** (e + 1) - 1 for p, e in f.items()), prod(p - 1 for p in f) * n
        )
        - sum(Fraction(1, p) for p in f)
    ).denominator


def A354437(n):
    return sum(factorial(n) * (-k) ** (n - k) // factorial(k) for k in range(n + 1))


def A354436(n):
    return sum(factorial(n) * k ** (n - k) // factorial(k) for k in range(n + 1))


def A354154_gen():  # generator of terms
    aset, aqueue, c, b, f, p = {1}, deque([1]), 2, 1, True, 2
    yield 0
    while True:
        for m in count(c):
            if m not in aset and gcd(m, b) == 1:
                yield p - m
                p = nextprime(p)
                aset.add(m)
                aqueue.append(m)
                if f:
                    aqueue.popleft()
                b = lcm(*aqueue)
                f = not f
                while c in aset:
                    c += 1
                break


def A297330(n):
    s = str(n)
    return sum(abs(int(s[i]) - int(s[i + 1])) for i in range(len(s) - 1))


def A354212_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        s = str(n)
        t = str(n * sum(abs(int(s[i]) - int(s[i + 1])) for i in range(len(s) - 1)))
        if s != t and sorted(s) == sorted(t):
            yield n


def A118478(n):
    return (
        1
        if n == 1
        else int(
            min(
                min(
                    crt((m, (k := primorial(n)) // m), (0, -1))[0],
                    crt((k // m, m), (0, -1))[0],
                )
                for m in (
                    prod(d)
                    for l in range(1, n // 2 + 1)
                    for d in combinations(sieve.primerange(prime(n) + 1), l)
                )
            )
        )
    )


def A215021(n):
    return (
        1
        if n == 1
        else (
            s := int(
                min(
                    min(
                        crt((m, (k := primorial(n)) // m), (0, -1))[0],
                        crt((k // m, m), (0, -1))[0],
                    )
                    for m in (
                        prod(d)
                        for l in range(1, n // 2 + 1)
                        for d in combinations(sieve.primerange(prime(n) + 1), l)
                    )
                )
            )
        )
        * (s + 1)
        // k
    )


def A214089(n):
    return (
        3
        if n == 1
        else int(
            min(
                filter(
                    isprime,
                    (
                        crt(tuple(sieve.primerange(prime(n) + 1)), t)[0]
                        for t in product((1, -1), repeat=n)
                    ),
                )
            )
        )
    )


def A345988(n):
    if n == 1:
        return 2
    plist = tuple(p**q for p, q in factorint(n).items())
    return (
        n * (n - 1)
        if len(plist) == 1
        else (
            s := int(
                min(
                    min(crt((m, n // m), (0, -1))[0], crt((n // m, m), (0, -1))[0])
                    for m in (
                        prod(d)
                        for l in range(1, len(plist) // 2 + 1)
                        for d in combinations(plist, l)
                    )
                )
            )
        )
        * (s + 1)
    )


def A215085(n):
    return (
        1
        if n == 1
        else (
            int(
                min(
                    filter(
                        isprime,
                        (
                            crt(tuple(sieve.primerange(prime(n) + 1)), t)[0]
                            for t in product((1, -1), repeat=n)
                        ),
                    )
                )
            )
            ** 2
            - 1
        )
        // 4
        // primorial(n)
    )


def A354160_gen():  # generator of terms
    aset, aqueue, c, b, f = {1}, deque([1]), 2, 1, True
    while True:
        for m in count(c):
            if m not in aset and gcd(m, b) == 1:
                if len(fm := factorint(m)) == sum(fm.values()) == 2:
                    yield m
                aset.add(m)
                aqueue.append(m)
                if f:
                    aqueue.popleft()
                b = lcm(*aqueue)
                f = not f
                while c in aset:
                    c += 1
                break


def A354161_gen():  # generator of terms
    aset, aqueue, c, b, f, i = {1}, deque([1]), 2, 1, True, 1
    while True:
        for m in count(c):
            if m not in aset and gcd(m, b) == 1:
                i += 1
                if len(fm := factorint(m)) == sum(fm.values()) == 2:
                    yield i
                aset.add(m)
                aqueue.append(m)
                if f:
                    aqueue.popleft()
                b = lcm(*aqueue)
                f = not f
                while c in aset:
                    c += 1
                break


def A354162_gen():  # generator of terms
    aset, aqueue, c, b, f = {1}, deque([1]), 2, 1, True
    while True:
        for m in count(c):
            if m not in aset and gcd(m, b) == 1:
                if m % 2 and len(fm := factorint(m)) == sum(fm.values()) == 2:
                    yield m
                aset.add(m)
                aqueue.append(m)
                if f:
                    aqueue.popleft()
                b = lcm(*aqueue)
                f = not f
                while c in aset:
                    c += 1
                break


def A354163_gen():  # generator of terms
    aset, aqueue, c, b, f, i = {1}, deque([1]), 2, 1, True, 1
    while True:
        for m in count(c):
            if m not in aset and gcd(m, b) == 1:
                i += 1
                if m % 2 and len(fm := factorint(m)) == sum(fm.values()) == 2:
                    yield i
                aset.add(m)
                aqueue.append(m)
                if f:
                    aqueue.popleft()
                b = lcm(*aqueue)
                f = not f
                while c in aset:
                    c += 1
                break


def A354443(n):
    return fibonacci(pow(n, n, A001175(n))) % n


def A060305(n):
    x, p = (1, 1), prime(n)
    for k in count(1):
        if x == (0, 1):
            return k
        x = (x[1], (x[0] + x[1]) % p)


def A345983_gen():  # generator of terms
    c = 1
    for n in count(2):
        yield c
        plist = tuple(p**q for p, q in factorint(n).items())
        c += (
            n - 1
            if len(plist) == 1
            else int(
                min(
                    min(crt((m, n // m), (0, -1))[0], crt((n // m, m), (0, -1))[0])
                    for m in (
                        prod(d)
                        for l in range(1, len(plist) // 2 + 1)
                        for d in combinations(plist, l)
                    )
                )
            )
        )


def A345984_gen():  # generator of terms
    c = 1
    for n in count(4, 2):
        yield c
        plist = tuple(p**q for p, q in factorint(n).items())
        c += (
            n - 1
            if len(plist) == 1
            else int(
                min(
                    min(crt((m, n // m), (0, -1))[0], crt((n // m, m), (0, -1))[0])
                    for m in (
                        prod(d)
                        for l in range(1, len(plist) // 2 + 1)
                        for d in combinations(plist, l)
                    )
                )
            )
        )


def A344875(n):
    return prod((p ** (1 + e) if p == 2 else p**e) - 1 for p, e in factorint(n).items())


def A345992(n):
    if n == 1:
        return 1
    plist = tuple(p**q for p, q in factorint(n).items())
    return (
        1
        if len(plist) == 1
        else gcd(
            n,
            int(
                min(
                    min(crt((m, n // m), (0, -1))[0], crt((n // m, m), (0, -1))[0])
                    for m in (
                        prod(d)
                        for l in range(1, len(plist) // 2 + 1)
                        for d in combinations(plist, l)
                    )
                )
            ),
        )
    )


def A214149(n):
    return (
        7
        if n == 1
        else int(
            min(
                filter(
                    lambda n: n > 3 and isprime(n),
                    (
                        crt(tuple(sieve.primerange(5, prime(n + 2) + 1)), t)[0]
                        for t in product((3, -3), repeat=n)
                    ),
                )
            )
        )
    )


def A214150(n):
    return (
        19
        if n == 1
        else int(
            min(
                filter(
                    lambda n: n > 5 and isprime(n),
                    (
                        crt(tuple(sieve.primerange(7, prime(n + 3) + 1)), t)[0]
                        for t in product((5, -5), repeat=n)
                    ),
                )
            )
        )
    )


def A354463(n):
    c, m = 0, 2**n
    while m >= 5:
        m //= 5
        c += m
    return c


def A070824(n):
    return 0 if n == 1 else divisor_count(n) - 2


def A078709(n):
    return n // divisor_count(n)


def A353960_gen():  # generator of terms
    adict, a = {}, 1
    yield a
    while True:
        if a in adict:
            adict[a] += 1
            a *= adict[a]
        else:
            adict[a] = 1
            a //= divisor_count(a)
        yield a


def A130290(n):
    return prime(n) // 2


def A005097(n):
    return prime(n + 1) // 2


def A354169_gen():  # generator of terms
    aset, aqueue, b, f = {0, 1, 2}, deque([2]), 2, False
    yield from (0, 1, 2)
    while True:
        for k in count(1):
            m, j, j2, r, s = 0, 0, 1, b, k
            while r > 0:
                r, q = divmod(r, 2)
                if not q:
                    s, y = divmod(s, 2)
                    m += y * j2
                j += 1
                j2 *= 2
            if s > 0:
                m += s * 2 ** b.bit_length()
            if m not in aset:
                yield m
                aset.add(m)
                aqueue.append(m)
                if f:
                    aqueue.popleft()
                b = reduce(or_, aqueue)
                f = not f
                break


def A354757_gen():  # generator of terms
    aset, aqueue, b, f = {0, 1, 2}, deque([2]), 2, False
    yield from (0, 0, 1)
    while True:
        for k in count(1):
            m, j, j2, r, s = 0, 0, 1, b, k
            while r > 0:
                r, q = divmod(r, 2)
                if not q:
                    s, y = divmod(s, 2)
                    m += y * j2
                j += 1
                j2 *= 2
            if s > 0:
                m += s * 2 ** b.bit_length()
            if m not in aset:
                yield sum(aqueue)
                aset.add(m)
                aqueue.append(m)
                if f:
                    aqueue.popleft()
                b = reduce(or_, aqueue)
                f = not f
                break


def A354680_gen():  # generator of terms
    aset, aqueue, b, f = {0, 1, 2}, deque([2]), 2, False
    yield 0
    while True:
        for k in count(1):
            m, j, j2, r, s = 0, 0, 1, b, k
            while r > 0:
                r, q = divmod(r, 2)
                if not q:
                    s, y = divmod(s, 2)
                    m += y * j2
                j += 1
                j2 *= 2
            if s > 0:
                m += s * 2 ** b.bit_length()
            if m not in aset:
                if bin(m).count("1") > 1:
                    yield m
                aset.add(m)
                aqueue.append(m)
                if f:
                    aqueue.popleft()
                b = reduce(or_, aqueue)
                f = not f
                break


def A354798_gen():  # generator of terms
    aset, aqueue, b, f, i = {0, 1, 2}, deque([2]), 2, False, 2
    yield 0
    while True:
        for k in count(1):
            m, j, j2, r, s = 0, 0, 1, b, k
            while r > 0:
                r, q = divmod(r, 2)
                if not q:
                    s, y = divmod(s, 2)
                    m += y * j2
                j += 1
                j2 *= 2
            if s > 0:
                m += s * 2 ** b.bit_length()
            if m not in aset:
                i += 1
                if bin(m).count("1") > 1:
                    yield i
                aset.add(m)
                aqueue.append(m)
                if f:
                    aqueue.popleft()
                b = reduce(or_, aqueue)
                f = not f
                break


def A054055(n):
    return max(int(d) for d in str(n))


def A095815(n):
    return n + max(int(d) for d in str(n))


def A016116(n):
    return 1 << (n >> 1)


def A007590(n):
    return n**2 >> 1


def A000212(n):
    return n**2 // 3


def A008615(n):
    return (n >> 1) - n // 3


def A074148(n):
    return n + (n**2 >> 1)


def A098844_gen():  # generator of terms
    aqueue, f, b = deque([]), False, 1
    yield 1
    for i in count(2):
        yield (a := i * b)
        aqueue.append(a)
        if f:
            b = aqueue.popleft()
        f = not f


def A098844(n):
    return n * prod(n >> k for k in range(1, n.bit_length() - 1))


def A033485_gen():  # generator of terms
    aqueue, f, b, a = deque([2]), True, 1, 2
    yield from (1, 2)
    while True:
        a += b
        yield a
        aqueue.append(a)
        if f:
            b = aqueue.popleft()
        f = not f


def A040039_gen():  # generator of terms
    aqueue, f, b, a = deque([2]), True, 1, 2
    yield from (1, 1, 2, 2)
    while True:
        a += b
        yield from (a, a)
        aqueue.append(a)
        if f:
            b = aqueue.popleft()
        f = not f


def A178855_gen():  # generator of terms
    aqueue, f, b, a = deque([2]), True, 1, 2
    while True:
        a += b
        aqueue.append(a)
        if f:
            yield (a - 1) // 2
            b = aqueue.popleft()
        f = not f


def A094451_gen():  # generator of terms
    aqueue, f, b, a = deque([2]), True, 1, 2
    yield from (1, 2)
    while True:
        a = (a + b) % 3
        yield a
        aqueue.append(a)
        if f:
            b = aqueue.popleft()
        f = not f


def A008794(n):
    return (n >> 1) ** 2


@lru_cache(maxsize=None)
def A320225(n):
    return 1 if n == 1 else sum(A320225(d) * (n // d - 1) for d in range(1, n))


def A320225_gen():  # generator of terms
    alist, a = [1], 1
    yield a
    for n in count(2):
        a = sum(alist[d - 1] * (n // d - 1) for d in range(1, n))
        yield a
        alist.append(a)


def A347027_gen():  # generator of terms
    aqueue, f, b, a = deque([3]), True, 1, 3
    yield from (1, 3)
    while True:
        a += 2 * b
        yield a
        aqueue.append(a)
        if f:
            b = aqueue.popleft()
        f = not f


def A346912_gen():  # generator of terms
    aqueue, f, b, a = deque([2]), True, 1, 2
    yield from (1, 3, 7)
    while True:
        a += b
        yield 4 * a - 1
        aqueue.append(a)
        if f:
            b = aqueue.popleft()
        f = not f


def A102378_gen():  # generator of terms
    aqueue, f, b, a = deque([2]), True, 1, 2
    yield from (1, 3)
    while True:
        a += b
        yield 2 * a - 1
        aqueue.append(a)
        if f:
            b = aqueue.popleft()
        f = not f


def A062187_gen():  # generator of terms
    aqueue, f, b, a = deque([1]), True, 0, 1
    yield from (0, 1)
    while True:
        a -= b
        yield a
        aqueue.append(a)
        if f:
            b = aqueue.popleft()
        f = not f


def A062186_gen():  # generator of terms
    aqueue, f, b, a = deque([0]), True, 1, 0
    yield from (1, 0)
    while True:
        a -= b
        yield a
        aqueue.append(a)
        if f:
            b = aqueue.popleft()
        f = not f


def A062188_gen():  # generator of terms
    aqueue, f, b, a = deque([1]), True, 0, 1
    yield from (0, 1)
    while True:
        a += b
        yield a
        aqueue.append(a)
        if f:
            b = aqueue.popleft()
        f = not f


def A022907_gen():  # generator of terms
    aqueue, f, b, a = deque([2]), True, 1, 2
    yield from (0, 2, 5)
    while True:
        a += b
        yield 3 * a - 1
        aqueue.append(a)
        if f:
            b = aqueue.popleft()
        f = not f


def A022905_gen():  # generator of terms
    aqueue, f, b, a = deque([2]), True, 1, 2
    yield 1
    while True:
        a += b
        aqueue.append(a)
        if f:
            yield (3 * a - 1) // 2
            b = aqueue.popleft()
        f = not f


def A022908_gen():  # generator of terms
    aqueue, f, b, a = deque([2]), True, 1, 2
    yield from (0, 2)
    while True:
        a += b
        aqueue.append(a)
        if f:
            yield (3 * a + 1) // 2
            b = aqueue.popleft()
        f = not f


def A352717_gen():  # generator of terms
    a, b = 1, 3
    while True:
        yield from (a,) * (b - a)
        a, b = b, a + b


def A130241_gen():  # generator of terms
    a, b = 1, 3
    for i in count(1):
        yield from (i,) * (b - a)
        a, b = b, a + b


def A130247_gen():  # generator of terms
    yield from (1, 0)
    a, b = 3, 4
    for i in count(2):
        yield from (i,) * (b - a)
        a, b = b, a + b


def A130242_gen():  # generator of terms
    yield from (0, 0, 0, 2)
    a, b = 3, 4
    for i in count(3):
        yield from (i,) * (b - a)
        a, b = b, a + b


def A130245_gen():  # generator of terms
    yield from (0, 1, 2)
    a, b = 3, 4
    for i in count(3):
        yield from (i,) * (b - a)
        a, b = b, a + b


def A130249_gen():  # generator of terms
    a, b = 0, 1
    for i in count(0):
        yield from (i,) * (b - a)
        a, b = b, 2 * a + b


def A130249(n):
    return (3 * n + 1).bit_length() - 1


def A276710_gen():  # generator of terms
    p, q = 3, 5
    while True:
        for m in range(p + 1, q):
            r = m ** (m - 1)
            c = 1
            for k in range(m + 1):
                c = c * comb(m, k) % r
            if c == 0:
                yield m
        p, q = q, nextprime(q)


def A353010_gen():  # generator of terms
    p, q = 3, 5
    while True:
        for m in range(p + 1, q):
            r = m ** (m - 1)
            c = 1
            for k in range(m + 1):
                c = c * comb(m, k) % r
            if c == 0:
                d, (e, f) = -m, divmod(prod(comb(m, k) for k in range(m + 1)), m)
                while f == 0:
                    d += 1
                    e, f = divmod(e, m)
                yield d
        p, q = q, nextprime(q)


def A351628_gen():  # generator of terms
    a, b, c = 1, 3, 0
    while True:
        yield from (c + i * a for i in range(1, b - a + 1))
        a, b, c = b, a + b, c + a * (b - a)


def A001250_gen():  # generator of terms
    yield from (1, 1)
    blist = (0, 2)
    while True:
        yield (blist := tuple(accumulate(reversed(blist), initial=0)))[-1]


def A348615_gen():  # generator of terms
    yield from (0, 0)
    blist, f = (0, 2), 1
    for n in count(2):
        f *= n
        yield f - (blist := tuple(accumulate(reversed(blist), initial=0)))[-1]


def A354862(n):
    f = factorial(n)
    return sum(
        f * (a := factorial(n // d)) // (b := factorial(d))
        + (f * b // a if d**2 < n else 0)
        for d in divisors(n, generator=True)
        if d**2 <= n
    )


def A354863(n):
    f = factorial(n)
    return sum(f * n // d // factorial(d) for d in divisors(n, generator=True))


def A067742(n):
    return sum(1 for d in divisors(n, generator=True) if n <= 2 * d**2 < 4 * n)


def A319529_gen(startvalue=1):  # generator of terms
    for k in count(max(1, startvalue + 1 - (startvalue & 1)), 2):
        if any((k <= 2 * d**2 < 4 * k for d in divisors(k, generator=True))):
            yield k


def A132049_gen():  # generator of terms
    yield 2
    blist = (0, 1)
    for n in count(2):
        yield Fraction(
            2 * n * blist[-1],
            (blist := tuple(accumulate(reversed(blist), initial=0)))[-1],
        ).numerator


def A132050_gen():  # generator of terms
    yield 1
    blist = (0, 1)
    for n in count(2):
        yield Fraction(
            2 * n * blist[-1],
            (blist := tuple(accumulate(reversed(blist), initial=0)))[-1],
        ).denominator


def A000708_gen():  # generator of terms
    yield -1
    blist = (0, 1)
    for n in count(2):
        yield -2 * blist[-1] + (blist := tuple(accumulate(reversed(blist), initial=0)))[
            -1
        ]


def A024255_gen():  # generator of terms
    yield from (0, 1)
    blist = (0, 1)
    for n in count(2):
        yield n * (
            blist := tuple(
                accumulate(
                    reversed(tuple(accumulate(reversed(blist), initial=0))), initial=0
                )
            )
        )[-1]


def A141479_gen():  # generator of terms
    yield from (2, 3)
    blist = (0, 1)
    for n in count(0):
        yield (blist := tuple(accumulate(reversed(blist), initial=0)))[-1] + (
            2,
            1,
            1,
            2,
        )[n & 3]


def A000756_gen():  # generator of terms
    yield from (1, 2)
    blist = (1, 2)
    while True:
        yield (blist := tuple(accumulate(reversed(blist), initial=0)))[-1]


def A180942_gen():  # generator of terms
    blist = (0, 1)
    for n in count(2):
        blist = tuple(accumulate(reversed(blist), initial=0))
        if (
            n & 1
            and (blist[-1] + (1 if (n - 1) >> 1 & 1 else -1)) % n == 0
            and not isprime(n)
        ):
            yield n


def A166298_gen():  # generator of terms
    yield 0
    blist, c = (0, 1), 1
    for n in count(1):
        yield (blist := tuple(accumulate(reversed(blist), initial=0)))[-1] - c
        c = c * (4 * n + 2) // (n + 2)


def A338399_gen():  # generator of terms
    blist, a, b = tuple(), 0, 1
    while True:
        yield (
            blist := tuple(accumulate(reversed(blist), func=operator_sub, initial=a))
        )[-1]
        a, b = b, a + b


def A338398_gen():  # generator of terms
    blist = tuple()
    for i in count(1):
        yield (
            blist := tuple(
                accumulate(reversed(blist), func=operator_sub, initial=prime(i))
            )
        )[-1]


def A338400_gen():  # generator of terms
    blist = tuple()
    for i in count(0):
        yield (
            blist := tuple(
                accumulate(reversed(blist), func=operator_sub, initial=npartitions(i))
            )
        )[-1]


def A102590_gen():  # generator of terms
    blist, m = tuple(), 1
    while True:
        yield (
            blist := tuple(accumulate(reversed(blist), func=operator_sub, initial=m))
        )[-1]
        m *= 2


def A062162_gen():  # generator of terms
    blist, m = tuple(), -1
    while True:
        yield (blist := tuple(accumulate(reversed(blist), initial=(m := -m))))[-1]


def A097953_gen():  # generator of terms
    blist, m = tuple(), 1
    while True:
        yield (blist := tuple(accumulate(reversed(blist), initial=(m + 1) // 2)))[-1]
        m *= -2


def A000667_gen():  # generator of terms
    blist = tuple()
    while True:
        yield (blist := tuple(accumulate(reversed(blist), initial=1)))[-1]


def A061531_gen():  # generator of terms
    blist, m = tuple(), 1
    for i in count(1):
        yield (blist := tuple(accumulate(reversed(blist), initial=m)))[-1]
        m = mobius(i)


def A306822_gen():  # generator of terms
    blist, m = tuple(), 1
    for i in count(1):
        yield (blist := tuple(accumulate(reversed(blist), initial=m)))[-1]
        m = m * (4 * i - 2) // i


def A307595_gen():  # generator of terms
    blist = tuple()
    for i in count(0):
        yield (
            blist := tuple(
                accumulate(
                    reversed(blist), initial=hyperexpand(hyper((1 - i, -i), [], 1))
                )
            )
        )[-1]


def A308521_gen():  # generator of terms
    blist, m = tuple(), 1
    for i in count(1):
        yield (blist := tuple(accumulate(reversed(blist), initial=m)))[-1]
        m *= 2 * i


def A337445_gen():  # generator of terms
    blist, m = tuple(), 1
    for i in count(1):
        yield (
            blist := tuple(accumulate(reversed(blist), func=operator_sub, initial=m))
        )[-1]
        m *= i


def A308681_gen():  # generator of terms
    blist, m = tuple(), 1
    for i in count(1):
        yield (
            blist := tuple(accumulate(reversed(blist), func=operator_sub, initial=m))
        )[-1]
        m *= 2 * i - 1


def A337443_gen():  # generator of terms
    blist = tuple()
    for i in count(1):
        yield (
            blist := tuple(accumulate(reversed(blist), func=operator_sub, initial=i))
        )[-1]


def A337444_gen():  # generator of terms
    blist = tuple()
    for i in count(1, 2):
        yield (
            blist := tuple(accumulate(reversed(blist), func=operator_sub, initial=i))
        )[-1]


def A337446_gen():  # generator of terms
    blist, c = tuple(), 1
    for i in count(0):
        yield (
            blist := tuple(accumulate(reversed(blist), func=operator_sub, initial=c))
        )[-1]
        c = c * (4 * i + 2) // (i + 2)


def A347071_gen():  # generator of terms
    blist, m = tuple(), 1
    for i in count(1):
        yield (
            blist := tuple(accumulate(reversed(blist), func=operator_sub, initial=m))
        )[-1]
        m = m * i + 1


def A337447_gen():  # generator of terms
    yield from (1, 0)
    blist, alist = (1, 0), (1,)
    while True:
        yield (
            blist := tuple(
                accumulate(
                    reversed(blist),
                    func=operator_sub,
                    initial=(alist := list(accumulate(alist, initial=alist[-1])))[-1],
                )
            )
        )[-1]


def A230960_gen():  # generator of terms
    blist, m = tuple(), 1
    for i in count(1):
        yield (blist := tuple(accumulate(reversed(blist), initial=m)))[-1]
        m *= i


def A000738_gen():  # generator of terms
    blist, a, b = tuple(), 0, 1
    while True:
        yield (blist := tuple(accumulate(reversed(blist), initial=a)))[-1]
        a, b = b, a + b


def A000747_gen():  # generator of terms
    blist = tuple()
    for i in count(1):
        yield (blist := tuple(accumulate(reversed(blist), initial=prime(i))))[-1]


def A000753_gen():  # generator of terms
    blist, c = tuple(), 1
    for i in count(0):
        yield (blist := tuple(accumulate(reversed(blist), initial=c)))[-1]
        c = c * (4 * i + 2) // (i + 2)


def A231179_gen():  # generator of terms
    blist = tuple()
    for i in count(0):
        yield (blist := tuple(accumulate(reversed(blist), initial=i)))[-1]


def A000718_gen():  # generator of terms
    yield 1
    blist, c = (1,), 1
    for i in count(2):
        yield (blist := tuple(accumulate(reversed(blist), initial=c)))[-1]
        c += i


def A000674_gen():  # generator of terms
    yield 1
    blist = (1,)
    while True:
        yield (blist := tuple(accumulate(reversed(blist), initial=2)))[-1]


def A101473_gen():  # generator of terms
    blist, a, b = tuple(), 0, 1
    while True:
        yield (blist := tuple(accumulate(reversed(blist), initial=a)))[-1]
        a, b = b, 2 * a + b


def A101474_gen():  # generator of terms
    blist, a, b = tuple(), 0, -1
    while True:
        yield (blist := tuple(accumulate(reversed(blist), initial=a)))[-1]
        a, b = -b, -2 * a - b


def A307594_gen():  # generator of terms
    blist, a, b = tuple(), 1, -1
    for n in count(1):
        yield (blist := tuple(accumulate(reversed(blist), initial=a)))[-1]
        a, b = a * n + b, -b


def A306799_gen():  # generator of terms
    blist, a = tuple(), 1
    for i in count(1):
        yield (blist := tuple(accumulate(reversed(blist), initial=a)))[-1]
        a = 2 * a * i // (i + 1) if i & 1 else 2 * a


def A307592_gen():  # generator of terms
    blist = (1, 2)
    yield from blist
    for i in count(2):
        yield (blist := tuple(accumulate(reversed(blist), initial=i ** (i - 2))))[-1]


def A308520_gen():  # generator of terms
    blist = tuple()
    for i in count(0):
        yield (
            blist := tuple(accumulate(reversed(blist), initial=i * (i + 1) // 2 + 1))
        )[-1]


def A307593_gen():  # generator of terms
    blist, m = tuple(), 1
    for i in count(1):
        yield (blist := tuple(accumulate(reversed(blist), initial=m)))[-1]
        m = m * i + 1


def A306880_gen():  # generator of terms
    blist = tuple()
    for i in count(0):
        yield (blist := tuple(accumulate(reversed(blist), initial=i**i)))[-1]


def A306881_gen():  # generator of terms
    yield 0
    blist = (0,)
    for i in count(1):
        yield (blist := tuple(accumulate(reversed(blist), initial=i ** (i - 1))))[-1]


def A296792_gen():  # generator of terms
    blist, m = tuple(), 1
    for i in count(1, 2):
        yield (blist := tuple(accumulate(reversed(blist), initial=m)))[-1]
        m *= i


def A347072_gen():  # generator of terms
    blist, m = (0,), 1
    yield from blist
    for i in count(1):
        yield (blist := tuple(accumulate(reversed(blist), initial=m)))[-1]
        m *= i


def A307879_gen():  # generator of terms
    blist, m = tuple(), 1
    yield from blist
    while True:
        yield (blist := tuple(accumulate(reversed(blist), initial=m)))[-1]
        m *= 4


def A307878_gen():  # generator of terms
    blist, m = tuple(), 1
    yield from blist
    while True:
        yield (blist := tuple(accumulate(reversed(blist), initial=m)))[-1]
        m *= 3


def A306836_gen():  # generator of terms
    blist, a, b = (1,), 1, 1
    yield from blist
    for i in count(2):
        yield (blist := tuple(accumulate(reversed(blist), initial=b)))[-1]
        a, b = b, (b * (2 * i + 1) + (3 * i - 3) * a) // (i + 2)


def A306832_gen():  # generator of terms
    blist, a, b = (1,), 1, 1
    yield from blist
    for i in count(2):
        yield (blist := tuple(accumulate(reversed(blist), initial=b)))[-1]
        a, b = b, (b * (2 * i - 1) + (3 * i - 3) * a) // i


def A231894_gen():  # generator of terms
    blist, c = tuple(), 1
    for i in count(1):
        yield (blist := tuple(accumulate(reversed(blist), initial=c)))[-1]
        c = c * (4 * i + 2) // (i + 2)


def A000736_gen():  # generator of terms
    yield 1
    blist, c = (1,), 1
    for i in count(0):
        yield (blist := tuple(accumulate(reversed(blist), initial=c)))[-1]
        c = c * (4 * i + 2) // (i + 2)


def A230961_gen():  # generator of terms
    blist, m = tuple(), 1
    for i in count(1):
        yield (blist := tuple(accumulate(reversed(blist), initial=(m := m * i))))[-1]


def A231200_gen():  # generator of terms
    blist = tuple()
    for i in count(0, 2):
        yield (blist := tuple(accumulate(reversed(blist), initial=i)))[-1]


def A092090_gen():  # generator of terms
    blist, a, b = tuple(), 1, 2
    while True:
        yield (blist := tuple(accumulate(reversed(blist), initial=a)))[-1]
        a, b = b, a + b


def A062161_gen():  # generator of terms
    blist, m = tuple(), 1
    while True:
        yield (blist := tuple(accumulate(reversed(blist), initial=(m := 1 - m))))[-1]


def A062272_gen():  # generator of terms
    blist, m = tuple(), 0
    while True:
        yield (blist := tuple(accumulate(reversed(blist), initial=(m := 1 - m))))[-1]


def A000744_gen():  # generator of terms
    blist, a, b = tuple(), 1, 1
    while True:
        yield (blist := tuple(accumulate(reversed(blist), initial=a)))[-1]
        a, b = b, a + b


def A000660_gen():  # generator of terms
    yield 1
    blist = (1,)
    for i in count(1):
        yield (blist := tuple(accumulate(reversed(blist), initial=i)))[-1]


def A000733_gen():  # generator of terms
    yield 1
    blist = (1,)
    for i in count(0):
        yield (blist := tuple(accumulate(reversed(blist), initial=npartitions(i))))[-1]


def A000737_gen():  # generator of terms
    blist = tuple()
    for i in count(1):
        yield (blist := tuple(accumulate(reversed(blist), initial=i)))[-1]


def A000734_gen():  # generator of terms
    yield 1
    blist, m = (1,), 1
    while True:
        yield (blist := tuple(accumulate(reversed(blist), initial=m)))[-1]
        m <<= 1


def A000751_gen():  # generator of terms
    blist = tuple()
    for i in count(0):
        yield (blist := tuple(accumulate(reversed(blist), initial=npartitions(i))))[-1]


def A000754_gen():  # generator of terms
    blist = tuple()
    for i in count(1, 2):
        yield (blist := tuple(accumulate(reversed(blist), initial=i)))[-1]


def A000732_gen():  # generator of terms
    yield 1
    blist = (1,)
    for i in count(1):
        yield (blist := tuple(accumulate(reversed(blist), initial=prime(i))))[-1]


def A000697_gen():  # generator of terms
    yield 1
    blist, m = (1,), 1
    for i in count(1):
        yield (blist := tuple(accumulate(reversed(blist), initial=m)))[-1]
        m += 2 * i + 1


def A000752_gen():  # generator of terms
    blist, m = tuple(), 1
    while True:
        yield (blist := tuple(accumulate(reversed(blist), initial=m)))[-1]
        m <<= 1


def A230953_gen():  # generator of terms
    blist = tuple()
    for i in count(2):
        yield (blist := tuple(accumulate(reversed(blist), initial=prime(i))))[-1]


def A230954_gen():  # generator of terms
    blist = tuple()
    for i in count(1):
        yield (blist := tuple(accumulate(reversed(blist), initial=composite(i))))[-1]


def A230955_gen():  # generator of terms
    yield 1
    blist = (1,)
    for i in count(1):
        yield (blist := tuple(accumulate(reversed(blist), initial=composite(i))))[-1]


def A000746_gen():  # generator of terms
    blist, c = tuple(), 1
    for i in count(2):
        yield (blist := tuple(accumulate(reversed(blist), initial=c)))[-1]
        c += i


def A000745_gen():  # generator of terms
    blist, c = tuple(), 1
    for i in count(1):
        yield (blist := tuple(accumulate(reversed(blist), initial=c)))[-1]
        c += 2 * i + 1


if sys.version_info >= (3, 10):

    def A230952_gen():  # generator of terms
        blist = tuple()
        for i in count(0):
            yield (blist := tuple(accumulate(reversed(blist), initial=i.bit_count())))[
                -1
            ]

else:

    def A230952_gen():  # generator of terms
        blist = tuple()
        for i in count(0):
            yield (
                blist := tuple(accumulate(reversed(blist), initial=bin(i).count("1")))
            )[-1]


def A000764_gen():  # generator of terms
    blist, alist = (1, 2), (1,)
    yield from blist
    while True:
        yield (
            blist := tuple(
                accumulate(
                    reversed(blist),
                    initial=(alist := list(accumulate(alist, initial=alist[-1])))[-1],
                )
            )
        )[-1]


def A182665(n):
    if n == 1:
        return 0
    plist = tuple(p**q for p, q in factorint(n).items())
    return (
        1
        if len(plist) == 1
        else n
        - int(
            min(
                min(crt((m, n // m), (0, -1))[0], crt((n // m, m), (0, -1))[0])
                for m in (
                    prod(d)
                    for l in range(1, len(plist) // 2 + 1)
                    for d in combinations(plist, l)
                )
            )
        )
    )


def A354921_gen(startvalue=2):  # generator of terms
    for n in count(max(startvalue, 2)):
        plist = tuple(p**q for p, q in factorint(n).items())
        if (
            len(plist) == 1
            or (
                n
                - int(
                    min(
                        min(crt((m, n // m), (0, -1))[0], crt((n // m, m), (0, -1))[0])
                        for m in (
                            prod(d)
                            for l in range(1, len(plist) // 2 + 1)
                            for d in combinations(plist, l)
                        )
                    )
                )
            )
            & 1
        ):
            yield n


def A354922_gen(startvalue=1):  # generator of terms
    if startvalue <= 1:
        yield 1
    for n in count(max(startvalue, 2)):
        plist = tuple(p**q for p, q in factorint(n).items())
        if (
            len(plist) != 1
            and not (
                n
                - int(
                    min(
                        min(crt((m, n // m), (0, -1))[0], crt((n // m, m), (0, -1))[0])
                        for m in (
                            prod(d)
                            for l in range(1, len(plist) // 2 + 1)
                            for d in combinations(plist, l)
                        )
                    )
                )
            )
            & 1
        ):
            yield n


def A354920(n):
    if n == 1:
        return 0
    plist = tuple(p**q for p, q in factorint(n).items())
    return (
        1
        if len(plist) == 1
        else (
            n
            - int(
                min(
                    min(crt((m, n // m), (0, -1))[0], crt((n // m, m), (0, -1))[0])
                    for m in (
                        prod(d)
                        for l in range(1, len(plist) // 2 + 1)
                        for d in combinations(plist, l)
                    )
                )
            )
        )
        & 1
    )


def A354919_gen(startvalue=1):  # generator of terms
    if startvalue <= 1:
        yield 1
    for n in count(max(startvalue, 2)):
        plist = tuple(p**q for p, q in factorint(n).items())
        if len(plist) == 1:
            if (n - 1) & 1:
                yield n
        elif (
            int(
                min(
                    min(crt((m, n // m), (0, -1))[0], crt((n // m, m), (0, -1))[0])
                    for m in (
                        prod(d)
                        for l in range(1, len(plist) // 2 + 1)
                        for d in combinations(plist, l)
                    )
                )
            )
            & 1
        ):
            yield n


def A068311(n):
    return (
        sum(
            (
                factorial(n) * e // p
                for p, e in sum(
                    (Counter(factorint(m)) for m in range(2, n + 1)),
                    start=Counter({2: 0}),
                ).items()
            )
        )
        if n > 1
        else 0
    )


def A068327(n):
    return sum((n ** (n + 1) * e // p for p, e in factorint(n).items())) if n > 1 else 0


def A168386(n):
    return (
        sum(
            (
                factorial2(n) * e // p
                for p, e in sum(
                    (Counter(factorint(m)) for m in range(n, 1, -2)),
                    start=Counter({2: 0}),
                ).items()
            )
        )
        if n > 1
        else 0
    )


def A260620(n):
    s = prod(factorial(i) for i in range(2, n + 1))
    return (
        sum(
            s * e // p
            for p, e in sum(
                (
                    (lambda x: Counter({k: x[k] * (n - m + 1) for k in x}))(
                        factorint(m)
                    )
                    for m in range(2, n + 1)
                ),
                start=Counter({2: 0}),
            ).items()
        )
        if n > 1
        else 0
    )


def A260619(n):
    s = prod(i**i for i in range(2, n + 1))
    return (
        sum(
            s * e // p
            for p, e in sum(
                (
                    (lambda x: Counter({k: x[k] * m for k in x}))(factorint(m))
                    for m in range(2, n + 1)
                ),
                start=Counter({2: 0}),
            ).items()
        )
        if n > 1
        else 0
    )


def A068329(n):
    f = fibonacci(n)
    return sum((f * e // p for p, e in factorint(f).items())) if n > 2 else 0


def A354918(n):
    if n == 1:
        return 1
    plist = tuple(p**q for p, q in factorint(n).items())
    return (
        n - 1
        if len(plist) == 1
        else int(
            min(
                min(crt((m, n // m), (0, -1))[0], crt((n // m, m), (0, -1))[0])
                for m in (
                    prod(d)
                    for l in range(1, len(plist) // 2 + 1)
                    for d in combinations(plist, l)
                )
            )
        )
    ) & 1


def A354927(n):
    return int(n == 1 or divisor_count(n) == 4)


def A354966(n):
    a, s = gcd(n, 24), sum(sieve[j] ** 2 for j in range(1, n + 1))
    for i in count(1):
        (b, c), p = divmod(s, a), sieve[i]
        if c == 0 and isprime(b):
            return p
        s += sieve[i + n] ** 2 - p**2


def A354950(n):
    plist = list(primerange(2, p := prime(n)))
    return sum(
        1
        for l in range(1, n)
        for d in combinations(plist, l)
        if isprime(q := prod(d) * p - 1) and isprime(q + 2)
    )


def A049240(n):
    return int(isqrt(n) ** 2 != n)


def A067280(n):
    return len(
        (a := continued_fraction_periodic(0, 1, n))[:1] + (a[1] if a[1:] else [])
    )


def A003285(n):
    a = continued_fraction_periodic(0, 1, n)
    return len(a[1]) if a[1:] else 0


def A068717(n):
    return (
        0
        if (a := isqrt(n) ** 2 == n)
        else (-1 if len(continued_fraction_periodic(0, 1, n)[1]) & 1 else 1 - int(a))
    )


def A068718_gen():  # generator of terms
    yield 1
    blist = (1,)
    for n in count(2):
        yield (
            blist := tuple(
                accumulate(
                    reversed(blist),
                    initial=(
                        0
                        if (a := isqrt(n) ** 2 == n)
                        else (
                            1
                            if len(continued_fraction_periodic(0, 1, n)[1]) & 1
                            else int(a) - 1
                        )
                    ),
                )
            )
        )[-1]


def A104854_gen():  # generator of terms
    yield 1
    blist = (0, 1)
    while True:
        yield -blist[-1] + 2 * (blist := tuple(accumulate(reversed(blist), initial=0)))[
            -1
        ]


def A231895_gen():  # generator of terms
    yield 3
    blist = (0, 1)
    while True:
        yield blist[-1] + 2 * (blist := tuple(accumulate(reversed(blist), initial=0)))[
            -1
        ]


def A344000_gen():  # generator of terms
    for n in count(1):
        plist = tuple(p**q for p, q in factorint(2 * n).items())
        if (
            len(plist) > 1
            and min(
                min(crt((m, 2 * n // m), (0, -1))[0], crt((2 * n // m, m), (0, -1))[0])
                for m in (
                    prod(d)
                    for l in range(1, len(plist) // 2 + 1)
                    for d in combinations(plist, l)
                )
            )
            & 1
            == 0
        ):
            yield n


def A344001_gen():  # generator of terms
    for n in count(1):
        plist = tuple(p**q for p, q in factorint(2 * n).items())
        if (
            len(plist) == 1
            or min(
                min(crt((m, 2 * n // m), (0, -1))[0], crt((2 * n // m, m), (0, -1))[0])
                for m in (
                    prod(d)
                    for l in range(1, len(plist) // 2 + 1)
                    for d in combinations(plist, l)
                )
            )
            & 1
        ):
            yield n


def A344763(n):
    plist = tuple(p**q for p, q in factorint(2 * n).items())
    return (
        1 - n
        if len(plist) == 1
        else n
        - int(
            min(
                min(crt((m, 2 * n // m), (0, -1))[0], crt((2 * n // m, m), (0, -1))[0])
                for m in (
                    prod(d)
                    for l in range(1, len(plist) // 2 + 1)
                    for d in combinations(plist, l)
                )
            )
        )
    )


def A344878(n):
    return lcm(*(p ** (e + int(p == 2)) - 1 for p, e in factorint(n).items()))


def A344879(n):
    return prod(
        a := tuple(p ** (e + int(p == 2)) - 1 for p, e in factorint(n).items())
    ) // lcm(*a)


def A226295(n):
    return n_order(prime(n), prime(n + 1))


def A355039_gen():  # generator of terms
    p, q = 3, 5
    while True:
        yield from (
            n
            for n in range(p + 2, q, 2)
            if max((f := factorint(n)).values()) == 1
            and not any((n - 1) % (p - 1) for p in f)
            and isprime(len(f))
        )
        p, q = q, nextprime(q)


def A355023(n):
    return 7 * comb(n, n - 8) * factorial(n - 2)


def A345993(n):
    if n == 1:
        return 1
    plist = tuple(p**q for p, q in factorint(n).items())
    return (
        n
        if len(plist) == 1
        else gcd(
            n,
            1
            + int(
                min(
                    min(crt((m, n // m), (0, -1))[0], crt((n // m, m), (0, -1))[0])
                    for m in (
                        prod(d)
                        for l in range(1, len(plist) // 2 + 1)
                        for d in combinations(plist, l)
                    )
                )
            ),
        )
    )


def A354988(n):
    if n == 1:
        return 0
    plist = tuple(p**q for p, q in factorint(n).items())
    return (
        n - 1
        if len(plist) == 1
        else -gcd(
            n,
            s := int(
                min(
                    min(crt((m, n // m), (0, -1))[0], crt((n // m, m), (0, -1))[0])
                    for m in (
                        prod(d)
                        for l in range(1, len(plist) // 2 + 1)
                        for d in combinations(plist, l)
                    )
                )
            ),
        )
        + gcd(n, s + 1)
    )


def A345995_gen():
    for n in count(2):
        plist = tuple(p**q for p, q in factorint(n).items())
        if len(plist) > 1 and gcd(
            n,
            s := int(
                min(
                    min(crt((m, n // m), (0, -1))[0], crt((n // m, m), (0, -1))[0])
                    for m in (
                        prod(d)
                        for l in range(1, len(plist) // 2 + 1)
                        for d in combinations(plist, l)
                    )
                )
            ),
        ) < gcd(n, s + 1):
            yield n


def A354989(n):
    if n == 1:
        return 0
    plist = tuple(p**q for p, q in factorint(n).items())
    return (
        0
        if len(plist) == 1
        else int(
            gcd(
                n,
                s := int(
                    min(
                        min(crt((m, n // m), (0, -1))[0], crt((n // m, m), (0, -1))[0])
                        for m in (
                            prod(d)
                            for l in range(1, len(plist) // 2 + 1)
                            for d in combinations(plist, l)
                        )
                    )
                ),
            )
            > gcd(n, s + 1)
        )
    )


def A345994(n):
    if n == 1:
        return 1
    plist = tuple(p**q for p, q in factorint(n).items())
    return (
        1
        if len(plist) == 1
        else min(
            gcd(
                n,
                s := int(
                    min(
                        min(crt((m, n // m), (0, -1))[0], crt((n // m, m), (0, -1))[0])
                        for m in (
                            prod(d)
                            for l in range(1, len(plist) // 2 + 1)
                            for d in combinations(plist, l)
                        )
                    )
                ),
            ),
            gcd(n, s + 1),
        )
    )


def A346596(n):
    if n == 1:
        return 1
    plist = tuple(p**q for p, q in factorint(n).items())
    return (
        n
        if len(plist) == 1
        else max(
            gcd(
                n,
                s := int(
                    min(
                        min(crt((m, n // m), (0, -1))[0], crt((n // m, m), (0, -1))[0])
                        for m in (
                            prod(d)
                            for l in range(1, len(plist) // 2 + 1)
                            for d in combinations(plist, l)
                        )
                    )
                ),
            ),
            gcd(n, s + 1),
        )
    )


def A354411(n):
    if n == 1:
        return 2
    k = prod(plist := tuple(sieve.primerange(prime(n) + 1)))
    return (
        t := int(
            min(
                min(crt((m, k // m), (0, -1))[0], crt((k // m, m), (0, -1))[0])
                for m in (
                    prod(d)
                    for l in range(1, len(plist) // 2 + 1)
                    for d in combinations(plist, l)
                )
            )
        )
    ) * (t + 1)


def A354970_gen():  # generator of terms
    aqueue, f, a, b = deque([]), False, 1, 2
    yield from (1, 2)
    while True:
        c = b * (b - 1) // 2 + 1 + (b if f else a)
        yield c
        aqueue.append(c)
        if f:
            a, b = b, aqueue.popleft()
        f = not f


def A355017(n):
    return sum(1 for b in range(2, n) if isprime(sum(sympydigits(n, b)[1:])))


def A001923_gen():  # generator of terms
    yield from accumulate((k**k for k in count(1)), initial=0)


def A062970_gen():  # generator of terms
    yield from accumulate((k**k for k in count(1)), initial=1)


def A061789_gen():  # generator of terms
    yield from accumulate(((p := prime(k)) ** p for k in count(1)))


def A060946_gen():  # generator of terms
    yield from accumulate((k ** (k - 1) for k in count(1)))


def A001099_gen():  # generator of terms
    yield from accumulate((k**k for k in count(1)), func=lambda x, y: y - x)


def A185353_gen():  # generator of terms
    yield from accumulate(
        (pow(k, k, 10) for k in count(1)), func=lambda x, y: (x + y) % 10
    )


def A229784_gen():  # generator of terms
    yield from accumulate(
        (pow(k, k**k, 10) for k in count(1)), func=lambda x, y: (x + y) % 10
    )


def A128981_gen():  # generator of terms
    yield 1
    for i, j in enumerate(accumulate(k**k for k in count(1)), start=2):
        if j % i == 0:
            yield i


def A326501_gen():  # generator of terms
    yield from accumulate((-k) ** k for k in count(0))


def A343931_gen():  # generator of terms
    yield 1
    for i, j in enumerate(accumulate((-k) ** k for k in count(1)), start=2):
        if j % i == 0:
            yield i


def A188776_gen():  # generator of terms
    yield 1
    for i, j in enumerate(accumulate(k**k for k in count(2)), start=2):
        if not j % i:
            yield i


def A343932(n):
    return sum(pow(k, k, n) for k in range(1, n + 1)) % n


def A354894(n):
    return (comb(2 * n - 1, n - 1) * (harmonic(2 * n - 1) - harmonic(n - 1))).p


def A354895(n):
    return (comb(2 * n - 1, n - 1) * (harmonic(2 * n - 1) - harmonic(n - 1))).q


def A355057_gen():  # generator of terms
    aset, aqueue, c, b, f = {1}, deque([1]), 2, 1, True
    yield 1
    while True:
        for m in count(c):
            if m not in aset and gcd(m, b) == 1:
                yield prod(primefactors(b))
                aset.add(m)
                aqueue.append(m)
                if f:
                    aqueue.popleft()
                b = lcm(*aqueue)
                f = not f
                while c in aset:
                    c += 1
                break


def A354765_gen():  # generator of terms
    aset, aqueue, c, b, f = {1}, deque([1]), 2, 1, True
    yield 0
    while True:
        for m in count(c):
            if m not in aset and gcd(m, b) == 1:
                yield sum(2 ** (primepi(p) - 1) for p in primefactors(b))
                aset.add(m)
                aqueue.append(m)
                if f:
                    aqueue.popleft()
                b = lcm(*aqueue)
                f = not f
                while c in aset:
                    c += 1
                break


def A354764_gen():  # generator of terms
    aset, aqueue, c, b, f = {1}, deque([1]), 2, 1, True
    yield 1
    while True:
        for m in count(c):
            if m not in aset and gcd(m, b) == 1:
                yield prod(primefactors(m))
                aset.add(m)
                aqueue.append(m)
                if f:
                    aqueue.popleft()
                b = lcm(*aqueue)
                f = not f
                while c in aset:
                    c += 1
                break


def A343983_gen():  # generator of terms
    yield 1
    for k in count(1):
        if sum(pow(j, j, k) for j in divisors(k, generator=True)) % k == 1:
            yield k


def A062796(n):
    return sum(d**d for d in divisors(n, generator=True))


def A262843(n):
    return sum(d ** (d - 1) for d in divisors(n, generator=True))


def A283498(n):
    return sum(d ** (d + 1) for d in divisors(n, generator=True))


def A342628(n):
    return sum(d ** (n - d) for d in divisors(n, generator=True))


def A342629(n):
    return sum((n // d) ** (n - d) for d in divisors(n, generator=True))


def A308668(n):
    return sum(d ** (n // d + n) for d in divisors(n, generator=True))


def A308594(n):
    return sum(d ** (d + n) for d in divisors(n, generator=True))


def A023887(n):
    return divisor_sigma(n, n)


def A354975(n):
    return sum(prime(i + n) % prime(i) for i in range(1, n + 1))


def A355076(n):
    return sum(
        Fraction(
            reduce(
                lambda x, y: (x[0], x[0] + x[1]) if int(y) else (x[0] + x[1], x[1]),
                bin(k)[-1:1:-1],
                (1, 0),
            )[1],
            reduce(
                lambda x, y: (x[0], x[0] + x[1]) if int(y) else (x[0] + x[1], x[1]),
                bin(k + 1)[-1:1:-1],
                (1, 0),
            )[1],
        )
        for k in range(n + 1)
    ).denominator


def A355075(n):
    return sum(
        Fraction(
            reduce(
                lambda x, y: (x[0], x[0] + x[1]) if int(y) else (x[0] + x[1], x[1]),
                bin(k)[-1:1:-1],
                (1, 0),
            )[1],
            reduce(
                lambda x, y: (x[0], x[0] + x[1]) if int(y) else (x[0] + x[1], x[1]),
                bin(k + 1)[-1:1:-1],
                (1, 0),
            )[1],
        )
        for k in range(n + 1)
    ).numerator


def A324294(n):
    return reduce(
        lambda x, y: (x[0], x[0] + x[1]) if int(y) else (x[0] + x[1], x[1]),
        bin(divisor_sigma(n) + 1)[-1:1:-1],
        (1, 0),
    )[1]


def A244476(n):
    return sorted(
        set(
            sum(
                reduce(
                    lambda x, y: (x[0], x[0] + x[1]) if y else (x[0] + x[1], x[1]),
                    k,
                    (1, 0),
                )
            )
            for k in product((False, True), repeat=n)
        ),
        reverse=True,
    )[5]


def A244475(n):
    return sorted(
        set(
            sum(
                reduce(
                    lambda x, y: (x[0], x[0] + x[1]) if y else (x[0] + x[1], x[1]),
                    k,
                    (1, 0),
                )
            )
            for k in product((False, True), repeat=n)
        ),
        reverse=True,
    )[4]


def A244474(n):
    return sorted(
        set(
            sum(
                reduce(
                    lambda x, y: (x[0], x[0] + x[1]) if y else (x[0] + x[1], x[1]),
                    k,
                    (1, 0),
                )
            )
            for k in product((False, True), repeat=n)
        ),
        reverse=True,
    )[3]


def A002487(n):
    return (
        0
        if n == 0
        else sum(
            reduce(
                lambda x, y: (x[0], x[0] + x[1]) if int(y) else (x[0] + x[1], x[1]),
                bin(n)[-1:2:-1],
                (1, 0),
            )
        )
    )


def A240388(n):
    return (
        sum(
            reduce(
                lambda x, y: (x[0], x[0] + x[1]) if int(y) else (x[0] + x[1], x[1]),
                bin(3 * n)[-1:2:-1],
                (1, 0),
            )
        )
        // 2
    )


def A293957(n):
    return (
        0
        if n <= 2
        else max(
            Counter(
                m
                for m in (
                    sum(
                        reduce(
                            lambda x, y: (
                                (x[0], x[0] + x[1]) if y else (x[0] + x[1], x[1])
                            ),
                            chain(k, (1,)),
                            (1, 0),
                        )
                    )
                    for k in product((False, True), repeat=n - 2)
                )
                if m != 1 and m != 2
            ).values()
        )
    )


def A293160(n):
    return (
        n
        if n <= 1
        else len(
            {1}
            | set(
                sum(
                    reduce(
                        lambda x, y: (x[0], x[0] + x[1]) if y else (x[0] + x[1], x[1]),
                        chain(k, (1,)),
                        (1, 0),
                    )
                )
                for k in product((False, True), repeat=n - 2)
            )
        )
    )


def A101624(n):
    return sum(int(not k & ~(n - k)) * 2**k for k in range(n // 2 + 1))


def A006921(n):
    return sum(int(not r & ~(n - r)) * 2 ** (n // 2 - r) for r in range(n // 2 + 1))


def A260022(n):
    return sum(int(not r & ~(2 * n - r)) * 2 ** (n - r) for r in range(n + 1))


def A168081(n):
    return sum(int(not r & ~(2 * n - 1 - r)) * 2 ** (n - 1 - r) for r in range(n))


def A257971(n):
    return (
        sum(
            int(not r & ~(n + 2 - r)) * 2 ** (n // 2 + 1 - r) for r in range(n // 2 + 2)
        )
        if n & 1
        else -sum(
            int(not r & ~(n - 1 - r)) * 2 ** (n // 2 - 1 - r) for r in range(n // 2)
        )
    )


def A355009_gen():  # generator of terms
    return filter(
        isprime,
        (sum(prime(i + n) % prime(i) for i in range(1, n + 1)) for n in count(1)),
    )


def A354972_gen():  # generator of terms
    for n in count(1):
        if isprime(sum(prime(i + n) % prime(i) for i in range(1, n + 1))):
            yield n


def A353196(n):
    return prod((1 << i) + 1 for i in range(1, n + 1)) << n


def A028362(n):
    return prod((1 << i) + 1 for i in range(1, n))


def A355140(n):
    return (2 * n + (d := divisor_count(n))) // (2 * d)


def A334762(n):
    return (a := divmod(n, divisor_count(n)))[0] + int((a[1] > 0) == True)


def A090395(n):
    return n // gcd(n, divisor_count(n))


def A090387(n):
    return (d := divisor_count(n)) // gcd(n, d)


def A353172(n):
    a = primeomega(n)
    for k in count(2):
        if (m := n % k) > 0 and primeomega(m) == a:
            return k


def A003956(n):
    return prod((1 << i) - 1 for i in range(2, 2 * n + 1, 2)) << n * (n + 2) + 3


def A014115(n):
    return (
        2
        if n == 0
        else ((1 << n) - 1) * prod((1 << i) - 1 for i in range(2, 2 * n - 1, 2))
        << n * (n + 1) + 1
    )


def A014116(n):
    return (
        2 + 696729598 * (n // 3)
        if n == 0 or n == 3
        else ((1 << n) - 1) * prod((1 << i) - 1 for i in range(2, 2 * n - 1, 2))
        << n * (n + 1) + 1
    )


def A001309(n):
    return (
        2
        if n == 0
        else ((1 << n) - 1) * prod((1 << i) - 1 for i in range(2, 2 * n - 1, 2))
        << n * (n + 1) + 2
    )


def A003053(n):
    return (1 << (n >> 1) ** 2) * prod(
        (1 << i) - 1 for i in range(2, 2 * ((n - 1) // 2) + 1, 2)
    )


def A090770(n):
    return prod((1 << i) - 1 for i in range(2, 2 * n + 1, 2)) << (n + 1) ** 2


def A003923(n):
    return (1 << n**2) * prod((1 << i) - 1 for i in range(2, 2 * n + 1, 2))


def A144545(n):
    return ((1 << n) + 1) * prod((1 << i) - 1 for i in range(2, 2 * n - 1, 2)) << n * (
        n - 1
    )


def A000296_gen():
    yield from (1, 0)
    blist, a, b = (1,), 0, 1
    while True:
        blist = list(accumulate(blist, initial=(b := blist[-1])))
        yield (a := b - a)


def A105479_gen():  # generator of terms
    yield from (0, 0, 1)
    blist, b, c = (1,), 1, 1
    for n in count(2):
        c += n
        blist = list(accumulate(blist, initial=(b := blist[-1])))
        yield b * c


def A064299_gen():  # generator of terms
    yield from (1, 1)
    blist, b, m = (1, 2), 1, 1
    for n in count(1):
        blist = list(accumulate(blist, initial=(b := blist[-1])))
        yield b * (m := m * (4 * n + 2) // (n + 2))


def A064299(n):
    return bell(n) * catalan(n)


def A099977_gen():  # generator of terms
    yield 1
    blist, b = (1, 2), 1
    while True:
        for _ in range(2):
            blist = list(accumulate(blist, initial=(b := blist[-1])))
        yield b


def A020557_gen():  # generator of terms
    yield 1
    blist, b = (1,), 1
    while True:
        for _ in range(2):
            blist = list(accumulate(blist, initial=(b := blist[-1])))
        yield b


def A070906_gen():  # generator of terms
    yield 1
    blist, b = (1,), 1
    while True:
        for _ in range(3):
            blist = list(accumulate(blist, initial=(b := blist[-1])))
        yield b


def A135084(n):
    return bell(2**n - 1)


def A135085(n):
    return bell(2**n)


def A193274_gen():  # generator of terms
    yield 0
    blist, b = (1,), 1
    while True:
        blist = list(accumulate(blist, initial=(b := blist[-1])))
        yield b * (b - 1) // 2


def A068939(n):
    return bell(n**2)


def A092460_gen():  # generator of terms
    yield 0
    blist, b = (1,), 1
    while True:
        blist = list(accumulate(blist, initial=b))
        yield from range(b + 1, b := blist[-1])


def A325630_gen():  # generator of terms
    blist, b = (1,), 1
    for k in count(1):
        blist = list(accumulate(blist, initial=(b := blist[-1])))
        if b % k == 0:
            yield k


def A091772_gen():  # generator of terms
    yield 1
    blist, b, c = (1, 2), 1, 1
    for n in count(1):
        blist = list(accumulate(blist, initial=(b := blist[-1])))
        yield gcd(b, c := c * (4 * n + 2) // (n + 2))


def A113865(n):
    return len(str(bell(n)))


if sys.version_info >= (3, 10):

    def A166266(n):
        return int(bell(n)).bit_count()

else:

    def A166266(n):
        return bin(bell(n)).count("1")


def A204618_gen():  # generator of terms
    yield 0
    blist, b = (1,), 1
    for n in count(1):
        blist = list(accumulate(blist, initial=(b := blist[-1])))
        yield b * n**2


def A217143_gen():  # generator of terms
    yield 1
    blist, b, c = (1,), 1, 1
    while True:
        blist = list(accumulate(blist, initial=(b := blist[-1])))
        yield (c := c + b**2)


def A217144_gen():  # generator of terms
    yield 1
    blist, b, c, f = (1,), 1, 1, 1
    while True:
        blist = list(accumulate(blist, initial=(b := blist[-1])))
        yield (f := -f) * (c := c + f * b**2)


def A278973(n):
    return divisor_count(bell(n))


def A070907_gen():  # generator of terms
    yield 1
    blist, b = (1,), 1
    while True:
        for _ in range(4):
            blist = list(accumulate(blist, initial=(b := blist[-1])))
        yield b


def A070908_gen():  # generator of terms
    yield 1
    blist, b = (1,), 1
    while True:
        for _ in range(5):
            blist = list(accumulate(blist, initial=(b := blist[-1])))
        yield b


def A003422_gen():  # generator of terms
    yield from (0, 1)
    c, f = 1, 1
    for n in count(1):
        yield (c := c + (f := f * n))


def A006472(n):
    return n * factorial(n - 1) ** 2 >> n - 1


def A355171(n):
    f = factorial(n + 1)
    return sum(f * comb(n, k + 1) // (k + 2) // (k + 1) for k in range(n + 1))


def A009003_gen():  # generator of terms
    return filter(lambda n: any(map(lambda p: p % 4 == 1, primefactors(n))), count(1))


def A001705(n):
    f = factorial(n)
    return sum(f * (k + 1) // (n - k) for k in range(n))


def A157037_gen():  # generator of terms
    return filter(
        lambda n: isprime(sum(n * e // p for p, e in factorint(n).items())), count(2)
    )


def A353704_gen():  # generator of terms
    return filter(
        lambda n: isprime(sum(n * e // p for p, e in factorint(n).items())),
        (d * (10**l - 1) // 9 for l in count(1) for d in (1, 2, 3, 5, 6, 7)),
    )


def A353703_gen():  # generator of terms
    return filter(
        lambda n: isprime(sum(n * e // p for p, e in factorint(n).items())),
        chain.from_iterable(
            chain(
                (int((s := str(d)) + s[-2::-1]) for d in range(10**l, 10 ** (l + 1))),
                (int((s := str(d)) + s[::-1]) for d in range(10**l, 10 ** (l + 1))),
            )
            for l in count(0)
        ),
    )


def A029803_gen():  # generator of terms
    return chain(
        (0,),
        chain.from_iterable(
            chain(
                (
                    int((s := oct(d)[2:]) + s[-2::-1], 8)
                    for d in range(8**l, 8 ** (l + 1))
                ),
                (
                    int((s := oct(d)[2:]) + s[::-1], 8)
                    for d in range(8**l, 8 ** (l + 1))
                ),
            )
            for l in count(0)
        ),
    )


def A029733_gen():  # generator of terms
    return filter(
        lambda k: (s := hex(k**2)[2:])[: (t := (len(s) + 1) // 2)] == s[: -t - 1 : -1],
        count(0),
    )


def A029805_gen():  # generator of terms
    return filter(
        lambda k: (s := oct(k**2)[2:])[: (t := (len(s) + 1) // 2)] == s[: -t - 1 : -1],
        count(0),
    )


def A002778_gen():  # generator of terms
    return filter(
        lambda k: (s := str(k**2))[: (t := (len(s) + 1) // 2)] == s[: -t - 1 : -1],
        count(0),
    )


def A136522(n):
    return int((s := str(n))[: (t := (len(s) + 1) // 2)] == s[: -t - 1 : -1])


def A029983_gen():  # generator of terms
    return filter(
        lambda k: (s := bin(k)[2:])[: (t := (len(s) + 1) // 2)] == s[: -t - 1 : -1],
        (k**2 for k in count(0)),
    )


def A003166_gen():  # generator of terms
    return filter(
        lambda k: (s := bin(k**2)[2:])[: (t := (len(s) + 1) // 2)] == s[: -t - 1 : -1],
        count(0),
    )


def A128921_gen():  # generator of terms
    return filter(
        lambda n: is_square(int(str(n**2)[::-1])),
        chain(
            (0,),
            chain.from_iterable(
                chain(
                    (
                        int((s := str(d)) + s[-2::-1])
                        for d in range(10**l, 10 ** (l + 1))
                    ),
                    (int((s := str(d)) + s[::-1]) for d in range(10**l, 10 ** (l + 1))),
                )
                for l in count(0)
            ),
        ),
    )


def A319483_gen():  # generator of terms
    return filter(
        lambda n: is_square(int(str(n)[::-1])),
        map(
            lambda n: n**2,
            chain(
                (0,),
                chain.from_iterable(
                    chain(
                        (
                            int((s := str(d)) + s[-2::-1])
                            for d in range(10**l, 10 ** (l + 1))
                        ),
                        (
                            int((s := str(d)) + s[::-1])
                            for d in range(10**l, 10 ** (l + 1))
                        ),
                    )
                    for l in count(0)
                ),
            ),
        ),
    )


def A302864(n):
    for k in count(0, 2):
        if (s := str(k + 1 << n))[: (t := (len(s) + 1) // 2)] == s[: -t - 1 : -1]:
            return k + 1 << n


def A280876_gen():  # generator of terms
    return filter(
        lambda n: isprime(n) and isprime(primepi(n)),
        chain.from_iterable(
            chain(
                (int((s := str(d)) + s[-2::-1]) for d in range(10**l, 10 ** (l + 1))),
                (int((s := str(d)) + s[::-1]) for d in range(10**l, 10 ** (l + 1))),
            )
            for l in count(0)
        ),
    )


def A309325_gen():  # generator of terms
    c = 0
    for a in chain.from_iterable(
        chain(
            (int((s := str(d)) + s[-2::-1]) for d in range(10**l, 10 ** (l + 1))),
            (int((s := str(d)) + s[::-1]) for d in range(10**l, 10 ** (l + 1))),
        )
        for l in count(0)
    ):
        yield c + (c := a)


def A076612_gen():  # generator of terms
    return chain(
        (1, 4, 6, 8, 9),
        chain.from_iterable(
            (
                int((s := str(d)) + e + s[::-1])
                for d in range(10**l, 10 ** (l + 1))
                for e in "014689"
            )
            for l in count(0)
        ),
    )


def A089717_gen():  # generator of terms
    return map(
        lambda n: n * (n + 1) // 2,
        chain(
            (0,),
            chain.from_iterable(
                chain(
                    (
                        int((s := str(d)) + s[-2::-1])
                        for d in range(10**l, 10 ** (l + 1))
                    ),
                    (int((s := str(d)) + s[::-1]) for d in range(10**l, 10 ** (l + 1))),
                )
                for l in count(0)
            ),
        ),
    )


def A082208_gen():  # generator of terms
    return filter(
        lambda n: (s := str(sum(int(d) for d in str(n))))[: (t := (len(s) + 1) // 2)]
        == s[: -t - 1 : -1],
        chain(
            (0,),
            chain.from_iterable(
                chain(
                    (
                        int((s := str(d)) + s[-2::-1])
                        for d in range(10**l, 10 ** (l + 1))
                    ),
                    (int((s := str(d)) + s[::-1]) for d in range(10**l, 10 ** (l + 1))),
                )
                for l in count(0)
            ),
        ),
    )


def A083851_gen():  # generator of terms
    return filter(
        lambda n: n % 11,
        chain.from_iterable(
            (int((s := str(d)) + s[-2::-1]) for d in range(10**l, 10 ** (l + 1)))
            for l in count(0)
        ),
    )


def A027829_gen():  # generator of terms
    return filter(
        lambda n: (s := str(n))[: (t := (len(s) + 1) // 2)] == s[: -t - 1 : -1],
        map(
            lambda n: n**2,
            (
                d
                for l in count(2, 2)
                for d in range(isqrt(10 ** (l - 1)) + 1, isqrt(10**l) + 1)
            ),
        ),
    )


def A353217_gen():  # generator of terms
    return chain(
        (0, 1),
        filter(
            lambda m: (s := str(sum((m * e // p for p, e in factorint(m).items()))))[
                : (t := (len(s) + 1) // 2)
            ]
            == s[: -t - 1 : -1],
            (n * (n + 1) // 2 for n in count(2)),
        ),
    )


def A068312(n):
    return (
        0
        if n <= 1
        else (
            (n + 1) * sum((n * e // p for p, e in factorint(n).items()))
            + sum(((n + 1) * e // p for p, e in factorint(n + 1).items())) * n
            - (n * (n + 1) // 2)
        )
        // 2
    )


def A324989_gen():  # generator of terms
    return filter(
        lambda n: (
            s := str(isqrt(n) ** d if (d := divisor_count(n)) & 1 else n ** (d // 2))
        )[: (t := (len(s) + 1) // 2)]
        == s[: -t - 1 : -1],
        chain.from_iterable(
            chain(
                (int((s := str(d)) + s[-2::-1]) for d in range(10**l, 10 ** (l + 1))),
                (int((s := str(d)) + s[::-1]) for d in range(10**l, 10 ** (l + 1))),
            )
            for l in count(0)
        ),
    )


def A175317(n):
    return sum(
        isqrt(d) ** c if (c := divisor_count(d)) & 1 else d ** (c // 2)
        for d in divisors(n, generator=True)
    )


def A322671(n):
    return sum(
        isqrt(d) ** (c - 2) if (c := divisor_count(d)) & 1 else d ** (c // 2 - 1)
        for d in divisors(n, generator=True)
    )


def A174933(n):
    return sum(
        isqrt(d) ** (c + 2) if (c := divisor_count(d)) & 1 else d ** (c // 2 + 1)
        for d in divisors(n, generator=True)
    )


def A174939(n):
    return sum(k ** divisor_count(k) for k in range(1, n + 1))


def A174932(n):
    return n * sum(
        isqrt(d) ** (c - 2) if (c := divisor_count(d)) & 1 else d ** (c // 2 - 1)
        for d in divisors(n, generator=True)
    )


def A055067(n):
    return factorial(n) // (
        isqrt(n) ** c if (c := divisor_count(n)) & 1 else n ** (c // 2)
    )


def A072046(n):
    return gcd(
        p := isqrt(n) ** c if (c := divisor_count(n)) & 1 else n ** (c // 2),
        factorial(n) // p,
    )


def A280581(n):
    return (lambda m: isqrt(m) ** c if (c := divisor_count(m)) & 1 else m ** (c // 2))(
        divisor_sigma(n)
    )


def A048740(n):
    return (lambda m: isqrt(m) ** c if (c := divisor_count(m)) & 1 else m ** (c // 2))(
        composite(n)
    )


def A056924(n):
    return divisor_count(n) // 2


def A056925(n):
    return n ** (divisor_count(n) // 2)


def A219364_gen():  # generator of terms
    return filter(
        lambda n: (
            f := (
                lambda m: (
                    isqrt(m) ** c if (c := divisor_count(m)) & 1 else m ** (c // 2)
                )
            )
        )(n)
        > f(divisor_sigma(n)),
        count(1),
    )


def A280420(n):
    return (lambda m: (isqrt(m) if (c := divisor_count(m)) & 1 else 1) * m ** (c // 2))(
        factorial(n)
    )


def A027423(n):
    return prod(
        e + 1
        for e in sum(
            (Counter(factorint(i)) for i in range(2, n + 1)), start=Counter()
        ).values()
    )


def A355224(n):
    return int("".join(accumulate(str(n)[::-1], func=max))[::-1])


def A355223(n):
    return int("".join(accumulate(str(n)[::-1], func=min))[::-1])


def A355222(n):
    return int("".join(accumulate(str(n), func=max)))


def A355221(n):
    return int("".join(accumulate(str(n), func=min)))


def A280583(n):
    return (lambda m: (isqrt(m) if (c := divisor_count(m)) & 1 else 1) * m ** (c // 2))(
        divisor_count(n)
    )


def A353929(n):
    return len(set(sum(map(int, y[1])) for y in groupby(bin(n)[2:])))


def A280685(n):
    return divisor_sigma(
        (isqrt(n) if (c := divisor_count(n)) & 1 else 1) * n ** (c // 2)
    )


def A157195(n):
    return (
        0
        if (c := divisor_count(n)) <= 2
        else (isqrt(n) if (c := divisor_count(n)) & 1 else 1) * n ** (c // 2 - 1)
    )


def A309377(n):
    return (
        isqrt(n**n) if (c := prod(n * e + 1 for e in factorint(n).values())) & 1 else 1
    ) * n ** (n * (c // 2))


def A325838(n):
    return (lambda m: (isqrt(m) if (c := divisor_count(m)) & 1 else 1) * m ** (c // 2))(
        n * (n + 1) // 2
    )


def A084190(n):
    return lcm(*(d - 1 for d in divisors(n, generator=True) if d > 1))


def A162947_gen():  # generator of terms
    return chain((1,), filter(lambda n: divisor_count(n) == 6, count(2)))


def A344687(n):
    return (
        prod(
            e + 1
            for e in sum(
                (Counter(factorint(i)) for i in range(2, n + 1)), start=Counter()
            ).values()
        )
        // 2
    )


def A157672(n):
    return (
        prod(
            e + 1
            for e in sum(
                (Counter(factorint(i)) for i in range(2, n + 1)), start=Counter()
            ).values()
        )
        // 2
        - 1
    )


def A338576(n):
    return (isqrt(n) if (c := divisor_count(n)) & 1 else 1) * n ** (c // 2 + 1)


def A283995(n):
    return (
        lambda n: prod(
            prime(i + 1) ** e
            for i, e in enumerate(sorted(factorint(n).values(), reverse=True))
        )
    )((isqrt(n) if (c := divisor_count(n)) & 1 else 1) * n ** (c // 2))


def A184390(n):
    return (
        (m := ((isqrt(n) if (c := divisor_count(n)) & 1 else 1) * n ** (c // 2)))
        * (m + 1)
        // 2
    )


def A184391(n):
    return factorial((isqrt(n) if (c := divisor_count(n)) & 1 else 1) * n ** (c // 2))


def A354773_gen():  # generator of terms
    aset, aqueue, b, f = {0, 1, 2}, deque([2]), 2, False
    while True:
        for k in count(1):
            m, j, j2, r, s = 0, 0, 1, b, k
            while r > 0:
                r, q = divmod(r, 2)
                if not q:
                    s, y = divmod(s, 2)
                    m += y * j2
                j += 1
                j2 *= 2
            if s > 0:
                m += s * 2 ** b.bit_length()
            if m not in aset:
                if (s := bin(m)[:1:-1]).count("1") == 2:
                    yield s.index("1")
                aset.add(m)
                aqueue.append(m)
                if f:
                    aqueue.popleft()
                b = reduce(or_, aqueue)
                f = not f
                break


def A354774_gen():  # generator of terms
    aset, aqueue, b, f = {0, 1, 2}, deque([2]), 2, False
    while True:
        for k in count(1):
            m, j, j2, r, s = 0, 0, 1, b, k
            while r > 0:
                r, q = divmod(r, 2)
                if not q:
                    s, y = divmod(s, 2)
                    m += y * j2
                j += 1
                j2 *= 2
            if s > 0:
                m += s * 2 ** b.bit_length()
            if m not in aset:
                if (s := bin(m)[3:]).count("1") == 1:
                    yield len(s)
                aset.add(m)
                aqueue.append(m)
                if f:
                    aqueue.popleft()
                b = reduce(or_, aqueue)
                f = not f
                break


def A354775_gen():  # generator of terms
    aset, aqueue, b, f, i = {0, 1, 2}, deque([2]), 2, False, 2
    while True:
        for k in count(1):
            m, j, j2, r, s = 0, 0, 1, b, k
            while r > 0:
                r, q = divmod(r, 2)
                if not q:
                    s, y = divmod(s, 2)
                    m += y * j2
                j += 1
                j2 *= 2
            if s > 0:
                m += s * 2 ** b.bit_length()
            if m not in aset:
                i += 1
                if "11" in (s := bin(m)[2:]) and s.count("1") == 2:
                    yield i
                aset.add(m)
                aqueue.append(m)
                if f:
                    aqueue.popleft()
                b = reduce(or_, aqueue)
                f = not f
                break


def A001481_gen():  # generator of terms
    return filter(
        lambda n: (lambda m: all(d & 3 != 3 or m[d] & 1 == 0 for d in m))(factorint(n)),
        count(0),
    )


def A354776_gen():  # generator of terms
    return filter(
        lambda n: (lambda m: all(d & 3 != 3 or m[d] & 1 == 0 for d in m))(
            factorint(n // 2)
        ),
        count(0, 2),
    )


def A071011_gen():  # generator of terms
    return filter(
        lambda n: (
            lambda f: all(p & 3 != 3 or e & 1 == 0 for p, e in f)
            and prod((p ** (e + 1) - 1) // (p - 1) & 3 for p, e in f) & 3 == 0
        )(factorint(n).items()),
        count(0),
    )


def A155563_gen():  # generator of terms
    return filter(
        lambda n: all(
            e & 1 == 0 or (p & 3 != 3 and p % 3 < 2) for p, e in factorint(n).items()
        ),
        count(0),
    )


def A173256_gen():  # generator of terms
    return accumulate(
        filter(
            lambda n: all(p & 3 != 3 or e & 1 == 0 for p, e in factorint(n).items()),
            count(0),
        )
    )


def A250310_gen():  # generator of terms
    return filter(
        lambda n: all(p & 3 != 3 or e & 1 == 0 for p, e in factorint(n**2 - 3).items()),
        count(2),
    )


def A124132_gen():  # generator of terms
    return filter(
        lambda n: all(
            p & 3 != 3 or e & 1 == 0 for p, e in factorint(fibonacci(2 * n)).items()
        ),
        count(1),
    )


def A124130_gen():  # generator of terms
    return filter(
        lambda n: all(p & 3 != 3 or e & 1 == 0 for p, e in factorint(lucas(n)).items()),
        count(0),
    )


def A125110_gen():  # generator of terms
    return map(
        lambda m: m**3,
        filter(
            lambda n: all(p & 3 != 3 or e & 1 == 0 for p, e in factorint(n).items()),
            count(0),
        ),
    )


def A269833_gen():  # generator of terms
    return filter(
        lambda n: all(
            p & 3 != 3 or e & 1 == 0
            for p, e in factorint((1 << n) + factorial(n)).items()
        ),
        count(0),
    )


def A002479_gen():  # generator of terms
    return filter(
        lambda n: all(p & 7 < 5 or e & 1 == 0 for p, e in factorint(n).items()),
        count(0),
    )


def A155562_gen():  # generator of terms
    return filter(
        lambda n: all(
            (p & 3 != 3 and p & 7 < 5) or e & 1 == 0 for p, e in factorint(n).items()
        ),
        count(0),
    )


def A124134_gen():  # generator of terms
    return filter(
        lambda n: n & 1
        or all(p & 3 != 3 or e & 1 == 0 for p, e in factorint(fibonacci(n)).items()),
        count(1),
    )


def A236264_gen():  # generator of terms
    return filter(
        lambda n: all(
            p & 3 != 3 or e & 1 == 0 for p, e in factorint(fibonacci(n)).items()
        ),
        count(0, 2),
    )


def A180590_gen():  # generator of terms
    return filter(
        lambda n: all(
            p & 3 != 3 or e & 1 == 0 for p, e in factorint(4 * factorial(n) + 1).items()
        ),
        count(0),
    )


def A000118(n):
    return (
        divisor_sigma(n) << 3
        if n & 1
        else 3 * divisor_sigma(n >> (~n & n - 1).bit_length()) << 3 if n else 1
    )


def A333911_gen():  # generator of terms
    return filter(
        lambda n: all(
            p & 3 != 3 or e & 1 == 0
            for p, e in sum(
                (
                    Counter(factorint((p ** (e + 1) - 1) // (p - 1)))
                    for p, e in factorint(n).items()
                ),
                start=Counter(),
            ).items()
        ),
        count(1),
    )


def A333910_gen():  # generator of terms
    return filter(
        lambda n: all(
            p & 3 != 3 or e & 1 == 0
            for p, e in sum(
                (
                    Counter(factorint(1 + p)) + Counter({p: e - 1})
                    for p, e in factorint(n).items()
                ),
                start=Counter(),
            ).items()
        ),
        count(1),
    )


def A333909_gen():  # generator of terms
    return filter(
        lambda n: all(
            p & 3 != 3 or e & 1 == 0 for p, e in factorint(totient(n)).items()
        ),
        count(1),
    )


def A268379_gen():  # generator of terms
    return filter(
        lambda n: sum((f := factorint(n)).values()) - f.get(2, 0)
        < 2 * sum(f[p] for p in f if p & 3 == 1),
        count(1),
    )


def A263715_gen():  # generator of terms
    return filter(
        lambda n: n & 3 != 2
        or all(p & 3 != 3 or e & 1 == 0 for p, e in factorint(n).items()),
        count(0),
    )


def A022544_gen():  # generator of terms
    return filter(
        lambda n: any(p & 3 == 3 and e & 1 for p, e in factorint(n).items()), count(0)
    )


def A263737_gen():  # generator of terms
    return filter(
        lambda n: n & 3 != 2
        and any(p & 3 == 3 and e & 1 for p, e in factorint(n).items()),
        count(0),
    )


def A260728(n):
    return reduce(or_, (e for p, e in factorint(n).items() if p & 3 == 3), 0)


def A229062(n):
    return int(all(p & 3 != 3 or e & 1 == 0 for p, e in factorint(n).items()))


def A102548_gen():  # generator of terms
    return accumulate(
        int(all(p & 3 != 3 or e & 1 == 0 for p, e in factorint(n).items()))
        for n in count(1)
    )


def A097706(n):
    return prod(p**e for p, e in factorint(n).items() if p & 3 == 3)


def A102574(n):
    return prod(
        (q := int(p & 3 == 3)) * (p ** (2 * (e + 1)) - 1) // (p**2 - 1)
        + (1 - q) * (p ** (2 * e + 1) - 1) // (p - 1)
        for p, e in factorint(n).items()
    )


def A057653_gen():  # generator of terms
    return filter(
        lambda n: all(p & 3 != 3 or e & 1 == 0 for p, e in factorint(n).items()),
        count(1, 2),
    )


def A097269_gen():  # generator of terms
    return filter(
        lambda n: all(p & 3 != 3 or e & 1 == 0 for p, e in factorint(n // 2).items()),
        count(2, 4),
    )


def A073613_gen():  # generator of terms
    return filter(
        lambda n: all(p & 3 != 3 or e & 1 == 0 for p, e in factorint(n).items()),
        (m * (m + 1) // 2 for m in count(0)),
    )


def A035251_gen():  # generator of terms
    return filter(
        lambda n: all(not ((2 < p & 7 < 7) and e & 1) for p, e in factorint(n).items()),
        count(1),
    )


def A232531_gen():  # generator of terms
    return filter(
        lambda n: any((2 < p & 7 < 7) and e & 1 for p, e in factorint(n).items()),
        count(1),
    )


def A046711_gen():  # generator of terms
    return filter(
        lambda n: 0 < n & 3 < 3
        and all(p & 3 != 3 or e & 1 == 0 for p, e in factorint(n).items()),
        count(0),
    )


def A031363_gen():  # generator of terms
    return filter(
        lambda n: all(not ((1 < p % 5 < 4) and e & 1) for p, e in factorint(n).items()),
        count(1),
    )


def A020893_gen():  # generator of terms
    return filter(
        lambda n: all(p & 3 != 3 and e == 1 for p, e in factorint(n).items()), count(1)
    )


def A014198_gen():  # generator of terms
    return accumulate(
        map(
            lambda n: prod(
                e + 1 if p & 3 == 1 else (e + 1) & 1
                for p, e in factorint(n).items()
                if p > 2
            )
            << 2,
            count(1),
        ),
        initial=0,
    )


def A355175(n):
    return Matrix(
        n, n, [(i - j) ** 2 + int(i == j) for i in range(n) for j in range(n)]
    ).det()


def A048727(n):
    return n ^ n << 1 ^ n << 2


def A048730(n):
    return 7 * n - (n ^ n << 1 ^ n << 2)


def A284557(n):
    return (n ^ n << 1 ^ n << 2) % 3


def A269160(n):
    return n ^ (n << 1 | n << 2)


def A048725(n):
    return n ^ n << 2


def A269161(n):
    return n << 2 ^ (n << 1 | n)


def A213370(n):
    return n & n << 1


def A048735(n):
    return n & n >> 1


def A353168_gen():  # generator of terms
    return chain(
        (0,),
        chain.from_iterable(
            (
                sorted(n ^ n << 1 ^ n << 2 for n in range(2**l, 2 ** (l + 1)))
                for l in count(0)
            )
        ),
    )


def A355326(n):
    return Matrix(
        n, n, [1 if i == j else (i - j) ** 3 for i in range(n) for j in range(n)]
    ).det()


def A292272(n):
    return n & ~(n >> 1)


def A003188(n):
    return n ^ n >> 1


def A048728(n):
    return 3 * n - (n ^ n << 1)


def A229762(n):
    return ~n & n >> 1


def A229763(n):
    return n & ~(n << 1)


def A269170(n):
    return n | n >> 1


def A213064(n):
    return n << 1 & ~n


def A006068(n):
    k, m = n, n >> 1
    while m > 0:
        k ^= m
        m >>= 1
    return k


def A268717(n):
    k, m = n - 1, n - 1 >> 1
    while m > 0:
        k ^= m
        m >>= 1
    return k + 1 ^ k + 1 >> 1


def A268718(n):
    if n == 0:
        return 0
    k, m = n, n >> 1
    while m > 0:
        k ^= m
        m >>= 1
    return 1 + (k - 1 ^ k - 1 >> 1)


def A055975(n):
    return (n ^ n >> 1) - (n - 1 ^ n - 1 >> 1)


def A064706(n):
    return n ^ n >> 2


def A065621(n):
    return n ^ (n & ~-n) << 1


def A277823(n):
    return (m := n ^ (n & ~-n) << 1) ^ m << 1


def A245471(n):
    return (m := n + 1) ^ (m & ~-m) << 1 if n & 1 else n >> 1


def A114390(n):
    return (m := n**2) ^ (m & ~-m) << 1


def A284552(n):
    return (n ^ (n & ~-n) << 1) % n


def A048724(n):
    return n ^ n << 1


def A105081(n):
    return 1 + (n - 1 ^ n - 1 >> 1)


def A048726(n):
    return (n ^ n << 1) << 1


def A284574(n):
    return (n ^ n << 1) % 3


def A178729(n):
    return n ^ 3 * n


def A142149(n):
    return n if n & 1 else (n ^ n >> 1)


def A178734(n):
    return n ^ n << 3


def A277825(n):
    return (m := n ^ (n & ~-n) << 1) ^ m << 2


def A269137(n):
    return (n ^ n << 1) | (n ^ n << 2)


def A338524(n):
    k = prime(n)
    m = k >> 1
    while m > 0:
        k ^= m
        m >>= 1
    return k


def A143292(n):
    return (p := prime(n)) ^ p >> 1


def A292204_gen():  # generator of terms
    for n in count(0):
        k, m = n, n >> 1
        while m > 0:
            k ^= m
            m >>= 1
        if isprime(k):
            yield k


def A292600(n):
    k, m = n >> 1, n >> 2
    while m > 0:
        k ^= m
        m >>= 1
    return k


def A292601(n):
    k, m = n >> 1, n >> 2
    while m > 0:
        k ^= m
        m >>= 1
    return n - k


def A286546(n):
    k, m = n, n >> 1
    while m > 0:
        k ^= m
        m >>= 1
    return k - n


def A268716(n):
    k, m = n, n >> 1
    while m > 0:
        k ^= m
        m >>= 1
    return k << 1


def A268723(n):
    k, m = n, n >> 1
    while m > 0:
        k ^= m
        m >>= 1
    return (a := k**2) ^ a >> 1


def A268722(n):
    k, m = n, n >> 1
    while m > 0:
        k ^= m
        m >>= 1
    return (a := 3 * k) ^ a >> 1


def A268384_gen():  # generator of terms
    a = -1
    for n in count(0):
        b = int("".join(str(int(not (~n & k))) for k in range(n + 1)), 2)
        yield from (0,) * (b - a - 1)
        yield 1
        a = b


def A059905(n):
    return int(bin(n)[:1:-2][::-1], 2)


def A059906(n):
    return 0 if n < 2 else int(bin(n)[-2:1:-2][::-1], 2)


def A292371(n):
    return int(bin(n & ~(n >> 1))[:1:-2][::-1], 2)


def A292372(n):
    return 0 if (m := n & ~(n << 1)) < 2 else int(bin(m)[-2:1:-2][::-1], 2)


def A292373(n):
    return int(bin(n & n >> 1)[:1:-2][::-1], 2)


def A309952(n):
    return int(
        "".join(
            map(
                lambda x: str(xor(*x)),
                zip_longest(
                    (s := tuple(int(d) for d in bin(n)[2:]))[::-2],
                    s[-2::-2],
                    fillvalue=0,
                ),
            )
        )[::-1],
        2,
    )


def A057643(n):
    return lcm(*(d + 1 for d in divisors(n, generator=True)))


def A020696(n):
    return prod(d + 1 for d in divisors(n, generator=True))


def A355331_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: reduce(
            lambda a, b: a * b % n, (d + 1 for d in divisors(n, generator=True))
        )
        % n
        == 0,
        count(max(startvalue, 1)),
    )


def A062383(n):
    return 1 << n.bit_length()


def A142151(n):
    return (
        0
        if n == 0
        else (
            reduce(or_, (k ^ n - k for k in range(n + 1)))
            if n % 2
            else (1 << n.bit_length() - 1) - 1 << 1
        )
    )


def A153587(n):
    return n % ((1 << n.bit_length()) - n)


def A080079(n):
    return (1 << n.bit_length()) - n


def A029837(n):
    return (n - 1).bit_length()


def A035928_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: n
        == int(
            format(~n & (1 << (m := n.bit_length())) - 1, "0" + str(m) + "b")[::-1], 2
        ),
        count(max(startvalue, 1)),
    )


def A072376(n):
    return n if n < 2 else 1 << n.bit_length() - 2


def A176997_gen(startvalue=1):  # generator of terms
    if startvalue <= 1:
        yield 1
    k = 1 << (s := max(startvalue, 1)) - 1
    for n in count(s):
        if k % n == 1:
            yield n
        k <<= 1


def A355329_gen():  # generator of terms
    p = 2
    for m in count(6, 6):
        while q := (p - 1) % m:
            p = nextprime(p + m - q - 1)
        yield p
        p = nextprime(p)


def A007814(n):
    return (~n & n - 1).bit_length()


def A001511(n):
    return (~n & n - 1).bit_length() + 1


def A000404_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        c = False
        for p in (f := factorint(n)):
            if (q := p & 3) == 3 and f[p] & 1:
                break
            elif q == 1:
                c = True
        else:
            if c or f.get(2, 0) & 1:
                yield n


def A355237(n):
    m = 2
    for k in count(2):
        c = False
        for p in (f := factorint(k)):
            if (q := p & 3) == 3 and f[p] & 1:
                break
            elif q == 1:
                c = True
        else:
            if c or f.get(2, 0) & 1:
                if k - m == n:
                    return m
                m = k


def A355238(n):
    m = 2
    for k in count(2):
        c = False
        for p in (f := factorint(k)):
            if (q := p & 3) == 3 and f[p] & 1:
                break
            elif q == 1:
                c = True
        else:
            if c or f.get(2, 0) & 1:
                if k - m == n:
                    return k
                m = k


def A346070(n):
    return (~n & n - 1).bit_length() & 3


def A007733(n):
    return n_order(2, n >> (~n & n - 1).bit_length())


def A336937(n):
    return (~(m := int(divisor_sigma(n))) & m - 1).bit_length()


def A336842(n):
    return (
        ~((m := prod(nextprime(p) ** e for p, e in factorint(n).items())) + 1) & m
    ).bit_length()


def A335021(n):
    return (
        0
        if n == 1
        else (1 - (m := (~n & n - 1).bit_length())) * divisor_count(n >> m)
        - ((n & 1) << 1)
    )


def A331739(n):
    return n - (n >> (~n & n - 1).bit_length())


def A331700(n):
    return reduce(xor, (d**2 for d in divisors(n, generator=True)))


def A330569(n):
    return 1 + (0 if n & 1 else 1 << (~n & n - 1).bit_length() - 1)


def A326714(n):
    return (n * (n - 1) >> 1) + (~n & n - 1).bit_length()


def A324902(n):
    return (~(m := n | int(divisor_sigma(n)) - n) & m - 1).bit_length()


def A318456(n):
    return n | divisor_sigma(n) - n


def A324904(n):
    return (~(m := n << 1 | int(divisor_sigma(n))) & m - 1).bit_length()


def A324468(n):
    return (
        (~n & n - 1).bit_length()
        + (~(n + 1) & n).bit_length()
        + (~(n + 2) & n + 1).bit_length()
    )


def A066194(n):
    k, m = n - 1, n - 1 >> 1
    while m > 0:
        k ^= m
        m >>= 1
    return k + 1


def A094290(n):
    return prime((~n & n - 1).bit_length() + 1)


def A087230(n):
    return (~(m := 6 * n + 4) & m - 1).bit_length()


def A115364(n):
    return (m := ((~n & n - 1).bit_length() + 1)) * (m + 1) >> 1


def A082903(n):
    return 1 << (~(m := int(divisor_sigma(n))) & m - 1).bit_length()


def A036554_gen(startvalue=1):
    return filter(lambda n: (~n & n - 1).bit_length() & 1, count(max(startvalue, 1)))


def A079523_gen(startvalue=1):
    return filter(lambda n: (~(n + 1) & n).bit_length() & 1, count(max(startvalue, 1)))


def A072939_gen(startvalue=2):
    return filter(
        lambda n: (~(n - 1) & (n - 2)).bit_length() & 1, count(max(startvalue, 2))
    )


def A037227(n):
    return ((~n & n - 1).bit_length() << 1) + 1


def A003973(n):
    return prod(
        ((q := nextprime(p)) ** (e + 1) - 1) // (q - 1) for p, e in factorint(n).items()
    )


def A336932(n):
    return (
        ~(
            m := prod(
                ((q := nextprime(p)) ** (e + 1) - 1) // (q - 1)
                for p, e in factorint(n).items()
            )
        )
        & m - 1
    ).bit_length()


def A295664(n):
    return (~(m := int(divisor_count(n))) & m - 1).bit_length()


def A336931(n):
    return (
        ~(
            m := prod(
                ((q := nextprime(p)) ** (e + 1) - 1) // (q - 1)
                for p, e in factorint(n).items()
            )
        )
        & m - 1
    ).bit_length() - (~(k := int(divisor_count(n))) & k - 1).bit_length()


def A336930_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: (
            ~(
                m := prod(
                    ((q := nextprime(p)) ** (e + 1) - 1) // (q - 1)
                    for p, e in factorint(n).items()
                )
            )
            & m - 1
        ).bit_length()
        == (~(k := int(divisor_count(n))) & k - 1).bit_length(),
        count(max(startvalue, 1)),
    )


def A038712(n):
    return n ^ (n - 1)


def A023534_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: (~n & n - 1).bit_length() == primenu(n), count(max(startvalue, 1))
    )


def A337985(n):
    return (n % 3 > 1) * (1 + ((n + 3) // 6 & 1))


def A309773(n):
    return (
        n >> 1
        if (m := (~n & n - 1).bit_length() + 1) == n.bit_length()
        else n + (1 << m)
    )


def A048855(n):
    return (
        factorial(n) * prod(Fraction(p - 1, p) for p in primerange(n + 1))
    ).numerator


def A055597(n):
    return (
        ~(
            m := (
                factorial(n) * prod(Fraction(p - 1, p) for p in primerange(n + 1))
            ).numerator
        )
        & m - 1
    ).bit_length()


def A055656(n):
    return (
        ~(
            m := (
                (f := factorial(n))
                * prod(Fraction(p - 1, p) for p in primerange(n + 1))
            ).numerator
        )
        & m - 1
    ).bit_length() - (~f & f - 1).bit_length()


def A122840(n):
    return len(s := str(n)) - len(s.rstrip("0"))


def A006519(n):
    return n & -n


def A135481(n):
    return ~(n + 1) & n


def A136013(n):
    return sum(
        map(
            lambda x: (x[0] + 1) * (1 << x[0]),
            filter(lambda x: x[1] == "1", enumerate(bin(n)[-2:1:-1])),
        )
    )


def A036987(n):
    return int(not (n & (n + 1)))


def A135560(n):
    return (m := (~n & n - 1)).bit_length() + int(m == n - 1) + 1


def A135561(n):
    return (1 << (m := (~n & n - 1)).bit_length() + int(m == n - 1) + 1) - 1


def A135534(n):
    return (
        1
        if n == 1
        else (
            0
            if n & 1
            else (
                1 << (m := (~(k := n >> 1) & k - 1)).bit_length() + int(m == k - 1) + 1
            )
            - 1
        )
    )


def A135416(n):
    return int(not (n & (n + 1))) * (n + 1) >> 1


def A128311(n):
    return (pow(2, n - 1, n) - 1) % n


def A355058_gen():  # generator of terms
    return map(
        lambda n: n**2,
        filter(
            lambda n: prod((2 * e + 1) % 6 for e in factorint(n).values()) % 6 == 3,
            count(1),
        ),
    )


def A352798(n):
    return int(
        1
        / (
            continued_fraction_reduce([0] + [n] * n)
            - continued_fraction_reduce([0] + [n] * (n - 1))
        )
    )


def A127802(n):
    return 3 * int(not (n & (n + 1))) if n else 1


def A355418_gen():  # generator of terms
    p, q = 0, 2
    for i in count(0):
        s = set(str(i))
        yield from filter(lambda n: set(str(n)) == s, range(p, q))
        p, q = q, nextprime(q)


def A355317_gen():  # generator of terms
    p = 2
    for i in count(1):
        if int("".join(sorted(str(p)))) == int("".join(sorted(str(i)))):
            yield p
        p = nextprime(p)


def A355318_gen():  # generator of terms
    p = 2
    for i in count(1):
        if int("".join(sorted(str(p)))) == int("".join(sorted(str(i)))):
            yield i
        p = nextprime(p)


def A008619(n):
    return (n >> 1) + 1


def A004526(n):
    return n >> 1


def A002620(n):
    return (n**2) >> 2


def A023520(n):
    return (~(m := prime(n) * prime(n - 1) - 1) & m - 1).bit_length()


def A001223(n):
    return prime(n + 1) - prime(n)


def A080378(n):
    return (prime(n + 1) - prime(n)) & 3


def A023506(n):
    return (~(m := prime(n) - 1) & m - 1).bit_length()


def A025426(n):
    return (
        (
            m := prod(
                1 if p == 2 else (e + 1 if p & 3 == 1 else (e + 1) & 1)
                for p, e in factorint(n).items()
            )
        )
        + ((((~n & n - 1).bit_length() & 1) << 1) - 1 if m & 1 else 0)
    ) >> 1


def A005087(n):
    return len(primefactors(n)) + (n & 1) - 1


def A050603(n):
    return ((m := n >> 1) & ~(m + 1)).bit_length() + 1


def A355539_gen():  # generator of terms
    p, s, k = 2, set(), 0
    for i in count(1):
        if int(a := "".join(sorted(str(p)))) == int(b := "".join(sorted(str(i)))):
            k += 1
            if (q := (a.count("0"), b.count("0"))) not in s:
                yield k
                s.add(q)
        p = nextprime(p)


def A023528(n):
    return 0 if n == 1 else (~(m := prime(n) * prime(n - 1) + 1) & m - 1).bit_length()


def A023579(n):
    return (~(m := prime(n) + 3) & m - 1).bit_length()


def A086223(n):
    return (-(k := (m := (10**n - 1) // 9) & ~(m + 1)) + m + 1) // ((k + 1) << 1)


def A324466(n):
    return (~(m := factorial(3 * n) // factorial(n) ** 3) & m - 1).bit_length()


def A291982(n):
    return euler(n, n + 1) * (n + 1 & -n - 1)


def A291897(n):
    return euler((n << 1) - 1, n).p


def A259897(n):
    return (~(m := totient(comb(2 * n, n))) & m - 1).bit_length()


def A275019(n):
    return (~(m := n * (n + 1) * (n + 2) // 6) & m - 1).bit_length()


def A354782(n):
    return int(str(1 << n)[1])


def A008952(n):
    return int(str(1 << n)[0])


def A093049(n):
    return n - 1 - (~n & n - 1).bit_length() if n else 0


def A091311(n):
    return (int(bin(n)[2:], 3) << 1) - n


def A092525(n):
    return (n + 1) * (~n & n - 1) + n


def A093052(n):
    return n + (~(m := 3**n - 1) & m - 1).bit_length() if n else 0


def A093048(n):
    return n - (~n & n - 1).bit_length() if n else 0


def A100892(n):
    return ((~n & n - 1) << 2) + 2


def A119387(n):
    return (n + 1).bit_length() - (n + 1 & -n - 1).bit_length()


def A209229(n):
    return int(not (n & -n) ^ n) if n else 0


def A135523(n):
    return (~n & n - 1).bit_length() + int(not (n & -n) ^ n)


def A136480(n):
    return (~(m := n + (n & 1)) & m - 1).bit_length()


def A153733(n):
    return n >> (~(n + 1) & n).bit_length()


def A137780(n):
    return 1 + (1 << (prime(n + 1) - prime(n)))


def A177424(n):
    return (~(m := comb(n**2, n)) & m - 1).bit_length()


def A160467(n):
    return max(1, (n & -n) >> 1)


def A140670(n):
    return max(1, (n & -n) - 1)


def A186034_gen():  # generator of terms
    a, b = 1, 1
    yield from (0, 0)
    for n in count(2):
        a, b = b, (b * (2 * n + 1) + a * 3 * (n - 1)) // (n + 2)
        yield (~b & b - 1).bit_length()


def A186035_gen():  # generator of terms
    a, b = 1, 1
    yield from (1, 1)
    for n in count(2):
        a, b = b, (b * (2 * n + 1) + a * 3 * (n - 1)) // (n + 2)
        yield 1 - (((~b & b - 1).bit_length() & 1) << 1)


def A181741_gen():  # generator of terms
    m = 2
    for t in count(1):
        r = 1 << t - 1
        for k in range(t - 1, 0, -1):
            if isprime(s := m - r - 1):
                yield s
            r >>= 1
        m <<= 1


def A181743_gen():  # generator of terms
    m = 2
    for t in count(1):
        r = 1 << t - 1
        for k in range(t - 1, 0, -1):
            if isprime(m - r - 1):
                yield k
            r >>= 1
        m <<= 1


def A179504(n):
    return divisor_sigma(n << 1, n) if n else 1


def A201555(n):
    return comb((m := n**2) << 1, m)


def A007843(n):
    c = 0
    for k in count(1):
        c += (~k & k - 1).bit_length()
        if c >= n:
            return k


def A003602(n):
    return (n >> (n & -n).bit_length()) + 1


def A220779(n):
    return (~(m := int(harmonic(n, -n))) & m - 1).bit_length()


def A237881(n):
    return (~(m := prime(n) + prime(n + 1)) & m - 1).bit_length()


def A235062(n):
    return prod(
        map(lambda n: n >> (~n & n - 1).bit_length(), accumulate(range(1, n + 1), mul))
    )


def A234957(n):
    return 1 << ((~n & n - 1).bit_length() & -2)


def A235127(n):
    return (~n & n - 1).bit_length() >> 1


def A323921(n):
    return ((1 << ((~n & n - 1).bit_length() & -2) + 2) - 1) // 3


def A277549_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: (n >> ((~n & n - 1).bit_length() & -2)) & 3 == 1,
        count(max(startvalue, 1)),
    )


def A055039_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: (m := (~n & n - 1).bit_length()) & 1 and (n >> m) & 7 == 7,
        count(max(startvalue, 1)),
    )


def A004215_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: not (m := (~n & n - 1).bit_length()) & 1 and (n >> m) & 7 == 7,
        count(max(startvalue, 1)),
    )


def A272405_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: not (m := (~(s := int(divisor_sigma(n))) & s - 1).bit_length()) & 1
        and (s >> m) & 7 == 7,
        count(max(startvalue, 1)),
    )


def A234000_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: not (m := (~n & n - 1).bit_length()) & 1 and (n >> m) & 7 == 1,
        count(max(startvalue, 1)),
    )


def A055046_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: not (m := (~n & n - 1).bit_length()) & 1 and (n >> m) & 7 == 3,
        count(max(startvalue, 1)),
    )


def A055045_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: not (m := (~n & n - 1).bit_length()) & 1 and (n >> m) & 7 == 5,
        count(max(startvalue, 1)),
    )


def A225822_gen(startvalue=1):  # generator of terms
    return map(
        lambda m: (m << 1) + 1,
        filter(
            lambda n: n & 1 and not (~(n + 1) & n).bit_length() & 1,
            count(max(startvalue, 1)),
        ),
    )


def A199398(n):
    return reduce(xor, range(1, n << 1, 2))


def A126084(n):
    return reduce(xor, primerange(2, prime(n) + 1)) if n else 0


if sys.version_info >= (3, 10):

    def A011371(n):
        return n - n.bit_count()

    def A090616(n):
        return (n - n.bit_count()) >> 1

    def A090617(n):
        return (n - n.bit_count()) // 3

    def A090621(n):
        return (n - n.bit_count()) >> 2

    def A324465(n):
        return (
            3 * n.bit_count()
            - (~(n + 1) & n).bit_length()
            - (~(n + 2) & n + 1).bit_length()
            - (~(n + 3) & n + 2).bit_length()
            if n
            else 0
        )

    def A064394_gen(startvalue=3):  # generator of terms
        return filter(
            lambda n: n - n.bit_count() == prevprime(n), count(max(startvalue, 3))
        )

    def A064503_gen():  # generator of terms
        return islice(
            filter(lambda n: n - n.bit_count() == prevprime(n), count(3)), 0, None, 2
        )

    def A084953_gen(startvalue=1):  # generator of terms
        return filter(
            lambda n: (factorial(n) >> ((n - n.bit_count()) & -2)) & 7 == 7,
            count(max(startvalue, 1)),
        )

    def A276133(n):
        return (p := prime(n + 1) - 1) - p.bit_count() - (q := prime(n)) + q.bit_count()

    def A049606(n):
        return factorial(n) >> n - n.bit_count()

    def A060818(n):
        return 1 << n - n.bit_count()

    def A252488_gen():  # generator of terms
        m = 0
        for n in count(0):
            yield from [0] * (-m - 1 + (m := (n << 2) - n.bit_count()))
            yield 1

    def A120738(n):
        return (n << 2) - n.bit_count()

    def A101925(n):
        return (n << 1) - n.bit_count() + 1

    def A205509(n):
        return ((f := factorial(n - 1)) ^ f * n).bit_count()

    def A355489_gen(startvalue=1):  # generator of terms
        return filter(
            lambda n: n.bit_count() == (n & -n).bit_length() + 1,
            count(max(startvalue, 1)),
        )

else:

    def A011371(n):
        return n - bin(n).count("1")

    def A090616(n):
        return (n - bin(n).count("1")) >> 1

    def A090617(n):
        return (n - bin(n).count("1")) // 3

    def A090621(n):
        return (n - bin(n).count("1")) >> 2

    def A324465(n):
        return (
            3 * bin(n).count("1")
            - (~(n + 1) & n).bit_length()
            - (~(n + 2) & n + 1).bit_length()
            - (~(n + 3) & n + 2).bit_length()
            if n
            else 0
        )

    def A064394_gen(startvalue=3):  # generator of terms
        return filter(
            lambda n: n - bin(n).count("1") == prevprime(n), count(max(startvalue, 3))
        )

    def A064503_gen():  # generator of terms
        return islice(
            filter(lambda n: n - bin(n).count("1") == prevprime(n), count(3)),
            0,
            None,
            2,
        )

    def A084953_gen(startvalue=1):  # generator of terms
        return filter(
            lambda n: (factorial(n) >> ((n - bin(n).count("1")) & -2)) & 7 == 7,
            count(max(startvalue, 1)),
        )

    def A276133(n):
        return (
            (p := prime(n + 1) - 1)
            - bin(p).count("1")
            - (q := prime(n))
            + bin(q).count("1")
        )

    def A049606(n):
        return factorial(n) >> n - bin(n).count("1")

    def A060818(n):
        return 1 << n - bin(n).count("1")

    def A252488_gen():  # generator of terms
        m = 0
        for n in count(0):
            yield from [0] * (-m - 1 + (m := (n << 2) - bin(n).count("1")))
            yield 1

    def A120738(n):
        return (n << 2) - bin(n).count("1")

    def A101925(n):
        return (n << 1) - bin(n).count("1") + 1

    def A205509(n):
        return bin((f := factorial(n - 1)) ^ f * n).count("1")

    def A355489_gen(startvalue=1):  # generator of terms
        return filter(
            lambda n: bin(n).count("1") == (n & -n).bit_length() + 1,
            count(max(startvalue, 1)),
        )


def A065883(n):
    return n >> ((~n & n - 1).bit_length() & -2)


def A000534_gen(startvalue=0):  # generator of terms
    return filter(
        lambda n: n in {0, 1, 3, 5, 9, 11, 17, 29, 41}
        or n >> ((~n & n - 1).bit_length() & -2) in {2, 6, 14},
        count(max(startvalue, 0)),
    )


def A000414_gen(startvalue=0):  # generator of terms
    return filter(
        lambda n: not (
            n in {0, 1, 3, 5, 9, 11, 17, 29, 41}
            or n >> ((~n & n - 1).bit_length() & -2) in {2, 6, 14}
        ),
        count(max(startvalue, 0)),
    )


def A000378_gen(startvalue=0):  # generator of terms
    return filter(
        lambda n: (m := (~n & n - 1).bit_length()) & 1 or (n >> m) & 7 < 7,
        count(max(startvalue, 0)),
    )


def A244413(n):
    return (~n & n - 1).bit_length() // 3


def A010877(n):
    return n & 7


def A168181(n):
    return int(bool(n & 7))


def A053829(n):
    return sum(int(d) for d in oct(n)[2:])


def A054897(n):
    return (n - sum(int(d) for d in oct(n)[2:])) // 7


def A253513(n):
    return int(not (n & 7))


def A268355(n):
    return (m := (~n & n - 1)) + 1 >> (m.bit_length() % 3)


def A068504(n):
    return (m := prime(n) + 1) & -m


def A003484(n):
    return (((m := (~n & n - 1).bit_length()) & -4) << 1) + (1 << (m & 3))


def A101119(n):
    return (
        (1 << (m := (~n & n - 1).bit_length() + 4)) - ((m & -4) << 1) - (1 << (m & 3))
    )


def A101120(n):
    return (1 << (n + 3)) - (1 << ((n - 1) & 3)) - (((n + 3) & -4) << 1)


def A318466(n):
    return (n << 1) | int(divisor_sigma(n))


def A324906(n):
    return ((m := (n << 1) | int(divisor_sigma(n))) & ~(m + 1)).bit_length()


def A101121(n):
    return ((1 << (n + 2)) - (1 << ((n - 2) & 3)) - (((n + 2) & -4) << 1)) ^ (
        (1 << (n + 3)) - (1 << ((n - 1) & 3)) - (((n + 3) & -4) << 1)
    )


def A101122(n):
    return reduce(
        xor,
        (
            (
                (1 << (m := (~(k + 1) & k).bit_length() + 4))
                - ((m & -4) << 1)
                - (1 << (m & 3))
            )
            & -int(not k & ~(n - 1))
            for k in range(n)
        ),
    )


def A336066_gen(startvalue=2):  # generator of terms
    return filter(
        lambda n: n % (~n & n - 1).bit_length() == 0,
        count(max(startvalue + startvalue & 1, 2), 2),
    )


def A329486(n):
    return (3 * (n & -n) + n) >> 1


def A352757(n):
    return n * (n * (n * (24 * n - 48) + 48) - 23) + 5


def A286357(n):
    return ((m := int(divisor_sigma(n))) & -m).bit_length()


def A061214(n):
    return prod(i for i in range(prime(n) + 1, prime(n + 1)))


def A087963(n):
    return (~(m := prime(n) * 3 + 1) & m - 1).bit_length()


def A337923(n):
    return (
        int(not n % 3) + (int(not n % 6) << 1)
        if n % 12
        else 2 + (~n & n - 1).bit_length()
    )


def A220780(n):
    return (~(m := int(harmonic(k := (n << 1) + (n & 1), -k))) & m - 1).bit_length()


def A003159_gen(startvalue=1):  # generator of terms
    return filter(lambda n: (n & -n).bit_length() & 1, count(max(startvalue, 1)))


def A084089_gen():  # generator of terms
    return filter(lambda n: (n & -n).bit_length() & 1, count(1, 3))


def A084088_gen():  # generator of terms
    return filter(lambda n: (n & -n).bit_length() & 1, count(2, 3))


def A249152(n):
    return sum(i * (~i & i - 1).bit_length() for i in range(2, n + 1, 2))


def A249153(n):
    return sum(i * (~i & i - 1).bit_length() for i in range(2, 2 * n + 1, 2))


def A143157(n):
    return sum(i * (~i & i - 1).bit_length() for i in range(2, 2 * n + 1, 2)) >> 1


def A091512(n):
    return n * (n & -n).bit_length()


def A090129(n):
    return n if n < 3 else 1 << n - 2


def A090739(n):
    return (~n & n - 1).bit_length() + 3


def A090740(n):
    return (n & -n).bit_length() + int(not n & 1)


def A069895(n):
    return n * (n & -n).bit_length() << 1


def A318207(n):
    if n == 0:
        return 2
    a = 1 << n
    b = a << 1
    while True:
        if isprime(a + 3):
            return a + 3
        a += b


def A318938(n):
    return (
        (1 + 22 * ((1 << (3 * (m := (~n & n - 1).bit_length()) + 3)) - 1) // 7)
        * divisor_sigma(n >> m, 3)
        << 4
        if n
        else 1
    )


def A318939(n):
    return (
        3
        * (1 + 12 * ((1 << (3 * (m := (~n & n - 1).bit_length()) + 3)) - 1) // 7)
        * divisor_sigma(n >> m, 3)
        << 4
        if n
        else 1
    )


def A324903(n):
    return int(
        (~(m := int(divisor_sigma(n))) & m - 1).bit_length() > (~n & n - 1).bit_length()
    )


def A030141_gen(startvalue=0):  # generator of terms
    return filter(
        lambda n: all(int(a) + int(b) & 1 for a, b in zip(str(n), str(n)[1:])),
        count(max(startvalue, 0)),
    )


def A352758(n):
    return n * (n * (n * (24 * n - 48) + 48) - 25) + 6


def A355594(n):
    for m in count(1):
        if (
            sum(
                1
                for k in divisors(m, generator=True)
                if all(int(a) + int(b) & 1 for a, b in zip(str(k), str(k)[1:]))
            )
            == n
        ):
            return m


def A094267(n):
    return (((m := n >> 1) & ~(m + 1)).bit_length() + 1) * (-1 if n & 1 else 1)


def A181988(n):
    return (m := (n & -n).bit_length()) * ((n >> m) + 1)


def A183037(n):
    return (m := n & -n) * m.bit_length() << 1


def A059455_gen():  # generator of terms
    return filter(
        lambda p: isprime(p >> 1) and isprime(p << 1 | 1), (prime(i) for i in count(1))
    )


def A059452_gen():  # generator of terms
    return filter(
        lambda p: isprime(p >> 1) and not isprime(p << 1 | 1),
        (prime(i) for i in count(1)),
    )


def A059453_gen():  # generator of terms
    return filter(
        lambda p: not isprime(p >> 1) and isprime(p << 1 | 1),
        (prime(i) for i in count(1)),
    )


def A355265_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: any(map(lambda m: m > 5, factorint(n).values())),
        count(max(startvalue, 1)),
    )


def A355263(n):
    return prod(p ** (e // 3 + 1) for p, e in factorint(n).items())


def A355261(n):
    return prod(p ** ((e >> 1) + 1) for p, e in factorint(n).items())


def A355449(n):
    return int(isprime(n**2 + 2))


def A070940(n):
    return n.bit_length() - (~n & n - 1).bit_length()


def A089309(n):
    return (~((m := n >> (~n & n - 1).bit_length()) + 1) & m).bit_length()


def A320111(n):
    return divisor_count(n if n & 1 else n >> 1)


def A171977(n):
    return (n & -n) << 1


def A004755(n):
    return n + (1 << n.bit_length())


def A025480(n):
    return n >> ((~(n + 1) & n).bit_length() + 1)


def A092412(n):
    return (n & -n).bit_length() & 3


def A004754(n):
    return n + (1 << n.bit_length() - 1)


def A079946(n):
    return n + (1 << n.bit_length()) << 1


def A004780_gen(startvalue=1):  # generator of terms
    return filter(lambda n: n & (n << 1), count(max(startvalue, 1)))


def A004757(n):
    return n + (2 << n.bit_length())


def A004758(n):
    return n + (5 << n.bit_length() - 1)


def A004756(n):
    return n + (3 << n.bit_length() - 1)


def A004759(n):
    return n + (3 << n.bit_length())


def A349693(n):
    return divisor_count(n) * (m := (n & -n).bit_length() + 1) * (m + 1) // 6


def A336475(n):
    return (m := n >> (~n & n - 1).bit_length()) * divisor_count(m)


def A309530(n):
    return ((m := int(divisor_sigma((1 << n + 1) - 1))) & -m).bit_length()


def A326987(n):
    return divisor_count(n) - (n & -n).bit_length()


def A092673(n):
    return mobius(n) - (0 if n & 1 else mobius(n >> 1))


def A323885(n):
    return (n & -n).bit_length() + mobius(n) - (0 if n & 1 else mobius(n >> 1))


def A287896(n):
    return (n & -n).bit_length() * sum(
        reduce(
            lambda x, y: (x[0], x[0] + x[1]) if int(y) else (x[0] + x[1], x[1]),
            bin(n)[-1:2:-1],
            (1, 0),
        )
    )


def A274593(n):
    return (((m := ~(n + 1) & n) << 1) + 1) * ((n >> (k := m.bit_length())) | 1) - k - 1


def A271519(n):
    return (n - 1 >> (m := (~n & n - 1).bit_length()) + 1) + m


def A228368(n):
    return (m := n & -n).bit_length() - m


def A228367(n):
    return (m := n & -n) + m.bit_length()


def A228371(n):
    return ((m := (n >> 1) + 1) & -m).bit_length() if n & 1 else (m := n >> 1) & -m


def A117303(n):
    return (((m := (n & -n).bit_length()) << 1) - 1) * (1 << (n >> m))


def A006520(n):
    return sum(i & -i for i in range(1, n + 1))


def A228370(n):
    return sum(
        ((m := (i >> 1) + 1) & -m).bit_length() if i & 1 else (m := i >> 1) & -m
        for i in range(1, n + 1)
    )


def A228366(n):
    return sum(
        ((m := (i >> 1) + 1) & -m).bit_length() if i & 1 else (m := i >> 1) & -m
        for i in range(1, 2 * n + 1)
    )


def A355182(n):
    return ((m := (isqrt(((k := n * (n - 1)) << 3) + 1) + 1) >> 1) * (m + 1) >> 1) - k


def A328337(n):
    return sum(1 << (d - 1) for d in divisors(n, generator=True) if 1 < d < n)


def A034729(n):
    return sum(1 << (d - 1) for d in divisors(n, generator=True))


def A247146(n):
    return sum(1 << d - 1 for d in divisors(n, generator=True) if d < n)


def A354329(n):
    return (m := isqrt(n * (n * (n + 3) + 2) // 3)) * (m + 1) >> 1


def A053616(n):
    return abs((m := isqrt(k := n << 1)) * (m + 1) - k) >> 1


def A354330(n):
    return abs((m := isqrt(k := n * (n * (n + 3) + 2) // 3)) * (m + 1) - k) >> 1


def A001142(n):
    return prod(Fraction((k + 1) ** k, factorial(k)) for k in range(1, n))


def A355616(n):
    a = sorted(
        Fraction(x, y) for y in range(1, n + 1) for x in range(y + 1) if gcd(x, y) == 1
    )
    return len(set(a[i + 1] - a[i] for i in range(len(a) - 1)))


def A351964_gen():  # generator of terms
    yield 0
    l1, s, b = 1, 2, set()
    while True:
        for i in count(s):
            if not (i in b or i & l1):
                yield (~i & i - 1).bit_length()
                l1 = i
                b.add(i)
                while s in b:
                    b.remove(s)
                    s += 1
                break


def A001227(n):
    return divisor_count(n >> (~n & n - 1).bit_length())


def A349212(n):
    return (n + (m := (~n & n - 1).bit_length())) * divisor_count(n >> m)


def A349213(n):
    return (1 + n * (m := (~n & n - 1).bit_length())) * divisor_count(n >> m)


def A349211(n):
    f = factorint(n >> (m := (~n & n - 1).bit_length())).items()
    d = prod(e + 1 for p, e in f)
    s = prod((p ** (e + 1) - 1) // (p - 1) for p, e in f)
    return d + s * ((1 << (m + 1)) - 2)


def A348915(n):
    f = factorint(n >> (m := (~n & n - 1).bit_length())).items()
    d = prod(e + 1 for p, e in f)
    s = prod((p ** (e + 1) - 1) // (p - 1) for p, e in f)
    return s + d * m


def A183063(n):
    return divisor_count(n >> (m := (~n & n - 1).bit_length())) * m


def A065608(n):
    f = factorint(n).items()
    return prod((p ** (e + 1) - 1) // (p - 1) for p, e in f) - prod(e + 1 for p, e in f)


def A051001(n):
    return int(divisor_sigma(n >> (~n & n - 1).bit_length(), 4))


def A051002(n):
    return int(divisor_sigma(n >> (~n & n - 1).bit_length(), 5))


def A051000(n):
    return int(divisor_sigma(n >> (~n & n - 1).bit_length(), 3))


def A050999(n):
    return int(divisor_sigma(n >> (~n & n - 1).bit_length(), 2))


def A321810(n):
    return int(divisor_sigma(n >> (~n & n - 1).bit_length(), 6))


def A321816(n):
    return int(divisor_sigma(n >> (~n & n - 1).bit_length(), 12))


def A321811(n):
    return int(divisor_sigma(n >> (~n & n - 1).bit_length(), 7))


def A321815(n):
    return int(divisor_sigma(n >> (~n & n - 1).bit_length(), 11))


def A321812(n):
    return int(divisor_sigma(n >> (~n & n - 1).bit_length(), 8))


def A321813(n):
    return int(divisor_sigma(n >> (~n & n - 1).bit_length(), 9))


def A321814(n):
    return int(divisor_sigma(n >> (~n & n - 1).bit_length(), 10))


def A069283(n):
    return divisor_count(n >> (~n & n - 1).bit_length()) - 1 if n else 0


def A283208(n):
    return n + sum((n + 1) // (1 << j) for j in range(1, (n + 1).bit_length() + 2))


def A296306(n):
    return ((1 << ((n & -n).bit_length() << 1)) - 1) // 3


def A354790_gen():  # generator of terms
    aset, aqueue, c, b, f = {1}, deque([1]), 2, 1, True
    yield 1
    while True:
        for m in count(c):
            if (
                m not in aset
                and gcd(m, b) == 1
                and all(map(lambda n: n <= 1, factorint(m).values()))
            ):
                yield m
                aset.add(m)
                aqueue.append(m)
                if f:
                    aqueue.popleft()
                b = lcm(*aqueue)
                f = not f
                while c in aset:
                    c += 1
                break


def A354792_gen():  # generator of terms
    aset, aqueue, c, b, f = {1}, deque([1]), 2, 1, True
    yield 1
    while True:
        for m in count(c):
            if (
                m not in aset
                and gcd(m, b) == 1
                and all(map(lambda n: n <= 1, fs := factorint(m).values()))
            ):
                if len(fs) > 1:
                    yield m
                aset.add(m)
                aqueue.append(m)
                if f:
                    aqueue.popleft()
                b = lcm(*aqueue)
                f = not f
                while c in aset:
                    c += 1
                break


def A354791_gen():  # generator of terms
    aset, aqueue, c, b, f, i = {1}, deque([1]), 2, 1, True, 1
    yield 1
    while True:
        for m in count(c):
            if (
                m not in aset
                and gcd(m, b) == 1
                and all(map(lambda n: n <= 1, fs := factorint(m).values()))
            ):
                i += 1
                if len(fs) > 1:
                    yield i
                aset.add(m)
                aqueue.append(m)
                if f:
                    aqueue.popleft()
                b = lcm(*aqueue)
                f = not f
                while c in aset:
                    c += 1
                break


def A355322(n):
    return lcm(*(lucas(i) for i in range(1, n + 1)))


def A035105(n):
    return lcm(*(fibonacci(i) for i in range(1, n + 1)))


def A003972(n):
    return prod(
        (q := nextprime(p)) ** (e - 1) * (q - 1) for p, e in factorint(n).items()
    )


def A276086(n):
    m, p = 1, 2
    while n:
        n, a = divmod(n, p)
        m *= p**a
        p = nextprime(p)
    return m


def A355822_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        k = prod(nextprime(p) ** e for p, e in factorint(n).items())
        m, p, c = 1, 2, n
        while c:
            c, a = divmod(c, p)
            m *= p**a
            p = nextprime(p)
        if gcd(k, m) > 1:
            yield n


def A355821_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        k = prod(nextprime(p) ** e for p, e in factorint(n).items())
        m, p, c = 1, 2, n
        while c:
            c, a = divmod(c, p)
            m *= p**a
            p = nextprime(p)
        if gcd(k, m) == 1:
            yield n


def A355820(n):
    k = prod(nextprime(p) ** e for p, e in factorint(n).items())
    m, p = 1, 2
    while n:
        n, a = divmod(n, p)
        m *= p**a
        p = nextprime(p)
    return int(gcd(k, m) == 1)


def A277791(n):
    return n // gcd(n, divisor_sigma(n) - 1)


def A277790(n):
    return (m := divisor_sigma(n) - 1) // gcd(n, m)


def A355815(n):
    m, p, c = 1, 2, n
    while c:
        c, a = divmod(c, p)
        m *= p**a
        p = nextprime(p)
    return gcd(m, n // gcd(n, divisor_sigma(n) - 1))


def A000215(n):
    return (1 << (1 << n)) + 1


def A232460(n):
    return (1 << (1 << n)) - 5


def A152585(n):
    return (1 << 2 * (m := 1 << n)) * 3**m + 1


def A095077_gen():  # generator of terms
    return filter(
        isprime,
        map(
            lambda s: int("1" + "".join(s) + "1", 2),
            (s for l in count(2) for s in multiset_permutations("0" * (l - 2) + "11")),
        ),
    )


def A081091_gen():  # generator of terms
    return filter(
        isprime,
        map(
            lambda s: int("1" + "".join(s) + "1", 2),
            (s for l in count(1) for s in multiset_permutations("0" * (l - 1) + "1")),
        ),
    )


def A070826(n):
    return primorial(n) >> 1


def A330349(n):
    return (primorial(n + 1) >> 1) - (1 << n - 1)


def A355950(n):
    return (
        n * (1 + n ** (n - 2)) + sum(k ** (k - 1) * (n // k) for k in range(2, n))
        if n > 1
        else 1
    )


def A355888(n):
    return (
        factorial(n) + n + sum(factorial(k) * (n // k) for k in range(2, n))
        if n > 1
        else 1
    )


def A355887(n):
    return (
        n * (1 + n ** (n - 1)) + sum(k**k * (n // k) for k in range(2, n))
        if n > 1
        else 1
    )


def A355853_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: not any((str(n).count(d) ^ int(d)) & 1 for d in set(str(n)))
        and isprime(n),
        count(max(startvalue, 1)),
    )


def A355931(n):
    return gcd(divisor_sigma(n), n >> (~n & n - 1).bit_length())


def A355989(n):
    return rf((m := n + 1 >> 1) + (n + 1 & 1), m) >> 1


def A081125(n):
    return rf((m := n + 1 >> 1) + (n + 1 & 1), m)


def A354609_gen():  # generator of terms
    p, q = 3, 5
    while True:
        for n in range(p + 2 + (-p - 1) % 10, q, 10):
            f = factorint(n)
            if max(f.values()) == 1 and not any((n - 1) % (p - 1) for p in f):
                yield n
        p, q = q, nextprime(q)


def A355305_gen():  # generator of terms
    p, q = 3, 5
    while True:
        for n in range(p + 2 + (-p + 3) % 10, q, 10):
            f = factorint(n)
            if max(f.values()) == 1 and not any((n - 1) % (p - 1) for p in f):
                yield n
        p, q = q, nextprime(q)


def A355307_gen():  # generator of terms
    for n in count(7, 10):
        f = factorint(n)
        if len(f) == sum(f.values()) > 1 and not any((n - 1) % (p - 1) for p in f):
            yield n


def A355309_gen():  # generator of terms
    for n in count(3, 10):
        f = factorint(n)
        if len(f) == sum(f.values()) > 1 and not any((n - 1) % (p - 1) for p in f):
            yield n


def A279913(n):
    return 10**n + n - 10 ** (len(str(n)))


def A266959(n):
    return n + 10 ** (n - 1) if n > 1 else 1


def A356079(n):
    return n + sum(divisor_sigma(k, k) * (n // k) for k in range(2, n + 1))


if sys.version_info >= (3, 10):

    def A356040(n):
        return next(
            m
            for m in count(1)
            if divisor_count(m) == 2 * n
            and n == sum(1 for d in divisors(m, generator=True) if d.bit_count() & 1)
        )

    def A343018(n):
        return next(
            m + 1
            for m, t in enumerate(pairwise(map(divisor_count, count(1))))
            if t[1] == t[0] + n
        )

    def A343019(n):
        return next(
            m + 1
            for m, t in enumerate(pairwise(map(divisor_count, count(1))))
            if t[1] == t[0] - n
        )

else:

    def A356040(n):
        return next(
            m
            for m in count(1)
            if divisor_count(m) == 2 * n
            and n
            == sum(1 for d in divisors(m, generator=True) if bin(d).count("1") & 1)
        )

    def A343018(n):
        a, b = tee(map(divisor_count, count(1)))
        next(b, None)
        return next(m + 1 for m, t in enumerate(zip(a, b)) if t[1] == t[0] + n)

    def A343019(n):
        a, b = tee(map(divisor_count, count(1)))
        next(b, None)
        return next(m + 1 for m, t in enumerate(zip(a, b)) if t[1] == t[0] - n)


def A276715(n):
    return next(
        k
        for k in count(1)
        if all(divisor_sigma(k, i) == divisor_sigma(n + k, i) for i in (0, 1))
    )


def A269333(n):
    return next(k for k in count(2) if sum(map(int, str(k * n))) > n)


def A067270_gen():  # generator of terms
    a = 0
    yield from (0, 1)
    for n in count(0):
        if (
            b := int(min(crt(m := (1 << (n + 1), 5**n), (0, 1))[0], crt(m, (1, 0))[0]))
        ) > a:
            yield b
            a = b


def A228191(n):
    return int(min(crt(m := (1 << (n + 1), 5**n), (0, -1))[0], crt(m, (-1, 0))[0]))


def A003226_gen():  # generator of terms
    a = 0
    yield from (0, 1)
    for n in count(0):
        b = sorted((int(crt(m := (1 << n, 5**n), (0, 1))[0]), int(crt(m, (1, 0))[0])))
        if b[0] > a:
            yield from b
            a = b[1]
        elif b[1] > a:
            yield b[1]
            a = b[1]


def A228188(n):
    return (
        k := int(min(crt(m := (1 << (n + 1), 5**n), (0, -1))[0], crt(m, (-1, 0))[0]))
    ) * (k + 1) >> 1


def A356094(n):
    return (p := primorial(n)) // gcd(p, prime(n) - 1)


def A356093(n):
    return (p := prime(n) - 1) // gcd(p, primorial(n))


def A001614(n):
    return (m := n << 1) - (k := isqrt(m)) - int(m >= k * (k + 1) + 1)


def A118011(n):
    return (m := n << 1) + (k := isqrt(m)) + int(m >= k * (k + 1) + 1)


def A003056(n):
    return (k := isqrt(m := n + 1 << 1)) + int(m >= k * (k + 1) + 1) - 1


def A122797(n):
    return n + 1 - (k := isqrt(m := n << 1)) - int(m >= k * (k + 1) + 1)


def A122793(n):
    return (
        n * (n + 1)
        - (r := (k := isqrt(m := n << 1)) + int(m >= k * (k + 1) + 1))
        * ((6 * n + 1) - r**2)
        // 6
    )


def A017910(n):
    return isqrt(1 << n) if n & 1 else 1 << (n >> 1)


def A017912(n):
    return isqrt(1 << n) + 1 if n & 1 else 1 << (n >> 1)


def A080036(n):
    return (k := isqrt(m := n << 1)) + int(m >= k * (k + 1) + 1) + n + 1


def A003057(n):
    return (k := isqrt(m := n - 1 << 1)) + int(m >= k * (k + 1) + 1) + 1


def A355999(n):
    return int(
        (
            (1 << n - 6)
            * n ** (n - 7)
            * (
                n * (n * (n * (n * (n * (3 * n - 53) + 366) - 1309) + 2943) - 4926)
                + 4680
            )
        )
        // 3
    )


def A036571_gen():  # generator of terms
    c = 0
    for n in count(1):
        yield c
        c += 1 << (m := n << 1) - (k := isqrt(m)) - int(m >= k * (k + 1) + 1) - 1


def A356100(n):
    return sum((k - 1) ** n * (n // k) for k in range(2, n + 1))


def A003417(n):
    return 2 if n == 1 else 1 if n % 3 else n // 3 << 1


def A080408_gen():  # generator of terms
    blist = tuple()
    for n in count(1):
        yield (
            blist := tuple(
                accumulate(
                    reversed(blist),
                    initial=2 if n == 1 else 1 if n % 3 else n // 3 << 1,
                )
            )
        )[-1]


def A010879(n):
    return n % 10


def A130488(n):
    a, b = divmod(n, 10)
    return 45 * a + (b * (b + 1) >> 1)


def A053644(n):
    return 1 << n.bit_length() - 1 if n else 0


def A000030(n):
    return int(str(n)[0])


def A249079(n):
    a, b = divmod(n, 29)
    return 29 * n + a + int(b >= 15)


def A248786(n):
    a, b = divmod(n, 29)
    return 29 * n + a - int(not b) if n else 0


def A002265(n):
    return n >> 2


def A132292(n):
    return n - 1 >> 3


def A087811(n):
    return n * (n + 2) + (n & 1) >> 2


def A027434(n):
    return 1 + isqrt((n << 2) - 1)


def A049068(n):
    return n + 1 + isqrt((n << 2) - 1)


def A080037(n):
    return n + 2 + isqrt((n << 2) - 1) if n else 2


def A033638(n):
    return (n**2 >> 2) + 1


def A083479(n):
    return n + 1 - isqrt((n << 2) - 1) if n else 0


def A027709(n):
    return 1 + isqrt((n << 2) - 1) << 1 if n else 0


def A235382(n):
    return 3 + isqrt((n << 2) - 1) << 1 if n else 4


def A135708(n):
    return 3 * n + 1 + isqrt(12 * n - 4)


def A123663(n):
    return (m := n << 1) - 1 - isqrt((m << 1) - 1)


def A067628(n):
    return (c := isqrt(6 * n - 1) + 1) + ((c ^ n) & 1) if n else 0


def A078633(n):
    return (m := n << 1) + 1 + isqrt((m << 1) - 1)


def A182834(n):
    return n + isqrt(n - 1 << 1)


def A055228(n):
    return 1 + isqrt(factorial(n) - 1)


def A079530(n):
    return totient(n) - 1 - isqrt(n - 1)


def A104103(n):
    return 1 + isqrt(prime(n))


def A307136(n):
    return 1 + isqrt((n + isqrt(n + isqrt(n)) << 2) - 1)


def A038760(n):
    return m - k if (m := n - (k := isqrt(n)) ** 2) else 0


def A214078(n):
    return factorial(1 + isqrt(n - 1)) if n else 1


def A332932(n):
    return sum(1 + isqrt(d - 1) for d in divisors(n, generator=True))


def A189151_gen():  # generator of terms
    return (n for k in count(0) for n in range(k**2 + 1, k * (k + 1)))


def A038759(n):
    return m + n + k if (m := (k := isqrt(n)) ** 2 - n) else n


def A267708(n):
    return int((k := isqrt(n)) ** 2 + k - n + 1 > 0)


def A293332(n):
    return 1 + isqrt(5 * (1 << (n << 1)))


def A293331(n):
    return isqrt(5 * (1 << (n << 1)))


def A293333(n):
    return (k := isqrt(m := 5 * (1 << (n << 1)))) + int(m - k * (k + 1) >= 1)


def A293325(n):
    return 1 + isqrt(3 * (1 << (n << 1)))


def A094386(n):
    return isqrt(3 * (1 << (n - 1 << 1)))


def A293326(n):
    return (k := isqrt(m := 3 * (1 << (n << 1)))) + int(m - k * (k + 1) >= 1)


def A293137(n):
    return isqrt(n << 2) - 1 if n else 0


def A278814(n):
    return 1 + isqrt(3 * n)


def A028391(n):
    return n - isqrt(n)


def A184774_gen():  # generator of terms
    return filter(isprime, (isqrt(k**2 << 1) for k in count(1)))


def A184777_gen():  # generator of terms
    return filter(isprime, ((k << 1) + isqrt(k**2 << 1) for k in count(1)))


def A184778_gen():  # generator of terms
    return filter(lambda k: isprime((k << 1) + isqrt(k**2 << 1)), count(1))


def A184779_gen():  # generator of terms
    return map(
        primepi, filter(isprime, ((k << 1) + isqrt(k**2 << 1) for k in count(1)))
    )


def A184776_gen():  # generator of terms
    return map(primepi, filter(isprime, (isqrt(k**2 << 1) for k in count(1))))


def A184775_gen():  # generator of terms
    return filter(lambda k: isprime(isqrt(k**2 << 1)), count(1))


def A355928(n):
    return numbercore(divisor_sigma(n))


def A079529(n):
    return divisor_sigma(m := composite(n)) - 1 - m - isqrt(m - 1)


def A103416(n):
    return n - isqrt(prime(n + 1))


def A174804(n):
    return n * (n if (k := (m := isqrt(n)) ** 2) == n else k + m)


def A198081(n):
    return 1 + isqrt(3 * n * n) if n else 0


def A198263(n):
    return 1 + isqrt(n * n << 3) if n else 0


def A232423(n):
    return (1 + isqrt(m := n * (n * (n * (n - 1) - 1) + 1))) ** 2 - m - 1


def A232397(n):
    return (1 + isqrt(m := n * (n * (n * (n + 1) + 1) + 1))) ** 2 - m - 1


def A320471(n):
    return 0 if (m := isqrt(n)) ** 2 == n else m


def A273932_gen():  # generator of terms
    return filter(lambda n: isprime(1 + isqrt(factorial(n) - 1)), count(1))


def A316661(n):
    return 1 + isqrt((n << 1) ** n - 1)


def A017968(n):
    return (m := isqrt(k := 21**n)) + int(k - m * (m + 1) >= 1)


def A055789(n):
    return comb(n, (m := isqrt(n)) + int(n - m * (m + 1) >= 1))


def A213077(n):
    return n**2 - (m := isqrt(n)) - int(n - m * (m + 1) >= 1)


def A047946(n):
    return 5 * fibonacci(n) ** 2 + (-3 if n & 1 else 3)


def A299960(n):
    return ((1 << (n << 2) + 2) + 1) // 5


def A318236(n):
    return (3 * (1 << (n << 2) + 3) + 1) // 5


def A077118(n):
    return ((m := isqrt(k := n**3)) + int(k - m * (m + 1) >= 1)) ** 2


def A077119(n):
    return ((m := isqrt(k := n**3)) + int(k - m * (m + 1) >= 1)) ** 2 - k


def A011548(n):
    return (m := isqrt(k := 10 ** (n << 1) << 1)) + int(k - m * (m + 1) >= 1)


def A001670(n):
    return (m := isqrt(n)) + int(n - m * (m + 1) >= 1) << 1


def A011550(n):
    return (m := isqrt(k := 10 ** (n << 1) * 3)) + int(k - m * (m + 1) >= 1)


def A022851(n):
    return (m := isqrt(k := n**2 << 3)) + int(k - m * (m + 1) >= 1)


def A027662(n):
    return (m := isqrt(k := n * 10**6)) + int(k - m * (m + 1) >= 1)


def A027663(n):
    return (m := isqrt(k := n * 10**10)) + int(k - m * (m + 1) >= 1)


def A047749(n):
    return comb(n + (a := n >> 1), a + (b := n & 1)) // (n + 1 - b)


def A006013(n):
    return comb(3 * n + 1, n) // (n + 1)


def A130519(n):
    return (n - 1) ** 2 >> 3


def A032527(n):
    return 5 * n**2 >> 2


def A002821(n):
    return (m := isqrt(k := n**3)) + int(k - m * (m + 1) >= 1)


def A157502(n):
    return (k := n << 1) + (r := (m := isqrt(k)) + int(k - m * (m + 1) >= 1)) - (r & 1)


def A171152(n):
    return (
        n * (n + 1)
        + (r := (m := isqrt(k := n << 1)) + int(k - m * (m + 1) >= 1))
        * (3 * k + 1 - r**2)
        // 6
    )


def A079813(n):
    return int((m := isqrt(n)) ** 2 != n) - int(n - m * (m + 1) >= 1)


def A118175(n):
    return 1 + int(n - (m := isqrt(n + 1)) * (m + 1) >= 0) - int(m**2 != n + 1)


def A000194(n):
    return (m := isqrt(n)) + int(n - m * (m + 1) >= 1)


def A027664(n):
    return (m := isqrt(k := n * 10**14)) + int(k - m * (m + 1) >= 1)


def A293410(n):
    return 1 + isqrt(3 * n**4 - 1) if n else 0


def A221205(n):
    return (m := isqrt(k := int(primepi(10**n)))) + int(k - m * (m + 1) >= 1)


def A022850(n):
    return (m := isqrt(k := 7 * n * n)) + int(k - m * (m + 1) >= 1)


def A356150(n):
    s, t = bin(n)[2:], bin(~n & ((1 << n.bit_length()) - 1))[2:]
    return sum(m for m in range(1, n + 1) if (k := bin(m)[2:]) in s or k in t)


def A143803(n):
    return ((m := n << 1) - (k := isqrt(m)) - int(m >= k * (k + 1) + 1) << 1) - 1


def A133280(n):
    return (m := (n << 1) + 1) - ((isqrt(m + 1 << 2) + 1) >> 1)


def A143804(n):
    return 3 * ((m := n << 1) - (k := isqrt(m)) - int(m >= k * (k + 1) + 1)) - 2


def A049039(n):
    return (n << 1) - n.bit_length()


def A050271(n):
    a, b = divmod(n + 4, 3)
    return a**2 + b - 2


def A087278(n):
    a, b = divmod(n, 3)
    return a * (a + 2) + b


def A087279(n):
    return ((n + (b := n & 1)) ** 2 >> 2) + 1 - (b << 1)


def A332935(n):
    return sum(1 + isqrt(d**3 - 1) for d in divisors(n, generator=True))


def A332934(n):
    return sum(
        (m := isqrt(r := d**3)) + int(r - m * (m + 1) >= 1)
        for d in divisors(n, generator=True)
    )


def A332931(n):
    return sum(
        (m := isqrt(d)) + int(d - m * (m + 1) >= 1) for d in divisors(n, generator=True)
    )


def A053188(n):
    return abs(((m := isqrt(n)) + int(n - m * (m + 1) >= 1)) ** 2 - n)


def A351830(n):
    return abs(
        ((m := isqrt(r := n * (n * (2 * n + 3) + 1) // 6)) + int(r - m * (m + 1) >= 1))
        ** 2
        - r
    )


def A137803(n):
    return (
        (n >> 1) + (m := isqrt(r := n * n << 1)) + (n & 1) * int(r - m * (m + 1) >= 1)
    )


def A355160_gen(startvalue=0):  # generator of terms
    return filter(
        lambda n: int(((r := n**3) - (m := isqrt(r)) * (m + 1)) << 2 > 1),
        count(max(startvalue, 0)),
    )


def A355159_gen(startvalue=0):  # generator of terms
    return filter(
        lambda n: int(((r := n**3) - (m := isqrt(r)) * (m + 1)) << 2 <= 1),
        count(max(startvalue, 0)),
    )


def A006337(n):
    return -isqrt(m := n * n << 1) + isqrt(m + (n << 2) + 2)


def A022554(n):
    return (m := isqrt(n)) * (m * (-(m << 1) - 3) + 6 * n + 5) // 6


def A080763(n):
    return 3 + isqrt(m := n * n << 1) - isqrt(m + (n << 2) + 2)


def A003151(n):
    return n + isqrt(n * n << 1)


def A276862(n):
    return 1 - isqrt(m := n * n << 1) + isqrt(m + (n << 2) + 2)


def A159684(n):
    return -isqrt(m := (n + 1) ** 2 << 1) + isqrt(m + (n << 2) + 6) - 1


def A001952(n):
    return (m := n << 1) + isqrt(n * m)


def A348005(n):
    return n + (m := isqrt(n)) + int(n - m * (m + 1) >= 1) << 1


def A346276_gen():  # generator of terms
    return filter(
        lambda n: not (n % 7 or isprime(n)),
        (
            (10 ** (m + k) - 1) // 9 + 6 * 10**l
            for m in count(1, 3)
            for k in (0, 1)
            for l in range(m + k)
        ),
    )


def A309945(n):
    return (m := n - 1) - isqrt(m << 1)


def A326988(n):
    return divisor_sigma(n) - (n ^ (n - 1))


def A327306(n):
    return isqrt(9 * (m := 6 * n * n)) - 3 * isqrt(m)


def A338489(n):
    return (f := factorial(n)) - ((m := isqrt(f << 1)) * (m + 1) >> 1)


def A336911(n):
    return n**3 + 1 if n & 1 else isqrt(n)


def A329116(n):
    return ((t := 1 + isqrt(n - 1)) * (t - 1) - n) * (-1 if t & 1 else 1) if n else 0


def A255175(n):
    return ((1 + (t := isqrt(n))) * t - n - 1) * (1 if t & 1 else -1)


def A196199(n):
    return n - (t := isqrt(n)) * (t + 1)


def A022838(n):
    return isqrt(3 * n * n)


def A356086_gen():  # generator of terms
    return filter(
        lambda n: n == isqrt(3 * (isqrt(n**2 // 3) + 1) ** 2),
        ((k := n << 1) + isqrt(k * n) for n in count(1)),
    )


def A346308_gen():  # generator of terms
    return filter(
        lambda n: n == isqrt(3 * (isqrt(n**2 // 3) + 1) ** 2),
        (isqrt(n * n << 1) for n in count(1)),
    )


def A356088(n):
    return isqrt(isqrt(3 * n * n) ** 2 << 1)


def A356417_gen():  # generator of terms
    yield 0
    for l in count(1):
        nlist = []
        for m in range(1, isqrt(10**l) + 1):
            if m % 10:
                s = str(m**2)
                nlist.append(int(s[::-1]) * 10 ** (l - len(s)))
        yield from sorted(nlist)


def A354383(n):
    return int(26 * (a := fib2(n))[0] + 11 * a[1])


def A283776_gen():  # generator of terms
    return filter(lambda n: isqrt(3 * n * n) & 1, count(1))


def A355324(n):
    return fibonacci(n + 2) + lucas(n + 1) >> 1


def A354294(n):
    return (1 << n) - (1 << (n - 1 >> 1)) if n else 1


def A356434(n):
    return (
        (r if (m := nextprime(k := 1 << n)) > (k << 1) - (r := prevprime(k)) else m)
        if n > 1
        else 2
    )


def A117387(n):
    return (
        (m if (m := nextprime(k := 1 << n)) < (k << 1) - (r := prevprime(k)) else r)
        if n > 1
        else 2
    )


def A226178_gen():  # generator of terms
    return filter(
        lambda n: isprime(r := ((k := 1 << n) << 1) - (m := nextprime(k)))
        and nextprime(r) == m,
        count(1),
    )


def A346232(n):
    return isqrt(n**2 - 1 << 1) + 3


def A348776(n):
    return n + int(n < 3)


def A340507(n):
    return isqrt(m := n << 1) - (isqrt((m << 2) + 1) - 1 >> 1)


def A339765(n):
    return ((n + isqrt(5 * n**2)) & ~1) - 3 * n


def A005206(n):
    return (n + 1 + isqrt(5 * (n + 1) ** 2) >> 1) - n - 1


def A189663(n):
    return (n - 1 << 1) - (n - 1 + isqrt(5 * (n - 1) ** 2) >> 1)


def A019446(n):
    return (n + isqrt(5 * n**2) >> 1) - n + 1


def A060144(n):
    return (n << 1) - 1 - (n + isqrt(5 * n**2) >> 1) if n else 0


def A342959(n):
    return ((m := 10**n + 1) + isqrt(5 * m**2) >> 1) - m


def A060143(n):
    return (n + isqrt(5 * n**2) >> 1) - n


def A192002(n):
    return (
        (n + isqrt(m := 5 * n**2) >> 1)
        + (n + 1 + isqrt(m + 10 * n + 5) >> 1)
        - 3 * n
        - 1
    )


def A001950(n):
    return (n + isqrt(5 * n**2) >> 1) + n


def A342279(n):
    return (m := (n << 1) + 1) + isqrt(5 * m**2) >> 1


def A283234(n):
    return ((n + isqrt(5 * n**2)) & -2) + (n << 1)


def A283233(n):
    return (n + isqrt(5 * n**2)) & -2


def A109652(n):
    return prime(n + isqrt(5 * n**2) >> 1)


def A191403(n):
    return (
        (n + isqrt(m := 5 * n**2) >> 1) + (n + isqrt(m + (5 * (n + 1) << 2)) >> 1) + 1
    )


def A191404(n):
    return (n + isqrt(m := 5 * n**2) >> 1) + (n + 3 + isqrt(m + 30 * n + 45) >> 1)


def A316262_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: gcd(n, n + isqrt(5 * n**2) >> 1) > 1, count(max(startvalue, 1))
    )


def A014675(n):
    return (n + 2 + isqrt(m := 5 * (n + 2) ** 2) >> 1) - (
        n + 1 + isqrt(m - 10 * n - 15) >> 1
    )


def A085002(n):
    return ((n + isqrt(5 * n**2)) & 2) >> 1


def A191329(n):
    return m if (m := ((n + isqrt(5 * n**2)) & 2) + (n & 1)) < 3 else 1


def A188470(n):
    return (
        7 - (n + isqrt(5 * n**2) >> 1) + (n - 1 + isqrt(5 * (n - 5) ** 2) >> 1)
        if n > 5
        else int(n < 5)
    )


def A307294(n):
    return ((m := (n >> 1) + 1) + isqrt(5 * m**2) >> 1) + (n & 1)


def A307295(n):
    return ((m := (n >> 1) + 1) + isqrt(5 * m**2) >> 1) + m + (n & 1)


def A195170(n):
    return (n << 2) - (n + isqrt(5 * n**2) >> 1)


def A195171(n):
    return (m := 5 * n) - (n + isqrt(n * m) >> 1)


def A191402(n):
    return (n + isqrt(m := 5 * n**2) >> 1) + (n + 1 + isqrt(m + 10 * n + 5) >> 1)


def A190509(n):
    return n + ((m := n + isqrt(5 * n**2)) & -2) + (m >> 1)


def A185615_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: not (n + isqrt(5 * n**2) >> 1) % prod(primefactors(n)),
        count(max(startvalue, 1)),
    )


def A151915(n):
    return (n - 2 << 1) + ((m := n + isqrt(5 * n**2)) & -2) + (m >> 1)


def A135963(n):
    return comb(n + (n + isqrt(5 * n**2) >> 1), n)


def A134862(n):
    return 5 * (n + isqrt(5 * n**2) >> 1) + 3 * n


def A134859(n):
    return ((n + isqrt(5 * n**2) >> 1) - 1 << 1) + n


def A134860(n):
    return 3 * (n + isqrt(5 * n**2) >> 1) + (n << 1) - 1


def A134861(n):
    return 3 * ((n + isqrt(5 * n**2) >> 1) - 1) + (n << 1)


def A134864(n):
    return (m := 5 * n) + (((n + isqrt(n * m)) & -2) << 2)


def A026356(n):
    return (n + 1 + isqrt(5 * (n - 1) ** 2) >> 1) + n


def A134863(n):
    return 5 * (n + isqrt(5 * n**2) >> 1) + 3 * n - 1


def A035337(n):
    return 3 * (n + isqrt(5 * n**2) >> 1) + (n - 1 << 1)


def A035338(n):
    return 5 * (n + 1 + isqrt(5 * (n + 1) ** 2) >> 1) + 3 * n


def A137708(n):
    return ((m := n + 1 >> 1) + isqrt(5 * m**2) & -2) - (n & 1)


def A051626(n):
    return (
        0
        if (m := (n >> (~n & n - 1).bit_length()) // 5 ** multiplicity(5, n)) == 1
        else n_order(10, m)
    )


def A003622(n):
    return (n + isqrt(5 * n**2) >> 1) + n - 1


def A356491(n):
    return (
        Matrix(n, n, [prime(abs(i - j) + 1) for i in range(n) for j in range(n)]).per()
        if n
        else 1
    )


def A356490(n):
    return Matrix(
        n, n, [prime(abs(i - j) + 1) for i in range(n) for j in range(n)]
    ).det()


def A075317(n):
    return (n + isqrt(5 * n**2) & -2) - 1


def A075318(n):
    return (n + isqrt(5 * n**2) & -2) + (n << 1) - 1


def A075319(n):
    return (n + isqrt(5 * n**2) & -2) + n - 1 << 1


def A075320(n):
    return (m := (n + isqrt(5 * n**2) & -2) - 1) * ((n << 1) + m)


def A095281_gen():  # generator of terms
    return filter(isprime, ((n + isqrt(5 * n**2) >> 1) + n for n in count(1)))


def A095280_gen():  # generator of terms
    return filter(isprime, ((n + isqrt(5 * n**2) >> 1) for n in count(1)))


def A095907_gen():  # generator of terms
    k = 1
    for n in count(3):
        m = n + isqrt(5 * n**2) >> 1
        for _ in range(m - k - 1):
            yield 0
        yield 1
        k = m


def A054770(n):
    return (n + isqrt(5 * n**2) >> 1) + (n << 1) - 1


def A035336(n):
    return (n + isqrt(5 * n**2) & -2) + n - 1


def A026351(n):
    return (n + isqrt(5 * n**2) >> 1) + 1


def A004919(n):
    return (3 * n + isqrt(45 * n**2) >> 1) + (n << 1)


def A004976(n):
    return (isqrt(20 * n**2) >> 1) + (n << 1)


def A004958(n):
    return (isqrt(20 * n**2) >> 1) + (n << 1) + 1 if n else 0


def A078796(n):
    return (n + (m := isqrt(5 * n**2)) & -2) - m + 1


def A078588(n):
    return (n + isqrt(5 * n**2)) & 1


def A089809(n):
    return ((n + isqrt(5 * n**2)) & 1) ^ 1


def A026274(n):
    return (n + 1 + isqrt(5 * (n + 1) ** 2) >> 1) + n - 1


def A005614(n):
    return (n + isqrt(m := 5 * (n + 2) ** 2) >> 1) - (
        n + 1 + isqrt(m - 10 * n - 15) >> 1
    )


def A022342(n):
    return (n + isqrt(5 * n**2) >> 1) - 1


def A356274(n):
    return int(bin(n)[2:], n + 1)


def A355161_gen():  # generator of terms
    return filter(
        lambda n: ((~(m := n - prevprime(n)) + 1) & m) - m, (prime(n) for n in count(2))
    )


def A356247(n):
    k = -1
    for i in range(n - 1, 1, -1):
        k = i - Fraction(i + 1, k)
    return abs(k.numerator)


def A054084(n):
    return ((m := n + 1 >> 1) + isqrt(5 * m**2) >> 1) + m * (n & 1)


def A047924(n):
    return ((m := (n + isqrt(5 * n**2) >> 1) + 1) + isqrt(5 * m**2) >> 1) + m + 1


def A004641(n):
    return (
        [1, 0, 0, 1, 0, 1, 0, 1][n - 1]
        if n < 9
        else -1 - isqrt(m := (n - 9) * (n - 9) << 1) + isqrt(m + (n - 9 << 2) + 2)
    )


def A001030(n):
    return (
        [2, 1, 1, 2, 1, 2, 1, 2][n - 1]
        if n < 9
        else -isqrt(m := (n - 9) * (n - 9) << 1) + isqrt(m + (n - 9 << 2) + 2)
    )


def A007066(n):
    return (n + 1 + isqrt(5 * (n - 1) ** 2) >> 1) + n if n > 1 else 1


def A001966(n):
    return ((m := (n << 1) + 1) + isqrt(5 * m**2) >> 1) + m


def A001965(n):
    return ((m := (n << 1) + 1) + isqrt(5 * m**2) >> 1) - m


def A001468(n):
    return (n + 1 + isqrt(m := 5 * (n + 1) ** 2) >> 1) - (
        n + isqrt(m - 10 * n - 5) >> 1
    )


def A003231(n):
    return (n + isqrt(5 * n**2) >> 1) + (n << 1)


def A003849(n):
    return (
        2
        - (n + 2 + isqrt(m := 5 * (n + 2) ** 2) >> 1)
        + (n + 1 + isqrt(m - 10 * n - 15) >> 1)
    )


def A003623(n):
    return (n + isqrt(5 * n**2) & -2) + n


def A014677(n):
    return (
        (n + isqrt(m := 5 * (n + 2) ** 2) >> 1)
        - (n + 1 + isqrt(m - 10 * n - 15) & -2)
        + (n + isqrt(m - 20 * n - 20) >> 1)
        + 1
    )


def A026352(n):
    return (n + isqrt(5 * n**2) >> 1) + n + 1


def A050140(n):
    return (n + isqrt(5 * n**2) & -2) - n


def A026355(n):
    return (n - 1 + isqrt(5 * (n - 1) ** 2) >> 1) + 2 if n else 1


def A007067(n):
    return (isqrt(5 * n**2 << 2) >> 1) + n + 1 >> 1


def A120613(n):
    return (m := (n + isqrt(5 * n**2) >> 1) - n) + isqrt(5 * m**2) >> 1


def A003842(n):
    return (
        n
        + 2
        - ((m := (n + 2 + isqrt(5 * (n + 2) ** 2) >> 1) - n - 2) + isqrt(5 * m**2) >> 1)
    )


def A356646_gen():  # generator of terms
    return (
        a + 2
        for a, b in enumerate(
            accumulate(sum(prod(d) for d in factorint(n).items()) for n in count(2))
        )
        if perfect_power(b)
    )


def A085780_gen(startvalue=0):  # generator of terms
    if startvalue <= 0:
        yield 0
    for n in count(max(startvalue, 1)):
        for d in divisors(m := n << 2):
            if d**2 > m:
                break
            if (
                integer_nthroot((d << 2) + 1, 2)[1]
                and integer_nthroot((m // d << 2) + 1, 2)[1]
            ):
                yield n
                break


def A356748_gen(startvalue=0):  # generator of terms
    if startvalue <= 0:
        yield 0
    flag = False
    for n in count(max(startvalue, 1)):
        for d in divisors(m := n << 2):
            if d**2 > m:
                flag = False
                break
            if (
                integer_nthroot((d << 2) + 1, 2)[1]
                and integer_nthroot((m // d << 2) + 1, 2)[1]
            ):
                if flag:
                    yield n - 1
                flag = True
                break
        else:
            flag = False


def A096270(n):
    return (n + 1 + isqrt(5 * (n + 1) ** 2) >> 1) - (n + isqrt(5 * n**2) >> 1) >> 1


def A356768(n):
    return n**3 * (n * (n * (n + 2) + 2) + 1)


def A082389(n):
    return (n + 2 + isqrt(m := 5 * (n + 2) ** 2) >> 1) - (
        n + 1 + isqrt(m - 10 * n - 15) >> 1
    )


def A089910(n):
    return (n + isqrt(5 * n**2) & -2) + n + 1


def A088207_gen():  # generator of terms
    return accumulate((n + isqrt(5 * n**2) >> 1) + n for n in count(0))


def A075312(n):
    return (lambda m: m * (m + n))(n + isqrt(5 * n**2) >> 1)


def A140979(n):
    return (m := n + isqrt(5 * n**2) & -2) + isqrt(5 * m**2) >> 1


def A178129_gen():  # generator of terms
    return accumulate(n * ((isqrt(5 * n**2 << 2) >> 1) + n + 1 >> 1) for n in count(0))


def A050508(n):
    return n * ((isqrt(5 * n**2 << 2) >> 1) + n + 1 >> 1)


def A007069(n):
    return isqrt(isqrt(n**2 << 1) ** 2 << 1)


def A059648(n):
    return (m := n << 1) - 1 - isqrt(isqrt(n * m) ** 2 << 1) if n else 0


def A332789(n):
    return isqrt(isqrt(m := (n + 1) ** 2 << 1) ** 2 << 1) - isqrt(
        isqrt(m - (n << 2) - 2) ** 2 << 1
    )


def A101345(n):
    return (n + 1 + isqrt(5 * (n + 1) ** 2) & -2) + n - 2


def A101642(n):
    return 3 * (n + 1 + isqrt(5 * (n + 1) ** 2) >> 1) + (n << 1) - 3


def A022413(n):
    return (n + isqrt(5 * n**2) >> 1) + n + 3 if n else 1


def A188009(n):
    return (
        (n + isqrt(m := 5 * n**2) >> 1) - (n - 2 + isqrt(m - 20 * (n - 1)) >> 1) - 3
        if n > 1
        else 0
    )


def A123740(n):
    return (
        (n + 2 + isqrt(m := 5 * (n + 2) ** 2) >> 1)
        - (n + isqrt(m - 20 * (n + 1)) >> 1)
        - 3
    )


def A054347_gen():  # generator of terms
    return accumulate(n + isqrt(5 * n**2) >> 1 for n in count(0))


def A169938(n):
    return n * (n * (n * (n + 2) + 2) + 1)


def A061804(n):
    return n * ((n**2 << 2) + 2)


def A140868(n):
    return (m := n + isqrt(n * n << 1)) + isqrt(m * m << 1)


def A138330(n):
    return (m := n << 1) - isqrt(isqrt(n * m) ** 2 << 1)


def A074149(n):
    return (n * (n**2 - (n & 1)) >> 1) + n


def A176780(n):
    return n * (n * (n * (n + 6) + 14) + 15) + 6


def A178465(n):
    return n + (m := n & 1) + (n * (n**2 - m) >> 1) if n != 1 else 0


def A355419(n):
    return (p := prime(n)) + sum(
        2
        for x in range(2, p - 1)
        for y in range(x + 1, p)
        if pow(x, y, p) == pow(y, x, p)
    )


def A355486(n):
    p = prime(n)
    return sum(
        2
        for x in range(2, p - 1)
        for y in range(x + 1, p)
        if pow(x, y, p) == pow(y, x, p)
    )


def A356433_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: lcm(*(f := factorint(n)).values()) == prod(f),
        count(max(startvalue, 1)),
    )


def A072411(n):
    return lcm(*factorint(n).values())


def A052409(n):
    return gcd(*factorint(n).values())


def A268387(n):
    return reduce(xor, factorint(n).values(), 0)


def A267116(n):
    return reduce(or_, factorint(n).values(), 0)


def A267115(n):
    return reduce(and_, factorint(n).values()) if n > 1 else 0


def A355069(n):
    p = prime(n)
    return sum(
        sum(len(nthroot_mod(k, y, p, True)) for y in range(1, p)) ** 2 for k in range(p)
    )


def A356327(n):
    return sum(fibonacci(-a) * int(b) for a, b in enumerate(bin(n)[:1:-1], start=1))


def A355898_gen():  # generator of terms
    yield from (a := (1, 1))
    while True:
        yield (a := (a[1], (b := gcd(*a)) + sum(a) // b))[1]


def A131182_T(n, k):  # compute T(n, k)
    return factorial(n) * k**n


def A003233_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: ((m := (n + isqrt(5 * n**2) >> 1) + n) + isqrt(5 * m**2) >> 1)
        + (m << 1)
        == ((k := (n + isqrt(5 * n**2) >> 1) + (n << 1)) + isqrt(5 * k**2) >> 1) + k,
        count(max(1, startvalue)),
    )


def A003234_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: ((m := (n + isqrt(5 * n**2) >> 1) + n) + isqrt(5 * m**2) >> 1)
        + (m << 1)
        + 1
        == ((k := (n + isqrt(5 * n**2) >> 1) + (n << 1)) + isqrt(5 * k**2) >> 1) + k,
        count(max(1, startvalue)),
    )


def A061711(n):
    return factorial(n) * n**n


def A356182(n):
    return isqrt(3 * ((k := n << 1) + isqrt(k * n)) ** 2)


def A356180(n):
    return isqrt(3 * isqrt(n**2 << 1) ** 2)


def A046080(n):
    return prod((e << 1) + 1 for p, e in factorint(n).items() if p & 3 == 1) >> 1


def A046079(n):
    return prod((e + (p & 1) << 1) - 1 for p, e in factorint(n).items()) >> 1


def A263931(n):
    return (
        comb(m := n << 1, n) * primorial(n, nth=False) // primorial(m, nth=False)
        if n
        else 1
    )


def A261130(n):
    return primorial(n << 1, nth=False) // primorial(n, nth=False) if n else 1


def A022839(n):
    return isqrt(5 * n**2)


def A356426(n):
    return int(bin((n << 1) - 1)[2:], 3) + 1


def A022340_gen(startvalue=0):  # generator of terms
    return filter(
        lambda n: not n & (n >> 1), count(max(0, startvalue + (startvalue & 1)), 2)
    )


def A000846(n):
    return comb(3 * n, n) - comb(n << 1, n)


def A133388(n):
    return max((a for a, b in diop_DN(-1, n)), default=0)


def A355277(n):
    for a in "7531":
        for b in product("97531", repeat=n - 1):
            m = int(a + "".join(b))
            if set(str(m * (m + 1) >> 1)) <= {"1", "3", "5", "7", "9"}:
                return m


def A349247(n):
    for a in product("13579", repeat=n):
        if set(str((m := int("".join(a))) * (m + 1) >> 1)) <= {"1", "3", "5", "7", "9"}:
            return m


def A356208(n):
    return sum(
        1
        for m in range(1, (n**2 << 1) + 1)
        if n == max((a for a, b in diop_DN(-1, m)), default=0)
    )


def A356209(n):
    for m in range(n**2 << 1, 0, -1):
        if n == max((a for a, b in diop_DN(-1, m)), default=0):
            return m


def A356473(n):
    return (p := prod(f := factorint(n))) // gcd(
        p, prod((p - 1) * e + p for p, e in f.items())
    )


def A356472(n):
    f = factorint(n)
    return (m := prod((p - 1) * e + p for p, e in f.items())) // gcd(prod(f), m)


def A000161(n):
    f = factorint(n)
    return (
        int(not any(e & 1 for e in f.values()))
        + (
            (
                (
                    m := prod(
                        1 if p == 2 else (e + 1 if p & 3 == 1 else (e + 1) & 1)
                        for p, e in f.items()
                    )
                )
                + ((((~n & n - 1).bit_length() & 1) << 1) - 1 if m & 1 else 0)
            )
            >> 1
        )
        if n
        else 1
    )


def A025441(n):
    f = factorint(n).items()
    return (
        -int(not (any((e - 1 if p == 2 else e) & 1 for p, e in f) or n & 1))
        + (
            (
                (
                    m := prod(
                        1 if p == 2 else (e + 1 if p & 3 == 1 else (e + 1) & 1)
                        for p, e in f
                    )
                )
                + ((((~n & n - 1).bit_length() & 1) << 1) - 1 if m & 1 else 0)
            )
            >> 1
        )
        if n
        else 0
    )


def A025435(n):
    f = factorint(n)
    return (
        int(not any(e & 1 for p, e in f.items() if p > 2))
        * (1 - ((f.get(2, 0) & 1) << 1))
        + (
            (
                (
                    m := prod(
                        1 if p == 2 else (e + 1 if p & 3 == 1 else (e + 1) & 1)
                        for p, e in f.items()
                    )
                )
                + ((((~n & n - 1).bit_length() & 1) << 1) - 1 if m & 1 else 0)
            )
            >> 1
        )
        if n
        else 0
    )


def A073092_gen():  # generator of terms
    yield (c := 1)
    for n in count(1):
        f = factorint(n)
        c += int(not any(e & 1 for e in f.values())) + (
            (
                (
                    m := prod(
                        1 if p == 2 else (e + 1 if p & 3 == 1 else (e + 1) & 1)
                        for p, e in f.items()
                    )
                )
                + ((((~n & n - 1).bit_length() & 1) << 1) - 1 if m & 1 else 0)
            )
            >> 1
        )
        yield c


def A328804_gen():  # generator of terms
    return map(
        lambda n: max((a + b for a, b in diop_DN(-1, n))),
        filter(
            lambda n: (lambda m: all(d & 3 != 3 or m[d] & 1 == 0 for d in m))(
                factorint(n)
            ),
            count(0),
        ),
    )


def A328803_gen():  # generator of terms
    return map(
        lambda n: min((a + b for a, b in diop_DN(-1, n))),
        filter(
            lambda n: (lambda m: all(d & 3 != 3 or m[d] & 1 == 0 for d in m))(
                factorint(n)
            ),
            count(0),
        ),
    )


def A118882_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        f = factorint(n)
        if 1 < int(not any(e & 1 for e in f.values())) + (
            (
                (
                    m := prod(
                        1 if p == 2 else (e + 1 if p & 3 == 1 else (e + 1) & 1)
                        for p, e in f.items()
                    )
                )
                + ((((~n & n - 1).bit_length() & 1) << 1) - 1 if m & 1 else 0)
            )
            >> 1
        ):
            yield n


def A124979_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        f = factorint(n)
        if n % 5 and 1 < int(not any(e & 1 for e in f.values())) + (
            (
                (
                    m := prod(
                        1 if p == 2 else (e + 1 if p & 3 == 1 else (e + 1) & 1)
                        for p, e in f.items()
                    )
                )
                + ((((~n & n - 1).bit_length() & 1) << 1) - 1 if m & 1 else 0)
            )
            >> 1
        ):
            yield n


def A306358_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue + 1 - (startvalue & 1), 1), 2):
        f = factorint(n)
        if 1 < int(not any(e & 1 for e in f.values())) + (
            (
                (
                    m := prod(
                        1 if p == 2 else (e + 1 if p & 3 == 1 else (e + 1) & 1)
                        for p, e in f.items()
                    )
                )
                + ((((~n & n - 1).bit_length() & 1) << 1) - 1 if m & 1 else 0)
            )
            >> 1
        ):
            yield n


def A356886_gen():  # generator of terms
    aset, alist = {1}, [1]
    yield 1
    for n in count(2):
        if k := (0 if (i := 1 << n.bit_length()) == n << 1 else i - n):
            p, m = 3, alist[k - 1]
            while p * m in aset:
                p = nextprime(p)
            r = p * m
        else:
            r = n
        alist.append(r)
        aset.add(r)
        yield r


def A356840(n):
    return max(factorint(n).items(), key=lambda x: (x[1], x[0]))[0]


def A356838(n):
    return max(factorint(n).items(), key=lambda x: (x[1], -x[0]))[0]


def A356862_gen(startvalue=2):  # generator of terms
    return filter(
        lambda n: len(f := sorted(factorint(n).values(), reverse=True)) == 1
        or f[0] != f[1],
        count(max(startvalue, 2)),
    )


def A356964(n):
    a, b, c, s = 1, 2, 4, 0
    for i in bin(n)[-1:1:-1]:
        s += int(i) * a
        a, b, c = b, c, a + b + c
    return s


def A022290(n):
    a, b, s = 1, 2, 0
    for i in bin(n)[-1:1:-1]:
        s += int(i) * a
        a, b = b, a + b
    return s


def A354529(n):
    return 9 * n - 6 if n < 3 else n * (3 * n + 8) - 2 - 3 * (n & 1) >> 1


def A356421_gen():
    m = 1
    while True:
        n = m + 1 << 1
        k = m
        p = nextprime(k)
        while k + p > n:
            k -= 1
            p = nextprime(k)
        if k + p == n:
            yield k
        m = n - 1


def A357073(n):
    tlist, s, m = [1, 2], 0, n
    while (t := tlist[-1] + tlist[-2]) <= n:
        tlist.append(t)
    for d in tlist[::-1]:
        s = (s << 1) % n
        if d <= m:
            s = (s + 1) % n
            m -= d
    return s


def A357096_gen():
    p = 2
    while True:
        if (
            isprime((q := p << 1) + 1)
            and not isprime((r := q << 1) + 3)
            and isprime((r << 1) + 7)
        ):
            yield p
        p = nextprime(p)


def A356981_gen(startvalue=1):  # generator of terms
    return filter(
        lambda k: sum(int(d) for d in set(str(k))) == sum(primefactors(k)),
        count(max(startvalue, 1)),
    )


def A357019(n):
    return max(
        (a for a, b in diop_quadratic(symbolx * (symbolx - symboly) + symboly**2 - n)),
        default=0,
    )


def A076775(n):
    return gcd(n, int(bin(n)[2:]))


def A357111(n):
    return n // gcd(n, int(bin(n)[2:]))


def A357039(n):
    return sum(
        1
        for m in range(1, n**2 + 1)
        if sum((m * e // p for p, e in factorint(m).items())) == n << 1
    )


def A099302(n):
    return sum(
        1
        for m in range(1, (n**2 >> 2) + 1)
        if sum((m * e // p for p, e in factorint(m).items())) == n
    )


def A099303(n):
    for m in range(n**2 >> 2, 0, -1):
        if sum((m * e // p for p, e in factorint(m).items())) == n:
            return m
    return 0


def A098699(n):
    if n < 2:
        return n + 1
    for m in range(1, (n**2 >> 2) + 1):
        if sum((m * e // p for p, e in factorint(m).items())) == n:
            return m
    return 0


def A098700_gen(startvalue=2):  # generator of terms
    return filter(
        lambda n: all(
            map(
                lambda m: sum((m * e // p for p, e in factorint(m).items())) != n,
                range(1, (n**2 >> 1) + 1),
            )
        ),
        count(max(startvalue, 2)),
    )


def A189560(n):
    if n == 0:
        return 3
    mdict = {}
    for k in count(1, 2):
        c = 0
        for m in range(1, (k**2 >> 2) + 1):
            if m not in mdict:
                mdict[m] = sum((m * e // p for p, e in factorint(m).items()))
            if mdict[m] == k:
                c += 1
            if c > n:
                break
        if c == n:
            return k


def A179239_gen():  # generator of terms
    return chain(
        (0,),
        (
            int(a + "".join(b))
            for l in count(1)
            for a in "123456789"
            for b in combinations_with_replacement(
                "0" + "".join(str(d) for d in range(int(a), 10)), l - 1
            )
        ),
    )


def A075053(n):
    return sum(
        1
        for l in range(1, len(str(n)) + 1)
        for a in combinations(str(n), r=l)
        for b in multiset_permutations(a)
        if b[0] != "0" and isprime(int("".join(b)))
    )


def A039993(n):
    return sum(
        1
        for l in range(1, len(str(n)) + 1)
        for a in multiset_permutations(str(n), size=l)
        if a[0] != "0" and isprime(int("".join(a)))
    )


def A001918(n):
    return primitive_root(prime(n))


def A357130(n):
    return (n << 1) + 3 * (n & 1) - 1


def A262264_gen():  # generator of terms
    return filter(lambda p: p < primitive_root(p) ** 2, (prime(n) for n in count(1)))


def A268629_gen():  # generator of terms
    for n in count(1):
        p = prime(n)
        for i in range(1, p):
            if gcd(i, p) == 1 and is_squareful(i) and n_order(i, p) == p - 1:
                break
        else:
            yield p


def A355778_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        c = False
        for p in (f := factorint(n)):
            if (q := p & 3) == 3 and f[p] & 1:
                break
            elif q == 1:
                c = True
        else:
            if c or f.get(2, 0) & 1:
                c = False
                for p in (f := factorint(n**2 + 2)):
                    if (q := p & 3) == 3 and f[p] & 1:
                        break
                    elif q == 1:
                        c = True
                else:
                    if c or f.get(2, 0) & 1:
                        yield n


def A262038(n):
    sl = len(str(n))
    l = sl >> 1
    if sl & 1:
        w = 10**l
        n2 = w * 10
        for y in range(n // (10**l), n2):
            k, m = y // 10, 0
            while k >= 10:
                k, r = divmod(k, 10)
                m = 10 * m + r
            z = y * w + 10 * m + k
            if z >= n:
                return z
    else:
        w = 10 ** (l - 1)
        n2 = w * 10
        for y in range(n // (10**l), n2):
            k, m = y, 0
            while k >= 10:
                k, r = divmod(k, 10)
                m = 10 * m + r
            z = y * n2 + 10 * m + k
            if z >= n:
                return z


def A005132_gen():  # generator of terms
    a, aset = 0, set()
    for n in count(1):
        yield a
        aset.add(a)
        a = b if (b := a - n) >= 0 and b not in aset else a + n


def A356870_gen():  # generator of terms
    b, aset = 0, set()
    for n in count(1):
        aset.add(b)
        a, b = b, c if (c := b - n) >= 0 and c not in aset else b + n
        if not n & 1:
            yield a + b >> 2


def A356839_gen():  # generator of terms
    b, aset = 0, set()
    for n in count(1):
        aset.add(b)
        a, b = b, c if (c := b - n) >= 0 and c not in aset else b + n
        if n & 1:
            yield a + b


def A356551_gen():  # generator of terms
    b, c, aset = 0, 1, {0}
    for n in count(2):
        aset.add(c)
        a, b, c = b, c, d if (d := c - n) >= 0 and d not in aset else c + n
        yield c - a


def A335924_gen():  # generator of terms
    a, aset = 0, set()
    for n in count(1):
        yield a
        aset.add(a)
        a = (
            b
            if (b := a - n) >= 0 and b not in aset
            else c if (c := (n + 1 >> 1) + a) not in aset else a + n
        )


@lru_cache(maxsize=None)
def A074206(n):
    return (
        sum(
            A074206(d)
            for d in divisors(
                prod(
                    prime(i + 1) ** e
                    for i, e in enumerate(sorted(factorint(n).values(), reverse=True))
                ),
                generator=True,
                proper=True,
            )
        )
        if n > 1
        else n
    )


def A278223(n):
    return prod(
        prime(i + 1) ** e
        for i, e in enumerate(sorted(factorint((n << 1) - 1).values(), reverse=True))
    )


def A336158(n):
    return prod(
        prime(i + 1) ** e
        for i, e in enumerate(
            sorted(factorint(n >> (~n & n - 1).bit_length()).values(), reverse=True)
        )
    )


def A071364(n):
    return prod(
        prime(i + 1) ** p[1] for i, p in enumerate(sorted(factorint(n).items()))
    )


def A356334(n):
    return sum(
        1
        for x in range((1 << n) + 1)
        for y in range(x, (1 << n) + 1)
        if x ** (n + 1) + y ** (n + 1) == (x + y) ** n
    )


def A357253(n):
    return prevprime(6 * n)


def A061418_gen():  # generator of terms
    a = 2
    while True:
        yield a
        a += a >> 1


def A061419_gen():  # generator of terms
    a = 2
    while True:
        yield a - 1
        a += a >> 1


def A070885_gen():  # generator of terms
    a = 1
    while True:
        yield a
        a += (a + 1 >> 1) + (a & 1)


def A081848_gen():  # generator of terms
    yield (a := 3)
    while True:
        yield (b := (a + 1 >> 1) + (a & 1))
        a += b


def A073941_gen():  # generator of terms
    a, c = 1, 0
    yield 1
    while True:
        yield (a := (c := c + a) + 1 >> 1)


def A305497_gen():  # generator of terms
    a = 2
    while True:
        a += a >> 1
        yield (a << 1) - 4


def A305498_gen():  # generator of terms
    a = 2
    while True:
        yield (a << 1) - 2
        a += a >> 1


def A005428_gen():  # generator of terms
    a, c = 1, 0
    yield 1
    while True:
        yield (a := 1 + ((c := c + a) >> 1))


def A003312_gen():  # generator of terms
    a = 3
    while True:
        yield a
        a += a - 1 >> 1


def A182305_gen():  # generator of terms
    a = 4
    while True:
        yield a
        a += a >> 2


def A002379(n):
    return 3**n >> n


def A034082(n):
    return (3**n >> n) + 1 if n > 2 else 21


def A147788(n):
    return 3**n >> n - 1 if n else 2


def A182361_gen():  # generator of terms
    a = 8
    while True:
        yield a
        a += a >> 3


def A023376_gen():  # generator of terms
    a = 2
    while True:
        yield 1 << a
        a += a >> 1


@lru_cache(maxsize=None)
def A005704(n):
    return A005704(n - 1) + A005704(n // 3) if n else 1


@lru_cache(maxsize=None)
def A062051(n):
    return A062051(n - 1) + (0 if n % 3 else A062051(n // 3)) if n > 2 else 1


@lru_cache(maxsize=None)
def A000123(n):
    return A000123(n - 1) + A000123(n >> 1) if n else 1


def A356690(n):
    return prod(m for i in (1, 3, 7, 9) if isprime(m := 10 * n + i)) if n else 210


def A216292_gen(startvalue=1):  # generator of terms
    return filter(
        lambda k: sum(int(isprime(10 * k + i)) for i in (1, 3, 7, 9)) == 1,
        count(max(1, startvalue)),
    )


def A108958(n):
    return comb((n << 1) - 1, n - 1) - (1 << n - 1)


def A356549(n):
    return (
        n
        + 1
        + sum(
            n - m + 1
            for m in range(1, n + 2)
            for d in (2, 5)
            if str(d**m).startswith("1")
        )
    )


def A357273_gen():  # generator of terms
    yield 1
    for n in count(1):
        r = str(n)
        if n & 1 or r.startswith("2"):
            m = 10 ** (c := len(r)) + n
            s, sm = "", str(m)
            for d in divisors(m):
                s += str(d)
                if len(s) >= c + 1:
                    break
            if s.startswith(sm):
                yield m


def A357302_gen():  # generator of terms
    c = 0
    for k in count(1):
        if (
            d := len(diop_quadratic(symbolx * (symbolx + symboly) + symboly**2 - k**2))
        ) > c:
            yield k
            c = d


def A230097_gen():  # generator of terms
    c = -1
    for n in count(0):
        if (
            m := (
                (n**2).bit_count()
                if sys.version_info >= (3, 10)
                else bin(n**2).count("1")
            )
        ) > c:
            yield n
            c = m


def A357304_gen():  # generator of terms
    c = -1
    for n in count(0):
        if (
            m := (
                (n**2).bit_count()
                if sys.version_info >= (3, 10)
                else bin(n**2).count("1")
            )
        ) > c:
            yield (c := m)


@lru_cache(maxsize=None)
def A356990(n):
    return (
        1
        if n <= 1
        else n
        - A356990(
            A356990(
                A356990(A356990(n - A356990(A356990(A356990(A356990(A356990(n - 1)))))))
            )
        )
    )


def A005259(n):
    m, g = 1, 0
    for k in range(n + 1):
        g += m
        m *= ((n + k + 1) * (n - k)) ** 2
        m //= (k + 1) ** 4
    return g


def A005258(n):
    m, g = 1, 0
    for k in range(n + 1):
        g += m
        m *= (n + k + 1) * (n - k) ** 2
        m //= (k + 1) ** 3
    return g


def A108628(n):
    m, g = 1, 0
    for k in range(n + 1):
        g += m
        m *= (n + k + 2) * (n - k) * (n - k + 1)
        m //= (k + 1) ** 3
    return g


def A352653(n):
    if n == 0:
        return 0
    m, g = 1, 0
    for k in range(n + 1):
        g += m * n**2 // (n + k) ** 2
        m *= ((n + k + 1) * (n - k)) ** 2
        m //= (k + 1) ** 4
    return g >> 1


def A177316(n):
    if n == 0:
        return 1
    m, g = 1, 0
    for k in range(n + 1):
        g += m * n**2 // (n + k) ** 2
        m *= ((n + k + 1) * (n - k)) ** 2
        m //= (k + 1) ** 4
    return g


def A352654(n):
    if n == 0:
        return 0
    m, g = 1, 0
    for k in range(n + 1):
        g += -m * n // (n + k) if (n + k) & 1 else m * n // (n + k)
        m *= (n + k + 1) * (n - k) * (n + k)
        m //= (k + 1) ** 3
    return g


def A103882(n):
    if n == 0:
        return 1
    m, g = 1, 0
    for k in range(n + 1):
        g += m * n // (n + k)
        m *= (n + k + 1) * (n - k) ** 2
        m //= (k + 1) ** 3
    return g


def A006480(n):
    return factorial(3 * n) // factorial(n) ** 3


def A245086(n):
    return (
        0
        if n & 1
        else (-1 if (m := n >> 1) & 1 else 1) * factorial(3 * m) // factorial(m) ** 3
    )


def A273630(n):
    return (
        (1 if (m := n >> 1) & 1 else -1) * n**3 * factorial(3 * m) // factorial(m) ** 3
        if n & 1
        else 0
    )


def A273631(n):
    return (
        0
        if n & 1 or n == 0
        else (-1 if (m := n - 1 >> 1) & 1 else 1)
        * ((m + 1) * (n - 1)) ** 3
        * factorial(3 * m)
        // factorial(m) ** 3
    )


def A005260(n):
    m, g = 1, 0
    for k in range(n + 1):
        g += m
        m = m * (n - k) ** 4 // (k + 1) ** 4
    return g


def A005261(n):
    m, g = 1, 0
    for k in range(n + 1):
        g += m
        m = m * (n - k) ** 5 // (k + 1) ** 5
    return g


def A069865(n):
    m, g = 1, 0
    for k in range(n + 1):
        g += m
        m = m * (n - k) ** 6 // (k + 1) ** 6
    return g


def A063037_gen(startvalue=0):  # generator of terms
    return filter(
        lambda n: not ("000" in (s := bin(n)[2:]) or "111" in s),
        count(max(0, startvalue)),
    )


def A357753(n):
    return 1 << n - 1 if n & 1 else (isqrt(1 << n - 1) + 1) ** 2


def A116601(n):
    return isqrt((1 << n - 2) - 1) if n > 1 else 0


def A357754(n):
    return (isqrt((1 << n) - 1) if n & 1 else (1 << (n >> 1)) - 1) ** 2


def A130312_gen():  # generator of terms
    a, b = 1, 1
    while True:
        yield from (a,) * a
        a, b = b, a + b


def A357589_gen():  # generator of terms
    a, b, i = 1, 1, 1
    while True:
        yield from (j - a for j in range(i, i + a))
        i += a
        a, b = b, a + b


def A183544_gen():  # generator of terms
    a, b, i = 1, 1, 0
    while True:
        yield from (j + a for j in range(i, i + a))
        i += a
        a, b = b, a + b


if sys.version_info >= (3, 10):

    def A357658(n):
        return max(
            (k**2).bit_count()
            for k in range(isqrt((1 << n) - 1) + 1, isqrt((1 << n + 1) - 1) + 1)
        )

    def A357659(n):
        c = 0
        for k in range(isqrt((1 << n) - 1) + 1, isqrt((1 << n + 1) - 1) + 1):
            if (d := (k**2).bit_count()) > c:
                c, m = d, k
            elif d == c:
                m = min(m, k)
        return m

    def A357660(n):
        c = 0
        for k in range(isqrt((1 << n) - 1) + 1, isqrt((1 << n + 1) - 1) + 1):
            if (d := (k**2).bit_count()) > c:
                c, m = d, k
            elif d == c:
                m = max(m, k)
        return m

else:

    def A357658(n):
        return max(
            bin(k**2).count("1")
            for k in range(isqrt((1 << n) - 1) + 1, isqrt((1 << n + 1) - 1) + 1)
        )

    def A357659(n):
        c = 0
        for k in range(isqrt((1 << n) - 1) + 1, isqrt((1 << n + 1) - 1) + 1):
            if (d := bin(k**2).count("1")) > c:
                c, m = d, k
            elif d == c:
                m = min(m, k)
        return m

    def A357660(n):
        c = 0
        for k in range(isqrt((1 << n) - 1) + 1, isqrt((1 << n + 1) - 1) + 1):
            if (d := bin(k**2).count("1")) > c:
                c, m = d, k
            elif d == c:
                m = max(m, k)
        return m


def A357580(n):
    return simplify(((1 + sqrt(n)) ** n - (1 - sqrt(n)) ** n) / (n * sqrt(n))) >> 1


def A357502(n):
    return simplify(((1 + sqrt(n)) ** n - (1 - sqrt(n)) ** n) / sqrt(n)) >> 1


def A356217(n):
    return isqrt(5 * (n + isqrt(5 * n**2) >> 1) ** 2)


def A357812(n):
    return comb(n, n.bit_length())


def A113473(n):
    return n.bit_length()


def A037031(n):
    return comb(n, primepi(n))


def A353654_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: (m := (~n & n - 1).bit_length()) == bin(n >> m)[2:].count("0"),
        count(max(startvalue, 1)),
    )


def A086784(n):
    return bin(n >> (~n & n - 1).bit_length())[2:].count("0") if n else 0


if sys.version_info >= (3, 10):

    def A356385_gen():  # generator of terms
        return map(
            lambda x: x[1] - x[0],
            pairwise(
                filter(
                    lambda n: (~n & n - 1).bit_length() << 1
                    == n.bit_length() - n.bit_count(),
                    count(1),
                )
            ),
        )

else:

    def A356385_gen():  # generator of terms
        a, b = tee(
            filter(
                lambda n: (m := (~n & n - 1).bit_length())
                == bin(n >> m)[2:].count("0"),
                count(1),
            )
        )
        next(b, None)
        return map(lambda x: x[1] - x[0], zip(a, b))


def A215879(n):
    c = 0
    while (a := divmod(n, 3))[1]:
        c += 1
        n = a[0]
    return c


def A007949(n):
    c = 0
    while not (a := divmod(n, 3))[1]:
        c += 1
        n = a[0]
    return c


def A322523(n):
    c, m = 0, n
    while not (a := divmod(m, 3))[1]:
        c += 1
        m = a[0]
    if m == 2 or m % 3 == 1:
        return c
    m = (m + 1) // 3 - 2
    while (a := divmod(m, 3))[1]:
        c += 1
        m = a[0]
    return c + 1


def A354538(n):
    for k in count(1):
        c, m = 0, k
        while not (a := divmod(m, 3))[1]:
            c += 1
            m = a[0]
        if not (m == 2 or m % 3 == 1):
            c += 1
            m = (m + 1) // 3 - 2
            while (a := divmod(m, 3))[1]:
                c += 1
                m = a[0]
        if c == n:
            return k


def A081257(n):
    return max(primefactors(n - 1) + primefactors(n * (n + 1) + 1))


def A357127(n):
    return m if (m := max(primefactors(n * (n + 1) + 1))) > n else 1


def A357843(n):
    return sum(
        Fraction(1 if k & 1 else -1, divisor_count(k)) for k in range(1, n + 1)
    ).numerator


def A357844(n):
    return sum(
        Fraction(1 if k & 1 else -1, divisor_count(k)) for k in range(1, n + 1)
    ).denominator


def A357845(n):
    return sum(
        Fraction(1 if k & 1 else -1, divisor_sigma(k)) for k in range(1, n + 1)
    ).numerator


def A357846(n):
    return sum(
        Fraction(1 if k & 1 else -1, divisor_sigma(k)) for k in range(1, n + 1)
    ).denominator


def A060432(n):
    return (
        k := (r := isqrt(m := n + 1 << 1)) + int((m << 2) > (r << 2) * (r + 1) + 1) - 1
    ) * (k * (-k - 3) + 6 * n - 2) // 6 + n


def A204248(n):
    return (
        sum(
            stirling(n, n - k, kind=1)
            * stirling(n + 1, k + 1, kind=1)
            * factorial(n - k)
            * factorial(k)
            for k in range(n)
        )
        if n
        else 1
    )


def A064520(n):
    return sum(k if (isqrt(k << 3) + 1 >> 1) & 1 else -k for k in range(1, n + 1))


def A007664(n):
    return (
        1 << (r := (k := isqrt(m := n + 1 << 1)) + int(m >= k * (k + 1) + 1) - 1)
    ) * (n - 1 - (r * (r - 1) >> 1)) + 1


def A180272(n):
    return comb(n, (isqrt(n + 1 << 3) + 1 >> 1) - 1)


def A068092(n):
    return isqrt(10 ** (n - 1) << 3) + 1 >> 1


def A123578(n):
    return isqrt(n << 3) + 1 >> 1


def A357742(n):
    return max((k**2).bit_count() for k in range(1 << n - 1, 1 << n))


def A357750(n):
    for k in count(0):
        if (k**2).bit_count() - k.bit_count() == n:
            return k


def A356877(n):
    if n == 0:
        return 0
    for k in count((1 << n + 1) - 1):
        if k.bit_count() - (k**2).bit_count() == n:
            return k


def A130829(n):
    return 1 | ((m := isqrt(n)) + int((n - m * (m + 1) << 2) >= 1) << 1)


def A131664(n):
    return (10 ** (isqrt(n << 3) + 1 >> 1) - 1) // 9


def A133196(n):
    return 2 + (isqrt(n << 3) + 1 >> 1)


def A356371(n):
    return next(
        filter(
            lambda k: len(
                set(
                    gcd(i % j, j)
                    for i in range(k, n + k + 1)
                    for j in range(1, n + k + 1 - i)
                )
            )
            == n,
            count(n, n),
        )
    )


def A123387(n):
    return isqrt(prime(n) + 1 << 3) + 1 >> 1


def A007401(n):
    return n - 1 + (isqrt(n << 3) + 1 >> 1)


def A346522(n):
    return next(
        filter(
            lambda k: isqrt(k << 1) - isqrt(k - 1) == n,
            (m**2 + 1 >> 1 for m in count(1)),
        )
    )


def A357477(n):
    return next(
        filter(
            lambda k: isprime(
                (m := isqrt(k * n)) + int((k * n - m * (m + 1) << 2) >= 1)
            ),
            count(1),
        )
    )


def A357899(n):
    return next(
        filter(
            isprime,
            (
                (m := isqrt(k * n)) + int((k * n - m * (m + 1) << 2) >= 1)
                for k in count(1)
            ),
        )
    )


def A357823(n):
    return sum(1 for b in range(2, n) if n % sum(sympydigits(n, b)[1:]))


def A080221(n):
    return n - sum(1 for b in range(2, n) if n % sum(sympydigits(n, b)[1:]))


def A060839(n):
    return prod(3 for p, e in factorint(n).items() if (p != 3 or e != 1) and p % 3 != 2)


def A357905(n):
    return sum(1 for p, e in factorint(n).items() if (p != 3 or e != 1) and p % 3 != 2)


def A357062(n):
    return sum(
        max(1, 3 * (len(set(d)) - 1))
        for d in combinations_with_replacement(range(1, n + 1), 3)
        if prod(d) + sum(d) == n
    )


def A350535_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        flag = True
        for x in range(1, n + 1):
            if 3 * x + x**3 > n or not flag:
                break
            for y in range(x, n + 1):
                if x + 2 * y + x * y**2 > n:
                    break
                if (n - x - y) % (1 + x * y) == 0 and x + y * (2 + x * y) <= n:
                    flag = False
                    break
        if flag:
            yield n


def A356987_gen():  # generator of terms
    return filter(isprime, (10**k + m for k in count(1) for m in (1, 3, 7, 9)))


def A357576(n):
    return (
        0
        if n == 1
        else int(
            2
            * convex_hull(
                *[(0, 0), (n - 1, 0)]
                + [(x, isqrt((n - x) * (n + x) - 1)) for x in range(n)]
            ).area
        )
    )


def A357575(n):
    return (
        int(
            2
            * convex_hull(
                *[(n, 0), (0, 0)] + [(x, isqrt((n - x) * (n + x))) for x in range(n)]
            ).area
        )
        if n
        else 0
    )


def A357955(n):
    return 54 * comb(m := n << 1, n) + 3 * comb(m << 1, n) - 20 * comb(m + n, n)


def A358016(n):
    return max(filter(lambda k: k <= n - 2, sqrt_mod_iter(1, n)))


def A277777_gen():  # generator of terms
    for n in count(3):
        if (m := max(filter(lambda k: k < n - 1, sqrt_mod_iter(1, n)))) > 1:
            yield m


def A033949_gen():  # generator of terms
    return filter(
        lambda n: max(filter(lambda k: k < n - 1, sqrt_mod_iter(1, n))) > 1, count(3)
    )


def A228179_gen():  # generator of terms
    return chain.from_iterable((sorted(sqrt_mod_iter(1, n)) for n in count(2)))


def A358034_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: (s := sum(int(d) for d in str(n))) ** 2 == sum(divmod(n, s)),
        count(max(startvalue, 1)),
    )


def A277776_gen():  # generator of terms
    return chain.from_iterable(
        (sorted(filter(lambda m: 1 < m < n - 1, sqrt_mod_iter(1, n))) for n in count(2))
    )


def A357099_gen():  # generator of terms
    return chain.from_iterable(
        (
            sorted(filter(lambda m: 1 < m < n - 1, sqrt_mod_iter(1, n)))[1:2]
            for n in count(2)
        )
    )


def A082568_gen():  # generator of terms
    return chain.from_iterable(
        (
            sorted(filter(lambda m: 1 < m < n - 1, sqrt_mod_iter(1, n)))[:1]
            for n in count(2)
        )
    )


def A060594(n):
    return (1 << len(primefactors(n >> (s := (~n & n - 1).bit_length())))) * (
        1 if n & 1 else 1 << min(2, s - 1)
    )


def A073103(n):
    return (1 << min(s - 1, 3) if (s := (~n & n - 1).bit_length()) else 1) * prod(
        1 << (5 - (p & 3) >> 1) for p in primefactors(n >> s)
    )


def A357928(n):
    return (
        -1
        if n & 3 == 2
        else (
            min(
                (
                    m
                    for d in takewhile(lambda d: d**2 <= n, divisors(n))
                    if not ((m := n // d + d) & 1)
                ),
                default=0,
            )
            >> 1
        )
        - isqrt(n)
    )


def A358015(n):
    s = (
        (m := n >> (k := (~n & n - 1).bit_length()))
        // prod(q := primefactors(m))
        * prod(p + 1 for p in q)
    )
    return s >> 1 if n & 3 else s << k - 1


def A357884_gen():  # generator of terms
    a, s = 0, "0"
    for n in count(1):
        yield a
        if len(t := set(s) & set(str(n))) > 0:
            a = int(s.translate(s.maketrans("", "", "".join(t))) or 0)
        else:
            a += n
        s = str(a)


def A093803(n):
    if n == 1:
        return 1
    f = factorint(n)
    m = min(f)
    return prod(p ** (0 if p == 2 else e - 1 if p == m else e) for p, e in f.items())


def A056487(n):
    return 5 ** (n >> 1) * (3 if n & 1 else 1)


def A333592(n):
    return sum(comb(n + k - 1, k) ** 2 for k in range(n + 1)) if n else 1


def A357671(n):
    return (
        comb(n << 1, n) + sum(comb(n + k - 1, k) ** 2 for k in range(n + 1)) if n else 2
    )


def A357195(n):
    return next(
        filter(
            lambda n: (s := str(n))[: (t := len(s) + 1 >> 1)] == s[: -t - 1 : -1],
            (k * ((n << 1) + k - 1) >> 1 for k in count(1)),
        )
    )


def A358061(n):
    f = factorint(n).items()
    d = prod(e + 1 for p, e in f)
    return prod(pow(p, e - 1, d) * ((p - 1) % d) for p, e in f) % d


def A358068_gen(startvalue=2):  # generator of terms
    for n in count(max(startvalue, 2)):
        s = set(str(divisor_sigma(n) - n))
        if any(d in s for d in set(str(n))):
            yield n


def A357852(n):
    return prod(nextprime(p, ith=2) ** e for p, e in factorint(n).items())


def A000793(n):
    return max(lcm(*p) for p in partitions(n))


def A358035(n):
    return n * (n * ((n << 3) + 12) + 4) // 3 - 3


def A357143(n):
    t = len(s := sympydigits(n, 5)[1:])
    return sum(d**t for d in s)


def A357938(n):
    return prod(
        ((p ** (e + 1) - 1) // (p - 1) << 1) - 1 for p, e in factorint(n).items()
    )


def A358161(n):
    return (
        Matrix(
            n,
            n,
            [
                Fraction(i * j, 3).__ceil__()
                for i in range(1, n + 1)
                for j in range(1, n + 1)
            ],
        ).per()
        if n
        else 1
    )


def A358163(n):
    return (
        Matrix(
            n,
            n,
            [
                i * j - Fraction(i * j, 3).__ceil__()
                for i in range(1, n + 1)
                for j in range(1, n + 1)
            ],
        ).per()
        if n
        else 1
    )


def A358159(n):
    return (
        Matrix(
            n, n, [i * j - i * j // 3 for i in range(1, n + 1) for j in range(1, n + 1)]
        ).per()
        if n
        else 1
    )


def A358157(n):
    return (
        Matrix(
            n, n, [i * j // 3 for i in range(1, n + 1) for j in range(1, n + 1)]
        ).per()
        if n
        else 1
    )


def A358127(n):
    return len(
        set(
            gcd(prime(i) + 1, prime(j) + 1)
            for i in range(1, n)
            for j in range(i + 1, n + 1)
        )
    )


def A358127_gen():  # generator of terms
    a, b = [3], set()
    for n in count(2):
        q = prime(n) + 1
        b.update(set(gcd(p, q) for p in a))
        yield len(b)
        a.append(q)


def A357849(n):
    return sum(
        1
        for y in range(1, n - 1)
        if (m := 2 * n - 6 * y) >= 5 * y and 5 * (n - y) >= 2 * m and m % 5 == 0
    )


def A357489_gen():  # generator of terms
    for n in count(1):
        yield from sorted(
            (1 << n - 1) + (1 << x + (y := m // 6) - 1) + (1 << y - 1)
            for x in range(1, n)
            if (m := 2 * n - 5 * x) > 0 and 6 * (n - x) > m and m % 6 == 0
        )


def A068721(n):
    return 3 * n**2 * sum((n * e // p for p, e in factorint(n).items())) if n > 1 else 0


def A258649(n):
    for _ in range(9):
        if n <= 1:
            return 0
        n = sum((n * e // p for p, e in factorint(n).items()))
    return n


def A258650(n):
    for _ in range(10):
        if n <= 1:
            return 0
        n = sum((n * e // p for p, e in factorint(n).items()))
    return n


def A185232(n):
    for _ in range(n):
        if n <= 1:
            return 0
        n = sum((n * e // p for p, e in factorint(n).items()))
    return n


def A024551(n):
    q = prod(plist := tuple(prime(i) for i in range(1, n + 1)))
    return sum(q // p for p in plist)


def A068237(n):
    return -Fraction(
        sum((Fraction(e, p) for p, e in factorint(n).items())), n
    ).numerator


def A068238(n):
    return Fraction(
        sum((Fraction(e, p) for p, e in factorint(n).items())), n
    ).denominator


def A003557(n):
    return n // prod(primefactors(n))


def A342001(n):
    q = prod(f := factorint(n))
    return sum(q * e // p for p, e in f.items())


def A144261(n):
    return next(
        filter(lambda k: not (m := k * n) % sum(int(d) for d in str(m)), count(1))
    )


def A358067(n):
    return next(
        filter(
            lambda m: n
            == next(
                filter(
                    lambda k: not (r := k * m) % sum(int(d) for d in str(r)), count(1)
                )
            ),
            count(1),
        )
    )


def A342991_gen():  # generator of terms
    a = 0
    yield from (1, 1)
    for n in count(2):
        q, r = divmod(n, 3)
        yield from (a,) * (1 if r else q << 1)
        a = 1 - a


def A165560(n):
    return int(n & 3 == 2 or (n & 1 and sum(factorint(n).values()) & 1))


def A086134(n):
    return (
        0
        if n <= 1
        else (
            min(primefactors(m))
            if (m := sum((n * e // p for p, e in factorint(n).items()))) > 1
            else 0
        )
    )


def A327933_gen(startvalue=2):  # generator of terms
    return filter(
        lambda n: (m := sum((n * e // p for p, e in factorint(n).items()))) & 1
        and not m % 3,
        count(max(startvalue, 2)),
    )


def A327935_gen(startvalue=2):  # generator of terms
    return filter(
        lambda n: (m := sum((n * e // p for p, e in factorint(n).items()))) & 1
        and m % 3
        and not m % 5,
        count(max(startvalue, 2)),
    )


def A235992_gen(startvalue=0):  # generator of terms
    return filter(
        lambda n: not n & 3 or (n & 1 and not sum(factorint(n).values()) & 1),
        count(max(startvalue, 0)),
    )


def A235991_gen(startvalue=0):  # generator of terms
    return filter(
        lambda n: n & 3 == 2 or (n & 1 and sum(factorint(n).values()) & 1),
        count(max(startvalue, 0)),
    )


def A100706(n):
    return (10 ** ((n << 1) + 1) - 1) // 9


def A099814(n):
    return (10 ** (n << 1) - 1) // 9


def A358168(n):
    b, bdict, k = 0, {0: (1,)}, 10 ** (n - 1) if n > 1 else 0
    for m in count(2):
        if b >= k:
            return b
        if len(l := bdict[b]) > 1:
            b = m - 1 - l[-2]
            if b in bdict:
                bdict[b] = (bdict[b][-1], m)
            else:
                bdict[b] = (m,)
        else:
            b = 0
            bdict[0] = (bdict[0][-1], m)


def A358180(n):
    b, bdict, k = 0, {0: (1,)}, 10 ** (n - 1) if n > 1 else 0
    for m in count(2):
        if b >= k:
            return m - 1
        if len(l := bdict[b]) > 1:
            b = m - 1 - l[-2]
            if b in bdict:
                bdict[b] = (bdict[b][-1], m)
            else:
                bdict[b] = (m,)
        else:
            b = 0
            bdict[0] = (bdict[0][-1], m)


def A358196_gen(startvalue=0):  # generator of terms
    k = max(startvalue, 0)
    a, b = 5**k, 1 << 3 * k
    while True:
        if str(a)[0] == str(b)[0]:
            yield k
        k += 1
        a *= 5
        b <<= 3


def A358258(n):
    b, bdict, k = 0, {0: (1,)}, 1 << n - 1 if n > 1 else 0
    for m in count(2):
        if b >= k:
            return b
        if len(l := bdict[b]) > 1:
            b = m - 1 - l[-2]
            if b in bdict:
                bdict[b] = (bdict[b][-1], m)
            else:
                bdict[b] = (m,)
        else:
            b = 0
            bdict[0] = (bdict[0][-1], m)


def A358259(n):
    b, bdict, k = 0, {0: (1,)}, 1 << n - 1 if n > 1 else 0
    for m in count(2):
        if b >= k:
            return m - 1
        if len(l := bdict[b]) > 1:
            b = m - 1 - l[-2]
            if b in bdict:
                bdict[b] = (bdict[b][-1], m)
            else:
                bdict[b] = (m,)
        else:
            b = 0
            bdict[0] = (bdict[0][-1], m)


if sys.version_info >= (3, 10):

    def A358268(n):
        return next(
            filter(lambda k: k.bit_count() * n == (k**n).bit_count(), count(1, 2))
        )

else:

    def A358268(n):
        return next(
            filter(lambda k: bin(k).count("1") * n == bin(k**n).count("1"), count(1, 2))
        )


def A000940(n):
    return (
        1
        if n == 3
        else (
            (
                sum(
                    totient(m := n // d) ** 2 * factorial(d) * m**d
                    for d in divisors(n, generator=True)
                )
                + (1 << (k := n >> 1) - 2)
                * n
                * (n << 2 if n & 1 else (n + 6))
                * factorial(k)
            )
            >> 2
        )
        // n
        // n
    )


def A002619(n):
    return (
        sum(
            totient(m := n // d) ** 2 * factorial(d) * m**d
            for d in divisors(n, generator=True)
        )
        // n**2
    )


def A349225_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: not sum(
            totient(m := n // d) ** 2 * factorial(d) * m**d
            for d in divisors(n, generator=True)
        )
        % n**3,
        count(max(startvalue, 1)),
    )


def A094156(n):
    return (
        1
        if n == 1
        else (
            sum(
                totient(m := (r := (n << 1) + 1) // d) ** 2 * factorial(d) * m**d
                for d in divisors((n << 1) + 1, generator=True)
            )
            >> 2
        )
        // r**2
        + (1 << n - 2) * factorial(n)
    )


def A094157(n):
    return (
        2
        if n == 2
        else (
            (
                sum(
                    totient(m := (r := n << 1) // d) ** 2 * factorial(d) * m**d
                    for d in divisors(n << 1, generator=True)
                )
                + (1 << n - 2) * r * (r + 6) * factorial(n)
            )
            >> 2
        )
        // r**2
    )


@lru_cache(maxsize=None)
def A002083(n):
    return 1 if n <= 3 else (A002083(n - 1) << 1) - (A002083(n >> 1) if n & 1 else 0)


def A358012(n):
    return sum(divmod(n, 5))


def A053344(n):
    a, b = divmod(n, 25)
    c, d = divmod(b, 10)
    return a + c + sum(divmod(d, 5))


def A002266(n):
    return n // 5


def A000670(n):
    return sum(factorial(k) * stirling(n, k) for k in range(n + 1))


def A000594(n):
    return n**4 * divisor_sigma(n) - 24 * (
        (m := n + 1 >> 1) ** 2
        * (0 if n & 1 else (m * (35 * m - 52 * n) + 18 * n**2) * divisor_sigma(m) ** 2)
        + sum(
            (i * (i * (i * (70 * i - 140 * n) + 90 * n**2) - 20 * n**3) + n**4)
            * divisor_sigma(i)
            * divisor_sigma(n - i)
            for i in range(1, m)
        )
    )


def A295654_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: n == 1
        or abs(
            -840
            * (
                pow(m := n + 1 >> 1, 2, n)
                * (0 if n & 1 else pow(m * divisor_sigma(m), 2, n))
                + (
                    sum(
                        pow(i, 4, n) * divisor_sigma(i) * divisor_sigma(n - i)
                        for i in range(1, m)
                    )
                    << 1
                )
            )
            % n
        )
        == 1,
        count(max(startvalue, 1)),
    )


def A273650(n):
    return (
        -840
        * (
            pow(m := n + 1 >> 1, 2, n)
            * (0 if n & 1 else pow(m * divisor_sigma(m), 2, n))
            + (
                sum(
                    pow(i, 4, n) * divisor_sigma(i) * divisor_sigma(n - i)
                    for i in range(1, m)
                )
                << 1
            )
        )
        % n
    )


def A063938_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: not -840
        * (
            pow(m := n + 1 >> 1, 2, n)
            * (0 if n & 1 else pow(m * divisor_sigma(m), 2, n))
            + (
                sum(
                    pow(i, 4, n) * divisor_sigma(i) * divisor_sigma(n - i)
                    for i in range(1, m)
                )
                << 1
            )
        )
        % n,
        count(max(startvalue, 1)),
    )


def A296993_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: not -24
        * (
            (m := n + 1 >> 1) ** 2
            * (
                0
                if n & 1
                else (m * (35 * m - 52 * n) + 18 * n**2) * divisor_sigma(m) ** 2
            )
            + sum(
                (i * (i * (i * (70 * i - 140 * n) + 90 * n**2)))
                * divisor_sigma(i)
                * divisor_sigma(n - i)
                for i in range(1, m)
            )
        )
        % n**3,
        count(max(startvalue, 1)),
    )


def A296991_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: not -24
        * (
            (m := n + 1 >> 1) ** 2
            * (0 if n & 1 else m * (35 * m - 52 * n) * divisor_sigma(m) ** 2)
            + sum(
                i**3 * (70 * i - 140 * n) * divisor_sigma(i) * divisor_sigma(n - i)
                for i in range(1, m)
            )
        )
        % n**2,
        count(max(startvalue, 1)),
    )


def A273651(n):
    p = prime(n)
    return (
        -1680
        * sum(
            pow(i, 4, p) * divisor_sigma(i) * divisor_sigma(p - i)
            for i in range(1, p + 1 >> 1)
        )
        % p
    )


def A076847(n):
    return (
        -24
        if n == 1
        else (q := (p := prime(n)) ** 4) * (p + 1)
        - 24
        * (
            sum(
                (i * (i * (i * (70 * i - 140 * p) + 90 * p**2) - 20 * p**3) + q)
                * divisor_sigma(i)
                * divisor_sigma(p - i)
                for i in range(1, p + 1 >> 1)
            )
        )
    )


def A321540(n):
    return int("".join(sorted(str(3**n))))


def A321539(n):
    return int("".join(sorted(str(3**n), reverse=True)))


@lru_cache(maxsize=None)
def A000311(n):
    return (
        n
        if n <= 1
        else -(n - 1) * A000311(n - 1)
        + comb(n, m := n + 1 >> 1) * (0 if n & 1 else A000311(m) ** 2)
        + (sum(comb(n, i) * A000311(i) * A000311(n - i) for i in range(1, m)) << 1)
    )


def A001057(n):
    return (n if n & 1 else -n) + 1 >> 1


def A245852_gen():  # generator of terms
    return filter(lambda n: not "0" in str(n), (1 << 3 * n for n in count(0)))


def A009976(n):
    return 1 << 5 * n


def A133572(n):
    return 1 << (n << 3)


def A218723(n):
    return (1 << (n << 3)) // 255


def A131865(n):
    return (1 << (n + 1 << 2)) // 15


def A000004(n):
    return 0


def A000012(n):
    return 1


def A007395(n):
    return 2


def A010701(n):
    return 3


def A278577_gen():  # generator of terms
    yield 1
    for n in count(2):
        f = primefactors(n)
        if len(f) == 1:
            p, m = f[0], n + 1 >> 1
            yield (q := n**4) * (p * n - 1) // (p - 1) - 24 * (
                (
                    0
                    if n & 1
                    else (m * (35 * m - 52 * n) + 18 * n**2)
                    * (m * divisor_sigma(m)) ** 2
                )
                + sum(
                    (i * (i * (i * (70 * i - 140 * n) + 90 * n**2) - 20 * n**3) + q)
                    * divisor_sigma(i)
                    * divisor_sigma(n - i)
                    for i in range(1, m)
                )
            )


def A106867_gen():  # generator of terms
    return filter(
        lambda p: Poly(symbolx**3 - symbolx - 1, domain=GF(p)).is_irreducible,
        (prime(i) for i in count(1)),
    )


def A358118(n):
    return sum(
        (-1 if j & 1 else 1)
        * comb((n << 1) - j, j)
        * (comb(n - j + 1 << 1, n - j + 1) // (n - j + 2)) ** 2
        for j in range(n + 1)
    )


def A358119(n):
    return sum(
        (-1 if j & 1 else 1)
        * comb((n << 1) - j, j)
        * comb(n - j << 1, n - j)
        * comb(n - j + 2 << 1, n - j + 2)
        // (n - j + 1)
        // (n - j + 3)
        for j in range(n + 1)
    )


def A358270_gen():  # generator of terms
    return filter(
        lambda n: not (len(s := str(n)) & 1 or sum(int(d) for d in s) & 1),
        chain.from_iterable((range(10**l, 10 ** (l + 1)) for l in count(1, 2))),
    )


def A137233(n):
    return 9 * 10 ** (n - 1) + 1 >> 1


def A358109(n):
    return (1 << (n << 2)) * sum(
        binomial(S.Half, k) ** 2 * binomial(n, k) for k in range(n + 1)
    )


def A358108(n):
    return (1 << (n << 2)) * sum(
        binomial(-S.Half, k) ** 2 * binomial(n, k) for k in range(n + 1)
    )


def A004011(n):
    return (
        24
        * prod((p ** (e + 1) - 1) // (p - 1) for p, e in factorint(n).items() if p > 2)
        if n
        else 1
    )


def A001285_gen():  # generator of terms
    yield 1
    blist = [1]
    while True:
        c = [3 - d for d in blist]
        blist += c
        yield from c


def A358367(n):
    return (1 << n * 3) * binomial(3 * S.Half * n, n)


def A051500(n):
    return (3**n + 1) ** 2 >> 2


def A007051(n):
    return 3**n + 1 >> 1


def A036449_gen():  # generator of terms
    yield (a := 0)
    for n in count(1):
        if integer_nthroot(((b := n**2) - a << 3) + 1, 2)[1]:
            yield (a := b)


def A189475_gen():  # generator of terms
    a = 0
    for n in count(1):
        if integer_nthroot(((b := n**2) - a << 3) + 1, 2)[1]:
            yield b - a
            a = b


def A358416_gen():  # generator of terms
    yield (a := 0)
    for n in count(1):
        if integer_nthroot(((b := n**2) - a << 3) + 1, 2)[1]:
            yield n
            a = b


def A358417_gen():  # generator of terms
    a = 0
    for n in count(1):
        c, d = integer_nthroot(((b := n**2) - a << 3) + 1, 2)
        if d:
            yield c - 1 >> 1
            a = b


def A055231(n):
    return prod(p for p, e in factorint(n).items() if e == 1)


def A057521(n):
    return n // prod(p for p, e in factorint(n).items() if e == 1)


def A295294(n):
    return prod((p ** (e + 1) - 1) // (p - 1) for p, e in factorint(n).items() if e > 1)


def A326186(n):
    return n - n // prod(p for p, e in factorint(n).items() if e == 1)


def A349379(n):
    return prod(
        0 if e == 1 else p**e - (1 if e == 2 else p ** (e - 1))
        for p, e in factorint(n).items()
    )


def A001477(n):
    return n


def A057427(n):
    return int(n != 0)


def A038608(n):
    return -n if n & 1 else n


def A001787(n):
    return n << n - 1 if n else 0


def A055112(n):
    return n * (n * ((n << 1) + 3) + 1)


def A038567_gen():  # generator of terms
    yield from chain.from_iterable((n,) * totient(n) for n in count(1))


def A090368(n):
    return min(primefactors((n << 1) - 1), default=1)


def A023965(n):
    return integer_nthroot(n * 10**6, 6)[0] % 10


def A130146_gen():  # generator of terms
    yield from (n for n in count(1) for _ in range(n % 10))


def A001478(n):
    return -n


def A003059(n):
    return isqrt(n - 1) + 1


def A270439(n):
    return (
        (n >> 1) + 1 + (m := isqrt(n + 1)) + int(n - m * (m + 1) >= 0)
        if n & 1
        else -(n >> 1)
    )


def A001489(n):
    return -n


def A018252(n):
    return 1 if n == 1 else composite(n - 1)


def A002426(n):
    return sum(comb(n, k) * comb(k, n - k) for k in range(n + 1))


def A010054(n):
    return int(integer_nthroot((n << 3) + 1, 2)[1])


if sys.version_info >= (3, 10):

    def A038573(n):
        return (1 << n.bit_count()) - 1

    def A159913(n):
        return (1 << n.bit_count() + 1) - 1

    def A151783(n):
        return 1 << (n.bit_count() - 1 << 1)

    def A151780(n):
        return 5 ** (n.bit_count() - 1)

    def A151784(n):
        return 6 ** (n.bit_count() - 1)

    def A255743(n):
        return 1 if n == 1 else 9 * (1 << ((n - 1).bit_count() - 1) * 3)

    def A048881(n):
        return (n + 1).bit_count() - 1

    def A186032(n):
        return 1 if (n + 1).bit_count() & 1 else -1

else:

    def A038573(n):
        return (1 << bin(n).count("1")) - 1

    def A159913(n):
        return (1 << bin(n).count("1") + 1) - 1

    def A151783(n):
        return 1 << (bin(n).count("1") - 1 << 1)

    def A151780(n):
        return 5 ** (bin(n).count("1") - 1)

    def A151784(n):
        return 6 ** (bin(n).count("1") - 1)

    def A255743(n):
        return 1 if n == 1 else 9 * (1 << (bin(n - 1).count("1") - 1) * 3)

    def A048881(n):
        return bin(n + 1).count("1") - 1

    def A186032(n):
        return 1 if bin(n + 1).count("1") & 1 else -1


def A099628_gen():  # generator of terms
    m = 1
    for n in count(1):
        m *= 2
        r, k = m - 1, 1
        for _ in range(n):
            yield r + k
            k *= 2


if sys.version_info >= (3, 10):

    def A046161(n):
        return 1 << (n << 1) - n.bit_count()

else:

    def A046161(n):
        return 1 << (n << 1) - bin(n).count("1")


def A358199(n):
    for m in count(2):
        f = factorint(m).items()
        if all(
            map(
                isprime,
                (
                    prod((p ** ((e + 1) * i) - 1) // (p**i - 1) for p, e in f) - m**i
                    for i in range(1, n + 1)
                ),
            )
        ):
            return m


def A358440(n):
    return max(primefactors((n << 2) + 1))


def A000031(n):
    return (
        sum(totient(d) * (1 << n // d) for d in divisors(n, generator=True)) // n
        if n
        else 1
    )


def A008408(n):
    return (
        65520
        * (
            divisor_sigma(n, 11)
            - (
                n**4 * divisor_sigma(n)
                - 24
                * (
                    (m := n + 1 >> 1) ** 2
                    * (
                        0
                        if n & 1
                        else (m * (35 * m - 52 * n) + 18 * n**2) * divisor_sigma(m) ** 2
                    )
                    + sum(
                        (
                            i * (i * (i * (70 * i - 140 * n) + 90 * n**2) - 20 * n**3)
                            + n**4
                        )
                        * divisor_sigma(i)
                        * divisor_sigma(n - i)
                        for i in range(1, m)
                    )
                )
            )
        )
        // 691
        if n
        else 1
    )


def A013959(n):
    return divisor_sigma(n, 11)


def A007816(n):
    return ((n * (n + 5) + 6) * factorial((n << 2) + 1) >> 1) // factorial(3 * (n + 1))


def A036450(n):
    return divisor_count(divisor_count(divisor_count(n)))


def A269347_gen():  # generator of terms
    A268347_dict = {1: 1}
    yield 1
    for n in count(2):
        yield (s := sum(A268347_dict.get(d, 0) for d in divisors(n, generator=True)))
        A268347_dict[s] = A268347_dict.get(s, 0) + n


def A271503_gen():  # generator of terms
    A271503_dict = {1: 1}
    yield 1
    for n in count(2):
        yield (s := prod(A271503_dict.get(d, 1) for d in divisors(n, generator=True)))
        A271503_dict[s] = A271503_dict.get(s, 1) * n


def A271504_gen():  # generator of terms
    A271504_dict = {1: 1}
    yield 1
    for n in count(2):
        yield (s := lcm(*(A271504_dict.get(d, 1) for d in divisors(n, generator=True))))
        A271504_dict[s] = lcm(A271504_dict.get(s, 1), n)


def A003963(n):
    return prod(primepi(p) ** e for p, e in factorint(n).items())


def A002324(n):
    return prod(
        e + 1 if p % 3 == 1 else int(not e & 1)
        for p, e in factorint(n).items()
        if p != 3
    )


def A004016(n):
    return (
        6
        * prod(
            e + 1 if p % 3 == 1 else int(not e & 1)
            for p, e in factorint(n).items()
            if p != 3
        )
        if n
        else 1
    )


def A358043_gen(startvalue=1):  # generator of terms
    return filter(lambda n: not totient(n) & 7, count(max(startvalue, 1)))


def A122803(n):
    return -(1 << n) if n & 1 else 1 << n


def A053985(n):
    return -(b := int("10" * (n.bit_length() + 1 >> 1), 2)) + (n ^ b) if n else 0


def A356568(n):
    return ((1 << (m := n << 1)) - 1) * n**m


def A085534(n):
    return (m := n << 1) ** m


def A062206(n):
    return n ** (n << 1)


def A234472_gen(startvalue=0):  # generator of terms
    return filter(
        lambda n: integer_nthroot(int(str(n**4)[::-1]), 2)[1], count(max(startvalue, 0))
    )


def A102859_gen(startvalue=0):  # generator of terms
    return filter(
        lambda n: integer_nthroot(int(str(n**2)[::-1]), 2)[1], count(max(startvalue, 0))
    )


def A061457_gen():  # generator of terms
    return filter(
        lambda n: integer_nthroot(int(str(n)[::-1]), 2)[1], (n**2 for n in count(0))
    )


def A358351(n):
    c = set()
    for l in range(1, len(str(n)) + 1):
        l1, l2 = 10**l, 10 ** (l - 1)
        for d in combinations_with_replacement(tuple(range(10)), l):
            s, p = sum(d), prod(d)
            if l1 > (m := n - s - p) >= l2 and sorted(int(d) for d in str(m)) == list(
                d
            ):
                c.add(m)
    return len(c)


def A358509(n):
    return sum(map(int, str(3**n - 1 >> 1)))


def A227362(n):
    return int("".join(sorted(set(str(n)), reverse=True)))


def A230959(n):
    return int("".join(sorted(set("9876543210") - set(str(n)), reverse=True)) or 0)


def A358317_gen(startvalue=0):  # generator of terms
    for n in count(max(startvalue, 0)):
        if n == 0:
            yield 0
        else:
            for d in divisors(n, generator=True):
                a, b = integer_nthroot(d, 2)
                if b:
                    c, e = integer_nthroot(n // d - 1, 2)
                    if e and not (c ^ a) & 1:
                        yield n
                        break


def A358620(n):
    return 9 if n == 1 else 9 * (9 * n + 1) * 10 ** (n - 2)


def A358647(n):
    s = list(map(int, str(n)))
    l, i = len(s), 0
    for _ in range(l):
        i = (i + s[i]) % l
    return s[i]


def A357531(n):
    return m if (m := pow(2, n, n)) else n


def A082495(n):
    return (m if (m := pow(2, n, n)) else n) - 1


def A048298(n):
    return n if n and not (n & -n) ^ n else 0


def A283477(n):
    return prod(primorial(i) for i, b in enumerate(bin(n)[:1:-1], 1) if b == "1")


def A283980(n):
    return prod(nextprime(p) ** e if p > 2 else 6**e for p, e in factorint(n).items())


def A270142(n):
    return prod(composite(i) ** int(d) for i, d in enumerate(str(n), 1))


def A358985(n):
    if n == 1:
        return 10
    kset = set()
    for i in range(10 ** (n - 2), 10 ** (n - 1)):
        for j in range(int((s := str(i))[0]) + 1):
            kset.add(10 * i + j + int(str(j) + s[::-1]))
    return len(kset)


def A358986(n):
    kset = set()
    for i in range(1, 10 ** (n - 1)):
        for j in range(int((s := str(i))[0]) + 1):
            kset.add(10 * i + j + int(str(j) + s[::-1]))
    return 10 + len(kset)


def A358878_gen(startvalue=1):
    f = factorial(n := max(startvalue, 1))
    for m in count(n):
        if isprime((3 * f >> 1) - 1):
            yield m
        f *= m + 1


def A358970_gen(startvalue=0):  # generator of terms
    return filter(
        lambda n: not any(n % i for i, b in enumerate(bin(n)[:1:-1], 1) if b == "1"),
        count(max(startvalue, 0)),
    )


def A320673_gen(startvalue=0):  # generator of terms
    return filter(
        lambda n: not any(int(b) == bool(n % i) for i, b in enumerate(bin(n)[2:], 1)),
        count(max(startvalue, 0)),
    )


def A271410(n):
    return lcm(*(i for i, b in enumerate(bin(n)[:1:-1], 1) if b == "1"))


def A058891(n):
    return 1 << (1 << n - 1) - 1


def A348332(n):
    return ((1 << n) - 1) << (1 << n) - n


def A248034_gen():  # generator of terms
    c, clist = 0, [1] + [0] * 9
    while True:
        yield c
        c = clist[c % 10]
        for d in str(c):
            clist[int(d)] += 1


def A321348(n):
    return prod((e + 1) * (n * e + 2) >> 1 for e in factorint(n).values())


def A359038(n):
    return prod((e + 1) * (7 * e + 2) >> 1 for e in factorint(n).values())


def A356574(n):
    return prod((e + 1) * ((e << 1) + 1) for e in factorint(n).values())


def A249009_gen():  # generator of terms
    c, clist = 0, [1] + [0] * 9
    while True:
        yield c
        c = clist[int(str(c)[0])]
        for d in str(c):
            clist[int(d)] += 1


def A359044_gen():  # generator of terms
    for i in count(2):
        if not ((p := prime(i)) - 1) % (i - 1):
            yield p


def A105286_gen(startvalue=1):  # generator of terms
    return filter(lambda k: not (prime(k + 1) - 1) % k, count(max(startvalue, 1)))


def A358178_gen():  # generator of terms
    m, f, g = 1, [], set()
    for n in count(1):
        m *= n
        g.update(set(gcd(d, m + 1) for d in f))
        f.append(m + 1)
        yield len(g)


def A359050(n):
    f, g, k = 0, 1, 0
    while f + g - n:
        k += 1
        m, a = k + 1, [1, 0]
        while m:
            a[m & 1] = sum(a)
            m >>= 1
        f, g = g, a[1]
    return k


def A358700(n):
    return (n**2).bit_length()


def A359080_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: n | reduce(ior, divisors(n, generator=True)) == n,
        count(max(startvalue, 1)),
    )


def A102553_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: n == 1 or n | reduce(ior, primefactors(n)) == n,
        count(max(startvalue, 1)),
    )


def A102554_gen(startvalue=2):  # generator of terms
    return filter(
        lambda n: n | reduce(ior, primefactors(n)) != n, count(max(startvalue, 2))
    )


def A355670_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: n | reduce(ior, divisors(n, generator=True)) > n,
        count(max(startvalue, 1)),
    )


def A055642(n):
    return len(str(n))


def A359173_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: any(
            d * int(str(d)[::-1]) == n**2
            for d in divisors(n**2, generator=True)
            if d != n
        ),
        count(max(startvalue, 1)),
    )


def A002819(n):
    return sum(
        -1 if reduce(ixor, factorint(i).values(), 0) & 1 else 1 for i in range(1, n + 1)
    )


def A346202(n):
    return (
        sum(
            -1 if reduce(ixor, factorint(i).values(), 0) & 1 else 1
            for i in range(1, n + 1)
        )
        ** 2
    )


def A072203(n):
    return 1 + sum(
        1 if reduce(ixor, factorint(i).values(), 0) & 1 else -1 for i in range(1, n + 1)
    )


def A061019(n):
    return -n if reduce(ixor, factorint(n).values(), 0) & 1 else n


def A035327(n):
    return (~n) ^ (-1 << n.bit_length()) if n else 1


def A348074(n):
    return 3 * n + 1 if n & 1 or n == 0 else (~n) ^ (-1 << n.bit_length())


def A029931(n):
    return sum(i if j == "1" else 0 for i, j in enumerate(bin(n)[:1:-1], 1))


def A359154(n):
    return -1 if reduce(ixor, starmap(and_, factorint(n).items()), 0) & 1 else 1


def A356163(n):
    return (reduce(ixor, starmap(and_, factorint(n).items()), 0) & 1) ^ 1


def A353557(n):
    return 1 & n & (reduce(ixor, factorint(n).values(), 0) ^ 1)


def A359155(n):
    return (
        0
        if max((f := factorint(n)).values(), default=0) > 1
        else -1 if reduce(ixor, (p & 1 ^ 1 for p in f.keys()), 0) else 1
    )


def A255047(n):
    return -1 ^ (-1 << n) if n else 1


def A000051(n):
    return (1 << n) | 1 if n else 2


def A140407(n):
    return 2 if n == 1 else (1 << (n >> 1)) | 1 if n & 1 else -1 ^ (-2 << (n >> 1))


def A359166(n):
    return (-1 if reduce(ixor, (f := factorint(n)).values(), 0) & 1 else 1) * (
        -1
        if reduce(
            ixor,
            sum(
                (
                    Counter(factorint((p ** (e + 1) - 1) // (p - 1)))
                    for p, e in f.items()
                ),
                Counter(),
            ).values(),
            0,
        )
        & 1
        else 1
    )


def A358766(n):
    return (
        -1
        if reduce(
            ixor,
            sum(
                (
                    Counter(factorint((p ** (e + 1) - 1) // (p - 1)))
                    for p, e in factorint(n).items()
                ),
                Counter(),
            ).values(),
            0,
        )
        & 1
        else 1
    )


def A343785(n):
    return (
        -1
        if reduce(
            ixor, (e & 1 if p % 3 == 2 else 0 for p, e in factorint(n).items()), 0
        )
        else 1
    )


def A062756(n):
    return sympydigits(n, 3)[1:].count(1)


def A268643(n):
    return str(n).count("1")


def A343430(n):
    return prod(p**e for p, e in factorint(n).items() if p % 3 == 2)


def A329484(n):
    return prod(-e - 1 if e & 1 else e + 1 for e in factorint(n).values())


def A329445(n):
    return prod(-comb(p, e) if e & 1 else comb(p, e) for p, e in factorint(n).items())


def A322328(n):
    return prod(e << 2 for e in factorint(n).values())


def A226602(n):
    return prod(3 * e for e in factorint(n).values()) if n else 1


def A322327(n):
    return prod(e << 1 for e in factorint(n).values())


def A247503(n):
    return prod(p**e for p, e in factorint(n).items() if primepi(p) & 1)


def A248909(n):
    return prod(p**e for p, e in factorint(n).items() if not (p - 1) % 6)


def A343431(n):
    return prod(p**e for p, e in factorint(n).items() if not (p + 1) % 6)


def A309873(n):
    return -1 if (~n & n - 1).bit_length() & 1 else 1


def A325709(n):
    return prod(prime(factorial(primepi(p))) ** e for p, e in factorint(n).items())


def A166590(n):
    return prod((p + 2) ** e for p, e in factorint(n).items())


def A322361(n):
    return gcd(n, prod(nextprime(p) ** e for p, e in factorint(n).items()))


def A123066(n):
    return 1 + sum(1 if primenu(i) & 1 else -1 for i in range(1, n + 1))


def A162511(n):
    return -1 if reduce(lambda a, b: ~(a ^ b), factorint(n).values(), 0) & 1 else 1


def A327666(n):
    return sum(
        -1 if reduce(lambda a, b: ~(a ^ b), factorint(i).values(), 0) & 1 else 1
        for i in range(1, n + 1)
    )


def A065043(n):
    return (reduce(ixor, factorint(n).values(), 0) & 1) ^ 1


def A055037(n):
    return sum(
        1 for i in range(1, n + 1) if not (reduce(ixor, factorint(i).values(), 0) & 1)
    )


def A066829(n):
    return reduce(ixor, factorint(n).values(), 0) & 1


def A055038(n):
    return sum(1 for i in range(1, n + 1) if reduce(ixor, factorint(i).values(), 0) & 1)


def A002053(n):
    return next(
        filter(
            lambda m: -n
            == sum(
                -1 if reduce(ixor, factorint(i).values(), 0) & 1 else 1
                for i in range(1, m + 1)
            ),
            count(1),
        )
    )


def A056239(n):
    return sum(primepi(p) * e for p, e in factorint(n).items())


def A359362(n):
    return (sum((f := factorint(n)).values()) + 1) * sum(
        primepi(p) * e for p, e in f.items()
    )


def A239122(n):
    return sum(
        -i if reduce(ixor, factorint(i).values(), 0) & 1 else i for i in range(1, n + 1)
    )


def A212496(n):
    return sum(
        -1 if reduce(ixor, factorint(i).values(), i) & 1 else 1 for i in range(1, n + 1)
    )


def A166486(n):
    return (0, 1, 1, 1)[n & 3]


@lru_cache(maxsize=None)
def A127699(n):
    return 1 if n == 1 else lcm(n, A127699(reduced_totient(n)))


def A359098_gen():  # generator of terms
    for a in count(3):
        a10 = 10**a
        for ad in range(1, 10):
            for b in range(2, a):
                b10 = 10**b
                for bd in range(1, 10):
                    for c in range(1, b):
                        c10 = 10**c
                        for cd in range(1, 10):
                            for dd in range(1, 10):
                                yield ad * a10 + bd * b10 + cd * c10 + dd


def A358934(n):
    return sum(f := fib2(n)) ** 5 - f[1] ** 5


def A110299(n):
    c = 0
    for i in range(n):
        c = (c << 1) + prime(i + 1)
    return c


def A358737_gen():  # generator of terms
    for a in count(3):
        a10 = 10**a
        for ad in range(1, 10):
            for b in range(2, a):
                b10 = 10**b
                for bd in range(1, 10):
                    for c in range(1, b):
                        c10 = 10**c
                        yield from (
                            max(primefactors(ad * a10 + bd * b10 + cd * c10 + dd))
                            for cd in range(1, 10)
                            for dd in range(1, 10)
                        )


def A359473(n):
    return int(all(map(lambda m: not ((k := m + 1) & -k) ^ k, factorint(n).values())))


def A036537_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: all(
            map(lambda m: not ((k := m + 1) & -k) ^ k, factorint(n).values())
        ),
        count(max(startvalue, 1)),
    )


def A162643_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: any(map(lambda m: ((k := m + 1) & -k) ^ k, factorint(n).values())),
        count(max(startvalue, 1)),
    )


def A072587_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: not all(map(lambda m: m & 1, factorint(n).values())),
        count(max(startvalue, 1)),
    )


def A295316(n):
    return int(all(map(lambda m: m & 1, factorint(n).values())))


if sys.version_info >= (3, 10):

    def A359464(n):
        return reduce(ixor, (d.bit_count() for d in factorint(n).values()), 1) & 1

else:

    def A359464(n):
        return reduce(ixor, (bin(d).count("1") for d in factorint(n).values()), 1) & 1


def A175496_gen(startvalue=2):  # generator of terms
    return filter(
        lambda n: max(f := factorint(n).values()) > 1
        and all(map(lambda m: not ((k := m + 1) & -k) ^ k, f)),
        count(max(startvalue, 2)),
    )


def A353457(n):
    return prod(-int(e == 1) for p, e in factorint(n).items() if primepi(p) & 1)


def A353458(n):
    return prod(-int(e == 1) for p, e in factorint(n).items() if not primepi(p) & 1)


def A353459(n):
    f = [(primepi(p) & 1, -int(e == 1)) for p, e in factorint(n).items()]
    return prod(e for p, e in f if not p) + prod(e for p, e in f if p)


def A100716_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: any(map(lambda d: d[1] >= d[0], factorint(n).items())),
        count(max(startvalue, 1)),
    )


def A048103_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: all(map(lambda d: d[1] < d[0], factorint(n).items())),
        count(max(startvalue, 1)),
    )


def A358548_gen():  # generator of terms
    p, q = 2, 5
    while True:
        while not isprime(q):
            q += 3
        yield q - p
        p = q
        q += 3


def A358565_gen():  # generator of terms
    p, q = 5, 11
    while True:
        while not isprime(q):
            q += 3
        yield (q - p) // 6
        p = q
        q += 3


def A359469(n):
    f = [(primepi(p) & 1, int(e == 1)) for p, e in factorint(n).items()]
    return reduce(iand, (e for p, e in f if not p), 1) ^ reduce(
        iand, (e for p, e in f if p), 1
    )


def A359550(n):
    return int(all(map(lambda d: d[0] > d[1], factorint(n).items())))


def A359552(n):
    return int(any(map(lambda d: d[1] % d[0], factorint(n).items()))) ^ 1


def A359551(n):
    return prod(
        1 if (d := e % p) == 0 else (-1 if d == 1 else 0)
        for p, e in factorint(n).items()
    )


def A359402_gen(startvalue=0):  # generator of terms
    return filter(
        lambda n: (
            r := reduce(
                lambda c, d: (c[0] + d[0] * (e := int(d[1])), c[1] + e),
                enumerate(bin(n)[2:], start=1),
                (0, 0),
            )
        )[0]
        << 1
        == (n.bit_length() + 1) * r[1],
        count(max(startvalue, 0)),
    )


def A053866(n):
    return int(is_square(n) or is_square(n << 1))


def A028982_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: int(is_square(n) or is_square(n << 1)), count(max(startvalue, 1))
    )


def A359495(n):
    k = n.bit_length() - 1
    return sum((i << 1) - k for i, j in enumerate(bin(n)[2:]) if j == "1")


def A230877(n):
    return sum(i for i, j in enumerate(bin(n)[2:], 1) if j == "1")


def A230204(n):
    return sum(i for i, j in enumerate(bin(n)[2:]) if j == "1")


def A035263(n):
    return (n & -n).bit_length() & 1


def A039963(n):
    return ((m := (n >> 1) + 1) & -m).bit_length() & 1


def A081706_gen():  # generator of terms
    for n in count(0):
        if (n & -n).bit_length() & 1:
            m = n << 2
            yield m - 2
            yield m - 1


def A359592(n):
    return (mobius(n) & 1) ^ (0 if n & 1 else mobius(n >> 1) & 1)


def A096268(n):
    return (~(n + 1) & n).bit_length() & 1


def A056832(n):
    return 1 + ((~n & n - 1).bit_length() & 1)


def A197911(n):
    return n + sum((~(i + 1) & i).bit_length() & 1 for i in range(n))


def A214682(n):
    return n >> 1 if (~n & n - 1).bit_length() & 1 else n


def A096271(n):
    return (~(n + 1) & n).bit_length() % 3


def A359593(n):
    return prod(p**e for p, e in factorint(n).items() if e % p)


def A359594(n):
    return prod(p**e for p, e in factorint(n).items() if not e % p)


def A359591(n):
    return (
        mobius(n)
        if n & 1
        else (
            0
            if (m := n >> 1) & 1
            else prod(-int(e == 1) for e in factorint(m).values())
        )
    )


def A356809_gen():  # generator of terms
    a, b = 1, 2
    while True:
        if any(p & 3 == 3 and e & 1 for p, e in factorint(a).items()):
            yield a
        a, b = b, a + b


def A152822(n):
    return (1, 1, 0, 1)[n & 3]


def A186646(n):
    return n if n & 3 else n >> 1


def A283971(n):
    return n if (n - 2) & 3 else n >> 1


def A141726(n):
    return (0, 8, 7, 6, 5, 4, 3, 2, 1)[n % 9]


def A003266_gen():  # generator of terms
    a, b, c = 1, 1, 1
    while True:
        yield c
        c *= a
        a, b = b, a + b


def A012245(n):
    c = 1
    for i in count(1):
        if (c := c * i) >= n:
            return int(c == n)


def A359456(n):
    a, b, c = 1, 2, 1
    while (c := c * a) < n:
        a, b = b, a + b
    return int(c == n)


def A316341(n):
    c, i = 1, 1
    while (c := c * i) < n:
        i += 1
    return int(c == n)


def A143963(n):
    c, i, s = 1, 1, 0
    while (c := c * i) <= n:
        s += comb(n, c)
        i += 1
    return s


def A359549(n):
    return int(
        (m := (~n & n - 1).bit_length()) < 2
        and all(e == 2 for e in factorint(n >> m).values())
    )


def A359580_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: (m := (~n & n - 1).bit_length()) <= 1
        and all(e == 2 for e in factorint(n >> m).values()),
        count(max(startvalue, 1)),
    )


def A359684(n):
    return 1 if n == 1 else max(primefactors((1 << n) - n))


def A359685(n):
    return max(primefactors((1 << n) + n))


def A006127(n):
    return (1 << n) + n


def A000325(n):
    return (1 << n) - n


def A359600(n):
    return prod(
        prime(i) ** e
        for i, e in enumerate(sorted(factorint(n).values(), reverse=True), 2)
    )


def A359421(n):
    return prod(npartitions(d) for d in factorint(prime(n) ** 2 - 1).values())


def A089640(n):
    return sum(binomial(k, n - 1 - (3 * k >> 1)) for k in range(n + 1))


def A036347_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: (reduce(ixor, (p * e for p, e in factorint(n).items()), 0) ^ n) & 1,
        count(max(startvalue, 1)),
    )


def A359768(n):
    return (reduce(ixor, (p * e for p, e in factorint(n).items()), 0) ^ n) & 1


def A359844(n):
    return ((n << 1) + 1) ** 8 + 1 >> 1


def A359498(n):
    return ((n << 1) + 1) ** 8 - 1 >> 5


def A359499(n):
    return ((n << 1) + 1) ** 16 - 1 >> 6


def A359500(n):
    return 7 ** (1 << n) - 1 >> n + 3


def A358272(n):
    return prod(
        -(p ** (e & -2)) if e & 1 else p ** (e & -2) for p, e in factorint(n).items()
    )


def A010684(n):
    return 3 if n & 1 else 1


def A112033(n):
    return 3 * (1 << (n >> 1) + (int(not n & 1) << 1))


def A166681_gen():  # generator of terms
    p = 13
    while True:
        for q in multiset_permutations(str(p)):
            if (r := int("".join(q))) > p and isprime(r):
                yield p
                break
        p = nextprime(p)


def A048675(n):
    return sum(e << primepi(p) - 1 for p, e in factorint(n).items())


def A359830_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: sum(e << primepi(p) - 1 for p, e in factorint(n).items()) % 3,
        count(max(startvalue, 1)),
    )


def A320770(n):
    return -(1 << (n >> 1)) if n & 4 else 1 << (n >> 1)


def A014848(n):
    return n**2 - (n >> 1)


def A173511(n):
    return (n**2 << 2) + (n >> 1)


def A289296(n):
    return (n - 1) * (n | 1)


def A090932(n):
    return factorial(n) >> (n >> 1)


def A110138(n):
    return ((m := n >> 1) + (n & 1)) ** m


def A099202(n):
    return 1 << (n**2 >> 1)


def A272299(n):
    return n + (n & -2) + 3 * (n // 3)


def A110139(n):
    return (m := n >> 1) ** m


def A244586(n):
    return n | 4


def A244584(n):
    return n | 3


def A244587(n):
    return n | 5


def A143621(n):
    return -1 if n & 4 else 1


def A140730(n):
    return ((n & 3) + 1) * 5 ** (n >> 2)


def A133874(n):
    return 1 + (n >> 2) & 3


def A130909(n):
    return n & 15


def A080412(n):
    return (0, 1, -1, 0)[n & 3] + n


def A038714(n):
    return (m := n >> 2) * (m + 1)


def A053836(n):
    return sum(int(d, 16) for d in hex(n)[2:])


def A008838(n):
    return (m := n >> 3) * (m + bool(n & 7))


def A115273(n):
    return prod(divmod(n, 3))


def A257848(n):
    return (n >> 3) * (n & 7)


def A142150(n):
    return (n + 1 >> 1) * (n & 1 ^ 1)


def A257849(n):
    return prod(divmod(n, 9))


def A004457(n):
    return n ^ 16


def A100281(n):
    return n ^ (m := n >> 2) ^ (m >> 2)


if sys.version_info >= (3, 10):

    def A359496_gen(startvalue=0):  # generator of terms
        return filter(
            lambda n: sum(i for i, j in enumerate(bin(n)[2:]) if j == "1") << 1
            < n.bit_count() * (n.bit_length() - 1),
            count(max(startvalue, 0)),
        )

    def A088149(n):
        if n == 1:
            return 2
        for p in count((1 << n) - 1, 2):
            if p.bit_count() >= n and isprime(p):
                m = p.bit_length()
                l = 1 << m - 1
                k, cset, q = l - 1, {p}, p
                for _ in range(m - 1):
                    p = bool(p & l) + ((p & k) << 1)
                    if p not in cset and isprime(p):
                        cset.add(p)
                if len(cset) == n:
                    return q

    def A088148(n):
        if n == 1:
            return 2
        for p in count((1 << n) - 1):
            if p.bit_count() >= n:
                m = p.bit_length()
                l = 1 << m - 1
                k, cset, q = l - 1, set(), p
                for _ in range(m):
                    if p not in cset and isprime(p):
                        cset.add(p)
                    p = bool(p & l) + ((p & k) << 1)
                if len(cset) == n:
                    return q

else:

    def A359496_gen(startvalue=0):  # generator of terms
        return filter(
            lambda n: sum(i for i, j in enumerate(bin(n)[2:]) if j == "1") << 1
            < bin(n).count("1") * (n.bit_length() - 1),
            count(max(startvalue, 0)),
        )

    def A088149(n):
        if n == 1:
            return 2
        for p in count((1 << n) - 1, 2):
            if bin(p).count("1") >= n and isprime(p):
                m = p.bit_length()
                l = 1 << m - 1
                k, cset, q = l - 1, {p}, p
                for _ in range(m - 1):
                    p = bool(p & l) + ((p & k) << 1)
                    if p not in cset and isprime(p):
                        cset.add(p)
                if len(cset) == n:
                    return q

    def A088148(n):
        if n == 1:
            return 2
        for p in count((1 << n) - 1):
            if bin(p).count("1") >= n:
                m = p.bit_length()
                l = 1 << m - 1
                k, cset, q = l - 1, set(), p
                for _ in range(m):
                    if p not in cset and isprime(p):
                        cset.add(p)
                    p = bool(p & l) + ((p & k) << 1)
                if len(cset) == n:
                    return q


def A161602_gen(startvalue=1):  # generator of terms
    return filter(lambda n: n > int(bin(n)[-1:1:-1], 2), count(max(startvalue, 1)))


def A161603_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: n > int(bin(n)[-1:1:-1], 2), count(max(startvalue | 1, 1), 2)
    )


def A161601_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: n < int(bin(n)[-1:1:-1], 2), count(max(startvalue | 1, 1), 2)
    )


def A359840_gen():  # generator of terms
    return map(
        int,
        filter(
            lambda s: isprime(int(s, 5)), (gmpy2digits(prime(i), 4) for i in count(1))
        ),
    )


def A059995(n):
    return n // 10


def A359841(n):
    return (
        (
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            22,
            24,
            26,
            28,
            30,
            33,
            36,
            39,
            40,
            44,
            48,
            50,
            55,
            60,
            66,
            70,
            77,
            80,
            88,
            90,
            99,
        )[n - 1]
        if n <= 32
        else (n - 23) * 10
    )


def A077947(n):
    return (k := (m := 1 << n + 2) // 7) + int((m - 7 * k << 1) >= 7)


def A080413(n):
    return ((n & 3) << 1) + bool(n & 4) + (n & -8)


def A080414(n):
    return ((n & 6) >> 1) + ((n & 1) << 2) + (n & -8)


def A080542(n):
    return (1 + (n & 1)) * (1 << n.bit_length() - 2) + (n >> 1) if n > 1 else n


def A080541(n):
    return (
        ((n & (m := 1 << n.bit_length() - 2) - 1) << 1) + (m << 1) + bool(m & n)
        if n > 1
        else n
    )


def A059893(n):
    return int("1" + bin(n)[:2:-1], 2)


def A168427(n):
    return (21, 3, 9, 27)[n & 3] if n else 1


def A336953(n):
    if n == 0:
        return 0
    l, m = -(n % n.bit_length()), bin(n)[2:]
    return int(m[l:] + m[:l], 2)


def A038572(n):
    return (n >> 1) + (1 << n.bit_length() - 1 if n & 1 else 0)


def A006257(n):
    return bool(n & (m := 1 << n.bit_length() - 1)) + ((n & m - 1) << 1) if n else 0


def A062050(n):
    return n - (1 << n.bit_length() - 1) + 1


def A053645(n):
    return n & (1 << n.bit_length() - 1) - 1


def A359329(n):
    return (n * (n - 4) + n * (n & 1)) >> 1


def A000165(n):
    return factorial(n) << n


def A283027(n):
    return n**4 * (n**4 * (n**8 + 1) + 2) >> 2


def A283031(n):
    return n**7 * (n**6 * (n**12 + 1) + 2) >> 2


def A359832(n):
    return (n & 1) | ((~n & n - 1).bit_length() & 1)


def A328981(n):
    return ((n & 1) | ((~n & n - 1).bit_length() & 1)) ^ 1


def A359559(n):
    return (
        Matrix(
            n,
            n,
            [
                i - j + (1 if i > j else -1) if i != j else I
                for i in range(n)
                for j in range(n)
            ],
        ).det()
        * (1, -I, -1, I)[n & 3]
    )


def A359560(n):
    return (
        Matrix(
            n,
            n,
            [
                i - j + (1 if i > j else -1) if i != j else I
                for i in range(n)
                for j in range(n)
            ],
        ).per()
        * (1, -I, -1, I)[n & 3]
        if n
        else 1
    )


def A359561(n):
    return (
        Matrix(
            n,
            n,
            [
                (n + j - i if i > j else j - i - n) if i != j else n * I
                for i in range(n)
                for j in range(n)
            ],
        ).det()
        * (1, -I, -1, I)[n & 3]
    )


def A359562(n):
    return (
        Matrix(
            n,
            n,
            [
                (n + j - i if i > j else j - i - n) if i != j else n * I
                for i in range(n)
                for j in range(n)
            ],
        ).per()
        * (1, -I, -1, I)[n & 3]
        if n
        else 1
    )


def A359614(n):
    return min(
        Matrix(
            n,
            n,
            [
                (d[i - j] if i > j else -d[j - i]) if i != j else d[0] * I
                for i in range(n)
                for j in range(n)
            ],
        ).det()
        * (1, -I, -1, I)[n & 3]
        for d in permutations(range(1, n + 1))
    )


def A359615(n):
    return max(
        Matrix(
            n,
            n,
            [
                (d[i - j] if i > j else -d[j - i]) if i != j else d[0] * I
                for i in range(n)
                for j in range(n)
            ],
        ).det()
        * (1, -I, -1, I)[n & 3]
        for d in permutations(range(1, n + 1))
    )


def A359616(n):
    return (
        min(
            Matrix(
                n,
                n,
                [
                    (d[i - j] if i > j else -d[j - i]) if i != j else d[0] * I
                    for i in range(n)
                    for j in range(n)
                ],
            ).per()
            * (1, -I, -1, I)[n & 3]
            for d in permutations(range(1, n + 1))
        )
        if n
        else 1
    )


def A359617(n):
    return (
        max(
            Matrix(
                n,
                n,
                [
                    (d[i - j] if i > j else -d[j - i]) if i != j else d[0] * I
                    for i in range(n)
                    for j in range(n)
                ],
            ).per()
            * (1, -I, -1, I)[n & 3]
            for d in permutations(range(1, n + 1))
        )
        if n
        else 1
    )


def A293296(n):
    return (n**2 << 1) - (n >> 2)


def A007877(n):
    return (0, 1, 2, 1)[n & 3]


def A193682(n):
    return (0, 1, 2, 3, 0, 3, 2, 1)[n & 7]


def A190785(n):
    a, b = divmod(n - 1, 7)
    return (0, 2, 3, 5, 7, 9, 11)[b] + 12 * a


def A004525(n):
    return ((n >> 1) & -2) + bool(n & 3)


def A004524(n):
    return -(bool((m := n + 1) & 3) ^ 1) + ((m >> 1) & -2)


def A004655(n):
    return 10 ** (n >> 2) << (n & 3)


def A047573(n):
    a, b = divmod(n - 1, 7)
    return (0, 1, 2, 4, 5, 6, 7)[b] + (a << 3)


def A257844(n):
    return (n >> 2) * (n & 3)


def A238170(n):
    return isqrt(n**9)


def A360080(n):
    if n <= 1:
        return 1
    m = 1 << (1 << n) - 1
    i = m
    while i := nextprime(i):
        if isprime((k := i << 1) + 1):
            return k - (m << 1) + 1


def A360081(n):
    m = 1 << 3 * (1 << n) - 1
    i = m
    while i := nextprime(i):
        if isprime((k := i << 1) + 1):
            return k - (m << 1) + 1


def A360067(n):
    return Matrix(
        n, n, [i**j * (i - j) for i in range(1, n + 1) for j in range(1, n + 1)]
    ).det()


def A002450(n):
    return ((1 << (n << 1)) - 1) // 3


def A048647(n):
    return n ^ ((n & ((1 << (m := n.bit_length()) + (m & 1)) - 1) // 3) << 1)


def A271324(n):
    return n + (n >> 2) + (n & 3)


def A063224(n):
    return n - 1 + sum(divmod(n - 1, 3))


def A273308(n):
    return n + sum(divmod(n, 3)) if n > 1 else 0


def A063200(n):
    return n - 1 + sum(divmod(n - 1, 3)) if n > 1 else 1


def A265888(n):
    return n + (-(n >> 2) if n & 1 else n >> 2)


def A063695(n):
    return n & ((1 << (m := n.bit_length()) + (m & 1 ^ 1)) - 1) // 3


def A090569(n):
    return (n - 1 & ((1 << (m := (n - 1).bit_length()) + (m & 1 ^ 1)) - 1) // 3) + 1


def A063694(n):
    return n & ((1 << (m := n.bit_length()) + (m & 1)) - 1) // 3


def A088442(n):
    return ((n & ((1 << (m := n.bit_length()) + (m & 1)) - 1) // 3) << 1) + 1


def A004514(n):
    return (n & ((1 << (m := n.bit_length()) + (m & 1)) - 1) // 3) << 1


def A200675(n):
    return 1 << (n >> 2)


def A055264(n):
    return (0, 1, 3, 6)[n & 3] + 9 * (n >> 2)


def A174438(n):
    return (0, 2, 5, 8)[n & 3] + 9 * (n >> 2)


def A122461(n):
    return n >> 1 & -2


def A122587(n):
    return int(bin(n)[2 : 3 + (n.bit_length() & 1 ^ 1)], 2)


def A214864(n):
    return (10, 11, 14, 15)[n - 1 & 3] + ((n - 1 & -4) << 2)


def A131478(n):
    return n**4 + 3 >> 2


def A030301(n):
    return n.bit_length() & 1 ^ 1


def A030300(n):
    return n.bit_length() & 1


def A000975(n):
    return ((1 << n + 1) - 1 - (n & 1 ^ 1)) // 3


def A079954(n):
    return ((1 << k) - 2) // 3 if (k := n.bit_length()) & 1 else n - ((1 << k) - 1) // 3


def A079947(n):
    return n - ((1 << k) - 2) // 3 if (k := n.bit_length()) & 1 else ((1 << k) - 1) // 3


def A206925(n):
    s = bin(n)[2:]
    k = len(s)
    return sum(
        1
        for i in range(k)
        for j in range(i + 1, k + 1)
        if s[i:j] == s[j - 1 : i - 1 - k : -1]
    )


def A187323(n):
    return 3 * (n >> 2) + bool(n & 2) + n // 3


def A187321(n):
    return 3 * (n >> 2) + bool(n & 2)


def A187324(n):
    return (n >> 2) + bool(n & 2) + n // 3


def A187322(n):
    return (n >> 1) + (3 * n >> 2)


def A186421(n):
    return (n >> 1) | 1 if n & 1 else n


def A087960(n):
    return -1 if n + 1 & 2 else 1


def A186423(n):
    return (
        6 * n * (n + 1)
        + 3
        + (-2 * n - 1 if n & 1 else 2 * n + 1)
        + (4 if n + 1 & 2 else -4)
    ) >> 4


def A186424(n):
    return (n * (3 * n + 2) + 1 if n & 1 else n * (3 * n + 4) + 2) >> 1


def A062717(n):
    return (n * (3 * n + 4) + 1 if n & 1 else n * (3 * n + 2)) >> 1


def A001318(n):
    return (n * (3 * n + 4) + 1 if n & 1 else n * (3 * n + 2)) >> 3


def A177332(n):
    return (n * (n * (2 * n + 3) + 1) + 84) // 174


def A129756(n):
    return (n >> 1) | 1


def A131078(n):
    return int(not n - 1 & 4)


def A131479(n):
    return n**4 >> 2


def A133872(n):
    return int(not n & 2)


def A112030(n):
    return (3, 1, -3, -1)[n & 3]


def A099254(n):
    a, b = divmod(n, 3)
    return (1 + (b & 1)) * (-a - 1 if a & 1 else a + 1)


def A008217(n):
    return (n >> 2) * (n + 1 >> 2)


def A038715(n):
    return (n >> 2) * (1 + (n + 1 >> 2))


def A051036(n):
    return comb(n, n >> 2)


def A037827(n):
    s = "0" * (n.bit_length() & 1) + bin(n)[2:]
    return sum(1 for i in range(0, len(s) - 2, 2) if s[i : i + 2] >= s[i + 2 : i + 4])


def A173562(n):
    return n**2 + (n >> 2)


def A173707(n):
    return n * (n * (n * (n + 2) + 1) - 4) // 12


def A160529(n):
    return 25 * (n >> 2) + (0, 1, 5, 6)[n & 3]


def A360297(n):
    p = prime(n)
    q = nextprime(p)
    s, k = p + q, 1
    while s % (q := nextprime(q)):
        k += 1
        s += q
    return k


def A360311(n):
    p = prime(n)
    q = nextprime(p)
    s, k = p + q, 1
    while s % (q := nextprime(q)):
        k += 1
        s += q
    return s


def A360312(n):
    p = prime(n)
    q = nextprime(p)
    s, k = p + q, 1
    while s % (q := nextprime(q)):
        k += 1
        s += q
    return q


def A295643(n):
    return (n >> 2) ** 2


def A360376(n):
    p = prime(n)
    s, k = p, 0
    while (s + 1) % (p := nextprime(p)):
        k += 1
        s *= p
    return k


def A360406(n):
    p = prime(n)
    q = nextprime(p)
    s, k = p * q, 1
    while (s - 1) % (q := nextprime(q)):
        k += 1
        s *= q
    return k


def A038040(n):
    return divisor_count(n) * n


def A360388_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        b = tuple(int(d) for d in bin(n)[2:])
        m = len(b)
        if all(reduce(ixor, (b[i] & b[i + k] for i in range(m - k))) for k in range(m)):
            yield n


def A053006_gen(startvalue=1):  # generator of terms
    return filter(lambda n: n_order(2, (n << 1) - 1) & 1, count(max(startvalue, 1)))


def A036259_gen(startvalue=1):  # generator of terms
    return filter(lambda n: n_order(2, n) & 1, count(max(startvalue, 1) | 1, 2))


def A067695(n):
    if n == 1:
        return 1
    f, g = map(tuple, zip(*sorted(factorint(n).items())))
    return f[g.index(min(g))]


def A359612(n):
    return (f := list(map(tuple, zip(*sorted(factorint(n).items(), reverse=True)))))[0][
        f[1].index(min(f[1]))
    ]


def A360053_gen():  # generator of terms
    for i in count(1):
        p = prime(i)
        if all((pow(2, p - 1, prime(j) ** 2) - 1 for j in range(1, i))):
            yield p


def A359178_gen(startvalue=2):  # generator of terms
    return filter(
        lambda n: (f := list(factorint(n).values())).count(min(f)) == 1,
        count(max(startvalue, 2)),
    )


def A348699_gen():  # generator of terms
    return filter(
        lambda p: isprime(sum(1 for d in str(p) if d in {"2", "3", "5", "7"})),
        (prime(i) for i in count(1)),
    )


def A092619_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: isprime(sum(1 for d in str(n) if d in {"2", "3", "5", "7"})),
        count(max(startvalue, 1)),
    )


def A085557_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: len(s := str(n))
        < (sum(1 for d in s if d in {"2", "3", "5", "7"}) << 1),
        count(max(startvalue, 1)),
    )


def A046034_gen():  # generator of terms
    yield from (int("".join(d)) for l in count(1) for d in product("2357", repeat=l))


def A084544(n):
    m = (3 * n + 1).bit_length() - 1 >> 1
    return int(
        "".join(
            (
                str(
                    ((3 * n + 1 - (1 << (m << 1))) // (3 << ((m - 1 - j) << 1)) & 3) + 1
                )
                for j in range(m)
            )
        )
    )


def A046034(n):
    m = (3 * n + 1).bit_length() - 1 >> 1
    return int(
        "".join(
            (
                "2357"[(3 * n + 1 - (1 << (m << 1))) // (3 << ((m - 1 - j) << 1)) & 3]
                for j in range(m)
            )
        )
    )


def A084544_gen():  # generator of terms
    yield from (int("".join(d)) for l in count(1) for d in product("1234", repeat=l))


def A045926(n):
    m = (3 * n + 1).bit_length() - 1 >> 1
    return (
        int(
            "".join(
                (
                    str(
                        ((3 * n + 1 - (1 << (m << 1))) // (3 << ((m - 1 - j) << 1)) & 3)
                        + 1
                    )
                    for j in range(m)
                )
            )
        )
        << 1
    )


def A045926_gen():  # generator of terms
    yield from (
        int("".join(d)) << 1 for l in count(1) for d in product("1234", repeat=l)
    )


def A358348(n):
    return (n - (m := n % 9) << 1) + (0, 1, 4, 7, 9, 10, 13, 16, 17)[m]


def A189510(n):
    return (9, 1, 4, 9, 4, 2, 9, 7, 1, 9, 1, 5, 9, 4, 7, 9, 7, 8)[n % 18] if n else 1


def A145389(n):
    return (9, 1, 3, 6, 1, 6, 3, 1, 9)[n % 9] if n else 0


def A061579(n):
    return (r := isqrt((n << 3) + 1) - 1 >> 1) * (r + 2) - n


def A137688(n):
    return 1 << (isqrt((n << 3) + 1) - 1 >> 1)


def A181133(n):
    return n + (isqrt((n << 3) + 1) - 1 >> 1)


def A022846(n):
    return isqrt(n**2 << 3) + 1 >> 1


def A023532(n):
    return bool(is_square((n << 3) + 9)) ^ 1


def A089633_gen():  # generator of terms
    return ((1 << t) - (1 << k) - 1 for t in count(1) for k in range(t - 1, -1, -1))


def A101688(n):
    return isqrt((m := n << 1) + 1) - (isqrt((m << 2) + 8) + 1 >> 1) + 1


if sys.version_info >= (3, 10):

    def A014081(n):
        return (n & (n >> 1)).bit_count()

    def A245195(n):
        return 1 << (n & (n >> 1)).bit_count()

    def A020985(n):
        return -1 if (n & (n >> 1)).bit_count() & 1 else 1

    def A020986(n):
        return sum(-1 if (m & (m >> 1)).bit_count() & 1 else 1 for m in range(n + 1))

    def A020987(n):
        return (n & (n >> 1)).bit_count() & 1

    def A022155_gen(startvalue=0):  # generator of terms
        return filter(
            lambda n: (n & (n >> 1)).bit_count() & 1, count(max(startvalue, 0))
        )

    def A203463_gen(startvalue=0):  # generator of terms
        return filter(
            lambda n: (n & (n >> 1)).bit_count() & 1 ^ 1, count(max(startvalue, 0))
        )

    def A203531_gen():  # generator of terms
        c, a = 0, 1
        for n in count(0):
            if (n & (n >> 1)).bit_count() & 1 ^ a:
                c += 1
            else:
                yield c
                c = 1
                a ^= 1

    def A020990(n):
        return sum(
            -1 if ((m & (m >> 1)).bit_count() ^ m) & 1 else 1 for m in range(n + 1)
        )

    def A213786(n):
        return sum(
            (-1 if (i & (i >> 1)).bit_count() & 1 else 1)
            * sum(
                -1 if (j & (j >> 1)).bit_count() & 1 else 1 for j in range(i + 1, n + 1)
            )
            for i in range(1, n + 1)
        )

    def A213626(n):
        return sum(
            (-1 if (i & (i >> 1)).bit_count() & 1 else 1)
            * sum(
                (-1 if (j & (j >> 1)).bit_count() & 1 else 1)
                * sum(
                    -1 if (k & (k >> 1)).bit_count() & 1 else 1
                    for k in range(j + 1, n + 1)
                )
                for j in range(i + 1, n + 1)
            )
            for i in range(n + 1)
        )

    def A359045(n):
        return sum(
            (-1 if (i & (i >> 1)).bit_count() & 1 else 1)
            * sum(
                (-1 if (j & (j >> 1)).bit_count() & 1 else 1)
                * sum(
                    -1 if (k & (k >> 1)).bit_count() & 1 else 1
                    for k in range(j + 1, n + 1)
                )
                for j in range(i + 1, n + 1)
            )
            for i in range(1, n + 1)
        )

    def A239904(n):
        return n - n.bit_count() + (n & (n >> 1)).bit_count()

else:

    def A014081(n):
        return bin(n & (n >> 1)).count("1")

    def A245195(n):
        return 1 << bin(n & (n >> 1)).count("1")

    def A020985(n):
        return -1 if bin(n & (n >> 1)).count("1") & 1 else 1

    def A020986(n):
        return sum(-1 if bin(m & (m >> 1)).count("1") & 1 else 1 for m in range(n + 1))

    def A020987(n):
        return bin(n & (n >> 1)).count("1") & 1

    def A022155_gen(startvalue=0):  # generator of terms
        return filter(
            lambda n: bin(n & (n >> 1)).count("1") & 1, count(max(startvalue, 0))
        )

    def A203463_gen(startvalue=0):  # generator of terms
        return filter(
            lambda n: bin(n & (n >> 1)).count("1") & 1 ^ 1, count(max(startvalue, 0))
        )

    def A203531_gen():  # generator of terms
        c, a = 0, 1
        for n in count(0):
            if bin(n & (n >> 1)).count("1") & 1 ^ a:
                c += 1
            else:
                yield c
                c = 1
                a ^= 1

    def A020990(n):
        return sum(
            -1 if (bin(m & (m >> 1)).count("1") ^ m) & 1 else 1 for m in range(n + 1)
        )

    def A213786(n):
        return sum(
            (-1 if bin(i & (i >> 1)).count("1") & 1 else 1)
            * sum(
                -1 if bin(j & (j >> 1)).count("1") & 1 else 1
                for j in range(i + 1, n + 1)
            )
            for i in range(1, n + 1)
        )

    def A213626(n):
        return sum(
            (-1 if bin(i & (i >> 1)).count("1") & 1 else 1)
            * sum(
                (-1 if bin(j & (j >> 1)).count("1") & 1 else 1)
                * sum(
                    -1 if bin(k & (k >> 1)).count("1") & 1 else 1
                    for k in range(j + 1, n + 1)
                )
                for j in range(i + 1, n + 1)
            )
            for i in range(n + 1)
        )

    def A359045(n):
        return sum(
            (-1 if bin(i & (i >> 1)).count("1") & 1 else 1)
            * sum(
                (-1 if bin(j & (j >> 1)).count("1") & 1 else 1)
                * sum(
                    -1 if bin(k & (k >> 1)).count("1") & 1 else 1
                    for k in range(j + 1, n + 1)
                )
                for j in range(i + 1, n + 1)
            )
            for i in range(1, n + 1)
        )

    def A239904(n):
        return n - bin(n).count("1") + bin(n & (n >> 1)).count("1")


def A014493(n):
    return ((n << 1) - 1) * (n - (n & 1 ^ 1))


def A352116(n):
    return n * ((n - 1) << 1) * (n + 1) // 3 + n * (n & 1)


def A000447(n):
    return n * ((n**2 << 2) - 1) // 3


def A002206(n):
    return (
        sum(
            Fraction(stirling(n + 1, k, kind=1, signed=True), k + 1)
            for k in range(n + 2)
        )
        / factorial(n + 1)
    ).numerator


def A002207(n):
    return (
        sum(
            Fraction(stirling(n + 1, k, kind=1, signed=True), k + 1)
            for k in range(n + 2)
        )
        / factorial(n + 1)
    ).denominator


def A322756(n):
    return (
        n - Fraction(1, 2) + Fraction(1 << (m := n << 1) - 1, comb(m, n))
    ).denominator


def A322755(n):
    return (n - Fraction(1, 2) + Fraction(1 << (m := n << 1) - 1, comb(m, n))).numerator


def A056966(n):
    s = bin(n)[2:]
    s = "0" * (len(s) & 1) + s
    return int("0" + "".join(s[i + 1] * int(s[i]) for i in range(0, len(s), 2)), 2)


def A056967(n):
    s = str(n)
    s = "0" * (len(s) & 1) + s
    return int("0" + "".join(s[i + 1] * int(s[i]) for i in range(0, len(s), 2)))


def A047842(n):
    s = str(n)
    return int("".join(str(s.count(d)) + d for d in sorted(set(s))))


def A235775(n):
    s = str(n)
    s = "".join(str(s.count(d)) + d for d in sorted(set(s)))
    return int("".join(str(s.count(d)) + d for d in sorted(set(s))))


def A029783_gen(startvalue=0):  # generator of terms
    return filter(lambda n: not set(str(n)) & set(str(n**2)), count(max(startvalue, 0)))


def A189056_gen(startvalue=0):  # generator of terms
    return filter(lambda n: set(str(n)) & set(str(n**2)), count(max(startvalue, 0)))


def A001122_gen():  # generator of terms
    p = 2
    while p := nextprime(p):
        if is_primitive_root(2, p):
            yield p


def A001123_gen():  # generator of terms
    p = 3
    while p := nextprime(p):
        if not is_primitive_root(2, p) and is_primitive_root(3, p):
            yield p


def A001124_gen():  # generator of terms
    p = 5
    while p := nextprime(p):
        if primitive_root(p) == 5:
            yield p


def A319248_gen():  # generator of terms
    p = 2
    while p := nextprime(p):
        if isprime(p + 2) and is_primitive_root(2, p) and is_primitive_root(2, p + 2):
            yield p


def A319249_gen():  # generator of terms
    p = 2
    while p := nextprime(p):
        if isprime(p + 2) and is_primitive_root(2, p) and is_primitive_root(2, p + 2):
            yield p + 2


def A359452(n):
    return (
        (10**n << n - 1) + (-(1 << (n << 1) - 1) if n & 1 else 1 << (n << 1) - 1)
        if n
        else 1
    )


def A359453(n):
    return (
        (10**n << n - 1) + (1 << (n << 1) - 1 if n & 1 else -(1 << (n << 1) - 1))
        if n
        else 0
    )


def A083207_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        d = divisors(n)
        s = sum(d)
        if s & 1 ^ 1 and n << 1 <= s:
            d = d[:-1]
            s2, ld = (s >> 1) - n, len(d)
            z = [[0 for _ in range(s2 + 1)] for _ in range(ld + 1)]
            for i in range(1, ld + 1):
                y = min(d[i - 1], s2 + 1)
                z[i][:y] = z[i - 1][:y]
                for j in range(y, s2 + 1):
                    z[i][j] = max(z[i - 1][j], z[i - 1][j - y] + y)
                if z[i][s2] == s2:
                    yield n
                    break


def A083210_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        d = divisors(n)
        s = sum(d)
        if s & 1 ^ 1 and n << 1 <= s:
            d = d[:-1]
            s2, ld = (s >> 1) - n, len(d)
            z = [[0 for _ in range(s2 + 1)] for _ in range(ld + 1)]
            for i in range(1, ld + 1):
                y = min(d[i - 1], s2 + 1)
                z[i][:y] = z[i - 1][:y]
                for j in range(y, s2 + 1):
                    z[i][j] = max(z[i - 1][j], z[i - 1][j - y] + y)
                if z[i][s2] == s2:
                    break
            else:
                yield n
        else:
            yield n


def A328327_gen(startvalue=1):  # generator of terms
    m = -1
    for n in count(max(startvalue, 1)):
        d = divisors(n)
        s = sum(d)
        if s & 1 ^ 1 and n << 1 <= s:
            d = d[:-1]
            s2, ld = (s >> 1) - n, len(d)
            z = [[0 for _ in range(s2 + 1)] for _ in range(ld + 1)]
            for i in range(1, ld + 1):
                y = min(d[i - 1], s2 + 1)
                z[i][:y] = z[i - 1][:y]
                for j in range(y, s2 + 1):
                    z[i][j] = max(z[i - 1][j], z[i - 1][j - y] + y)
                if z[i][s2] == s2:
                    if m == n - 1:
                        yield m
                    m = n
                    break


def A345704_gen(startvalue=1):  # generator of terms
    m = -20
    for n in count(max(startvalue, 1)):
        d = divisors(n)
        s = sum(d)
        if s & 1 ^ 1 and n << 1 <= s:
            d = d[:-1]
            s2, ld = (s >> 1) - n, len(d)
            z = [[0 for _ in range(s2 + 1)] for _ in range(ld + 1)]
            for i in range(1, ld + 1):
                y = min(d[i - 1], s2 + 1)
                z[i][:y] = z[i - 1][:y]
                for j in range(y, s2 + 1):
                    z[i][j] = max(z[i - 1][j], z[i - 1][j - y] + y)
                if z[i][s2] == s2:
                    if m == n - 12:
                        yield m
                    m = n
                    break


def A007283(n):
    return 3 << n


def A001710(n):
    return factorial(n) >> 1 if n > 1 else 1


def A001813(n):
    return factorial(n << 1) // factorial(n)


def A001599_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        f = factorint(n)
        s = prod((p ** (e + 1) - 1) // (p - 1) for p, e in f.items())
        if not reduce(lambda x, y: x * y % s, (e + 1 for e in f.values()), 1) * n % s:
            yield n


def A325022_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        f = factorint(n)
        s = prod((p ** (e + 1) - 1) // (p - 1) for p, e in f.items())
        if (
            n * n % s
            and not reduce(lambda x, y: x * y % s, (e + 1 for e in f.values()), 1)
            * n
            % s
        ):
            yield n


def A325021_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        f = factorint(n)
        s = prod((p ** (e + 1) - 1) // (p - 1) for p, e in f.items())
        if not (
            n * n % s
            or reduce(lambda x, y: x * y % s, (e + 1 for e in f.values()), 1) * n % s
        ):
            yield n


def A325020_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        f = factorint(n)
        s = prod((p ** (e + 1) - 1) // (p - 1) for p, e in f.items())
        if (
            not (n - reduce(lambda x, y: x * y % s, (e + 1 for e in f.values()), 1))
            * n
            % s
        ):
            yield n


def A359147(n):
    return sum(n_order(2, m) for m in range(1, n + 1 << 1, 2))


def A339979_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        f = primefactors(n)
        d = [x for x in divisors(n) if primefactors(x) == f]
        s = sum(d)
        if s & 1 ^ 1 and n << 1 <= s:
            d = d[:-1]
            s2, ld = (s >> 1) - n, len(d)
            z = [[0 for _ in range(s2 + 1)] for _ in range(ld + 1)]
            for i in range(1, ld + 1):
                y = min(d[i - 1], s2 + 1)
                z[i][:y] = z[i - 1][:y]
                for j in range(y, s2 + 1):
                    z[i][j] = max(z[i - 1][j], z[i - 1][j - y] + y)
                if z[i][s2] == s2:
                    yield n
                    break


def A360283(n):
    return factorial(n) * lcm(*(i for i in range(1, n + 2))) // (n + 1)


def A071176(n):
    m = 10 * n
    if is_square(m):
        return 0
    a = 1
    while (k := (isqrt(a * (m + 1) - 1) + 1) ** 2 - m * a) >= 10 * a:
        a *= 10
    return k


def A071177(n):
    m = 10 * n
    if (k := isqrt(m)) ** 2 != m:
        a = 1
        while (k := isqrt(a * (m + 1) - 1) + 1) ** 2 - m * a >= 10 * a:
            a *= 10
    return k


def A359800(n):
    m = 10 * n * n
    if is_square(m):
        return 0
    a = 1
    while (k := (isqrt(a * (m + 1) - 1) + 1) ** 2 - m * a) >= 10 * a:
        a *= 10
    return k


def A245631(n):
    m = 10 * n
    if integer_nthroot(m, 3)[1]:
        return 0
    a = 1
    while (k := (integer_nthroot(a * (m + 1) - 1, 3)[0] + 1) ** 3 - m * a) >= 10 * a:
        a *= 10
    return k


def A246561(n):
    return (
        0
        if len(l := nthroot_mod(n, 3, (m := 10 ** (len(str(n)))))) == 0
        else int((min(x for x in l + [d + m for d in l] if x ** 3 >= m) ** 3 - n) // m)
    )


def A246449_gen(startvalue=0):  # generator of terms
    return filter(
        lambda n: not len(nthroot_mod(n, 3, 10 ** (len(str(n))))),
        count(max(startvalue, 0)),
    )


def A246422_gen(startvalue=0):  # generator of terms
    return filter(
        lambda n: len(nthroot_mod(n, 3, 10 ** (len(str(n))))), count(max(startvalue, 0))
    )


def A360573_gen():  # generator of terms
    yield from (
        int("1" + "".join(d) + "1", 2)
        for l in count(0)
        for d in multiset_permutations("000" + "1" * l)
    )


def A360574_gen():  # generator of terms
    yield from (
        int("1" + "".join(d) + "1")
        for l in count(0)
        for d in multiset_permutations("000" + "1" * l)
    )


def A357774_gen():  # generator of terms
    for l in count(2):
        m = (10 ** (l + 2) - 1) // 9
        for i in range(l, 0, -1):
            k = m - 10**i
            yield from (k - 10**j for j in range(i - 1, 0, -1))


def A360760(n):
    return n**2 * (n**13 * (n + 1) + 1) + 1


@lru_cache(maxsize=None)
def A006894(n):
    return ((m := A006894(n - 1)) * (m + 1) >> 1) + 1 if n else 0


def A001463(n):
    return sum(A001462(m) for m in range(1, n + 1))


def A061433(n):
    return isqrt(10**n - 1) ** 2


def A061432(n):
    return (isqrt(10 ** (n - 1) - 1) + 1) ** 2


def A309828_gen():  # generator of terms
    return filter(is_square, (int(str(k) + str((k << 1) + 1)) for k in count(1)))


def A265181_gen():  # generator of terms
    return filter(isprime, (int(str(k**3) * 2) * 10 + 1 for k in count(1)))


def A243092(n):
    m, a = 10 * n, 10 ** (len(str(n)) - 1)
    while (
        k := (integer_nthroot(a * (m + 1) - 1, 3)[0] + 1) ** 3 - m * a
    ) >= 10 * a or k <= n:
        a *= 10
    return k


def A360570_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        if integer_nthroot(m := 10 * n, 3)[1]:
            yield n
        else:
            a = 1
            while (
                k := (integer_nthroot(a * (m + 1) - 1, 3)[0] + 1) ** 3 - m * a
            ) >= 10 * a:
                a *= 10
                if a > n:
                    break
            else:
                if k <= n:
                    yield n


if sys.version_info >= (3, 10):

    def A060764(n):
        e = map(lambda x: x[1] - x[0], pairwise(d := divisors(n)))
        return len(set(d) - set(e))

else:

    def A060764(n):
        d = divisors(n)
        e = [d[i] - d[i - 1] for i in range(1, len(d))]
        return len(set(d) - set(e))


def A011755(n):
    return sum(k * totient(k) for k in range(1, n + 1))


def A135342_gen():  # generator of terms
    a, b = 3, 5
    yield from (1, 3, 5)
    for n in count(3):
        a, b = b, (b << 1) - a + totient(n)
        yield b


def A000016(n):
    return (
        sum(
            totient(d) << n // d - 1
            for d in divisors(n >> (~n & n - 1).bit_length(), generator=True)
        )
        // n
        if n
        else 1
    )


def A063776(n):
    return (
        sum(
            totient(d) << n // d - 1
            for d in divisors(n >> (~n & n - 1).bit_length(), generator=True)
        )
        << 1
    ) // n


def A053636(n):
    return (
        sum(
            totient(d) << n // d - 1
            for d in divisors(n >> (~n & n - 1).bit_length(), generator=True)
        )
        << 1
    )


def A327477(n):
    return (
        (1 << n - 1)
        - sum(
            totient(d) << n // d - 1
            for d in divisors(n >> (~n & n - 1).bit_length(), generator=True)
        )
        // n
        if n
        else 0
    )


def A026119(n):
    m = (n << 1) + 1
    return sum(totient(d) << m // d - 1 for d in divisors(m, generator=True)) // m


def A000013(n):
    return sum(totient(d << 1) << n // d - 1 for d in divisors(n)) // n if n else 1


def A051293(n):
    return (
        sum(
            (
                sum(
                    totient(d) << k // d - 1
                    for d in divisors(k >> (~k & k - 1).bit_length(), generator=True)
                )
                << 1
            )
            // k
            for k in range(1, n + 1)
        )
        - n
    )


def A327475(n):
    return (
        sum(
            (
                sum(
                    totient(d) << k // d - 1
                    for d in divisors(k >> (~k & k - 1).bit_length(), generator=True)
                )
                << 1
            )
            // k
            for k in range(1, n + 1)
        )
        - n
        + 1
    )


def A082550(n):
    return (
        sum(
            totient(d) << n // d - 1
            for d in divisors(n >> (~n & n - 1).bit_length(), generator=True)
        )
        << 1
    ) // n - 1


def A000695_gen():  # generator of terms
    yield (a := 0)
    for n in count(1):
        yield (a := a + ((1 << ((~n & n - 1).bit_length() << 1) + 1) + 1) // 3)


def A327474_gen():  # generator of terms
    a, b = 4, 6
    yield from (1, 2, 4, 6)
    for n in count(3):
        a, b = b, (b << 1) - a + totient(n)
        yield b


def A065795(n):
    return (
        sum(
            (
                sum(
                    totient(d) << k // d - 1
                    for d in divisors(k >> (~k & k - 1).bit_length(), generator=True)
                )
                << 1
            )
            // k
            for k in range(1, n + 1)
        )
        >> 1
    )


def A327471(n):
    return (1 << n) - (
        sum(
            (
                sum(
                    totient(d) << k // d - 1
                    for d in divisors(k >> (~k & k - 1).bit_length(), generator=True)
                )
                << 1
            )
            // k
            for k in range(1, n + 1)
        )
        >> 1
    )


def A213636(n):
    return next(filter(None, (n % d for d in range(2, n)))) if n > 2 else n


def A213635(n):
    return n - next(filter(None, (n % d for d in range(2, n)))) if n > 2 else 0


def A007978(n):
    return next(filter(lambda d: n % d, range(2, n))) if n > 2 else n + 1


def A266620(n):
    return 4 if n == 3 else nextprime(n)


def A133907(n):
    p, m = 2, (n + 2) * (n + 1) >> 1
    while m % p != 1:
        q = nextprime(p)
        m = m * ff(n + q, q - p) // ff(q, q - p)
        p = q
    return p


def A133635_gen(startvalue=1):  # generator of terms
    return filter(
        lambda k: comb(k + 5, k) % k == 1 and not isprime(k), count(max(startvalue, 1))
    )


def A026430_gen():  # generator of terms
    yield from (0, 1)
    blist, s = [1], 1
    while True:
        c = [3 - d for d in blist]
        blist += c
        yield from (s + d for d in accumulate(c))
        s += sum(c)


def A360392_gen():  # generator of terms
    yield 3
    blist, s = [1], 3
    while True:
        c = [3 - d for d in blist]
        blist += c
        yield from (s + d for d in accumulate(c))
        s += sum(c)


def A360393_gen():  # generator of terms
    yield from (1, 2)
    blist, s = [1], 3
    while True:
        c = [3 - d for d in blist]
        blist += c
        for d in c:
            yield from range(s + 1, s := s + d)


def A165451_gen():  # generator of terms
    for l in count(0):
        for i in range(1, 10):
            fi = factorial(i)
            yield from sorted(
                int(str(i) + "".join(map(str, k)))
                for j in combinations_with_replacement(range(10), l)
                for k in multiset_permutations(j)
                if isprime(fi + sum(map(factorial, j)))
            )


def A173688_gen():  # generator of terms
    for l in count(0):
        for i in range(1, 10):
            fi = factorial(i) ** 2
            yield from sorted(
                int(str(i) + "".join(map(str, k)))
                for j in combinations_with_replacement(range(10), l)
                for k in multiset_permutations(j)
                if isprime(fi + sum(map(lambda n: factorial(n) ** 2, j)))
            )


def A173687_gen():  # generator of terms
    yield 0
    for l in count(0):
        for i in range(1, 10):
            fi = factorial(i)
            yield from sorted(
                int(str(i) + "".join(map(str, k)))
                for j in combinations_with_replacement(range(10), l)
                for k in multiset_permutations(j)
                if is_square(fi + sum(map(factorial, j)))
            )


def A173689_gen():  # generator of terms
    yield 0
    for l in count(0):
        for i in range(1, 10):
            fi = factorial(i) ** 2
            yield from sorted(
                int(str(i) + "".join(map(str, k)))
                for j in combinations_with_replacement(range(10), l)
                for k in multiset_permutations(j)
                if is_square(fi + sum(map(lambda n: factorial(n) ** 2, j)))
            )


def A356847_gen():  # generator of terms
    p, plist = 5, [4]
    yield p
    while True:
        p = nextprime(p)
        while not all(map(lambda d: isprime(p + d), plist)):
            p = nextprime(p)
        yield p
        plist.append(p - 1)


def A070677(n):
    return n_order(5, n) if n % 5 and n > 1 else 0


def A360761_gen():  # generator of terms
    p = 5
    while True:
        try:
            discrete_log(p := nextprime(p), 2, pow(3, n_order(5, p), p))
        except:
            continue
        yield p


def A360825(n):
    if n == 3:
        return 2
    m = nextprime(n)
    return (m - 1) * pow(reduce(lambda i, j: i * j % m, range(n + 1, m), 1), -1, m) % m


def A275111(n):
    return (
        ((q := prime(n + 1)) - 1)
        * pow(reduce(lambda i, j: i * j % q, range(prime(n) + 1, q), 1), -1, q)
        % q
    )


def A360423_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        m = 10 ** len(str(n))
        m2 = 10 * m
        for k in count((m - 1) // n + 1):
            if (r := k * n) >= m2:
                break
            s = str(r)
            if s[0] == min(d for d in s if d != "0"):
                if any(int(s[i:] + s[:i]) % n for i in range(1, len(s))):
                    break
        if r >= m2:
            yield n


def A360805_gen(startvalue=0):  # generator of terms
    n = max(startvalue, 0)
    m = nextprime(n)
    while True:
        a = m - 1
        klist = []
        for i in range(m - 1, n, -1):
            a = a * pow(i, -1, m) % m
            if a > i - 1:
                klist.append(i - 1)
        yield from sorted(klist)
        n, m = m, nextprime(m)


def A360511(n):
    return primorial(n) - prime(n + 1) ** 3


def A360510(n):
    return (primorial(n) >> 1) - prime(n + 1) ** 2


def A064819(n):
    return primorial(n) - prime(n + 1) ** 2


def A060882(n):
    return primorial(n) - prime(n + 1) if n else -1


def A057588(n):
    return primorial(n) - 1


def A359530(n):
    return prod((p + 4) ** e for p, e in factorint(n).items())


def A300570(n):
    return int(bin(reduce(lambda i, j: (i << j.bit_length()) + j, range(n, 0, -1)))[2:])


def A300571(n):
    return (
        int(bin(reduce(lambda i, j: (i << j.bit_length()) + j, range(n, 0, -1), 0))[2:])
        * 10
    )


def A058935(n):
    return int(bin(reduce(lambda i, j: (i << j.bit_length()) + j, range(n + 1)))[2:])


def A047778(n):
    return reduce(lambda i, j: (i << j.bit_length()) + j, range(n + 1))


def A048440(n):
    return reduce(
        lambda i, j: (i << 3 * (1 + (j.bit_length() - 1) // 3)) + j, range(n + 1)
    )


def A098780(n):
    return reduce(lambda i, j: (i << j.bit_length()) + j, range(n, 0, -1))


def A048447(n):
    return reduce(
        lambda i, j: (i << (bool((m := j.bit_length()) & 3) << 2) + (m & -4)) + j,
        range(n + 1),
    )


def A048436(n):
    return reduce(
        lambda i, j: (i << (bool((m := j.bit_length()) & 1) << 1) + (m & -2)) + j,
        range(n + 1),
    )


def A007908(n):
    return reduce(lambda i, j: i * 10 ** len(str(j)) + j, range(1, n + 1))


def A071620_gen():  # generator of terms
    c, l = 0, 0
    for n in count(1):
        for d in str(n):
            c = 10 * c + int(d)
            l += 1
            if isprime(c):
                yield l


def A357041(n):
    return sum(comb(d + n // d - 1, d) << d - 1 for d in divisors(n, generator=True))


def A241102_gen():  # generator of terms
    p, q = 3**3, 5
    while True:
        if isprime((m := q**3) - p >> 1):
            yield m - p
        p, q = m, nextprime(q)


def A360490_gen():  # generator of terms
    p, q = 3**3, 5
    while True:
        if isprime(k := (m := q**3) - p >> 1):
            yield k
        p, q = m, nextprime(q)


def A243761_gen():  # generator of terms
    p, q = 2, 3
    while True:
        if isprime(r := p * (p + q) + q**2):
            yield r
        p, q = q, nextprime(q)


def A237627_gen():  # generator of terms
    p = 1
    while p := nextprime(p):
        if isprime((p - 1) ** 2 + 1):
            yield p * ((p - 1) ** 2 + 1)


def A270249_gen():  # generator of terms
    p, q = 2, 3
    while True:
        if q - p == 2 and isprime(s := 3 * p * q + 4) and isprime(s - 2):
            yield s
        p, q = q, nextprime(q)


def A360567_gen():  # generator of terms
    p = 1
    while p := nextprime(p):
        if isprime((m := isqrt(p)) + int(p - m * (m + 1) >= 1)):
            yield p


def A023963(n):
    return integer_nthroot(n * 10**4, 4)[0] % 10


def A023967(n):
    return integer_nthroot(n * 10**8, 8)[0] % 10


def A361012(n):
    return prod(divisor_sigma(e) for e in factorint(n).values())


def A360859_T(n, k):
    return (
        comb(n, m := k >> 1) ** 2 * (n - m) // (m + 1)
        if k & 1
        else comb(n, k >> 1) ** 2
    )


def A360858_T(n, k):
    return comb(n, m := k >> 1) ** 2 * (n + 1) // (m + 1 if k & 1 else n + 1 - m)


def A360857_T(n, k):
    return (
        comb(n + 1, m := k >> 1) ** 2 * (n + 1 - m) * (n - m) // ((m + 1) * (n + 1))
        if k & 1
        else comb(n + 1, m := k >> 1) ** 2 * (n + 1 - m) // (n + 1)
    )


def A360365(n):
    return sum(prod(int(d) for d in str(m)) for m in range(3, 3 * n + 1, 3))


def A360861(n):
    return sum(
        comb(n, m := k >> 1) ** 2 * (n - m) // (m + 1) for k in range(1, n + 1, 2)
    ) + sum(comb(n, k >> 1) ** 2 for k in range(0, n + 1, 2))


def A360944_gen(startvalue=1):  # generator of terms
    return filter(lambda n: is_square((totient(n) << 3) + 1), count(max(1, startvalue)))


def A236386_gen(startvalue=1):  # generator of terms
    return filter(lambda n: is_square((totient(n) << 2) + 1), count(max(1, startvalue)))


def A078164_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: integer_nthroot(totient(n), 4)[1], count(max(1, startvalue))
    )


if sys.version_info >= (3, 10):

    def A360980(n):
        k = n
        while k.bit_count() & 1 ^ 1:
            k += n
        return k

else:

    def A360980(n):
        k = n
        while bin(k).count("1") & 1 ^ 1:
            k += n
        return k


if sys.version_info >= (3, 10):

    def A360981(n):
        k = n
        while k.bit_count() & 1:
            k += n
        return k

else:

    def A360981(n):
        k = n
        while bin(k).count("1") & 1:
            k += n
        return k


def A020330(n):
    return (n << n.bit_length()) | n


def A360793_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: len(f := sorted(factorint(n).values(), reverse=True)) > 1
        and f[0] == 3
        and f[1] == 1,
        count(max(startvalue, 1)),
    )


def A361064(n):
    return prod(divisor_sigma(e, 3) for e in factorint(n).values())


def A361063(n):
    return prod(divisor_sigma(e, 2) for e in factorint(n).values())


def A360769_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: sum(f := factorint(n).values()) > len(f) > 1,
        count(max(startvalue + (startvalue & 1 ^ 1), 1), 2),
    )


def A083652(n):
    return 2 + (n + 1) * (m := (n + 1).bit_length()) - (1 << m)


if sys.version_info >= (3, 10):

    def A106400(n):
        return -1 if n.bit_count() & 1 else 1

    def A010060(n):
        return n.bit_count() & 1

    def A010059(n):
        return n.bit_count() & 1 ^ 1

    def A001285(n):
        return 2 if n.bit_count() & 1 else 1

    def A026430(n):
        return n + (n - 1 >> 1) + (n - 1 & 1 | (n.bit_count() & 1 ^ 1))

    def A356133(n):
        return 3 * n - (2 if (n - 1).bit_count() & 1 else 1)

    def A359352(n):
        return (
            (m := n + 1 + (n - 1 >> 1) + (n - 1 & 1 | (n.bit_count() & 1 ^ 1)))
            + (m - 1 >> 1)
            + (m - 1 & 1 | (m.bit_count() & 1 ^ 1))
        )

    def A360136(n):
        return (
            1
            + (m := n + (n - 1 >> 1) + (n - 1 & 1 | (n.bit_count() & 1 ^ 1)))
            + (m - 1 >> 1)
            + (m - 1 & 1 | (m.bit_count() & 1 ^ 1))
        )

    def A360392(n):
        return n + 2 + (n - 1 >> 1) + (n - 1 & 1 | (n.bit_count() & 1 ^ 1))

    def A360134(n):
        return 3 * (
            m := n + 1 + (n - 1 >> 1) + (n - 1 & 1 | (n.bit_count() & 1 ^ 1))
        ) - (2 if (m - 1).bit_count() & 1 else 1)

    def A360138(n):
        return (
            (m := 3 * n - (2 if (n - 1).bit_count() & 1 else 1))
            + (m - 1 >> 1)
            + (m - 1 & 1 | (m.bit_count() & 1 ^ 1))
            + 1
        )

    def A115384(n):
        return (n >> 1) + (n & 1 | ((n + 1).bit_count() & 1 ^ 1))

    def A076826(n):
        return 1 if n & 1 else (n.bit_count() & 1) << 1

    def A000788(n):
        return sum(i.bit_count() for i in range(1, n + 1))

    def A163095(n):
        return sum(i.bit_count() for i in range(1, n + 1)) ** 2

    def A059015(n):
        return (
            2
            + (n + 1) * (m := (n + 1).bit_length())
            - (1 << m)
            - sum(i.bit_count() for i in range(1, n + 1))
        )

    def A181132(n):
        return (
            1
            + (n + 1) * (m := (n + 1).bit_length())
            - (1 << m)
            - sum(i.bit_count() for i in range(1, n + 1))
        )

    def A255817(n):
        return ((n >> 1) & 1) ^ (n & 1 | ((n + 1).bit_count() & 1 ^ 1))

    def A159481(n):
        return (n + 1 >> 1) + ((n + 1).bit_count() & 1 & n + 1)

    def A245710(n):
        return (n + 1 >> 1) - ((n + 1).bit_count() & 1 & (n + 1) ^ 1)

    def A301896(n):
        return (
            2
            + (n + 1) * (m := (n + 1).bit_length())
            - (1 << m)
            - (k := sum(i.bit_count() for i in range(1, n + 1)))
        ) * k

    def A268289(n):
        return (
            (sum(i.bit_count() for i in range(1, n + 1)) << 1)
            - 1
            - (n + 1) * (m := (n + 1).bit_length())
            + (1 << m)
        )

    def A296062(n):
        return (
            (k := n + 1)
            - (sum(i.bit_count() for i in range(1, k)) << 1)
            + k * (m := k.bit_length())
            - (1 << m)
        )

    def A110316(n):
        return 1 << (k := n + 1) - (
            sum(i.bit_count() for i in range(1, k)) << 1
        ) + k * (m := k.bit_length()) - (1 << m)

    def A067587(n):
        c, k = 0, 0
        for i, j in enumerate(bin(n)[-1:1:-1]):
            if j == "1":
                k += 1
                c += comb(i, k)
        return comb(n.bit_count() + c, 2) + c + 1

    def A356419(n):
        c, k = 0, 0
        for i, j in enumerate(bin(n)[-1:1:-1]):
            if j == "1":
                k += 1
                c += comb(i, k)
        return comb(n.bit_count() + c + 1, 2) - c

    def A037861(n):
        return n.bit_length() - (n.bit_count() << 1) if n else 1

    def A303581(n):
        return (n.bit_count() & 1) + n.bit_length()

    def A029883(n):
        return (n.bit_count() & 1) - ((n - 1).bit_count() & 1)

    def A036585(n):
        return 2 + (n.bit_count() & 1) - ((n - 1).bit_count() & 1)

    def A036577(n):
        return (n.bit_count() & 1) + ((n - 1).bit_count() & 1 ^ 1)

    def A007413(n):
        return 2 - (n.bit_count() & 1) + ((n - 1).bit_count() & 1)

    def A001969(n):
        return ((m := n - 1).bit_count() & 1) + (m << 1)

    def A026147(n):
        return 1 + ((m := n - 1).bit_count() & 1) + (m << 1)

    def A000069(n):
        return ((m := n - 1) << 1) + (m.bit_count() & 1 ^ 1)

    def A181155(n):
        return 1 + ((m := n - 1) << 1) + (m.bit_count() & 1 ^ 1)

    def A092246(n):
        return (n << 2) - (1 if (n - 1).bit_count() & 1 else 3)

    def A268673(n):
        return (((m := n - 2) << 4) + (13 if m.bit_count() & 1 else 5)) if n > 1 else n

    def A228495(n):
        return n.bit_count() & 1 & n

    def A092436(n):
        return n.bit_count() & 1 ^ 1

    def A128309(n):
        return ((m := n - 1) << 1) + (m.bit_count() & 1 ^ 1) << 1

    def A129771(n):
        return (((m := n - 1) << 1) + (m.bit_count() & 1 ^ 1) << 1) + 1

    def A254379(n):
        return (n & 1 ^ 1) & n.bit_count()

    def A254377(n):
        return n.bit_count() & 1 & n ^ 1

else:

    def A106400(n):
        return -1 if bin(n).count("1") & 1 else 1

    def A010060(n):
        return bin(n).count("1") & 1

    def A010059(n):
        return bin(n).count("1") & 1 ^ 1

    def A001285(n):
        return 2 if n.bit_count() & 1 else 1

    def A026430(n):
        return n + (n - 1 >> 1) + (n - 1 & 1 | (bin(n).count("1") & 1 ^ 1))

    def A356133(n):
        return 3 * n - (2 if bin(n - 1).count("1") & 1 else 1)

    def A359352(n):
        return (
            (m := n + 1 + (n - 1 >> 1) + (n - 1 & 1 | (bin(n).count("1") & 1 ^ 1)))
            + (m - 1 >> 1)
            + (m - 1 & 1 | (bin(m).count("1") & 1 ^ 1))
        )

    def A360136(n):
        return (
            1
            + (m := n + (n - 1 >> 1) + (n - 1 & 1 | (bin(n).count("1") & 1 ^ 1)))
            + (m - 1 >> 1)
            + (m - 1 & 1 | (bin(m).count("1") & 1 ^ 1))
        )

    def A360392(n):
        return n + 2 + (n - 1 >> 1) + (n - 1 & 1 | (bin(n).count("1") & 1 ^ 1))

    def A360134(n):
        return 3 * (
            m := n + 1 + (n - 1 >> 1) + (n - 1 & 1 | (bin(n).count("1") & 1 ^ 1))
        ) - (2 if bin(m - 1).count("1") & 1 else 1)

    def A360138(n):
        return (
            (m := 3 * n - (2 if bin(n - 1).count("1") & 1 else 1))
            + (m - 1 >> 1)
            + (m - 1 & 1 | (bin(m).count("1") & 1 ^ 1))
            + 1
        )

    def A115384(n):
        return (n >> 1) + (n & 1 | (bin(n + 1).count("1") & 1 ^ 1))

    def A076826(n):
        return 1 if n & 1 else (bin(n).count("1") & 1) << 1

    def A000788(n):
        return sum(bin(i).count("1") for i in range(1, n + 1))

    def A163095(n):
        return sum(bin(i).count("1") for i in range(1, n + 1)) ** 2

    def A059015(n):
        return (
            2
            + (n + 1) * (m := (n + 1).bit_length())
            - (1 << m)
            - sum(bin(i).count("1") for i in range(1, n + 1))
        )

    def A181132(n):
        return (
            1
            + (n + 1) * (m := (n + 1).bit_length())
            - (1 << m)
            - sum(bin(i).count("1") for i in range(1, n + 1))
        )

    def A255817(n):
        return ((n >> 1) & 1) ^ (n & 1 | (bin(n + 1).count("1") & 1 ^ 1))

    def A159481(n):
        return (n + 1 >> 1) + (bin(n + 1).count("1") & 1 & n + 1)

    def A245710(n):
        return (n + 1 >> 1) - (bin(n + 1).count("1") & 1 & (n + 1) ^ 1)

    def A301896(n):
        return (
            2
            + (n + 1) * (m := (n + 1).bit_length())
            - (1 << m)
            - (k := sum(bin(i).count("1") for i in range(1, n + 1)))
        ) * k

    def A268289(n):
        return (
            (sum(bin(i).count("1") for i in range(1, n + 1)) << 1)
            - 1
            - (n + 1) * (m := (n + 1).bit_length())
            + (1 << m)
        )

    def A296062(n):
        return (
            (k := n + 1)
            - (sum(bin(i).count("1") for i in range(1, k)) << 1)
            + k * (m := k.bit_length())
            - (1 << m)
        )

    def A110316(n):
        return 1 << (k := n + 1) - (
            sum(bin(i).count("1") for i in range(1, k)) << 1
        ) + k * (m := k.bit_length()) - (1 << m)

    def A067587(n):
        c, k = 0, 0
        for i, j in enumerate(bin(n)[-1:1:-1]):
            if j == "1":
                k += 1
                c += comb(i, k)
        return comb(bin(n).count("1") + c, 2) + c + 1

    def A356419(n):
        c, k = 0, 0
        for i, j in enumerate(bin(n)[-1:1:-1]):
            if j == "1":
                k += 1
                c += comb(i, k)
        return comb(bin(n).count("1") + c + 1, 2) - c

    def A037861(n):
        return n.bit_length() - (bin(n).count("1") << 1) if n else 1

    def A303581(n):
        return (bin(n).count("1") & 1) + n.bit_length()

    def A029883(n):
        return (bin(n).count("1") & 1) - (bin(n - 1).count("1") & 1)

    def A036585(n):
        return 2 + (bin(n).count("1") & 1) - (bin(n - 1).count("1") & 1)

    def A036577(n):
        return (bin(n).count("1") & 1) + (bin(n - 1).count("1") & 1 ^ 1)

    def A007413(n):
        return 2 - (bin(n).count("1") & 1) + (bin(n - 1).count("1") & 1)

    def A001969(n):
        return (bin(m := n - 1).count("1") & 1) + (m << 1)

    def A026147(n):
        return 1 + (bin(m := n - 1).count("1") & 1) + (m << 1)

    def A000069(n):
        return ((m := n - 1) << 1) + (bin(m).count("1") & 1 ^ 1)

    def A181155(n):
        return 1 + ((m := n - 1) << 1) + (bin(m).count("1") & 1 ^ 1)

    def A092246(n):
        return (n << 2) - (1 if bin(n - 1).count("1") & 1 else 3)

    def A268673(n):
        return (
            (((m := n - 2) << 4) + (13 if bin(m).count("1") & 1 else 5)) if n > 1 else n
        )

    def A228495(n):
        return bin(n).count("1") & 1 & n

    def A092436(n):
        return bin(n).count("1") & 1 ^ 1

    def A128309(n):
        return ((m := n - 1) << 1) + (bin(m).count("1") & 1 ^ 1) << 1

    def A129771(n):
        return (((m := n - 1) << 1) + (bin(m).count("1") & 1 ^ 1) << 1) + 1

    def A254379(n):
        return (n & 1 ^ 1) & bin(n).count("1")

    def A254377(n):
        return bin(n).count("1") & 1 & n ^ 1


def A068076(n):
    c, k = 0, 0
    for i, j in enumerate(bin(n)[-1:1:-1]):
        if j == "1":
            k += 1
            c += comb(i, k)
    return c


def A263017(n):
    c, k = 1, 0
    for i, j in enumerate(bin(n)[-1:1:-1]):
        if j == "1":
            k += 1
            c += comb(i, k)
    return c


def A361079(n):
    c, k = 0, 0
    for i, j in enumerate(bin(n)[-1:1:-1]):
        if j == "1":
            k += 1
            c += comb(i + 1, k) - comb(i, k)
    return c


def A361083(n):
    c = 0
    for s, d in partitions(n, m=9, size=True):
        d.update({0: 9 - s})
        c += sum(
            1
            for p in multiset_permutations(d)
            if p[0] * (p[4] * p[8] - p[5] * p[7])
            - p[1] * (p[3] * p[8] - p[5] * p[6])
            + p[2] * (p[3] * p[7] - p[4] * p[6])
            == 1
        )
    return c


def A361082(n):
    c = 0
    for s, d in partitions(n, m=9, k=n - 8, size=True):
        if s == 9:
            c += sum(
                1
                for p in multiset_permutations(d)
                if p[0] * (p[4] * p[8] - p[5] * p[7])
                - p[1] * (p[3] * p[8] - p[5] * p[6])
                + p[2] * (p[3] * p[7] - p[4] * p[6])
                == 1
            )
    return c


def A004718(n):
    c = 0
    for k, g in groupby(bin(n)[2:]):
        c = c + len(list(g)) if k == "1" else (-c if len(list(g)) & 1 else c)
    return c


def A256187(n):
    c, d = 0, 0
    for k, g in groupby(bin(n + 1)[2:]):
        c = c + len(list(g)) if k == "1" else (-c if len(list(g)) & 1 else c)
    for k, g in groupby(bin(n)[2:]):
        d = d + len(list(g)) if k == "1" else (-d if len(list(g)) & 1 else d)
    return c - d


def A083866_gen(startvalue=0):  # generator of terms
    n, c = max(0, startvalue), 0
    for k, g in groupby(bin(n)[2:]):
        c = c + len(list(g)) if k == "1" else (-c if len(list(g)) & 1 else c)
    while True:
        if c == 0:
            yield n
        n += 1
        c = c - t - 1 if (t := (~n & n - 1).bit_length()) & 1 else t + 1 - c


def A323908(n):
    c = 0
    for k, g in groupby(bin(n)[2:]):
        c = c + len(list(g)) if k == "1" else (-c if len(list(g)) & 1 else c)
    return -c ^ (-c << 1) if c <= 0 else c ^ (c & ~-c) << 1


def A361016(n):
    c = 0
    for k, g in groupby(bin(n)[2:]):
        c = c + len(list(g)) if k == "1" else (-c if len(list(g)) & 1 else c)
    return int(not c)


def A360497_gen():  # generator of terms
    xset = {2, 3, 5, 7}
    yield from (2, 3, 5, 7)
    for l in count(1):
        for d in product("2357", repeat=l):
            for e in (3, 7):
                if sum(map(int, d)) + e in xset and isprime(
                    m := int("".join(d)) * 10 + e
                ):
                    xset.add(m)
                    yield m


def A279319(n):
    return (0, 1, 2, 3, 4, 5, 6, 7, 8, 7, 6, 5, 4, 3, 2, 1)[n & 15]


def A329893(n):
    c, s = [0] * (m := n.bit_length()), bin(n)[2:]
    for i in range(m):
        if s[i] == "1":
            for j in range(m - i):
                c[j] = c[j] + 1
        else:
            for j in range(m - i):
                c[j] = -c[j]
    return prod(1 + d for d in c)


def A325804_gen(startvalue=0):  # generator of terms
    for n in count(max(startvalue, 0)):
        c, s = [0] * (m := n.bit_length()), bin(n)[2:]
        for i in range(m):
            if s[i] == "1":
                for j in range(m - i):
                    c[j] = c[j] + 1
            else:
                for j in range(m - i):
                    c[j] = -c[j]
        if all(1 + d for d in c):
            yield n


def A325803_gen():  # generator of terms
    for n in count(0):
        c, s = [0] * (m := n.bit_length()), bin(n)[2:]
        for i in range(m):
            if s[i] == "1":
                for j in range(m - i):
                    c[j] = c[j] + 1
            else:
                for j in range(m - i):
                    c[j] = -c[j]
        if k := prod(1 + d for d in c):
            yield k


def A274604(n):
    if n & 1:
        return (n >> 1) + 1
    c = 0
    for k, g in groupby(bin(m := n >> 1)[2:]):
        c = c + len(list(g)) if k == "1" else (-c if len(list(g)) & 1 else c)
    return m - c


def A082850_gen():  # generator of terms
    S = []
    for n in count(1):
        yield from (m := S + [n])
        S += m


def A361257(n):
    return sum(
        j * n**i for i, j in Counter(j.bit_count() for j in range(n + 1)).items()
    )


if sys.version_info >= (3, 10):

    def A074202_gen(startvalue=1):  # generator of terms
        return filter(
            lambda n: not ((1 << n) - 1) % n.bit_count(), count(max(startvalue, 1))
        )

    def A254651(n):
        return (n & 1 ^ 1) & n.bit_count() ^ 1

    def A254655_gen():  # generator of terms
        return (
            len(list(g))
            for k, g in groupby((n & 1 ^ 1) & n.bit_count() for n in count(0))
        )

    def A254378_gen():  # generator of terms
        return (
            len(list(g)) for k, g in groupby(n.bit_count() & 1 & n for n in count(0))
        )

else:

    def A074202_gen(startvalue=1):  # generator of terms
        return filter(
            lambda n: not ((1 << n) - 1) % bin(n).count("1"), count(max(startvalue, 1))
        )

    def A254651(n):
        return (n & 1 ^ 1) & bin(n).count("1") ^ 1

    def A254655_gen():  # generator of terms
        return (
            len(list(g))
            for k, g in groupby((n & 1 ^ 1) & bin(n).count("1") for n in count(0))
        )

    def A254378_gen():  # generator of terms
        return (
            len(list(g))
            for k, g in groupby(bin(n).count("1") & 1 & n for n in count(0))
        )


def A043276(n):
    return max(len(list(g)) for k, g in groupby(bin(n)[2:]))


def A043290(n):
    return max(len(list(g)) for k, g in groupby(hex(n)[2:]))


def A043282(n):
    return max(len(list(g)) for k, g in groupby(oct(n)[2:]))


def A043281(n):
    return max(len(list(g)) for k, g in groupby(sympydigits(n, 7)[1:]))


def A033014_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: set(len(list(g)) for k, g in groupby(hex(n)[2:])) == {2},
        count(max(startvalue, 1)),
    )


def A043320_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: set(len(list(g)) for k, g in groupby(hex(17 * n)[2:])) == {2},
        count(max(startvalue, 1)),
    )


def A005940(n):
    return prod(
        prime(len(a) + 1) ** b
        for a, b in Counter(accumulate(bin(n - 1)[2:].split("1")[:0:-1])).items()
    )


def A324054(n):
    return prod(
        ((p := prime(len(a) + 1)) ** (b + 1) - 1) // (p - 1)
        for a, b in Counter(accumulate(bin(n)[2:].split("1")[:0:-1])).items()
    )


def A156552(n):
    return sum(
        1 << primepi(p) + i for i, p in enumerate(factorint(n, multiple=True), -1)
    )


def A323243(n):
    return (
        divisor_sigma(
            sum(
                (1 << primepi(p) - 1) << i
                for i, p in enumerate(factorint(n, multiple=True))
            )
        )
        if n > 1
        else 0
    )


def A323244(n):
    return (
        (lambda n: (n << 1) - divisor_sigma(n))(
            sum(
                (1 << primepi(p) - 1) << i
                for i, p in enumerate(factorint(n, multiple=True))
            )
        )
        if n > 1
        else 0
    )


def A005941(n):
    return (
        sum(1 << primepi(p) + i for i, p in enumerate(factorint(n, multiple=True), -1))
        + 1
    )


def A103969_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: sum(
            (1 << primepi(p) - 1) << i
            for i, p in enumerate(factorint(n, multiple=True))
        )
        + 1
        == prod(
            prime(len(a) + 1) ** b
            for a, b in Counter(accumulate(bin(n - 1)[2:].split("1")[:0:-1])).items()
        ),
        count(max(startvalue, 1)),
    )


def A329603(n):
    return prod(
        prime(len(a) + 1) ** b
        for a, b in Counter(
            accumulate(
                bin(
                    1
                    + 3
                    * sum(
                        (1 << primepi(p) - 1) << i
                        for i, p in enumerate(factorint(n, multiple=True))
                    )
                )[2:].split("1")[:0:-1]
            )
        ).items()
    )


def A360822_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: len(s := str(n**2)) <= s.count("8") + s.count("9") + 2,
        count(max(startvalue, 1)),
    )


def A046801(n):
    return divisor_count((1 << n) - 1)


def A179682(n):
    m = n * (n + 1) >> 1
    k = n + 1
    while not is_square(m * k * (k + 1) >> 1):
        k += 1
    return k


def A175497_gen(startvalue=0):  # generator of terms
    return filter(
        lambda k: not k
        or any(
            map(
                lambda d: is_square((d << 3) + 1) and is_square((k**2 // d << 3) + 1),
                takewhile(lambda d: d**2 < k, divisors(k**2)),
            )
        ),
        count(max(startvalue, 0)),
    )


def A169836_gen():  # generator of terms
    return filter(
        lambda k: not k
        or any(
            map(
                lambda d: is_square((d << 3) + 1) and is_square((k // d << 3) + 1),
                takewhile(lambda d: d**2 < k, divisors(k)),
            )
        ),
        (m**2 for m in count(0)),
    )


def A169835_gen():  # generator of terms
    return filter(
        lambda k: any(
            map(
                lambda d: is_square((d << 3) + 1) and is_square((k // d << 3) + 1),
                takewhile(lambda d: d**2 <= k, divisors(k)),
            )
        ),
        (m**2 for m in count(0)),
    )


def A135506_gen():  # generator of terms
    x = 1
    for n in count(2):
        y = x + lcm(x, n)
        yield y // x - 1
        x = y


if sys.version_info >= (3, 10):

    def A178244(n):
        return comb(n.bit_length(), n.bit_count())

    def A080791(n):
        return n.bit_length() - n.bit_count()

    def A023416(n):
        return n.bit_length() - n.bit_count() if n else 1

else:

    def A178244(n):
        return comb(n.bit_length(), bin(n).count("1"))

    def A080791(n):
        return bin(n)[2:].count("0") if n else 0

    def A023416(n):
        return bin(n)[2:].count("0")


def A360940_gen(startvalue=1):  # generator of terms
    for k in count(max(startvalue, 1)):
        f = factorint(k)
        t = prod(p ** (e - 1) * (p - 1) for p, e in f.items())
        s = prod(e + 1 for e in f.values())
        if not k * (s + t) % (s * t):
            yield k


def A235353_gen(startvalue=1):  # generator of terms
    for k in count(max(startvalue, 1)):
        f = factorint(k)
        t = prod(p ** (e - 1) * (p - 1) for p, e in f.items())
        s = prod(e + 1 for e in f.values())
        if not (k % s or k % t):
            yield k


def A077585(n):
    return (1 << (1 << n) - 1) - 1


def A001146(n):
    return 1 << (1 << n)


def A054008(n):
    return n % divisor_count(n)


def A054009(n):
    return n % (divisor_count(n) - 1)


def A032741(n):
    return divisor_count(n) - 1 if n else 0


def A039653(n):
    return divisor_sigma(n) - 1 if n else 0


def A361291(n):
    return (((n << 1) + 1) ** n - 1) // (n << 1)


def A066708(n):
    return next(filter(lambda m: m % divisor_count(m) == n, count(n)))


def A135504_gen():  # generator of terms
    yield (a := 1)
    for n in count(2):
        yield (a := a + lcm(a, n))


def A106108_gen():  # generator of terms
    yield (a := 7)
    for n in count(2):
        yield (a := a + gcd(a, n))


def A132199_gen():  # generator of terms
    a = 7
    for n in count(2):
        yield (b := gcd(a, n))
        a += b


def A137613_gen():  # generator of terms
    a = 7
    for n in count(2):
        if (b := gcd(a, n)) > 1:
            yield b
        a += b


def A168007_gen():  # generator of terms
    yield (a := 1)
    for n in count(2):
        yield (a := a + (min(primefactors(a), default=1) if a & 1 or a == 2 else -1))


def A168008_gen():  # generator of terms
    a = 1
    for n in count(2):
        yield (b := min(primefactors(a), default=1) if a & 1 or a == 2 else -1)
        a += b


def A033950_gen(startvalue=1):  # generator of terms
    return filter(lambda k: not k % divisor_count(k), count(max(startvalue, 1)))


def A230504(n):
    return next(
        filter(isprime, accumulate(count(2), lambda x, y: x + gcd(x, y), initial=n))
    )


def A008977(n):
    return factorial(n << 2) // factorial(n) ** 4


def A188662(n):
    return comb(3 * n, n) ** 2


def A185679(n):
    return len(str(n**2))


def A071317_gen():  # generator of terms
    return accumulate(map(lambda n: sum(map(int, str(n**2))), count(0)))


def A240752(n):
    return sum(map(int, str(m := n**2))) - sum(map(int, str(m - (n << 1) + 1)))


def A185076(n):
    for k in count(1):
        if n == (t := len(s := str(k**2))) + sum(map(int, s)):
            return k
        if t >= n:
            return 0


def A053312_gen():  # generator of terms
    a = 0
    for n in count(0):
        yield (a := a + (10 ** n if (a >> n) & 1 else 10**n << 1))


def A147884_gen():  # generator of terms
    a, b, c = 0, 1, 1
    for n in count(0):
        a += b * c if (a >> n) & 1 else b * c << 1
        c *= 5
        yield int(discrete_log(c, a, 2))
        b <<= 1


def A361477(n):
    return factorial(len(c := [len(list(g)) for k, g in groupby(bin(n)[2:])])) // prod(
        map(factorial, Counter(c).values())
    )


def A126933_gen():  # generator of terms
    a, b = 2, 10
    for n in count(1):
        a += b if (c := a >> n) & 1 else b << 1
        b *= 10
        yield c


def A361253(n):
    if n <= 1:
        return n
    a, b = integer_nthroot(c := n, 2)
    while b:
        a, b = integer_nthroot(c := a, 2)
    return c


def A225546(n):
    return prod(
        prod(prime(i) for i, v in enumerate(bin(e)[:1:-1], 1) if v == "1")
        ** (1 << primepi(p) - 1)
        for p, e in factorint(n).items()
    )


def A335956(n):
    return ((1 << n) - 1) * (n & -n)


def A361610(n):
    return 5**n * (n * (n * (4 * n + 18) + 17) + 3) // 3


def A361608(n):
    return 7**n * (n * (n * (n * (n * (81 * n + 765) + 2085) + 1835) + 474) + 40) // 40


def A361609(n):
    return (n * (9 * n + 23) + 8) << ((n << 1) - 3) if n > 1 else 19 * n + 1


def A005109_gen():  # generator of terms
    p = 2
    while True:
        q = p - 1
        q >>= (~q & q - 1).bit_length()
        a, b = divmod(q, 3)
        while not b:
            a, b = divmod(q := a, 3)
        if q == 1:
            yield p
        p = nextprime(p)


def A161942(n):
    return (m := int(divisor_sigma(n))) >> (~m & m - 1).bit_length()


def A349161(n):
    f = factorint(n).items()
    a = prod(nextprime(p) ** e for p, e in f)
    b = prod((p ** (e + 1) - 1) // (p - 1) for p, e in f)
    return a // gcd(a, b)


def A133058_gen():  # generator of terms
    a = 1
    yield from (1, 1)
    for n in count(2):
        yield (a := a + n + 1 if (b := gcd(a, n)) == 1 else a // b)


def A339571_gen():  # generator of terms
    a, aset = 1, {1}
    yield 1
    for n in count(2):
        a = a + n + 1 if (b := gcd(a, n)) == 1 else a // b
        if a not in aset:
            aset.add(a)
            yield a


def A336164_gen():  # generator of terms
    yield (a := 1)
    for n in count(2):
        yield (a := a + n - 1 if (b := gcd(a, n)) == 1 else a // b)


def A334840_gen():  # generator of terms
    yield (a := 1)
    for n in count(2):
        yield (a := a << 2 if (b := gcd(a, n)) == 1 else a // b)


def A359804_gen():  # generator of terms
    aset, bset, cset = set(), {1}, {1, 2}
    yield from (1, 2)
    while True:
        for i in count(1):
            if not (i in aset or i in bset):
                p = prime(i)
                for j in count(1):
                    if (m := j * p) not in cset:
                        yield m
                        cset.add(m)
                        break
                break
        aset, bset = bset, set(map(primepi, primefactors(m)))


def A351495_gen():  # generator of terms
    aset, cset = set(), {1}
    yield 1
    while True:
        for i in count(1):
            if not i in aset:
                p = prime(i)
                for j in count(1):
                    if (m := j * p) not in cset:
                        yield m
                        cset.add(m)
                        break
                break
        aset = set(map(primepi, primefactors(m)))


def A360789(n):
    p, m = prime(n + 1), n + 1
    while p % m != n:
        p = nextprime(p)
        m += 1
    return p


def A073325(n):
    p, m = prime(n), n
    while p % m != n - 1:
        p = nextprime(p)
        m += 1
    return m


def A361330_gen():  # generator of terms
    aset, cset = {1}, {1, 2}
    yield from (2, 3)
    while True:
        for i in count(1):
            if not i in aset:
                p = prime(i)
                for j in count(1):
                    if (m := j * p) not in cset:
                        aset = set(map(primepi, primefactors(m)))
                        for k in count(1):
                            if k not in aset:
                                yield prime(k)
                                break
                        cset.add(m)
                        break
                break


def A361331(n):
    if n <= 2:
        return n
    aset, cset = {1}, {1, 2}
    for r in count(3):
        for i in count(1):
            if not i in aset:
                p = prime(i)
                for j in count(1):
                    if (m := j * p) not in cset:
                        aset = set(map(primepi, primefactors(m)))
                        for k in count(1):
                            if k not in aset:
                                if k == n:
                                    return r
                                break
                        cset.add(m)
                        break
                break


def A361671(n):
    return numbercore(n * (n * (n + 3) + 2) // 6)


def A361670(n):
    return numbercore(n * (n + 1) >> 1)


def A083481(n):
    return numbercore(n * (n + 1))


def A083482(n):
    return n * (n + 1) // prod(p ** (q >> 1) for p, q in factorint(n * (n + 1)).items())


def A019554(n):
    return n // prod(p ** (q >> 1) for p, q in factorint(n).items())


def A017665(n):
    return (m := divisor_sigma(n)) // gcd(m, n)


def A361624(n):
    return len(
        primefactors(
            int("".join(map(str, range(n, 1, -1))) + "".join(map(str, range(1, n + 1))))
        )
    )


def A007942(n):
    return int("".join(map(str, range(n, 1, -1))) + "".join(map(str, range(1, n + 1))))


def A017666(n):
    return n // gcd(divisor_sigma(n), n)


def A361563_gen():  # generator of terms
    return filter(
        lambda p: not p & 2 and isprime(((1 << p) + 1) // 3),
        (prime(n) for n in count(2)),
    )


def A361562_gen():  # generator of terms
    return filter(
        lambda p: p & 2 and isprime(((1 << p) + 1) // 3), (prime(n) for n in count(2))
    )


def A112633_gen():  # generator of terms
    return filter(
        lambda p: p & 2 and isprime((1 << p) - 1), (prime(n) for n in count(2))
    )


def A360736(n):
    return sum(
        factorint(
            int("".join(map(str, range(n, 1, -1))) + "".join(map(str, range(1, n + 1))))
        ).values()
    )


def A071296(n):
    if n % 3 == 2:
        return 0
    f, g = fib2(n)
    return int(f * (f + (g << 1) + 6) + g * (g + 2) + 5 >> 2)


def A360448_gen():  # generator of terms
    for i in count(2):
        k = (1 << i) + 1
        for j in range(1, i):
            if isprime(m := k + (1 << j)):
                yield primepi(m)


def A034960_gen():  # generator of terms
    a, p = 0, 2
    while True:
        yield p * ((a << 1) + p)
        a, p = a + p, nextprime(p)


def A034957_gen():  # generator of terms
    a, p = 0, 2
    while True:
        yield p * ((a << 1) + p - 1) >> 1
        a, p = a + p, nextprime(p)


def A034959_gen():  # generator of terms
    a, p = 0, 2
    while True:
        yield p * ((a << 1) + p - 1)
        a, p = a + p, nextprime(p)


def A034956_gen():  # generator of terms
    a, p = 0, 2
    while True:
        yield p * ((a << 1) + p + 1) >> 1
        a, p = a + p, nextprime(p)


if sys.version_info >= (3, 10):

    def A014499(n):
        return prime(n).bit_count()

else:

    def A014499(n):
        return bin(prime(n)).count("1")


def A061007(n):
    return 2 if n == 4 else int(isprime(n))


def A361627_gen():  # generator of terms
    p, s = 2, 2
    for n in count(1):
        if gcd(n, s) > 1:
            yield n
        s += (p := nextprime(p))


def A010709(n):
    return 4


def A361263(n):
    return (k := n + 1 >> 1) * (k**5 + 1 - ((n & 1) << 1)) >> 1


def A361743(n):
    return sum(comb(n, k) ** 2 * k << k - 1 for k in range(1, n + 1)) << 1 if n else 1


def A002003(n):
    return (
        sum(comb(n, k) ** 2 * k << k - 1 for k in range(1, n + 1)) // n << 1 if n else 0
    )


def A047781(n):
    return sum(comb(n, k) ** 2 * k << k - 1 for k in range(1, n + 1)) // n if n else 0


def A108666(n):
    return sum(comb(n, k) ** 2 * k << k - 1 for k in range(1, n + 1)) if n else 0


def A104684_T(n, k):
    return comb(n, k) * comb((n << 1) - k, n)


def A243949(n):
    return sum(comb(n, k) * comb(n + k, k) for k in range(n + 1)) ** 2


def A243946(n):
    return sum(
        5 ** (n - k) * comb(m := k << 1, k) * comb(n << 1, m) for k in range(n + 1)
    )


def A243947(n):
    return sum(
        5 ** (n - k) * comb(m := k << 1, k) * comb((n << 1) + 1, m)
        for k in range(n + 1)
    )


def A361752(n):
    return sum(
        comb(m := (r := n - (k << 1)) << 1, k) * comb(m, r) for k in range((n >> 1) + 1)
    )


def A361753(n):
    return sum(
        comb(m := (r := n - 3 * k) << 1, k) * comb(m, r) for k in range(n // 3 + 1)
    )


def A361745_A(n, m):  # compute square array A(n,m)
    return (
        1
        if not (m and n)
        else sum(comb(n - 1, i) * comb(m + i, n) for i in range(max(n - m, 0), n)) * n
        << 1
    )


def A082897_gen(startvalue=3):  # generator of terms
    for n in count((k := max(startvalue, 3)) + 1 - (k & 1), 2):
        t = gmpy2digits(n, 3)
        if t.count("0") == len(t) - 1:
            yield n
        else:
            m, s = n, 1
            while (m := totient(m)) > 1:
                s += m
            if s == n:
                yield n


def A091847_gen(startvalue=3):  # generator of terms
    for n in count((k := max(startvalue, 3)) + 1 - (k & 1), 2):
        t = gmpy2digits(n, 3)
        if t.count("0") != len(t) - 1:
            m, s = n, 1
            while (m := totient(m)) > 1:
                s += m
            if s == n:
                yield n


def A361719(n):
    return (
        (
            -((m := n >> 1) + 1) * n**2 * comb(n - 1, m)
            if n & 2
            else ((m := n >> 1) + 1) * n**2 * comb(n - 1, m)
        )
        if n & 1
        else (
            ((m := n >> 1) ** 3 << 1) * comb(n, m)
            if n & 2
            else -((m := n >> 1) ** 3 << 1) * comb(n, m)
        )
    )


def A361794(n):
    return prod(
        (p ** (3 * (e >> 1) + 3) - 1) // (p**3 - 1) for p, e in factorint(n).items()
    )


def A361793(n):
    return prod(
        (p ** (e // 3 + 1 << 1) - 1) // (p**2 - 1) for p, e in factorint(n).items()
    )


def A361099(n):
    return n**2 * (n * (n - 3) + 8) // 6


def A361612(n):
    return isqrt(10 ** ((n << 1) | 1))


def A361690(n):
    return (
        sum(1 for p in range((1 << n) + 1, (1 << n) + n + 1, 2) if isprime(p))
        if n != 1
        else 2
    )


def A361267_gen(startvalue=1):  # generator of terms
    p = prime(m := max(startvalue, 1))
    q = nextprime(p)
    r = nextprime(q)
    for k in count(m):
        if r - p == 6:
            yield k
        p, q, r = q, r, nextprime(r)


def A361716(n):
    return (
        (
            sum(
                comb(n, k) ** 3 * k if k & 1 else -comb(n, k) ** 3 * k
                for k in range(n + 1)
            )
        )
        // (n if n & 1 else -n)
        if n
        else 0
    )


def A359696(n):
    return (sum(isqrt(n**2 * (n - y) // y) for y in range(1, n)) << 1) + n


def A239100(n):
    if n <= 8:
        return (0, 1, 1, 2, 3, 4, 6, 8)[n - 1]
    r, b = divmod(n, 3)
    return (
        ((107 << r - 3) // 7 - 2 if b == 1 else ((17 << r) - 6) // 7 - 1)
        if b
        else (43 << r - 2) // 7 - 2
    )


def A098129(n):
    return int("".join(str(j) * j for j in range(1, n + 1)))


def A001855(n):
    return n * (m := (n - 1).bit_length()) - (1 << m) + 1


def A123753(n):
    return (n + 1) * (1 + (m := n.bit_length())) - (1 << m) + 1


def A003314(n):
    return n * (1 + (m := (n - 1).bit_length())) - (1 << m)


def A061168(n):
    return (n + 1) * ((m := n.bit_length()) - 1) - (1 << m) + 2


def A295513(n):
    return n * (m := (n - 1).bit_length()) - (1 << m) if n else -1


def A033156(n):
    return n * (2 + (m := (n - 1).bit_length())) - (1 << m)


def A097383(n):
    return (n + 1) * (m := n.bit_length()) - (1 << m) - (n - 1 >> 1)


def A054248(n):
    return n * (1 + (m := (n - 1).bit_length())) - (1 << m) + (n & 1)


def A070941(n):
    return n.bit_length() + 1


def A361508(n):
    return (
        n
        if n <= 1
        else (
            ceiling(log(n * sqrt(5) - S.Half, (1 + sqrt(5)) / 2))
            if is_square(m := 5 * n**2 - 4) or is_square(m + 8)
            else -1
        )
    )


def A010056(n):
    return int(is_square(m := 5 * n**2 - 4) or is_square(m + 8))


def A005086(n):
    return sum(
        1
        for d in divisors(n, generator=True)
        if is_square(m := 5 * d**2 - 4) or is_square(m + 8)
    )


def A361831(n):
    for m in count((n + 8) // 9):
        c = (t := 10**m)
        for a, b in partitions(n, m=m, k=9, size=True):
            b[0] = m - a
            for s in multiset_permutations(b):
                if (lambda n: isprime(n) or n == 1)(
                    int(
                        "0"
                        + gmpy2digits(
                            k := int("0" + "".join(str(d) for d in s)), 3
                        ).rstrip("0"),
                        3,
                    )
                ):
                    c = min(c, k)
        if c < t:
            return c


def A106843_gen(startvalue=2):  # generator of terms
    for m in count(max(startvalue, 2)):
        a, b = divmod(m, 3)
        while not b:
            a, b = divmod(a, 3)
        if (k := 3 * a + b) == 1 or isprime(k):
            yield m


def A040051(n):
    return npartitions(n) & 1


def A002865(n):
    return npartitions(n) - npartitions(n - 1) if n else 1


def A053445(n):
    return npartitions(n + 2) - (npartitions(n + 1) << 1) + npartitions(n)


def A119288(n):
    return 1 if len(s := primefactors(n)) <= 1 else sorted(s)[1]


def A010055(n):
    return int(len(primefactors(n)) <= 1)


def A069513(n):
    return int(len(primefactors(n)) == 1)


def A268340(n):
    return int(len(s := primefactors(n)) == 1 and n > s[0])


@lru_cache(maxsize=None)
def A359399(n):
    if n <= 1:
        return 1
    c, j = 0, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 * (j2 - 1) - j * (j - 1) >> 1) * A359399(k1)
        j, k1 = j2, n // j2
    return c + (n * (n + 1) - (j - 1) * j >> 1)


@lru_cache(maxsize=None)
def A359478(n):
    if n <= 1:
        return 1
    c, j = 0, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c -= (j2 * (j2 - 1) - j * (j - 1) >> 1) * A359478(k1)
        j, k1 = j2, n // j2
    return c - (n * (n + 1) - (j - 1) * j >> 1)


@lru_cache(maxsize=None)
def A359479(n):
    if n <= 1:
        return 1
    c, j = 0, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (
            (j2 >> 1 if j2 & 1 else -(j2 >> 1)) + (-(j >> 1) if j & 1 else j >> 1)
        ) * A359479(k1)
        j, k1 = j2, n // j2
    return (
        c + (-(n + 1 >> 1) if n & 1 else n + 1 >> 1) + (-(j >> 1) if j & 1 else j >> 1)
    )


@lru_cache(maxsize=None)
def A360658(n):
    if n <= 1:
        return 1
    c, j = 0, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c -= ((j2 * (j2 - 1)) ** 2 - (j * (j - 1)) ** 2 >> 2) * A360658(k1)
        j, k1 = j2, n // j2
    return c - ((n * (n + 1)) ** 2 - ((j - 1) * j) ** 2 >> 2)


@lru_cache(maxsize=None)
def A360390(n):
    if n <= 1:
        return 1
    c, j = 0, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c -= (
            (j2 * (j2 - 1) * ((j2 << 1) - 1) - j * (j - 1) * ((j << 1) - 1))
            // 6
            * A360390(k1)
        )
        j, k1 = j2, n // j2
    return c - (n * (n + 1) * ((n << 1) + 1) - j * (j - 1) * ((j << 1) - 1)) // 6


def A055615(n):
    return n * mobius(n)


def A067497(n):
    return (10**n - 1).bit_length()


def A361977(n):
    return prevprime((10**n - 1).bit_length())


@lru_cache(maxsize=None)
def A361981(n):
    if n <= 1:
        return 1
    c, j = 0, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (
            (j2 * (j2 - 1) if j2 & 1 else -j2 * (j2 - 1))
            + (-j * (j - 1) if j & 1 else j * (j - 1))
            >> 1
        ) * A361981(k1)
        j, k1 = j2, n // j2
    return c + (
        (-n * (n + 1) if n & 1 else n * (n + 1))
        + (-j * (j - 1) if j & 1 else j * (j - 1))
        >> 1
    )


@lru_cache(maxsize=None)
def A361983(n):
    if n <= 1:
        return 1
    c, j = 1, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (
            (j2 * (j2 - 1) if j2 & 1 else -j2 * (j2 - 1))
            + (-j * (j - 1) if j & 1 else j * (j - 1))
            >> 1
        ) * A361983(k1)
        j, k1 = j2, n // j2
    return c + (
        (-n * (n + 1) if n & 1 else n * (n + 1))
        + (-j * (j - 1) if j & 1 else j * (j - 1))
        >> 1
    )


@lru_cache(maxsize=None)
def A361982(n):
    if n <= 1:
        return 1
    c, j = 1, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (
            ((j2 << 1) - 1 if j2 & 1 else -(j2 << 1) + 1)
            + (-(j << 1) + 1 if j & 1 else (j << 1) - 1)
            >> 2
        ) * A361982(k1)
        j, k1 = j2, n // j2
    return c + (
        (-(n << 1) - 1 if n & 1 else (n << 1) + 1)
        + (-(j << 1) + 1 if j & 1 else (j << 1) - 1)
        >> 2
    )


def A239237_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: "0" in (s := str(n))
        and isprime(sum(s.count(d) * n ** int(d) for d in set(s))),
        count(max(1, startvalue)),
    )


def A239236_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: (s := str(n))
        and isprime(sum(s.count(d) * int(d) ** n for d in set(s) if d != "0")),
        count(max(1, startvalue)),
    )


def A361100(n):
    return (1 << (1 << (1 << (1 << (1 << 1))))) // 10 ** (39458 - n) % 10


def A361252_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: "0" in (s := str(n))
        and isprime(n)
        and isprime(sum(s.count(d) * n ** int(d) for d in set(s))),
        count((k := max(1, startvalue)) + 1 - (k & 1), 2),
    )


def A362002_gen(startvalue=0):  # generator of terms
    for k in count(max(startvalue, 0)):
        c = iter(str((m := k**2) * k))
        if all(map(lambda b: any(map(lambda a: a == b, c)), str(m))):
            yield k


def A362001_gen(startvalue=1):  # generator of terms
    for k in count(max(startvalue, 1)):
        c = iter(str(1 << k))
        if all(map(lambda b: any(map(lambda a: a == b, c)), str(k**2))):
            yield k


def A046829_gen(startvalue=0):  # generator of terms
    for k in count(max(startvalue, 0)):
        c = iter(str(k**2))
        if all(map(lambda b: any(map(lambda a: a == b, c)), str(k))):
            yield k


def A052212_gen(startvalue=1):  # generator of terms
    for k in count(max(startvalue, 1)):
        c = iter(str(k**2))
        if all(map(lambda b: any(map(lambda a: a == b, c)), str(k))):
            yield k


def A029772_gen(startvalue=0):  # generator of terms
    return filter(lambda n: set(str(n)) <= set(str(n**2)), count(max(startvalue, 0)))


if sys.version_info >= (3, 10):

    def A045620_gen(startvalue=0):  # generator of terms
        return filter(
            lambda k: Counter(str(m := k**2)) <= Counter(str(k * m)),
            count(max(startvalue, 0)),
        )

    def A046827_gen(startvalue=0):  # generator of terms
        return filter(
            lambda k: Counter(str(k)) <= Counter(str(k**2)), count(max(startvalue, 0))
        )

    def A064827_gen(startvalue=1):  # generator of terms
        return filter(
            lambda k: Counter(str(k)) <= Counter(str(k**2)), count(max(startvalue, 1))
        )

else:

    def A045620_gen(startvalue=0):  # generator of terms
        return filter(
            lambda k: not len(Counter(str(m := k**2)) - Counter(str(k * m))),
            count(max(startvalue, 0)),
        )

    def A046827_gen(startvalue=0):  # generator of terms
        return filter(
            lambda k: not len(Counter(str(k)) - Counter(str(k**2))),
            count(max(startvalue, 0)),
        )

    def A064827_gen(startvalue=1):  # generator of terms
        return filter(
            lambda k: not len(Counter(str(k)) - Counter(str(k**2))),
            count(max(startvalue, 1)),
        )


def A029776_gen(startvalue=0):  # generator of terms
    return filter(lambda n: set(str(n)) <= set(str(n**3)), count(max(startvalue, 0)))


def A029780_gen(startvalue=0):  # generator of terms
    return filter(
        lambda n: set(str(n)) <= set(str(m := n**2)) & set(str(n * m)),
        count(max(startvalue, 0)),
    )


def A029781_gen():  # generator of terms
    return map(
        lambda x: x[1],
        filter(
            lambda x: set(str(x[0])) <= set(str(x[1])) & set(str(prod(x))),
            ((n, n**2) for n in count(0)),
        ),
    )


def A046834_gen(startvalue=1):  # generator of terms
    for k in count(max(startvalue, 1)):
        c = iter(str(k**2)[1:-1])
        if all(map(lambda b: any(map(lambda a: a == b, c)), str(k))):
            yield k


def A046830_gen(startvalue=1):  # generator of terms
    for k in count(max(startvalue, 1)):
        if k % 10:
            c = iter(str(k**2))
            if all(map(lambda b: any(map(lambda a: a == b, c)), str(k))):
                yield k


def A046835_gen(startvalue=1):  # generator of terms
    for k in count(max(startvalue, 1)):
        if k % 10:
            c = iter(str(k**2)[1:-1])
            if all(map(lambda b: any(map(lambda a: a == b, c)), str(k))):
                yield k


def A046831_gen(startvalue=0):  # generator of terms
    return filter(lambda n: n % 10 and str(n) in str(n**2), count(max(startvalue, 0)))


def A018834_gen(startvalue=0):  # generator of terms
    return filter(lambda n: str(n) in str(n**2), count(max(startvalue, 0)))


def A362018_gen(startvalue=0):  # generator of terms
    for k in count(max(startvalue, 0)):
        c = iter(str(1 << k))
        if any(map(lambda b: all(map(lambda a: a != b, c)), str(k**2))):
            yield k


def A326418_gen(startvalue=0):  # generator of terms
    return filter(
        lambda n: n == int("".join((s := str(n**2))[len(s) & 1 ^ 1 :: 2])),
        count(max(startvalue, 0)),
    )


def A362020_gen(startvalue=0):  # generator of terms
    return filter(
        lambda n: n % 10 and n == int("".join((s := str(n**2))[len(s) & 1 ^ 1 :: 2])),
        count(max(startvalue, 0)),
    )


@lru_cache(maxsize=None)
def A347030(n):
    if n <= 1:
        return n
    c, j = 1, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j & 1) * (-1 if j & 1 else 1) * A347030(k1)
        j, k1 = j2, n // j2
    return c + (n + 1 - j & 1) * (-1 if j & 1 else 1)


@lru_cache(maxsize=None)
def A347031(n):
    if n <= 1:
        return n
    c, j = 1, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j & 1) * (1 if j & 1 else -1) * A347031(k1)
        j, k1 = j2, n // j2
    return c + (n + 1 - j & 1) * (1 if j & 1 else -1)


@lru_cache(maxsize=None)
def A068340(n):
    if n <= 1:
        return 1
    c, j = 1, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c -= (j2 * (j2 - 1) - j * (j - 1) >> 1) * A068340(k1)
        j, k1 = j2, n // j2
    return c - (n * (n + 1) - (j - 1) * j >> 1)


@lru_cache(maxsize=None)
def A336276(n):
    if n <= 1:
        return 1
    c, j = 1, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c -= (
            (j2 * (j2 - 1) * ((j2 << 1) - 1) - j * (j - 1) * ((j << 1) - 1))
            // 6
            * A336276(k1)
        )
        j, k1 = j2, n // j2
    return c - (n * (n + 1) * ((n << 1) + 1) - j * (j - 1) * ((j << 1) - 1)) // 6


@lru_cache(maxsize=None)
def A336277(n):
    if n <= 1:
        return 1
    c, j = 1, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c -= ((j2 * (j2 - 1)) ** 2 - (j * (j - 1)) ** 2 >> 2) * A336277(k1)
        j, k1 = j2, n // j2
    return c - ((n * (n + 1)) ** 2 - ((j - 1) * j) ** 2 >> 2)


@lru_cache(maxsize=None)
def A336278(n):
    if n <= 1:
        return 1
    c, j = 1, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c -= (
            (
                j2 * (j2**2 * (j2 * (6 * j2 - 15) + 10) - 1)
                - j * (j**2 * (j * (6 * j - 15) + 10) - 1)
            )
            // 30
            * A336278(k1)
        )
        j, k1 = j2, n // j2
    return (
        c
        - (
            n * (n**2 * (n * (6 * n + 15) + 10) - 1)
            - j * (j**2 * (j * (6 * j - 15) + 10) - 1)
        )
        // 30
    )


@lru_cache(maxsize=None)
def A336279(n):
    if n <= 1:
        return 1
    c, j = 1, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c -= (
            (
                j2**2 * (j2**2 * (j2 * (2 * j2 - 6) + 5) - 1)
                - j**2 * (j**2 * (j * (2 * j - 6) + 5) - 1)
            )
            // 12
            * A336279(k1)
        )
        j, k1 = j2, n // j2
    return (
        c
        - (
            n**2 * (n**2 * (n * (2 * n + 6) + 5) - 1)
            - j**2 * (j**2 * (j * (2 * j - 6) + 5) - 1)
        )
        // 12
    )


@lru_cache(maxsize=None)
def A361338_helper(k):
    return set(
        prod(divmod(k, s))
        for i in range(1, len(str(k)))
        if k % (s := (r := 10 ** (i - 1)) * 10) >= r or i == 1
    )


def A361338(n):
    if n < 10:
        return 1
    c, d, m = {n}, set(), 0
    while True:
        c = set(x for k in c for x in A361338_helper(k))
        d.update(c)
        if (r := len(d)) == m:
            return sum(1 for q in d if q < 10)
        m = r


def A361339(n):
    for m in count(1):
        if A361338(m) == n:
            return m


def A361380(n):
    return sum(
        comb(i, j) * (i - n) ** (i - j) * bell(j)
        for i in range(n + 1)
        for j in range(i + 1)
    )


def A344430(n):
    return sum(mobius(k) * k**k for k in range(1, n + 1))


def A008966(n):
    return int(max(factorint(n).values(), default=1) == 1)


def A361990_gen():  # generator of terms
    for l in count(2):
        c = set()
        for i in range(1, isqrt(10 ** (l - 1) - 1) + 1):
            i2 = i**2
            k = 10 ** (l - len(str(i2)) - 1)
            for j in count(0):
                f = int(fibonacci(j))
                if f >= 10 * k:
                    break
                if (f == 0 and k == 1) or f >= k:
                    n = i2 * 10 * k + f
                    for w in range(1, len(str(n))):
                        w2 = 10 ** (w - 1)
                        a, b = divmod(n, w2 * 10)
                        if w == 1 or b >= w2:
                            if is_square(b) and (
                                is_square(r := 5 * a**2 - 4) or is_square(r + 8)
                            ):
                                c.add(n)
        yield from sorted(c)


def A361349_gen(startvalue=1):  # generator of terms
    return filter(lambda n: A361338(n) == 10, count(max(startvalue, 1)))


def A362031_gen():  # generator of terms
    a, b, c = {}, {}, 1
    while True:
        yield c
        d = b[c] = b.get(c, primeomega(c))
        c = a[d] = a.get(d, 0) + 1


def A362033_gen():  # generator of terms
    a, b, c = {}, {}, 1
    for n in count(1):
        if c == 1:
            yield n
        d = b[c] = b.get(c, primeomega(c))
        c = a[d] = a.get(d, 0) + 1


def A362061_gen():  # generator of terms
    a, b, c = {}, {}, 1
    while True:
        yield c
        d = b[c] = b.get(c, primenu(c))
        c = a[d] = a.get(d, 0) + 1


def A362062(n):
    a, b, c = {}, {}, 1
    for m in count(1):
        d = b[c] = b.get(c, primenu(c))
        if d == n:
            return m
        c = a[d] = a.get(d, 0) + 1


def A362060_gen(startvalue=1):  # generator of terms
    p = prime(max(startvalue, 1))
    for k in count(max(startvalue, 1)):
        c = iter(str(p))
        if all(map(lambda b: any(map(lambda a: a == b, c)), str(k))):
            yield k
        p = nextprime(p)


def A362066_gen(startvalue=1):  # generator of terms
    p = prime(max(startvalue, 1))
    for k in count(max(startvalue, 1)):
        c = iter(str(p))
        if all(map(lambda b: any(map(lambda a: a == b, c)), str(k))):
            yield p
        p = nextprime(p)


def A062439(n):
    return prime(factorial(n))


def A362100_gen(startvalue=1):  # generator of terms
    a = 1 << 3 * (m := max(startvalue, 1))
    for n in count(m):
        if (s := str(n)) == str(a)[: len(s)]:
            yield n
        a <<= 3


def A100129_gen(startvalue=1):  # generator of terms
    a = 1 << (m := max(startvalue, 1))
    for n in count(m):
        if (s := str(n)) == str(a)[: len(s)]:
            yield n
        a <<= 1


def A362077_gen():  # generator of terms
    a, b = {1, 2}, 2
    yield from (1, 2)
    while True:
        for b in count(p := primeomega(b), p):
            if b not in a:
                yield b
                a.add(b)
                break


def A362089(n):
    return int(gmpy2digits(n, 3).replace("1", "01").replace("2", "02"), 3)


def A328749(n):
    return sum(
        (-(1 << i) if j & 1 else 1 << i)
        for i, j in enumerate(sympydigits(n, 3)[-1:0:-1])
        if j > 0
    )


def A362178_gen():  # generator of terms
    a, b = {1, 2}, 2
    yield from (1, 2)
    while True:
        for b in count(p := primenu(b), p):
            if b not in a:
                yield b
                a.add(b)
                break


def A362090(n):
    return sum(
        (-(1 << i) if int(j) & 1 else 1 << i)
        for i, j in enumerate(
            gmpy2digits(n, 3).replace("1", "01").replace("2", "02")[::-1]
        )
        if j != "0"
    )


def A328728_gen(startvalue=0):  # generator of terms
    for n in count(max(startvalue, 0)):
        s = gmpy2digits(n, 3)
        for i in range(len(s) - 1):
            if "0" not in s[i : i + 2]:
                break
        else:
            yield sum(
                (-(1 << i) if int(j) & 1 else 1 << i)
                for i, j in enumerate(s[::-1])
                if j != "0"
            )


def A122983(n):
    return (1 if n & 1 else 3) + 3**n >> 2


def A122585(n):
    return pow(n, -1, nextprime(n))


def A362254(n):
    return pow(n, -1, prevprime(n))


def A362047_gen(startvalue=2):  # generator of terms
    return filter(
        lambda n: (primepi(max(f := factorint(n))) - primepi(min(f))) * sum(f.values())
        == sum(primepi(i) * j for i, j in f.items()),
        count(max(startvalue, 2)),
    )


def A362268_gen(startvalue=2):  # generator of terms
    return filter(
        lambda n: (max(f := factorint(n)) - min(f)) * sum(f.values())
        == sum(map(prod, f.items())),
        count(max(startvalue, 2)),
    )


@lru_cache(maxsize=None)
def A362257(n):
    return (
        2 - n
        if n <= 2
        else ((a := 1 - A362257(n - 1)) + (b := 2 - A362257(n - 2)) >> 1)
        + A362257(n + a >> 1)
        + A362257(n + b >> 1)
    )


@lru_cache(maxsize=None)
def A239913(n):
    return (
        n - 1
        if n <= 2
        else A239913(a := 1 + A239913(n - 1))
        + A239913(b := 2 + A239913(n - 2))
        - a
        - b
        + n
    )


def A138705(n):
    return len(continued_fraction(abs(bernoulli(n << 1))))


def A138703(n):
    return sum(continued_fraction(abs(bernoulli(n))))


def A138706(n):
    return sum(continued_fraction(abs(bernoulli(n << 1))))


def A001469(n):
    return (2 - (2 << (m := n << 1))) * bernoulli(m)


def A110501(n):
    return ((2 << (m := n << 1)) - 2) * abs(bernoulli(m))


def A036968(n):
    return (2 - (2 << n)) * bernoulli(n)


def A005439(n):
    return (-2 if n & 1 else 2) * sum(
        comb(n, k) * (1 - (1 << n + k + 1)) * bernoulli(n + k + 1) for k in range(n + 1)
    )


def A000366(n):
    return (
        (-1 if n & 1 else 1)
        * sum(
            comb(n, k) * (1 - (1 << n + k + 1)) * bernoulli(n + k + 1)
            for k in range(n + 1)
        )
        >> n - 2
        if n > 1
        else 1
    )


def A362112(n):
    return ((4 << (m := n + 1 << 1)) - 4) * abs(bernoulli(m)) - abs(
        sum(
            comb(n, k) * (2 - (2 << n + k + 1)) * bernoulli(n + k + 1)
            for k in range(n + 1)
        )
    )


def A130168(n):
    return (
        abs(
            (2 - (2 << n + 1)) * bernoulli(n + 1)
            - (n + 1) * (1 - (1 << (m := n + 1 << 1))) * bernoulli(m)
            - (1 - (1 << m + 1)) * bernoulli(m + 1)
            + sum(
                (2 * comb(n, k + 1) - comb(n + 1, k))
                * (1 - (1 << (m := n + k + 2)))
                * bernoulli(m)
                for k in range(0, n)
            )
        )
        >> n - 1
    ) // 3


def A362295_gen():  # generator of terms
    yield from (0, 1, 2)
    a = [1, 2]
    while True:
        b = a[-1] + a[-2]
        c = a[-1] << 1
        flag = True
        for d in a:
            n = b + d
            if flag and n >= c:
                if n > c:
                    f = factorint(c)
                    if all(d & 3 != 3 or f[d] & 1 == 0 for d in f):
                        yield c
                flag = False
            f = factorint(n)
            if all(d & 3 != 3 or f[d] & 1 == 0 for d in f):
                yield n
        a.append(b)


def A000182(n):
    return abs(((2 - (2 << (m := n << 1))) * bernoulli(m) << m - 2) // n)


def A002105(n):
    return abs(((2 - (2 << (m := n << 1))) * bernoulli(m) << n - 1) // n)


def A047894(n):
    return len(str(abs(((2 - (2 << (m := n << 1))) * bernoulli(m) << m - 2) // n)))


def A155585(n):
    return (
        (((2 << (m := n + 1)) - 2) * bernoulli(m) << m - 2) // (m >> 1)
        if n & 1
        else (0 if n else 1)
    )


def A101921(n):
    return (n - 1 << 1) - (~n & n - 1).bit_length()


def A000146(n):
    return int(
        bernoulli(m := n << 1)
        + sum(Fraction(1, d + 1) for d in divisors(m, generator=True) if isprime(d + 1))
    )


def A085058(n):
    return (~(n + 1) & n).bit_length() + 2


def A358275(n):
    return (
        min(primefactors(int("".join(str(j) * j for j in range(1, n + 1)))))
        if n & 1
        else 2
    )


def A052882(n):
    return n * sum(factorial(k) * stirling(n - 1, k) for k in range(n))


def A354519(n):
    return sum(
        abs(((2 - (2 << (m := k << 1))) * bernoulli(m) << m - 2) // k) * comb(n, k << 1)
        for k in range(1, (n >> 1) + 1)
    )


def A354520(n):
    return sum(
        (((2 << (m := k << 1)) - 2) * bernoulli(m) << m - 2) // k * comb(n, k << 1)
        for k in range(1, (n >> 1) + 1)
    )


def A246006(n):
    return abs(euler(n - 1)) if n & 1 else abs(bernoulli(n)).p


def A361806(n):
    return sum({p for c in range(prime(n) + 1, prime(n + 1)) for p in primefactors(c)})


def A056831(n):
    return lcm(*range(prime(n) + 1, prime(n + 1)))


def A362296(n):
    return m - 1 if isprime(m := prime(n) + 2) else 1


def A361474(n):
    return n * (n * (n * (n * (n - 7) + 23) - 29) + 12) // 12


def A342099(n):
    return abs(
        prod(
            ((2 - (2 << (m := i << 1))) * bernoulli(m) << m - 2) // i
            for i in range(1, n + 1)
        )
    )


def A028296(n):
    return euler(n << 1)


def A173226(n):
    return sum(abs(euler(i)) for i in range(0, (n << 1) + 1, 2))


def A173253(n):
    if n <= 1:
        return n + 1
    c, blist = 2, (0, 1)
    for _ in range(n - 1):
        c += (blist := tuple(accumulate(reversed(blist), initial=0)))[-1]
    return c


def A361648(n):
    if n <= 1:
        return 1
    blist = (0, 1)
    for _ in range((m := n >> 1) - 1):
        blist = tuple(accumulate(reversed(blist), initial=0))
    return blist[-1] * sum(blist) * comb(n, m) if n & 1 else blist[-1] ** 2 * comb(n, m)


def A260786_gen():  # generator of terms
    yield from (2, 2)
    blist = (0, 2)
    while True:
        yield (blist := tuple(accumulate(reversed(blist), initial=0)))[-1]


def A141430(n):
    return (2, 7, 1, 2, 5, 7, 7, 2, 8, 7, 4, 2)[n % 12] if n > 1 else 1


def A014695(n):
    return (1, 2, 2, 1)[n & 3]


def A141458_gen():  # generator of terms
    yield 2
    blist = (0, 1)
    while True:
        yield (blist := tuple(accumulate(reversed(blist), initial=0)))[-1] + (
            blist := tuple(accumulate(reversed(blist), initial=0))
        )[-1]


def A004099_gen():  # generator of terms
    yield from (1, 1)
    blist = (0, 1)
    while True:
        blist = tuple(accumulate(reversed(blist), initial=0))
        yield sum(int(d) for d in str(blist[-1]))


if sys.version_info >= (3, 10):

    def A230958_gen():  # generator of terms
        blist = tuple()
        for i in count(0):
            yield (
                blist := tuple(
                    accumulate(reversed(blist), initial=2 if i.bit_count() & 1 else 1)
                )
            )[-1]

    def A230951_gen():  # generator of terms
        blist = tuple()
        for i in count(0):
            yield (
                blist := tuple(
                    accumulate(reversed(blist), initial=i.bit_count() & 1 ^ 1)
                )
            )[-1]

    def A230950_gen():  # generator of terms
        blist = tuple()
        for i in count(0):
            yield (
                blist := tuple(accumulate(reversed(blist), initial=i.bit_count() & 1))
            )[-1]

else:

    def A230958_gen():  # generator of terms
        blist = tuple()
        for i in count(0):
            yield (
                blist := tuple(
                    accumulate(
                        reversed(blist), initial=2 if bin(i).count("1") & 1 else 1
                    )
                )
            )[-1]

    def A230951_gen():  # generator of terms
        blist = tuple()
        for i in count(0):
            yield (
                blist := tuple(
                    accumulate(reversed(blist), initial=bin(i).count("1") & 1 ^ 1)
                )
            )[-1]

    def A230950_gen():  # generator of terms
        blist = tuple()
        for i in count(0):
            yield (
                blist := tuple(
                    accumulate(reversed(blist), initial=bin(i).count("1") & 1)
                )
            )[-1]


def A088388(n):
    return max(((p**e, e) for p, e in factorint(n).items()), default=(0, 0))[1]


def A088387(n):
    return max(((p**e, p) for p, e in factorint(n).items()), default=(0, 1))[1]


def A034699(n):
    return max((p**e for p, e in factorint(n).items()), default=1)


def A362040_gen():  # generator of terms
    a, b = set(), set()
    while True:
        yield (c := len(a := a | b))
        b = {c} | {c + d for d in b}


def A007947(n):
    return prod(primefactors(n), start=1)


def A306336(n):  # generator of terms
    if n == 0:
        return 1
    blist, c = (0, 1), 0
    for k in range(1, n + 1):
        c += stirling(n, k, kind=1, signed=True) * blist[-1]
        blist = tuple(accumulate(reversed(blist), initial=0))
    return c


def A317022(n):  # generator of terms
    if n == 0:
        return 1
    blist, c = (0, 1), 0
    for k in range(1, n + 1):
        c += stirling(n, k) * blist[-1]
        blist = tuple(accumulate(reversed(blist), initial=0))
    return c


def A180419(n):
    return (1 - euler(2 * (p := prime(n)))) // p >> 1 if n > 1 else 1


def A180417(n):
    return euler(1 << n) - 1 >> n if n > 1 else 0


def A131800(n):
    return (1, 2, 5, 6)[n & 3]


def A077382_gen():  # generator of terms
    yield (a := 1)
    for n in count(2, 3):
        yield (a := a * n)
        yield (a := a + n + 1)
        yield (a := a - n - 2)


def A077383_gen():  # generator of terms
    yield (a := 1)
    for n in count(2, 3):
        yield (a := a + n)
        yield (a := a * (n + 1))
        yield (a := a - n - 2)


def A077384_gen():  # generator of terms
    yield (a := 1)
    for n in count(2, 4):
        yield (a := a + n)
        yield (a := a * (n + 1))
        yield (a := a - n - 2)
        yield (a := a * (n + 3))


def A362269_gen():  # generator of terms
    yield (a := 1)
    for n in count(2, 3):
        yield (a := a - n)
        yield (a := a + n + 1)
        yield (a := a * (n + 2))


def A362270_gen():  # generator of terms
    yield (a := 1)
    for n in count(2, 3):
        yield (a := a - n)
        yield (a := a * (n + 1))
        yield (a := a + n + 2)


def A362271_gen():  # generator of terms
    yield (a := 1)
    for n in count(2, 3):
        yield (a := a + n)
        yield (a := a - n - 1)
        yield (a := a * (n + 2))


def A362272_gen():  # generator of terms
    yield (a := 1)
    for n in count(2, 3):
        yield (a := a * n)
        yield (a := a - n - 1)
        yield (a := a + n + 2)


def A362117(n):
    return int("".join(gmpy2digits(n, 5) for n in range(1, n + 1)))


def A117640(n):
    return int("".join(gmpy2digits(n, 4) for n in range(1, n + 1)))


def A362118(n):
    return 10 ** (n * (n + 1) >> 1) // 9


def A330527(n):
    c = a = factorial(n)
    blist = (0, 1)
    for d in range(2, n + 1):
        blist = tuple(accumulate(reversed(blist), initial=0))
        if n % d == 0:
            c += a * blist[-1] // factorial(d)
    return c


@lru_cache(maxsize=None)
def A362413(n):
    return (
        int(
            (
                (1 if n <= 2 else (2 if n & 1 else 3))
                + sum(
                    Fraction(
                        (1 if n - i <= 2 else (2 if n - i & 1 else 3)) * A362413(i),
                        factorial(i),
                    )
                    for i in range(1, n)
                )
            )
            * factorial(n - 1)
        )
        if n
        else 1
    )


def A362364(n):
    return prod(
        prime(i) * prime(i + 1) for i in range(2 + ((n & 1) << 1), (n << 1) - 1, 4)
    ) << (n & 1)


def A162296(n):
    f = factorint(n)
    return prod((p ** (e + 1) - 1) // (p - 1) for p, e in f.items()) - prod(
        p + 1 for p in f
    )


def A048250(n):
    return prod(p + 1 for p in primefactors(n))


def A357571(n):
    return (
        int(
            factorial(n) ** 2
            * sum(
                Fraction(1 << (n - j << 2), 3 * factorial(n - j))
                * sum(
                    (1 + i)
                    * (2 + i)
                    * factorial(4 + i)
                    * comb(14 + j + (i << 1), j - i)
                    * (-1 if (j - i) & 1 else 1)
                    << (j - i)
                    for i in range(j + 1)
                )
                for j in range(n + 1)
            )
        )
        >> 4
    )


def A052124(n):
    return int(
        (n + 5)
        * (n + 2)
        * factorial(n)
        * sum(
            Fraction((-1 if k & 1 else 1) * (k + 3) << k + 2, factorial(k + 5))
            for k in range(n + 1)
        )
    )


def A052127(n):
    return int(
        (n + 5)
        * (n + 2)
        * factorial(n) ** 2
        * sum(
            Fraction((-1 if k & 1 else 1) * (k + 3) << k + 2, factorial(k + 5))
            for k in range(n + 1)
        )
    )


def A362120(n):
    return next(
        filter(
            lambda k: len(
                s := num2words(k)
                .replace("-", "")
                .replace(",", "")
                .replace(" and ", "")
                .replace(" ", "")
            )
            >= n
            and s[n - 1] == "e",
            count(1),
        )
    )


def A362121(n):
    return next(
        filter(
            lambda k: len(
                s := num2words(k, lang="en_GB")
                .replace("-", "")
                .replace(",", "")
                .replace(" ", "")
            )
            >= n
            and s[n - 1] == "e",
            count(0),
        )
    )


def A362122(n):
    return next(
        filter(
            lambda k: len(
                s := num2words(k, lang="en_GB")
                .replace("-", "")
                .replace(",", "")
                .replace(" ", "")
            )
            >= n
            and s[n - 1] == "e",
            count(1),
        )
    )


def A164790(n):
    return next(
        filter(
            lambda k: len(
                s := num2words(k)
                .replace("-", "")
                .replace(",", "")
                .replace(" and ", "")
                .replace(" ", "")
            )
            >= n
            and s[n - 1] == "e",
            count(0),
        )
    )


def A362437(n):
    return n + sum(
        (
            1,
            3,
            3,
            2,
            1,
            4,
            2,
            4,
            1,
            8,
            5,
            1,
            3,
            1,
            1,
            3,
            10,
            1,
            1,
            1,
            1,
            4,
            4,
            8,
            4,
            10,
        )[a]
        for d in num2words(n).replace(" and ", "")
        if 0 <= (a := ord(d) - 97) <= 25
    )


def A113172(n):
    return sum(
        (
            1,
            3,
            3,
            2,
            1,
            4,
            2,
            4,
            1,
            8,
            5,
            1,
            3,
            1,
            1,
            3,
            10,
            1,
            1,
            1,
            1,
            4,
            4,
            8,
            4,
            10,
        )[a]
        for d in num2words(n).replace(" and ", "")
        if 0 <= (a := ord(d) - 97) <= 25
    )


def A290205(n):
    f = lambda n: sum(
        (
            1,
            3,
            3,
            2,
            1,
            4,
            2,
            4,
            1,
            8,
            5,
            1,
            3,
            1,
            1,
            3,
            10,
            1,
            1,
            1,
            1,
            4,
            4,
            8,
            4,
            10,
        )[a]
        for d in num2words(n).replace(" and ", "")
        if 0 <= (a := ord(d) - 97) <= 25
    )
    while True:
        n = f(n)
        if n in {4, 7, 8, 9, 4}:
            return 4
        if n == 12:
            return 12


def A075427(n):
    return (1 << (n >> 1) + 2) - 2 if n & 1 else (1 << (n >> 1) + 1) - 1


def A362343(n):
    return 1 << ((1 << (n >> 1) + 1) - 1 if n & 1 else (1 << (n >> 1) + 1) - 2)


def A362438(n):
    return n**2 + (1 << n - 1)


def A001580(n):
    return (1 << n) + n**2


def A361203(n):
    return n * (1 + (n - 1) % 9)


def A362526(n):
    return (n + 2 << n) + ((n - 7) * n >> 1) - 2


def A362468(n):
    return (n + 1 >> 1) + (5 ** (n - 1) << 1)


def A361247(n):
    return next(filter(lambda k: all(k % j < 3 for j in range(n, 3, -1)), count(3)))


def A361248(n):
    return next(filter(lambda k: all(k % j < 4 for j in range(n, 4, -1)), count(4)))


def A362291(n):
    c, m, S = 0, n & (-2), set(range(1, n**2 + 1))
    for a in combinations(range(1, n**2 + 1), m):
        q = sum(a)
        c += sum(1 for b in combinations(S - set(a), m) if sum(b) == q)
    return c


def A362280(n):
    c, m, S = 0, n & (-2), set(range(1, n**2 + 1))
    for a in combinations(range(1, n**2 + 1), m):
        q = sum(a)
        c += sum(1 for b in combinations(S - set(a), m) if sum(b) == q)
    return c * factorial(m) ** 2 * factorial(n**2 - (m << 1))


def A362581(n):
    if n <= 1:
        return n + 1
    blist = (0, 1)
    for _ in range(n - 1):
        blist = tuple(accumulate(reversed(blist), initial=0))
    return blist[-1] ** 2 * comb(n << 1, n)


def A065619(n):
    if n <= 2:
        return n
    blist = (0, 1)
    for _ in range(n - 2):
        blist = tuple(accumulate(reversed(blist), initial=0))
    return blist[-1] * n


def A000435(n):
    return (
        (
            sum(comb(n, k) * (n - k) ** (n - k) * k**k for k in range(1, (n + 1 >> 1)))
            << 1
        )
        + (0 if n & 1 else comb(n, m := n >> 1) * m**n)
    ) // n


def A001864(n):
    return (
        sum(comb(n, k) * (n - k) ** (n - k) * k**k for k in range(1, (n + 1 >> 1))) << 1
    ) + (0 if n & 1 else comb(n, m := n >> 1) * m**n)


def A001863(n):
    return (
        0
        if n < 2
        else (
            (
                sum(
                    comb(n, k) * (n - k) ** (n - k) * k**k
                    for k in range(1, (n + 1 >> 1))
                )
                << 1
            )
            + (0 if n & 1 else comb(n, m := n >> 1) * m**n)
        )
        // n
        // (n - 1)
    )


def A001865(n):
    return (
        (
            sum(comb(n, k) * (n - k) ** (n - k) * k**k for k in range(1, (n + 1 >> 1)))
            << 1
        )
        + (0 if n & 1 else comb(n, m := n >> 1) * m**n)
    ) // n + n ** (n - 1)


def A177453(n):
    return sum(
        (
            (
                sum(
                    comb(i, k) * (i - k) ** (i - k) * k**k
                    for k in range(1, (i + 1 >> 1))
                )
                << 1
            )
            + (0 if i & 1 else comb(i, m := i >> 1) * m**i)
        )
        // i
        // (i - 1)
        for i in range(2, n + 1)
    )


def A320064(n):
    return (
        0
        if n < 2
        else (
            (
                sum(
                    comb(n, k) * (n - k) ** (n - k) * k**k
                    for k in range(1, (n + 1 >> 1))
                )
                << 1
            )
            + (0 if n & 1 else comb(n, m := n >> 1) * m**n)
        )
        // n
        << n - 2
    )


def A063169(n):
    return (
        (
            sum(comb(n, k) * (n - k) ** (n - k) * k**k for k in range(1, (n + 1 >> 1)))
            << 1
        )
        + (0 if n & 1 else comb(n, m := n >> 1) * m**n)
        + n**n
    )


def A063170(n):
    return (
        (
            sum(comb(n, k) * (n - k) ** (n - k) * k**k for k in range(1, (n + 1 >> 1)))
            << 1
        )
        + (0 if n & 1 else comb(n, m := n >> 1) * m**n)
        + (n**n << 1)
        if n
        else 1
    )


def A362059(n):
    return -((q := isqrt(m := n >> 1)) ** 2) + (
        sum(m // k for k in range(1, q + 1)) << 1
    )


def A219706(n):
    return (
        (n - 1) * n**n
        - (
            sum(comb(n, k) * (n - k) ** (n - k) * k**k for k in range(1, (n + 1 >> 1)))
            << 1
        )
        - (0 if n & 1 else comb(n, m := n >> 1) * m**n)
        if n
        else 0
    )


def A321233(n):
    return (
        0
        if n < 2
        else (
            (
                sum(
                    comb(n, k) * (n - k) ** (n - k) * k**k
                    for k in range(1, (n + 1 >> 1))
                )
                << 1
            )
            + (0 if n & 1 else comb(n, m := n >> 1) * m**n)
        )
        // n
        << (n - 1 << 1)
    )


def A061540(n):
    return (
        0
        if n < 2
        else (
            (n * (n * (5 * n - 2) - 1) - 2) * n ** (n - 2)
            - 14
            * (
                (
                    sum(
                        comb(n, k) * (n - k) ** (n - k) * k**k
                        for k in range(1, (n + 1 >> 1))
                    )
                    << 1
                )
                + (0 if n & 1 else comb(n, m := n >> 1) * m**n)
            )
        )
        // 24
    )


def A036276(n):
    return sum(
        comb(n + 1, k) * (n + 1 - k) ** (n + 1 - k) * k**k
        for k in range(1, (n >> 1) + 1)
    ) + (comb(n + 1, m := n + 1 >> 1) * m ** (n + 1) >> 1 if n & 1 else 0)


def A000957_gen():  # generator of terms
    yield from (0, 1, 0)
    a, c = 0, 1
    for n in count(1):
        yield (a := (c := c * ((n << 2) + 2) // (n + 2)) - a >> 1)


def A138413_gen():  # generator of terms
    yield from (0, 0)
    a, c = 0, 1
    for n in count(1, 2):
        a = (c := c * ((n << 2) + 2) // (n + 2)) - a >> 1
        yield (a := (c := c * ((n + 1 << 2) + 2) // (n + 3)) - a >> 1)


def A138414_gen():  # generator of terms
    yield 1
    a, c = 0, 1
    for n in count(1, 2):
        yield (a := (c := c * ((n << 2) + 2) // (n + 2)) - a >> 1)
        a = (c := c * ((n + 1 << 2) + 2) // (n + 3)) - a >> 1


def A192675_gen():  # generator of terms
    yield from (0, 1, 0)
    a, c = 0, 1
    for n in count(1):
        yield isqrt(a := (c := c * ((n << 2) + 2) // (n + 2)) - a >> 1)


def A014300_gen():  # generator of terms
    yield from (1, 2)
    a, c = 1, 1
    for n in count(1):
        yield (a := (3 * n + 5) * (c := c * ((n << 2) + 2) // (n + 2)) - a >> 1)


def A000958_gen():  # generator of terms
    yield 1
    a, c = 0, 1
    for n in count(1):
        yield (c := c * ((n << 2) + 2) // (n + 2)) + a >> 1
        a = c - a >> 1


def A104629_gen():  # generator of terms
    a, c = 0, 1
    for n in count(1):
        yield (a := (c := c * ((n << 2) + 2) // (n + 2)) - a >> 1)


def A119259_gen():  # generator of terms
    yield from (1, 3)
    a, c = 2, 1
    for n in count(1):
        yield (a << n + 2) + (1 if n & 1 else -1)
        a = (3 * n + 5) * (c := c * ((n << 2) + 2) // (n + 2)) - a >> 1


def A333564_gen():  # generator of terms
    yield (a := 2)
    c = 1
    for n in count(1):
        yield a << n + 1
        a = (3 * n + 5) * (c := c * ((n << 2) + 2) // (n + 2)) - a >> 1


def A126983_gen():  # generator of terms
    yield from (1, -1, 0)
    a, c = 0, 1
    for n in count(1):
        yield (a := -a - (c := c * ((n << 2) + 2) // (n + 2)) >> 1)


def A064310_gen():  # generator of terms
    yield from (1, 1, 0)
    a, c = 0, 1
    for n in count(1):
        yield (a := (c := c * ((n << 2) + 2) // (n + 2)) - a >> 1) * (
            1 if n & 1 else -1
        )


def A014301_gen():  # generator of terms
    yield from (0, 1)
    a, b, c = 0, 3, 1
    for n in count(1):
        yield (
            (b := b * ((n << 1) + 3 << 1) // (n + 2))
            - (a := (c := c * ((n << 2) + 2) // (n + 2)) - a >> 1)
        ) // 3


def A362548(n):
    return npartitions(n) - 1 - (n**2 >> 2)


def A362068(n):
    if is_square(n):
        return 1
    if all(
        map(
            lambda x: x[0] & 3 < 3 or x[1] & 1 ^ 1,
            factorint(k := n >> (m := (~n & n - 1).bit_length())).items(),
        )
    ):
        return 2
    if m & 1 or 3 * k & 7 < 7:
        return 3
    return 4


def A362596(n):
    return (
        ((n * (n - 3) + 4) * comb(n << 1, n) // (n + 1) >> 2) + (1 << (n << 1) - 3)
        if n > 1
        else 1
    )


def A362595(n):
    return (
        ((n * (n + 1) + 4) * comb(n << 1, n) // (n + 1) >> 2) - (1 << (n << 1) - 3)
        if n > 1
        else 1
    )


def A238454(n):
    return (isqrt(m := 1 << (n << 1) - 1) + 1) ** 2 - m


def A267032(n):
    return (isqrt(m := 10 ** ((n << 1) + 1)) + 1) ** 2 - m


def A056008(n):
    return (isqrt(m := 1 << n) + 1) ** 2 - m


def A362603_gen():  # generator of terms
    yield 1
    blist, c = (0, 1), 1
    for n in count(1):
        blist, a, c = (
            tuple(accumulate(reversed(blist), initial=0)),
            blist[-1],
            c * ((n << 2) - 2),
        )
        yield int(c * (a - Fraction(blist[-1], (n + 1))))


def A024816(n):
    return (n * (n + 1) >> 1) - divisor_sigma(n)


def A362625(n):
    f = factorint(n)
    return (
        (n * (n - 1) >> 1)
        - n * prod(e + 1 for e in f.values())
        + prod((p ** (e + 1) - 1) // (p - 1) for p, e in f.items())
    )


def A091137(n):
    return prod(p ** (n // (p - 1)) for p in primerange(n + 2))


def A090624(n):
    return max((p - 1) * e for p, e in factorint(n).items())


@lru_cache(maxsize=None)
def A005245(n):
    return (
        min(
            min(A005245(a) + A005245(n - a) for a in range(1, (n >> 1) + 1)),
            min(
                (
                    A005245(d) + A005245(n // d)
                    for d in takewhile(lambda d: d * d <= n, divisors(n))
                    if d > 1
                ),
                default=n,
            ),
        )
        if n > 1
        else 1
    )


def A353441_gen(startvalue=1):  # generator of terms
    for a in count(max(startvalue, 1)):
        m2, m5 = (~a & a - 1).bit_length(), multiplicity(5, a)
        k, m = 10 ** max(m2, m5), 10 ** n_order(10, a // (1 << m2) // 5**m5) - 1
        if "5" in str(c := k // a) or "5" in str(m * k // a - c * m):
            yield a


def A362579_gen(startvalue=1):  # generator of terms
    for a in count(max(startvalue, 1)):
        m2, m5 = (~a & a - 1).bit_length(), multiplicity(5, a)
        k, m = 10 ** max(m2, m5), 10 ** n_order(10, a // (1 << m2) // 5**m5) - 1
        if not ("5" in str(c := k // a) or "5" in str(m * k // a - c * m)):
            yield a


def A362532(n):
    return next(
        filter(lambda k: all(k % (j << 1) < j for j in range(n, 0, -1)), count(1))
    )


def A053664(n):
    return int(crt([prime(i) for i in range(1, n + 1)], list(range(1, n + 1)))[0])


def A351473_gen(startvalue=1):  # generator of terms
    for a in count(max(startvalue, 1)):
        m2, m5 = (~a & a - 1).bit_length(), multiplicity(5, a)
        k, m = 10 ** max(m2, m5), 10 ** n_order(10, a // (1 << m2) // 5**m5) - 1
        if max(max(str(c := k // a)), max(str(m * k // a - c * m))) == "7":
            yield a


def A351474_gen(startvalue=1):  # generator of terms
    for a in count(max(startvalue, 1)):
        m2, m5 = (~a & a - 1).bit_length(), multiplicity(5, a)
        k, m = 10 ** max(m2, m5), 10 ** n_order(10, a // (1 << m2) // 5**m5) - 1
        if max(max(str(c := k // a)), max(str(m * k // a - c * m))) == "8":
            yield a


def A004216(n):
    return len(str(n)) - 1


def A058183(n):
    return (n + 1) * (s := len(str(n))) - (10**s - 1) // 9


def A070198(n):
    return lcm(*range(1, n + 2)) - 1


def A157752(n):
    return int(
        crt((s := [prime(i + 1) for i in range(1, n)]) + [prime(n + 1)], [2] + s)[0]
    )


def A177882(n):
    return sum((bool(~(3 * n) & 3 * n - k) ^ 1) << k for k in range(3 * n + 1))


def A038192(n):
    return sum(
        (bool(~(m := (n << 1) + 1) & m - k) ^ 1) << k for k in range((n + 1) << 1)
    )


def A089893(n):
    return (
        sum((bool(~(m := n << 1) & m - k) ^ 1) << k for k in range((n << 1) + 1)) - 1
        >> 2
    )


def A038183(n):
    return sum((bool(~(m := n << 1) & m - k) ^ 1) << k for k in range((n << 1) + 1))


def A087745(n):
    return sum((bool(~(m := n >> 1) & m - k) ^ 1) << k for k in range((n >> 1) + 1))


def A100308(n):
    return sum((bool(~n & n - k) ^ 1) * 5**k for k in range(n + 1))


def A100307(n):
    return sum((bool(~n & n - k) ^ 1) * 3**k for k in range(n + 1))


def A100311(n):
    return sum((bool(~n & n - k) ^ 1) << 3 * k for k in range(n + 1))


def A100309(n):
    return sum((bool(~n & n - k) ^ 1) * 6**k for k in range(n + 1))


def A100310(n):
    return sum((bool(~n & n - k) ^ 1) * 7**k for k in range(n + 1))


def A211344_gen():  # generator of terms
    return (
        sum(
            (bool(~(m := (1 << t) - (1 << k) - 1) & m - i) ^ 1) << i
            for i in range((1 << t) - (1 << k))
        )
        for t in count(1)
        for k in range(t - 1, -1, -1)
    )


def A051179(n):
    return (1 << (1 << n)) - 1


def A099885(n):
    return sum(
        (bool(~(m := n >> 1) & m - k) ^ 1) << k for k in range((n >> 1) + 1)
    ) << (n + 1 >> 1)


def A117998(n):
    return sum((bool(~n & n - k) ^ 1) << k for k in range(n + 1)) << n


def A362710_gen(startvalue=1):  # generator of terms
    for a in count(max(startvalue, 1)):
        m2, m5 = (~a & a - 1).bit_length(), multiplicity(5, a)
        k, m = 10 ** max(m2, m5), 10 ** (t := n_order(10, a // (1 << m2) // 5**m5)) - 1
        if not (
            "0" in str(c := k // a).lstrip("0")
            or ((w := str(m * k // a - c * m).zfill(t)) != "0" and "0" in w)
        ):
            yield a


def A362376(n):
    a = b = fibonacci(n)
    for k in count(1):
        if isprime(a + 1):
            return k
        a, b = b, a + b


def A177897(n):
    return sum((bool(~(m := 7 * n) & m - k) ^ 1) << k for k in range(7 * n + 1))


def A219843(n):
    return (1 << n + 1) - 1 - sum((bool(~n & n - k) ^ 1) << k for k in range(n + 1))


def A006943(n):
    return sum((bool(~n & n - k) ^ 1) * 10**k for k in range(n + 1))


if sys.version_info >= (3, 10):

    def A048967(n):
        return n + 1 - (1 << n.bit_count())

    def A324287(n):
        return (
            sum(
                reduce(
                    lambda x, y: (x[0], x[0] + x[1]) if int(y) else (x[0] + x[1], x[1]),
                    bin((n << 1) - n.bit_count())[-1:2:-1],
                    (1, 0),
                )
            )
            if n
            else 0
        )

    def A324288(n):
        return (
            sum(
                reduce(
                    lambda x, y: (x[0], x[0] + x[1]) if int(y) else (x[0] + x[1], x[1]),
                    bin(1 + (n << 1) - n.bit_count())[-1:2:-1],
                    (1, 0),
                )
            )
            if n
            else 1
        )

else:

    def A048967(n):
        return n + 1 - (1 << bin(n).count("1"))

    def A324287(n):
        return (
            sum(
                reduce(
                    lambda x, y: (x[0], x[0] + x[1]) if int(y) else (x[0] + x[1], x[1]),
                    bin((n << 1) - bin(n).count("1"))[-1:2:-1],
                    (1, 0),
                )
            )
            if n
            else 0
        )

    def A324288(n):
        return (
            sum(
                reduce(
                    lambda x, y: (x[0], x[0] + x[1]) if int(y) else (x[0] + x[1], x[1]),
                    bin(1 + (n << 1) - bin(n).count("1"))[-1:2:-1],
                    (1, 0),
                )
            )
            if n
            else 1
        )


def A309364(n):
    if n == 1:
        return 0
    c = 1
    for k in count(1):
        if not c % n:
            return k
        c = c * ((k << 1) + 1 << 1) // (k + 2)


def A070871(n):
    return sum(
        reduce(
            lambda x, y: (x[0], x[0] + x[1]) if int(y) else (x[0] + x[1], x[1]),
            bin(n)[-1:2:-1],
            (1, 0),
        )
    ) * sum(
        reduce(
            lambda x, y: (x[0], x[0] + x[1]) if int(y) else (x[0] + x[1], x[1]),
            bin(n + 1)[-1:2:-1],
            (1, 0),
        )
    )


def A020946(n):
    return (
        next(
            filter(
                lambda k: sum(
                    reduce(
                        lambda x, y: (
                            (x[0], x[0] + x[1]) if int(y) else (x[0] + x[1], x[1])
                        ),
                        bin(k)[-1:2:-1],
                        (1, 0),
                    )
                )
                == n,
                count(1),
            )
        )
        if n
        else 0
    )


def A020950(n):
    return (
        next(
            filter(
                lambda k: sum(
                    reduce(
                        lambda x, y: (
                            (x[0], x[0] + x[1]) if int(y) else (x[0] + x[1], x[1])
                        ),
                        bin(k)[-1:2:-1],
                        (1, 0),
                    )
                )
                == n,
                count(1),
            )
        )
        - 1
    )


def A283986(n):
    return sum(
        reduce(
            lambda x, y: (x[0], x[0] + x[1]) if int(y) else (x[0] + x[1], x[1]),
            bin(n)[-1:2:-1],
            (1, 0),
        )
    ) | sum(
        reduce(
            lambda x, y: (x[0], x[0] + x[1]) if int(y) else (x[0] + x[1], x[1]),
            bin(n - 1)[-1:2:-1],
            (1, 0),
        )
    )


def A283987(n):
    return (
        sum(
            reduce(
                lambda x, y: (x[0], x[0] + x[1]) if int(y) else (x[0] + x[1], x[1]),
                bin(n)[-1:2:-1],
                (1, 0),
            )
        )
        ^ sum(
            reduce(
                lambda x, y: (x[0], x[0] + x[1]) if int(y) else (x[0] + x[1], x[1]),
                bin(n - 1)[-1:2:-1],
                (1, 0),
            )
        )
        if n > 1
        else 1
    )


def A283988(n):
    return (
        sum(
            reduce(
                lambda x, y: (x[0], x[0] + x[1]) if int(y) else (x[0] + x[1], x[1]),
                bin(n)[-1:2:-1],
                (1, 0),
            )
        )
        & sum(
            reduce(
                lambda x, y: (x[0], x[0] + x[1]) if int(y) else (x[0] + x[1], x[1]),
                bin(n - 1)[-1:2:-1],
                (1, 0),
            )
        )
        if n > 1
        else 0
    )


def A362870(n):
    return divisor_sigma(n, 29)


def A281959(n):
    return divisor_sigma(n, 25)


def A174868_gen():  # generator of terms
    return accumulate(
        (
            sum(
                reduce(
                    lambda x, y: (x[0], x[0] + x[1]) if int(y) else (x[0] + x[1], x[1]),
                    bin(n)[-1:2:-1],
                    (1, 0),
                )
            )
            for n in count(1)
        ),
        initial=0,
    )


def A007729_gen():  # generator of terms
    return accumulate(
        sum(
            reduce(
                lambda x, y: (x[0], x[0] + x[1]) if int(y) else (x[0] + x[1], x[1]),
                bin(n)[-1:2:-1],
                (1, 0),
            )
        )
        for n in count(1)
    )


def A328566(n):
    return sum(set(k | n - k for k in range((n >> 1) + 1)))


def A328564(n):
    return sum(set(k & n - k for k in range((n >> 1) + 1)))


def A328565(n):
    return sum(set(k ^ n - k for k in range((n >> 1) + 1)))


def A006582(n):
    return sum(k ^ n - k for k in range(1, n + 1 >> 1)) << 1


def A006583(n):
    return (sum(k | n - k for k in range(1, n + 1 >> 1)) << 1) + (
        0 if n & 1 else n >> 1
    )


def A006581(n):
    return (sum(k & n - k for k in range(1, n + 1 >> 1)) << 1) + (
        0 if n & 1 else n >> 1
    )


def A090889(n):
    return (
        (sum(k & n - k for k in range(1, n + 1 >> 1)) << 1)
        + (0 if n & 1 else n >> 1)
        + n * (n - 1) * (n + 1) // 6
    )


def A362613(n):
    v = factorint(n).values()
    w = min(v, default=0)
    return sum(1 for e in v if e <= w)


def A362611(n):
    return list(v := factorint(n).values()).count(max(v, default=0))


def A058770_gen(startvalue=1):  # generator of terms
    return filter(
        lambda k: is_gaussian_prime(k * (1 + I) ** k + 1), count(max(startvalue, 1))
    )


def A056770(n):
    if not n % 10:
        return 0
    for l in count(1):
        if 9**l * n < 10 ** (l - 1):
            return 0
        c = 10**l
        for d in combinations_with_replacement(range(1, 10), l):
            if sorted(str(a := prod(d) * n)) == [str(e) for e in d]:
                c = min(c, a)
        if c < 10**l:
            return c


def A003634(n):
    for l in count(1):
        if 9 * l * n < 10 ** (l - 1):
            return 0
        c = 10**l
        for d in combinations_with_replacement(range(10), l):
            if sorted(str(a := sum(d) * n)) == [str(e) for e in d] and a > 0:
                c = min(c, a)
        if c < 10**l:
            return c


def A003635_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        for l in count(1):
            if 9 * l * n < 10 ** (l - 1):
                yield n
                break
            for d in combinations_with_replacement(range(10), l):
                if (s := sum(d)) > 0 and sorted(str(s * n)) == [str(e) for e in d]:
                    break
            else:
                continue
            break


def A058898_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        for l in count(1):
            if l * n < 1 << l - 1:
                yield n
                break
            for d in combinations_with_replacement((0, 1), l):
                if (s := sum(d)) > 0 and sorted(bin(s * n)[2:]) == [str(e) for e in d]:
                    break
            else:
                continue
            break


def A058906_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        for l in count(1):
            if 10 * l * n < 11 ** (l - 1):
                yield n
                break
            for d in combinations_with_replacement(range(11), l):
                if (s := sum(d)) > 0 and sorted(sympydigits(s * n, 11)[1:]) == list(d):
                    break
            else:
                continue
            break


def A052491(n):
    for k in count(1):
        for l in count(1):
            if (n - 1) * l * k < n ** (l - 1):
                return k
            for d in combinations_with_replacement(range(n), l):
                if (s := sum(d)) > 0 and sorted(sympydigits(s * k, n)[1:]) == list(d):
                    break
            else:
                continue
            break


def A130338_gen(startvalue=1):  # generator of terms
    n = nextprime(max(startvalue, 1) - 1)
    while True:
        for l in count(1):
            if 9 * l * n < 10 ** (l - 1):
                yield n
                break
            for d in combinations_with_replacement(range(10), l):
                if (s := sum(d)) > 0 and sorted(str(s * n)) == [str(e) for e in d]:
                    break
            else:
                continue
            break
        n = nextprime(n)


@lru_cache(maxsize=None)
def A061381(n):
    for k in count((0 if n <= 2 else A061381(n - 1)) + 1):
        for l in count(1):
            if (n - 1) * l * k < n ** (l - 1):
                return k
            for d in combinations_with_replacement(range(n), l):
                if (s := sum(d)) > 0 and sorted(sympydigits(s * k, n)[1:]) == list(d):
                    break
            else:
                continue
            break


def A058904_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        for l in count(1):
            if 7 * l * n < 1 << 3 * (l - 1):
                yield n
                break
            for d in combinations_with_replacement(range(8), l):
                if (s := sum(d)) > 0 and sorted(oct(s * n)[2:]) == list(map(str, d)):
                    break
            else:
                continue
            break


def A058902_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        for l in count(1):
            if 5 * l * n < 6 ** (l - 1):
                yield n
                break
            for d in combinations_with_replacement(range(6), l):
                if (s := sum(d)) > 0 and sorted(sympydigits(s * n, 6)[1:]) == list(d):
                    break
            else:
                continue
            break


def A058899_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        for l in count(1):
            if 2 * l * n < 3 ** (l - 1):
                yield n
                break
            for d in combinations_with_replacement((0, 1, 2), l):
                if (s := sum(d)) > 0 and sorted(sympydigits(s * n, 3)[1:]) == list(d):
                    break
            else:
                continue
            break


def A058900_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        for l in count(1):
            if 3 * l * n < 1 << ((l - 1) << 1):
                yield n
                break
            for d in combinations_with_replacement((0, 1, 2, 3), l):
                if (s := sum(d)) > 0 and sorted(sympydigits(s * n, 4)[1:]) == list(d):
                    break
            else:
                continue
            break


def A058901_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        for l in count(1):
            if 4 * l * n < 5 ** (l - 1):
                yield n
                break
            for d in combinations_with_replacement(range(5), l):
                if (s := sum(d)) > 0 and sorted(sympydigits(s * n, 5)[1:]) == list(d):
                    break
            else:
                continue
            break


def A058903_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        for l in count(1):
            if 6 * l * n < 7 ** (l - 1):
                yield n
                break
            for d in combinations_with_replacement(range(7), l):
                if (s := sum(d)) > 0 and sorted(sympydigits(s * n, 7)[1:]) == list(d):
                    break
            else:
                continue
            break


def A058905_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        for l in count(1):
            if l * n << 3 < 9 ** (l - 1):
                yield n
                break
            for d in combinations_with_replacement(range(9), l):
                if (s := sum(d)) > 0 and sorted(sympydigits(s * n, 9)[1:]) == list(d):
                    break
            else:
                continue
            break


def A058907_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        for l in count(1):
            if 11 * l * n < 12 ** (l - 1):
                yield n
                break
            for d in combinations_with_replacement(range(12), l):
                if (s := sum(d)) > 0 and sorted(sympydigits(s * n, 12)[1:]) == list(d):
                    break
            else:
                continue
            break


def A360181_gen(startvalue=0):  # generator of terms
    f = factorial(m := max(startvalue, 0))
    for k in count(m):
        if len(s := str(f)) <= sum(1 for d in s if d in {"1", "3", "5", "7", "9"}) << 1:
            yield k
        f *= k + 1


def A361470_gen():  # generator of terms
    x = 1
    for n in count(2):
        yield (y := gcd(x, n))
        x += x * n // y


def A362973(n):
    m, c = 10**n, 0
    for x in range(1, integer_nthroot(m, 5)[0] + 1):
        if all(d <= 1 for d in factorint(x).values()):
            for y in range(1, integer_nthroot(z := m // x**5, 4)[0] + 1):
                if gcd(x, y) == 1 and all(d <= 1 for d in factorint(y).values()):
                    c += integer_nthroot(z // y**4, 3)[0]
    return c


def A146208(n):
    ds = divisors(n)
    c, s = 0, [-d for d in ds[::-1]] + ds
    for x in s:
        d2 = [d // x for d in ds if d % x == 0]
        for y in (f - x for f in [-d for d in d2[::-1]] + d2):
            m, k = x * (z := x + y), 1
            while n >= abs(m) and k <= n:
                if n == m:
                    c += 1
                z += y
                m *= z
                k += 1
    return c


def A361015(n):
    ds = divisors(n)
    c, s = -len(ds) << 1, [-d for d in ds[::-1]] + ds
    for x in s:
        d2 = [d // x for d in ds if d % x == 0]
        for y in (f - x for f in [-d for d in d2[::-1]] + d2):
            m, k = x * (z := x + y), 1
            while n >= abs(m) and k <= n:
                if n == m:
                    c += 1
                z += y
                m *= z
                k += 1
    return c


def A359802(n):
    return prod((2, 3, 5, 7, 11, 13, 17, 19, 23, 29)[i] for i in map(int, str(n)))


def A337737(n):
    if n == 0:
        return 1
    a, k = 0, 1
    while True:
        m, c = k**3, 0
        for x in range(1, integer_nthroot(m, 5)[0] + 1):
            if all(d <= 1 for d in factorint(x).values()):
                for y in range(1, integer_nthroot(z := m // x**5, 4)[0] + 1):
                    if gcd(x, y) == 1 and all(d <= 1 for d in factorint(y).values()):
                        c += integer_nthroot(z // y**4, 3)[0]
        if c - a - 1 == n:
            return k - 1
        k += 1
        a = c


def A362961(n):
    c = 0
    for d in divisors(n):
        if (k := d**2) > n:
            break
        q, r = divmod(n, k)
        if not r:
            c += sum(
                d * (a[0] + (a[1] if a[0] != a[1] else 0))
                for a in cornacchia(1, 1, q) or []
            )
    return c


def A143574(n):
    c = 0
    for d in divisors(n):
        if (k := d**2) > n:
            break
        q, r = divmod(n, k)
        if not r:
            c += sum(
                k * (a[0] ** 2 + (a[1] ** 2 if a[0] != a[1] else 0))
                for a in cornacchia(1, 1, q) or []
            )
    return c


def A230486_gen(startvalue=2):  # generator of terms
    return filter(
        lambda n: (
            all(p & 3 == 1 for p in primefactors(n))
            if n & 1
            else any(p & 3 == 1 for p in primefactors(n))
        ),
        count(max(startvalue, 2)),
    )


def A304437_gen(startvalue=2):  # generator of terms
    return map(
        lambda n: min(min(a, b) for a, b in diop_DN(-1, n**n) if a > 0 and b > 0),
        filter(
            lambda n: (
                all(p & 3 == 1 for p in primefactors(n))
                if n & 1
                else any(p & 3 == 1 for p in primefactors(n))
            ),
            count(max(startvalue, 2)),
        ),
    )


def A363051(n):
    return sum(min(a) for a in diop_DN(-1, n)) >> 1


def A028392(n):
    return n + isqrt(n)


def A084888(n):
    return (
        (
            m := prod(
                1 if p == 2 else (3 * e + 1 if p & 3 == 1 else (3 * e + 1) & 1)
                for p, e in factorint(n).items()
            )
        )
        + ((((~(n**3) & n**3 - 1).bit_length() & 1) << 1) - 1 if m & 1 else 0)
    ) >> 1


def A000122(n):
    return is_square(n) << 1 if n else 1


def A089801(n):
    return int(is_square(3 * n + 1))


def A002448(n):
    return (-is_square(n) if n & 1 else is_square(n)) << 1 if n else 1


def A063725(n):
    f = factorint(n)
    return (
        prod(
            1 if p == 2 else (e + 1 if p & 3 == 1 else (e + 1) & 1)
            for p, e in f.items()
        )
        - (not any(e & 1 for e in f.values()))
        if n
        else 0
    )


def A008442(n):
    return (
        0
        if n & 3 != 1
        else sum(((a := d & 3) == 1) - (a == 3) for d in divisors(n, generator=True))
    )


def A290081(n):
    return (
        0
        if n & 1
        else (
            0
            if (m := n >> 1) & 3 != 1
            else sum(
                ((a := d & 3) == 1) - (a == 3) for d in divisors(m, generator=True)
            )
        )
    )


def A363122_gen(startvalue=2):  # generator of terms
    return filter(
        lambda n: n & -n
        > max(
            (p**e for p, e in factorint(n >> (~n & n - 1).bit_length()).items()),
            default=0,
        ),
        count(max(startvalue, 2)),
    )


def A116882_gen(startvalue=1):  # generator of terms
    return filter(lambda n: (n & -n) ** 2 >= n, count(max(startvalue, 1)))


def A363121(n):
    return (m := 2 * n - 1) << m.bit_length() if n > 1 else 1


def A363123_gen(startvalue=2):  # generator of terms
    return filter(
        lambda n: (m := n & -n)
        > max(
            (p**e for p, e in factorint(n >> (~n & n - 1).bit_length()).items()),
            default=1,
        )
        >= m >> 1,
        count(max(startvalue, 2)),
    )


def A318510(n):
    return prod(
        sum(
            reduce(
                lambda x, y: (x[0], x[0] + x[1]) if int(y) else (x[0] + x[1], x[1]),
                bin(nextprime(p))[-1:2:-1],
                (1, 0),
            )
        )
        ** e
        for p, e in factorint(n).items()
    )


def A284013(n):
    return (
        n
        - sum(
            reduce(
                lambda x, y: (x[0], x[0] + x[1]) if int(y) else (x[0] + x[1], x[1]),
                bin(n)[-1:2:-1],
                (1, 0),
            )
        )
        if n
        else 0
    )


def A318307(n):
    return 1 << sum(
        sum(
            reduce(
                lambda x, y: (x[0], x[0] + x[1]) if int(y) else (x[0] + x[1], x[1]),
                bin(e)[-1:2:-1],
                (1, 0),
            )
        )
        for e in factorint(n).values()
    )


def A318306(n):
    return sum(
        sum(
            reduce(
                lambda x, y: (x[0], x[0] + x[1]) if int(y) else (x[0] + x[1], x[1]),
                bin(e)[-1:2:-1],
                (1, 0),
            )
        )
        for e in factorint(n).values()
    )


def A318509(n):
    return prod(
        sum(
            reduce(
                lambda x, y: (x[0], x[0] + x[1]) if int(y) else (x[0] + x[1], x[1]),
                bin(p)[-1:2:-1],
                (1, 0),
            )
        )
        ** e
        for p, e in factorint(n).items()
    )


def A319687(n):
    return prod(
        sum(
            reduce(
                lambda x, y: (x[0], x[0] + x[1]) if int(y) else (x[0] + x[1], x[1]),
                bin(p)[-1:2:-1],
                (1, 0),
            )
        )
        ** e
        for p, e in factorint(n).items()
    ) - sum(
        reduce(
            lambda x, y: (x[0], x[0] + x[1]) if int(y) else (x[0] + x[1], x[1]),
            bin(n)[-1:2:-1],
            (1, 0),
        )
    )


def A127971(n):
    return sum(
        reduce(
            lambda x, y: (x[0], x[0] + x[1]) if int(y) else (x[0] + x[1], x[1]),
            bin(n + 1)[-1:2:-1],
            (1, 0),
        )
    ) + (n & 1)


def A286387(n):
    return (
        sum(
            reduce(
                lambda x, y: (x[0], x[0] + x[1]) if int(y) else (x[0] + x[1], x[1]),
                bin(n**2)[-1:2:-1],
                (1, 0),
            )
        )
        if n
        else 0
    )


def A295087_gen():  # generator of terms
    s = {0}
    yield 0
    for n in count(1):
        if (
            m := sum(
                reduce(
                    lambda x, y: (x[0], x[0] + x[1]) if int(y) else (x[0] + x[1], x[1]),
                    bin(n)[-1:2:-1],
                    (1, 0),
                )
            )
        ) not in s:
            yield m
            s.add(m)


def A071412(n):
    return (
        sum(
            reduce(
                lambda x, y: (
                    (x[0], (x[0] + x[1]) % 3) if int(y) else ((x[0] + x[1]) % 3, x[1])
                ),
                bin(n)[-1:2:-1],
                (1, 0),
            )
        )
        % 3
        if n
        else 0
    )


def A071911_gen(startvalue=0):  # generator of terms
    return filter(
        lambda n: not (
            n
            and sum(
                reduce(
                    lambda x, y: (
                        (x[0], (x[0] + x[1]) % 3)
                        if int(y)
                        else ((x[0] + x[1]) % 3, x[1])
                    ),
                    bin(n)[-1:2:-1],
                    (1, 0),
                )
            )
            % 3
        ),
        count(max(startvalue, 0)),
    )


def A319864(n):
    while (
        m := sum(
            reduce(
                lambda x, y: (x[0], x[0] + x[1]) if int(y) else (x[0] + x[1], x[1]),
                bin(n)[-1:2:-1],
                (1, 0),
            )
        )
    ) > 1:
        n = m
    return n.bit_length() - 1


def A007306(n):
    return (
        sum(
            reduce(
                lambda x, y: (x[0], sum(x)) if int(y) else (sum(x), x[1]),
                bin((n << 1) - 1)[-1:2:-1],
                (1, 0),
            )
        )
        if n
        else 1
    )


def A318316(n):
    return 1 << sum(
        sum(
            reduce(
                lambda x, y: (x[0], sum(x)) if int(y) else (sum(x), x[1]),
                bin((e << 1) - 1)[-1:2:-1],
                (1, 0),
            )
        )
        for e in factorint(n).values()
    )


def A318322(n):
    return sum(
        sum(
            reduce(
                lambda x, y: (x[0], sum(x)) if int(y) else (sum(x), x[1]),
                bin((e << 1) - 1)[-1:2:-1],
                (1, 0),
            )
        )
        for e in factorint(n).values()
    )


def A122155(n):
    return (
        int(
            ("1" if (m := len(s := bin(n)[2:]) - (n & -n).bit_length()) > 0 else "")
            + "".join(str(int(d) ^ 1) for d in s[1:m])
            + s[m:],
            2,
        )
        if n
        else 0
    )


def A362864_gen():  # generator of terms
    c = 0
    for k in count(1):
        if not (c := c + k - divisor_count(k)) % k:
            yield k


def A363060_gen(startvalue=1):  # generator of terms
    m = 1 << (k := max(startvalue, 1))
    for i in count(k):
        if str(m)[0] == "5":
            yield i
        m <<= 1


def A363195_gen():  # generator of terms
    for n in count(1):
        f = factorint(n).values()
        if all(e > 2 for e in f):
            yield prod(e + 1 for e in f)


def A362986_gen():  # generator of terms
    for n in count(1):
        f = factorint(n)
        if all(e > 2 for e in f.values()):
            yield prod((p ** (e + 1) - 1) // (p - 1) for p, e in f.items())


def A180114_gen():  # generator of terms
    for n in count(1):
        f = factorint(n)
        if all(e > 1 for e in f.values()):
            yield prod((p ** (e + 1) - 1) // (p - 1) for p, e in f.items())


def A363194_gen():  # generator of terms
    for n in count(1):
        f = factorint(n).values()
        if all(e > 1 for e in f):
            yield prod(e + 1 for e in f)


def A363215_gen(startvalue=2):  # generator of terms
    return filter(
        lambda n: pow(3, n - 1 >> (~(n - 1) & n - 2).bit_length(), n) == 1,
        count(max(startvalue, 2)),
    )


def A363508_gen():  # generator of terms
    return filter(lambda n: "2" not in gmpy2digits(n, 3), (n**2 for n in count(0)))


def A363428_gen():  # generator of terms
    return filter(lambda n: "0" not in gmpy2digits(n, 3), (n**2 for n in count(0)))


def A007956(n):
    return isqrt(n) ** (d - 2) if (d := divisor_count(n)) & 1 else n ** ((d >> 1) - 1)


def A361246(n):
    if n == 1:
        return 2
    alist, blist, c, klist = [], [], 1, list(range(n, 1, -1))
    while klist:
        k = klist.pop(0)
        if not c % k:
            blist.append(k)
        else:
            c = lcm(c, k)
            alist.append(k)
            for m in klist.copy():
                if not k % m:
                    klist.remove(m)
    for d in product([0, 1], repeat=len(alist)):
        x = solve_congruence(*zip(d, alist))
        if x is not None:
            y = x[0]
            if y > 1:
                for b in blist:
                    if y % b > 1:
                        break
                else:
                    if y < c:
                        c = y
    return int(c)


def A064219(n):
    if n == 1:
        return 1
    alist, blist, c, klist = [], [], 1, list(range(n, 1, -1))
    while klist:
        k = klist.pop(0)
        if not c % k:
            blist.append(k)
        else:
            c = lcm(c, k)
            alist.append(k)
            for m in klist.copy():
                if not k % m:
                    klist.remove(m)
    for d in product([0, 1], repeat=len(alist)):
        x = solve_congruence(*zip(d, alist))
        if x is not None:
            y = x[0]
            if y > 1:
                for b in blist:
                    if y % b > 1:
                        break
                else:
                    if y < c:
                        c = y
    return int(c - 1)


def A363533(n):
    a, b, k = 1, 1, 1
    while not isprime(n * a + 1):
        a, b, k = b, a + b, k + 1
    return k


def A363763(n):
    for k in range(n >> 1, ((n + 1) ** 2 << 1) + 1):
        c = 0
        for m in range(k**2 + 1, (k + 1) ** 2):
            if all(p == 2 or p & 3 == 1 or e & 1 ^ 1 for p, e in factorint(m).items()):
                c += 1
                if c > n:
                    break
        if c == n:
            return k
    return -1


def A077773(n):
    return sum(
        1
        for m in range(n**2 + 1, (n + 1) ** 2)
        if all(p == 2 or p & 3 == 1 or e & 1 ^ 1 for p, e in factorint(m).items())
    )


def A363691_gen(startvalue=3):  # generator of terms
    return filter(
        lambda n: all(
            d == 1 or d == n or n | d != n for d in divisors(n, generator=True)
        ),
        count(max(startvalue, 3) | 1, 2),
    )


def A363690_gen(startvalue=2):  # generator of terms
    return filter(
        lambda n: (m := n & -n) != n
        and all(d == m or d == n or n | d != n for d in divisors(n, generator=True)),
        count(max(startvalue, 2)),
    )


def A080942(n):
    return sum(
        1
        for d in divisors(n, generator=True)
        if not (d ^ n) & ((1 << d.bit_length()) - 1)
    )


def A080943_gen(startvalue=3):  # generator of terms
    return filter(
        lambda n: (m := n & -n) != n
        and all(
            d == m or d == n or (d ^ n) & ((1 << d.bit_length()) - 1)
            for d in divisors(n, generator=True)
        ),
        count(max(startvalue, 3)),
    )


def A080940(n):
    return (m := n & -n) * (m != n)


def A362531(n):
    m = 1
    while True:
        for k in range(n, 0, -1):
            if (l := k - m % (k << 1)) > 0:
                break
        else:
            return m
        m += l


def A362739(n):
    return (
        n >> 1
        if (m := n & -n) == n
        else n * ((p := min(primefactors(n // m))) - 1) // p >> 1
    )


def A060681(n):
    return n - n // min(primefactors(n), default=1)


def A362583(n):
    c = 0
    for i in range(2, n + 1):
        c = (c << 1) + (prime(i) & 3 == 3)
    return c


def A036538(n):
    return sum(
        1
        for m in range(1, (1 << n) + 1)
        if all(map(lambda w: not ((k := w + 1) & -k) ^ k, factorint(m).values()))
    )


def A336591_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: all(e == 1 or e == 3 for e in factorint(n).values()),
        count(max(startvalue, 1)),
    )


def A268335_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: all(e & 1 for e in factorint(n).values()), count(max(startvalue, 1))
    )


def A363761(n):
    for k in range(n >> 1, 3 * n):
        c = 0
        for m in range(k**2 + 1, (k + 1) ** 2):
            if all(p == 2 or p & 3 == 1 or e & 1 ^ 1 for p, e in factorint(m).items()):
                c += 1
                if c > n:
                    break
        if c == n:
            return k
    return -1


def A363762_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        for k in range(n >> 1, 3 * n):
            c = 0
            for m in range(k**2 + 1, (k + 1) ** 2):
                if all(
                    p == 2 or p & 3 == 1 or e & 1 ^ 1 for p, e in factorint(m).items()
                ):
                    c += 1
                    if c > n:
                        break
            if c == n:
                break
        else:
            yield n


def A100672(n):
    return int(prime(n) >> 1 & 1)


def A045326_gen():  # generator of terms
    return filter(lambda n: n >> 1 & 1, map(prime, count(1)))


def A362361(n):
    return (n << 10) - 3


def A362843_gen(startvalue=0):  # generator of terms
    return filter(
        lambda n: n == sum(int(d) ** ((i << 1) + 1) for i, d in enumerate(str(n))),
        count(max(startvalue, 0)),
    )


def A363673(n):
    m = (1 << (prime(n) << 1)) - 1
    a, b = divmod(m, 3)
    while not b:
        m = a
        a, b = divmod(m, 3)
    return min(primefactors(m))


def A152099(n):
    return (1 << (prime(n) << 1)) - 1


@lru_cache(maxsize=None)
def A306789(n):
    return (
        A306789(n - 1)
        * 2
        * n
        * factorial(2 * n - 1) ** 2
        // factorial(n) ** 3
        // n ** (n - 1)
        if n
        else 1
    )


@lru_cache(maxsize=None)
def A362174(n):
    return (
        A362174(n - 1)
        * (2 * n - 1)
        * factorial(2 * n - 2) ** 2
        // n
        // factorial(n - 1) ** 3
        // (n - 1) ** (n - 1)
        if n
        else 1
    )


def A363299(n):
    return 2 + (((1 << n + 1) + 3**n) << n)


def A363905_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: len(set(str(n**2)) | set(str(n**3))) == 10, count(max(startvalue, 1))
    )


def A028399(n):
    return (1 << n) - 4


def A175164(n):
    return (1 << n) - 1 << 4


def A175165(n):
    return (1 << n) - 1 << 5


def A175166(n):
    return (1 << n) - 1 << 6


def A037481(n):
    return (1 << (n << 1 | 1)) // 5


def A363773(n):
    return (1 << (n << 1 | 1)) // 5 + 1


def A015521(n):
    return ((1 << (n << 1)) | 1) // 5


def A247281(n):
    return (1 << (n << 1)) + (1 if n & 1 else -1)


def A363734(n):
    return (n - 1) * divisor_count(n) + n + 1 if n else 0


def A363735(n):
    return n * (n + 1) - (n - 1) * divisor_count(n) if n else 1


def A363421(n):
    return n**2 - 2 * (n - 1) * divisor_count(n) - 1 if n else 1


def A363913(n):
    return sum(3**k for k in divisors(n, generator=True)) if n else 1


def A362332_gen():  # generator of terms
    a, ndict = 2, {1: 1, 2: 2}
    yield from [1, 2]
    for n in count(3):
        yield (a := ndict[n] if n in ndict else (a * n if a % n else a // n))
        ndict[a] = n


def A340612_gen():  # generator of terms
    a, ndict = 0, {0: 0}
    yield 0
    for n in count(1):
        yield (
            a := (
                ndict[n]
                if n in ndict
                else (a - n if a >= n and a - n not in ndict else a + n)
            )
        )
        ndict[a] = n


def A340593_gen():  # generator of terms
    a, ndict = 0, {0: 0}
    yield 0
    for n in count(1):
        yield (
            a := (
                (a - m if a >= (m := ndict[n]) and a - m not in ndict else a + m)
                if n in ndict
                else (a - n if a >= n and a - n not in ndict else a + n)
            )
        )
        ndict[a] = n


def A340733_gen():  # generator of terms
    a, ndict = 0, {0: 0}
    yield 0
    for n in count(1):
        yield (
            a := (
                (a - m if a >= (m := n - ndict[n]) and a - m not in ndict else a + m)
                if n in ndict
                else (a - n if a >= n and a - n not in ndict else a + n)
            )
        )
        ndict[a] = n


def A362373_gen():  # generator of terms
    a, ndict = 0, {0: 0}
    yield 0
    for n in count(1):
        yield (
            a := (
                ndict[n]
                if n in ndict
                else (a - n if a >= n and a - n not in ndict else a + n)
            )
        )
        ndict[a] = ndict.get(a, 0) + n


def A364027_gen():  # generator of terms
    a, b, ndict = 0, 0, {0: 1}
    yield from (0, 0)
    while True:
        a, b = b, ndict[a + b]
        yield b
        ndict[a + b] = ndict.get(a + b, 0) + 1


def A364036_gen():  # generator of terms
    a, b, ndict = 0, 0, {0: 1}
    while True:
        a, b = b, ndict[a + b]
        yield b - 1
        ndict[a + b] = ndict.get(a + b, 0) + 1


def A363895(n):
    return sum(p := primefactors(n)) // len(p)


def A363052_gen(startvalue=1):  # generator of terms
    for m in count(max(startvalue, 1)):
        for k in divisors(m**2, generator=True):
            p, q = integer_nthroot(k**4 + (k * m**2 << 2), 2)
            if q:
                a, b = divmod(p - k**2, k << 1)
                if a > 0 and not b:
                    yield m
                    break


def A088915_gen(startvalue=0):  # generator of terms
    for m in count(max(startvalue, 0)):
        if m == 0:
            yield m
        else:
            for k in divisors(m, generator=True):
                p, q = integer_nthroot(k**4 + (k * m << 2), 2)
                if q and not (p - k**2) % (k << 1):
                    yield m
                    break


def A121741_gen(startvalue=1):  # generator of terms
    for m in count(max(startvalue, 1)):
        for k in divisors(m << 1, generator=True):
            p, q = integer_nthroot(k**4 + (k * m << 3), 2)
            if q and not (p - k**2) % (k << 1):
                yield m
                break


def A162651_gen(startvalue=1):  # generator of terms
    for m in count(max(startvalue, 1)):
        for r in divisors(m, generator=True):
            if is_square(r**2 - m // r):
                yield m
                break


def A363227_gen(startvalue=1):  # generator of terms
    for m in count(max(startvalue, 1)):
        c = {0}
        for d in divisors(m, generator=True):
            c.update({a + d for a in c} | {a - d for a in c})
        if all(k in c for k in range(1, m + 1)):
            yield m


def A005153_gen(startvalue=1):  # generator of terms
    for m in count(max(startvalue, 1)):
        if m == 1:
            yield 1
        else:
            l = (~m & m - 1).bit_length()
            if l > 0:
                P = (1 << l + 1) - 1
                for p, e in factorint(m >> l).items():
                    if p > 1 + P:
                        break
                    P *= (p ** (e + 1) - 1) // (p - 1)
                else:
                    yield m


def A334083_gen():  # generator of terms
    for n in count(0):
        m, flag = 1 << n, True
        for k in range(1, m):
            c = comb(m, k)
            if c > 1:
                l = (~c & c - 1).bit_length()
                if l > 0:
                    P = (1 << l + 1) - 1
                    for p, e in factorint(c >> l).items():
                        if p > 1 + P:
                            flag = False
                            break
                        P *= (p ** (e + 1) - 1) // (p - 1)
                else:
                    flag = False
                    break
        if flag:
            yield m


def A334082(n):
    m = 0
    for k in range(1, n):
        c = comb(n, k)
        l = (~c & c - 1).bit_length()
        if l > 0:
            P = (1 << l + 1) - 1
            for p, e in factorint(c >> l).items():
                if p > 1 + P:
                    break
                P *= (p ** (e + 1) - 1) // (p - 1)
            else:
                continue
            m += 1
        else:
            m += 1
    return m


def A334084_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        for k in range(1, n):
            c = comb(n, k)
            l = (~c & c - 1).bit_length()
            if l > 0:
                P = (1 << l + 1) - 1
                for p, e in factorint(c >> l).items():
                    if p > 1 + P:
                        break
                    P *= (p ** (e + 1) - 1) // (p - 1)
                else:
                    break
        else:
            yield n


def A237287_gen(startvalue=1):  # generator of terms
    for m in count(max(startvalue, 1)):
        if m > 1:
            l = (~m & m - 1).bit_length()
            if l > 0:
                P = (1 << l + 1) - 1
                for p, e in factorint(m >> l).items():
                    if p > 1 + P:
                        yield m
                        break
                    P *= (p ** (e + 1) - 1) // (p - 1)
            else:
                yield m


def A184387(n):
    return (m := divisor_sigma(n)) * (m + 1) >> 1


def A237290(n):
    ds = divisors(n)
    c, s = {0}, sum(ds)
    for d in ds:
        c.update({a + d for a in c})
    return sum(a for a in c if 1 <= a <= s)


def A237289(n):
    ds = divisors(n)
    c, s = {0}, sum(ds)
    for d in ds:
        c.update({a + d for a in c})
    return (s * (s + 1) >> 1) - sum(a for a in c if 1 <= a <= s)


def A119347(n):
    c = {0}
    for d in divisors(n, generator=True):
        c.update({a + d for a in c})
    return len(c) - 1


def A225561(n):
    c = {0}
    for d in divisors(n, generator=True):
        c.update({a + d for a in c})
    k = 1
    while k in c:
        k += 1
    return k - 1


def A030057(n):
    c = {0}
    for d in divisors(n, generator=True):
        c.update({a + d for a in c})
    k = 1
    while k in c:
        k += 1
    return k


def A308605(n):
    c = {0}
    for d in divisors(n, generator=True):
        c.update({a + d for a in c})
    return len(c)


def A007620_gen(startvalue=1):  # generator of terms
    for m in count(max(startvalue, 1)):
        if m == 1:
            yield 1
        else:
            c = {0}
            for d in divisors(m, generator=True):
                if d < m:
                    c.update({a + d for a in c})
            if all(a in c for a in range(m + 1)):
                yield m


def A003624_gen(startvalue=2):  # generator of terms
    return filter(
        lambda k: not isprime(k) and gcd(k, divisor_sigma(k)) == 1,
        count(max(startvalue, 2)),
    )


def A088827_gen(startvalue=2):  # generator of terms
    return filter(
        lambda n: is_square(n) or is_square(n >> 1),
        count(max(startvalue + (startvalue & 1), 2), 2),
    )


def A088828_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: not is_square(n), count(max(startvalue + (startvalue & 1 ^ 1), 1), 2)
    )


def A016754(n):
    return ((n << 1) | 1) ** 2


def A364089(n):
    m = 1 << (l := ((r := n**n) - (r - n) // (n - 1) ** 2).bit_length() - 1)
    while len(d := sympydigits(m, n)[1:]) > len(set(d)):
        l -= 1
        m >>= 1
    return l


if sys.version_info >= (3, 10):

    def A362951(n):
        return (n ^ totient(n)).bit_count()

else:

    def A362951(n):
        return bin(n ^ totient(n)).count("1")


def A263879(n):
    if n <= 2:
        return 7 - n
    p, c = prime(n), 1
    while isprime(p := (p << 1) + (-1 if p % 3 == 1 else 1)):
        c += 1
    return c


def A364091(n):
    if 5 <= n <= 6:
        return 8 - n
    q = 5
    while True:
        p, c = q, 1
        while isprime(p := (p << 1) + (-1 if p % 3 == 1 else 1)):
            c += 1
            if c > n:
                break
        if c == n:
            return q
        q = nextprime(q)


def A002208(n):
    return (-1 if n & 1 else 1) * (
        sum(
            Fraction(stirling(n + 1, k + 1, kind=1, signed=True), k + 1)
            for k in range(n + 1)
        )
        / factorial(n)
    ).numerator


def A002209(n):
    return (
        sum(
            Fraction(stirling(n + 1, k + 1, kind=1, signed=True), k + 1)
            for k in range(n + 1)
        )
        / factorial(n)
    ).denominator


def A006233(n):
    return sum(
        Fraction(stirling(n, k, kind=1, signed=True), k + 1) for k in range(n + 1)
    ).denominator


def A006232(n):
    return sum(
        Fraction(stirling(n, k, kind=1, signed=True), k + 1) for k in range(n + 1)
    ).numerator


def A081085(n):
    return sum(
        (1 << (n - (m := k << 1) << 1)) * comb(n, m) * comb(m, k) ** 2
        for k in range((n >> 1) + 1)
    )


def A363590(n):
    return sum(d**d for d in divisors(n >> (~n & n - 1).bit_length(), generator=True))


def A333823(n):
    return sum(
        (n // d) ** d for d in divisors(n >> (~n & n - 1).bit_length(), generator=True)
    )


def A333824(n):
    return sum(
        d ** (n // d) for d in divisors(n >> (~n & n - 1).bit_length(), generator=True)
    )


def A363991(n):
    return sum(
        d ** (d + 1) for d in divisors(n >> (~n & n - 1).bit_length(), generator=True)
    )


def A363228(n):
    return (~n & n - 1).bit_length() + 3 >> 1


def A244415(n):
    return (~n & n - 1).bit_length() + 1 >> 1


def A240226(n):
    return 1 << ((~n & n - 1).bit_length() + 1 & -2)


def A147810(n):
    return divisor_count(n**2 + 1) >> 1 if n else 1


def A363522(n):
    s = 0
    for k in range(n >> 1, ((n + 1) ** 2 << 1) + 1):
        c = 0
        for m in range(k**2 + 1, (k + 1) ** 2):
            if all(p == 2 or p & 3 == 1 or e & 1 ^ 1 for p, e in factorint(m).items()):
                c += 1
                if c > n:
                    break
        if c == n:
            s += 1
    return s


def A053529(n):
    return factorial(n) * npartitions(n)


def A362676(n):
    return int(hyperexpand(hyper((-n, 1 - n, S.Half), [1, 1], 1)) * (1 << (n << 1)))


def A363985(n):
    return int(
        hyperexpand(hyper((-n, (m := n << 1) + 1, S.Half), [1, 1], 1))
        * (-(1 << m) if n & 1 else 1 << m)
    )


def A143127(n):
    return -(((k := isqrt(n)) * (k + 1) >> 1) ** 2) + sum(
        i * (m := n // i) * (1 + m) for i in range(1, k + 1)
    )


def A083356(n):
    return (k := isqrt(n)) * (k + 1) * (2 + 4 * k - 3 * k * (k + 1)) // 24 + sum(
        i * (m := n // i) * (1 + m) >> 1 for i in range(1, k + 1)
    )


def A060872(n):
    return n * (divisor_count(n) + 1 >> 1)


def A364146_gen(startvalue=0):
    for k in count(max(startvalue, 0)):
        m = factorial(k)
        for d in divisors(m, generator=True):
            if d * divisor_count(d) == m:
                yield k
                break


def A363923(n):
    return prod(n**e // p for p, e in factorint(n).items())


def A205959(n):
    return prod(n // p for p in primefactors(n))


def A304404(n):
    return int(n ** (primenu(n) - 1))


def A028310(n):
    return n | bool(n) ^ 1


def A052955(n):
    return ((2 | n & 1) << (n >> 1)) - 1


def A364061_gen(startvalue=2):  # generator of terms
    return filter(
        lambda n: (l := (~n & n - 1).bit_length())
        < min(factorint(m := n >> l).values(), default=0)
        or m == 1,
        count(max(startvalue + startvalue & 1, 2), 2),
    )


def A194274(n):
    return (3 * n >> 2) + (n * (n + 2) + 1 >> 1) - (3 * n + 1 >> 2)


def A363518(n):
    return (
        6 * ((3 * n >> 2) + (n * (n + 2) + 1 >> 1) - (3 * n + 1 >> 2)) - 12 * n + 8
        if n > 1
        else 1
    )


def A007931(n):
    return int(bin(n + 1)[3:]) + (10 ** ((n + 1).bit_length() - 1) - 1) // 9


def A032810(n):
    return int(bin(n + 1)[3:]) + (10 ** ((n + 1).bit_length() - 1) - 1 << 1) // 9


def A256290(n):
    return int(bin(n + 1)[3:]) + (10 ** ((n + 1).bit_length() - 1) - 1 << 2) // 9


def A363286_gen(startvalue=3):  # generator of terms
    p = max(startvalue, 3) - 1
    while p := nextprime(p):
        if n_order(2, p) << 1 >= p - 1:
            yield p


def A163510_gen():  # generator of terms
    for n in count(1):
        k = n
        while k:
            yield (s := (~k & k - 1).bit_length())
            k >>= s + 1


def A163511(n):
    if n:
        k, c, m = n, 0, 1
        while k:
            c += 1
            m *= prime(c) ** (s := (~k & k - 1).bit_length())
            k >>= s + 1
        return m * prime(c)
    return 1


def A363285(n):
    m = 1 << n
    for r in count(1):
        s = prod(
            (p ** (e + 1 if p & 1 else e + n + 1) - 1) // (p - 1)
            for p, e in factorint(r).items()
        ) * ((m << 1) - 1 if r & 1 else 1)
        if abs(s - (r * m << 1)) == m:
            return r * m


def A228351_gen():  # generator of terms
    for n in count(1):
        k = n
        while k:
            yield (s := (~k & k - 1).bit_length() + 1)
            k >>= s


def A252464(n):
    return primeomega(n) + primepi(max(primefactors(n))) - 1 if n > 1 else 0


def A046660(n):
    return sum(e - 1 for e in factorint(n).values())


def A363919(n):
    return n ** sum(map(lambda e: e - 1, factorint(n).values()))


def A064690_gen():  # generator of terms
    ap, aq, sa = 1, 1, True
    for n in count(1):
        if (r := ap + aq) > 0:
            bq = aq * r
            bp = ap * r - aq**2
        else:
            bq = -aq * r
            bp = aq**2 - ap * r
        if sa is not (sb := bp > 0):
            yield n
        ap, aq, sa = bp, bq, sb


def A364258(n):
    c, p, k = 1, 1, n
    while k:
        c *= (p := nextprime(p)) ** (s := (~k & k - 1).bit_length())
        k >>= s + 1
    return c * p - n


def A364255(n):
    c, p, k = 1, 1, n
    while k:
        c *= (p := nextprime(p)) ** (s := (~k & k - 1).bit_length())
        k >>= s + 1
    return gcd(c * p, n)


def A324184(n):
    if n:
        c, p = 1, 1
        while n:
            c *= ((p := nextprime(p)) ** (s := (~n & n - 1).bit_length() + 1) - 1) // (
                p - 1
            )
            n >>= s
        return c * (p ** (s + 1) - 1) // (p**s - 1)
    return 1


def A324183(n):
    if n:
        c = 1
        while n:
            c *= (s := (~n & n - 1).bit_length() + 1)
            n >>= s
        return c * (s + 1) // s
    return 1


if sys.version_info >= (3, 10):

    def A192895(n):
        return sum(
            (d.bit_count() if d < n else -d.bit_count())
            for d in divisors(n, generator=True)
        )

    def A335420(n):
        c, p, k = 1, 1, n
        while k:
            c *= (p := nextprime(p)) ** (s := (~k & k - 1).bit_length())
            k >>= s + 1
        return (c * p).bit_count()

    def A059448(n):
        return (n.bit_length() ^ n.bit_count()) & 1

else:

    def A192895(n):
        return sum(
            (bin(d).count("1") if d < n else -bin(d).count("1"))
            for d in divisors(n, generator=True)
        )

    def A335420(n):
        c, p, k = 1, 1, n
        while k:
            c *= (p := nextprime(p)) ** (s := (~k & k - 1).bit_length())
            k >>= s + 1
        return bin(c * p).count("1")

    def A059448(n):
        return (n.bit_length() ^ bin(n).count("1")) & 1


def A161511(n):
    a, b = 0, 0
    for i, j in enumerate(bin(n)[:1:-1], 1):
        if int(j):
            a += i - b
            b += 1
    return a


def A161920(n):
    a, b = 1 + (m := n - 1).bit_length(), 1
    for i, j in enumerate(bin(m)[:1:-1], 1):
        if int(j):
            a += i - b
            b += 1
    return a


def A055941(n):
    a, b = 0, 1
    for i, j in enumerate(bin(n)[:1:-1], 1):
        if int(j):
            a += i - b
            b += 1
    return a


def A246016(n):
    a, b = 0, 0
    for i, j in enumerate(bin(n)[:1:-1]):
        if int(j):
            a ^= (i & 1) ^ b
            b ^= 1
    return -1 if a else 1


def A246017(n):
    c = 0
    for k in range(n + 1):
        a, b = 0, 1
        for i, j in enumerate(bin(k)[:1:-1]):
            if int(j):
                a ^= (i & 1) ^ (b := b ^ 1)
        c += -1 if a else 1
    return c


def A004761(n):
    return m + (1 << m.bit_length() - 1) if (m := n - 2) else n - 1


def A004760(n):
    return m + (1 << m.bit_length()) if (m := n - 2) > 0 else n - 1


def A364491(n):
    c, p, k = 1, 1, n
    while k:
        c *= (p := nextprime(p)) ** (s := (~k & k - 1).bit_length())
        k >>= s + 1
    return n // gcd(c * p, n)


def A364492(n):
    c, p, k = 1, 1, n
    while k:
        c *= (p := nextprime(p)) ** (s := (~k & k - 1).bit_length())
        k >>= s + 1
    return c * p // gcd(c * p, n)


def A364493(n):
    c, p, k = 1, 1, n
    while k:
        c *= (p := nextprime(p)) ** (s := (~k & k - 1).bit_length())
        k >>= s + 1
    return n * c * p // gcd(c * p, n) ** 2


def A054429_gen():  # generator of terms
    return (m for n in count(0) for m in range((1 << n + 1) - 1, (1 << n) - 1, -1))


def A009205(n):
    f = factorint(n).items()
    return gcd(
        prod(e + 1 for p, e in f), prod((p ** (e + 1) - 1) // (p - 1) for p, e in f)
    )


def A152054_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        l = len(s := tuple(int(d) for d in str(n)))
        for i in range(1, l - 1):
            if (s[i - 1] - s[i]) * (s[i] - s[i + 1]) < 0:
                yield n
                break


def A319744_gen():  # generator of terms
    c = 0
    for n in count(101):
        l = len(s := tuple(int(d) for d in str(n)))
        for i in range(1, l - 1):
            if (s[i - 1] - s[i]) * (s[i] - s[i + 1]) < 0:
                c += n
                yield c
                break


def A364549_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue + (startvalue & 1 ^ 1), 1), 2):
        if (
            not (
                sum(
                    pow(2, i + int(primepi(p)) - 1, n)
                    for i, p in enumerate(factorint(n, multiple=True))
                )
                + 1
            )
            % n
        ):
            yield n


def A364559(n):
    return (
        sum(1 << primepi(p) + i for i, p in enumerate(factorint(n, multiple=True), -1))
        + 1
        - n
    )


def A297167(n):
    return (
        primepi(max(f := factorint(n))) + sum(e - 1 for e in f.values()) - 1
        if n > 1
        else 0
    )


def A364557(n):
    return (
        1 << primepi(max(f := factorint(n))) + sum(e - 1 for e in f.values()) - 1
        if n > 1
        else 1
    )


def A364558(n):
    return (
        (1 << primepi(max(f := factorint(n))) + sum(e - 1 for e in f.values()) - 1)
        - prod(p ** (e - 1) * (p - 1) for p, e in f.items())
        if n > 1
        else 0
    )


def A131743(n):
    return (0, 1, 0, 2)[n & 3]


def A364447(n):
    return (3, 1, 2, 1)[n & 3]


def A364606_gen(startvalue=0):  # generator of terms
    m = mpz(1) << max(startvalue, 0)
    for k in count(max(startvalue, 0)):
        s = gmpy2digits(m)
        if not sum(int(d) for d in s) % len(s):
            yield k
        m <<= 1


def A057655(n):
    return 1 + (sum(isqrt(n - k**2) for k in range(isqrt(n) + 1)) << 2)


def A053557(n):
    return sum(
        Fraction(-1 if k & 1 else 1, factorial(k)) for k in range(n + 1)
    ).numerator


def A053556(n):
    return sum(
        Fraction(-1 if k & 1 else 1, factorial(k)) for k in range(n + 1)
    ).denominator


def A103816(n):
    return sum(
        Fraction(1 if k & 1 else -1, factorial(k)) for k in range(1, n + 1)
    ).numerator


def A364444(n):
    return sum(
        1
        for k in range(n**2 + 1, (n + 1) ** 2)
        if (m := (~k & k - 1).bit_length()) & 1 or (k >> m) & 7 < 7
    )


def A364445_gen():  # generator of terms
    a = 0
    for n in count(1):
        b = sum(
            1
            for k in range(n**2 + 1, (n + 1) ** 2)
            if (m := (~k & k - 1).bit_length()) & 1 or (k >> m) & 7 < 7
        )
        yield from range(a + 1, b)
        a = b


def A005810(n):
    return comb(n << 2, n)


def A004381(n):
    return comb(n << 3, n)


def A000415_gen(startvalue=2):  # generator of terms
    for n in count(max(startvalue, 2)):
        f = factorint(n).items()
        if any(e & 1 for p, e in f if p & 3 < 3) and not any(
            e & 1 for p, e in f if p & 3 == 3
        ):
            yield n


def A072401(n):
    return ((m := (~n & n - 1).bit_length()) & 1 ^ 1) & int((n >> m) & 7 == 7)


def A072400(n):
    return (n >> ((~n & n - 1).bit_length() & -2)) & 7


def A002828(n):
    if n == 0:
        return 0
    f = factorint(n).items()
    if not any(e & 1 for p, e in f):
        return 1
    if all(p & 3 < 3 or e & 1 ^ 1 for p, e in f):
        return 2
    return 3 + (((m := (~n & n - 1).bit_length()) & 1 ^ 1) & int((n >> m) & 7 == 7))


def A053610(n):
    c = 0
    while n:
        n -= isqrt(n) ** 2
        c += 1
    return c


def A062535(n):
    c, k, f = 0, n, factorint(n).items()
    while k:
        k -= isqrt(k) ** 2
        c += 1
    if not any(e & 1 for p, e in f):
        return c - 1
    if all(p & 3 < 3 or e & 1 ^ 1 for p, e in f):
        return c - 2
    return c - 3 - (((m := (~n & n - 1).bit_length()) & 1 ^ 1) & int((n >> m) & 7 == 7))


def A007770_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        m = n
        while m not in {1, 37, 58, 89, 145, 42, 20, 4, 16}:
            m = sum((0, 1, 4, 9, 16, 25, 36, 49, 64, 81)[ord(d) - 48] for d in str(m))
        if m == 1:
            yield n


def A090425_gen():  # generator of terms
    for n in count(1):
        c = 1
        while n not in {1, 37, 58, 89, 145, 42, 20, 4, 16}:
            n = sum((0, 1, 4, 9, 16, 25, 36, 49, 64, 81)[ord(d) - 48] for d in str(n))
            c += 1
        if n == 1:
            yield c


def A076712_gen():  # generator of terms
    for n in count(1):
        m = t = n * (n + 1) >> 1
        while m not in {1, 37, 58, 89, 145, 42, 20, 4, 16}:
            m = sum((0, 1, 4, 9, 16, 25, 36, 49, 64, 81)[ord(d) - 48] for d in str(m))
        if m == 1:
            yield t


def A031177_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        m = n
        while m not in {1, 37, 58, 89, 145, 42, 20, 4, 16}:
            m = sum((0, 1, 4, 9, 16, 25, 36, 49, 64, 81)[ord(d) - 48] for d in str(m))
        if m > 1:
            yield n


def A364682(n):
    c = 1
    while n not in {0, 1, 37, 58, 89, 145, 42, 20, 4, 16}:
        n = sum((0, 1, 4, 9, 16, 25, 36, 49, 64, 81)[ord(d) - 48] for d in str(n))
        c += 1
    return c


def A364479_gen():  # generator of terms
    n = 1
    while True:
        for z in (1, 3, 5, 7, 9):
            for y in range(z * n, (z + 1) * n):
                k, m = y // 10, 0
                while k >= 10:
                    k, r = divmod(k, 10)
                    m = 10 * m + r
                if isprime(a := y * n + 10 * m + k):
                    b = a
                    while b not in {1, 37, 58, 89, 145, 42, 20, 4, 16}:
                        b = sum(
                            (0, 1, 4, 9, 16, 25, 36, 49, 64, 81)[ord(d) - 48]
                            for d in str(b)
                        )
                    if b == 1:
                        yield a
        n *= 10


def A088732(n):
    return next(
        m for m in accumulate(repeat(n + 1), initial=(n << 1) + 1) if isprime(m)
    )


def A098731_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        m = n << 2
        while m not in {1, 37, 58, 89, 145, 42, 20, 4, 16}:
            m = sum((0, 1, 4, 9, 16, 25, 36, 49, 64, 81)[ord(d) - 48] for d in str(m))
        if m == 1:
            yield n


def A046519(n):
    m = 10 ** (n - 1)
    while m := nextprime(m):
        k = m
        while k not in {1, 37, 58, 89, 145, 42, 20, 4, 16}:
            k = sum((0, 1, 4, 9, 16, 25, 36, 49, 64, 81)[ord(d) - 48] for d in str(k))
        if k == 1:
            return m


def A124095_gen():  # generator of terms
    for l in count(1):
        for m in combinations_with_replacement("123456789", l):
            k = t = int("".join(m))
            while k not in {1, 37, 58, 89, 145, 42, 20, 4, 16}:
                k = sum(
                    (0, 1, 4, 9, 16, 25, 36, 49, 64, 81)[ord(d) - 48] for d in str(k)
                )
            if k == 1:
                yield t


def A193573(n):
    a = 1
    for k in count(2):
        m = k
        while m not in {1, 37, 58, 89, 145, 42, 20, 4, 16}:
            m = sum((0, 1, 4, 9, 16, 25, 36, 49, 64, 81)[ord(d) - 48] for d in str(m))
        if m == 1:
            if k - a == n:
                return a
            a = k


def A321284(n):
    return (1 << 35 * 3**n + 1) + 2


def A321308_gen(startvalue=2):  # generator of terms
    for m in count(max(startvalue, 2) + (max(startvalue, 2) & 1), 2):
        f = list(factorint(m).items())
        if all(
            f[i][0]
            <= 1
            + prod((f[j][0] ** (f[j][1] + 1) - 1) // (f[j][0] - 1) for j in range(i))
            for i in range(len(f))
        ):
            f = list(factorint(m**4 + 2).items())
            if all(
                f[i][0]
                <= 1
                + prod(
                    (f[j][0] ** (f[j][1] + 1) - 1) // (f[j][0] - 1) for j in range(i)
                )
                for i in range(len(f))
            ):
                yield m


def A225316(n):
    if n:
        c, k = 1, 1 << n
        for m in count(2, 2):
            f = list(factorint(m).items())
            if all(
                f[i][0]
                <= 1
                + prod(
                    (f[j][0] ** (f[j][1] + 1) - 1) // (f[j][0] - 1) for j in range(i)
                )
                for i in range(len(f))
            ):
                c += 1
                if c == k:
                    return m
    else:
        return 1


def A008480(n):
    return factorial(sum(f := factorint(n).values())) // prod(map(factorial, f))


def A363694(n):
    c, m, p = 0, 1, 2
    while p << 1 < n:
        c += primepi(n - p) - m
        p = nextprime(p)
        m += 1
    return c


def A363873(n):
    m, s = 1 << (k := n.bit_length() - 1), str(n)
    while m <= n or not str(m).startswith(s):
        k += 1
        m <<= 1
    return k


def A364443(n):
    return sum(
        1
        for k in range(n**2 + 1, (n + 1) ** 2)
        if not any(e & 1 for p, e in factorint(k).items() if p % 3 == 2)
    )


def A364499(n):
    return (
        prod(
            prime(len(a) + 1) ** b
            for a, b in Counter(accumulate(bin(n - 1)[2:].split("1")[:0:-1])).items()
        )
        - n
    )


def A364189(n):
    b = {
        a := tuple(divisor_count(i) for i in range(1, n + 1)),
    }
    for m in count(n + 1):
        if (a := a[1:] + (divisor_count(m),)) in b:
            return m - n + 1
        b.add(a)


def A364517(n):
    return (
        int(
            5
            * factorial(9 * n)
            * factorial2(7 * n) ** 2
            // factorial2(9 * n)
            // factorial(7 * n)
            // factorial2(5 * n)
            // factorial(n) ** 2
            // 7
        )
        if n
        else 1
    )


def A352652(n):
    return int(
        factorial(7 * n)
        * factorial2(5 * n) ** 2
        // factorial(5 * n)
        // factorial2(7 * n)
        // factorial2(3 * n)
        // factorial(n) ** 2
    )


def A275654(n):
    return int(
        factorial(5 * n)
        * factorial2(3 * n)
        * factorial2(7 * n)
        // factorial(3 * n)
        // factorial(n) ** 2
        // factorial2(5 * n) ** 2
    )


def A275652(n):
    return int(
        factorial(3 * n)
        * factorial2(5 * n)
        * factorial2(n)
        // factorial2(3 * n) ** 2
        // factorial(n) ** 3
    )


def A352651(n):
    return int(
        factorial(5 * n)
        * factorial2(3 * n) ** 2
        // factorial(3 * n)
        // factorial2(5 * n)
        // factorial(n) ** 2
        // factorial2(n)
    )


def A089625(n):
    c, p = 0, 2
    while n:
        if n & 1:
            c += p
        n >>= 1
        p = nextprime(p)
    return c


def A364801(n):
    if n < 4:
        return 0
    a, b, s = 1, 2, 0
    for i in bin(n)[-1:1:-1]:
        if int(i):
            s += a
        a, b = b, a + b
    return A364801(s) + 1


def A229522(n):
    return (0, 1, 6, 3, 6, 5, 6, 7, 6, 9)[n % 10]


def A364789(n):
    return int(str((n**n) ** n)[0])


def A364304(n):
    return int(
        factorial(7 * n)
        * factorial2(9 * n)
        * factorial2(5 * n)
        // factorial(5 * n)
        // factorial2(7 * n) ** 2
        // factorial(n) ** 2
    )


def A276098(n):
    return int(
        (factorial(7 * n) * factorial2(3 * n) << (n << 1))
        // factorial2(7 * n)
        // factorial(3 * n)
        // factorial(n << 1)
    )


def A276099(n):
    return int(
        (factorial(9 * n) * factorial2(5 * n) << (n << 1))
        // factorial2(9 * n)
        // factorial(5 * n)
        // factorial(n << 1)
    )


def A262733(n):
    return int(
        (factorial(7 * n) * factorial2(5 * n) << n)
        // (factorial2(7 * n) * factorial(5 * n) * factorial(n))
    )


def A347854(n):
    return int(
        (factorial(6 * n) * factorial2(n) << n)
        // (factorial(3 * n) * factorial(n << 1) * factorial2(3 * n))
    )


def A347856(n):
    return int(
        (factorial(6 * n) * factorial2(n) << n)
        // (factorial(n << 2) * factorial(n) * factorial2(3 * n))
    )


def A347857(n):
    return int(
        (factorial(6 * n) * factorial2(3 * n) << n)
        // (factorial(3 * n) * factorial(n << 1) * factorial2(5 * n))
    )


def A347858(n):
    return int(
        (factorial(9 * n) * factorial2(n) << (n << 2))
        // (factorial(3 * n) * factorial(n << 1) * factorial2(9 * n))
    )


def A262732(n):
    return int(
        (factorial(5 * n) * factorial2(3 * n) << n)
        // (factorial2(5 * n) * factorial(3 * n) * factorial(n))
    )


def A091496(n):
    return int(
        (factorial(5 * n) * factorial2(n) << (n << 1))
        // (factorial(n) * factorial(n << 1) * factorial2(5 * n))
    )


def A091527(n):
    return int(
        (factorial(3 * n) * factorial2(n) << n)
        // (factorial(n) ** 2 * factorial2(3 * n))
    )


def A001448(n):
    return comb(n << 2, n << 1)


def A364867_gen(startvalue=4):  # generator of terms
    p = max(startvalue - 1, 3)
    while p := nextprime(p):
        if n_order(9, p) == p - 1 >> 1:
            yield p


def A105875_gen(startvalue=2):  # generator of terms
    p = max(startvalue - 1, 1)
    while p := nextprime(p):
        if p != 3 and n_order(-3, p) == p - 1:
            yield p


def A105874_gen(startvalue=3):  # generator of terms
    p = max(startvalue - 1, 2)
    while p := nextprime(p):
        if n_order(-2, p) == p - 1:
            yield p


def A060778(n):
    return gcd(divisor_count(n + 1), divisor_count(n))


def A010705(n):
    return 3 | ((n & 1) << 2)


def A364520(n):
    return int(
        (factorial(7 * n) * factorial2(n) << (3 * n))
        // (factorial2(7 * n) * factorial(n) * factorial(3 * n))
    )


def A365008_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        n5, flag = n**5, False
        for i1 in range(1, n):
            i15 = i1**5
            for i2 in range(i1, n):
                i25 = i15 + i2**5
                if i25 >= n5:
                    break
                for i3 in range(i2, n):
                    i35 = i25 + i3**5
                    if i35 >= n5:
                        break
                    for i4 in range(i3, n):
                        i45 = i35 + i4**5
                        if i45 >= n5:
                            break
                        for i5 in range(i4, n):
                            i55 = i5**5
                            i65 = n5 - i45 - i55
                            if i65 < i55:
                                break
                            if integer_nthroot(i65, 5)[1]:
                                yield n
                                flag = True
                                break
                        if flag:
                            break
                    if flag:
                        break
                if flag:
                    break
            if flag:
                break


def A365020_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        n5, flag = n**5, False
        for i1 in range(1, n):
            i15 = i1**5
            for i2 in range(i1, n):
                i25 = i15 + i2**5
                if i25 >= n5:
                    break
                for i3 in range(i2, n):
                    i35 = i25 + i3**5
                    if i35 >= n5:
                        break
                    for i4 in range(i3, n):
                        i45 = i35 + i4**5
                        if i45 >= n5:
                            break
                        for i5 in range(i4, n):
                            i55 = i45 + i5**5
                            if i55 >= n5:
                                break
                            for i6 in range(i5, n):
                                i65 = i6**5
                                i75 = n5 - i55 - i65
                                if i75 < i65:
                                    break
                                if integer_nthroot(i75, 5)[1]:
                                    yield n
                                    flag = True
                                    break
                            if flag:
                                break
                        if flag:
                            break
                    if flag:
                        break
                if flag:
                    break
            if flag:
                break


def A364391(n):
    return n if n == 1 or isprime(n) else n - n // min(primefactors(n))


def A018892(n):
    return prod((a << 1) + 1 for a in factorint(n).values()) + 1 >> 1


def A365049(n):
    return sum(
        1
        + (prod((e + (p & 1) << 1) - 1 for p, e in factorint(d).items()) >> 1)
        + (
            prod((e + (p & 1) << 1) - 1 for p, e in factorint(n // d).items()) >> 1
            if d * d < n
            else 0
        )
        for d in takewhile(lambda d: d * d <= n, divisors(n))
    )


def A001196(n):
    return 3 * int(bin(n)[2:], 4)


def A224915(n):
    return 3 * int(bin(n)[2:], 4) - n >> 1


def A224923(n):
    return 3 * sum(int(bin(i)[2:], 4) for i in range(n + 1)) - (n * (n + 1) >> 1)


def A000695(n):
    return int(bin(n)[2:], 4)


def A062880(n):
    return int(bin(n)[2:], 4) << 1


def A062033(n):
    return int(bin(int(bin(n)[2:], 4))[2:]) * 10


def A065882(n):
    return (n >> ((~n & n - 1).bit_length() & -2)) & 3


def A235461_gen():  # generator of terms
    p = 1
    while p := nextprime(p):
        if isprime(m := int(bin(p)[2:], 4)):
            yield m


def A235462_gen():  # generator of terms
    p = 1
    while p := nextprime(p):
        if isprime(m := int(bin(p)[2:], 5)):
            yield m


def A365099(n):
    return len({pow(x, n, n**2) for x in range(n**2)})


def A023105(n):
    return ((1 << n - 1) + 5) // 3 if n else 1


def A195637(n):
    return len({pow(x, n, n) for x in range(n)})


def A331961(n):
    return next(m for m in (k**2 for k in range(isqrt(n), -1, -1)) if n & m == m)


def A330270(n):
    return next(k for k in count(0) if is_square(n ^ k))


if sys.version_info >= (3, 10):

    def A365089(n):
        return (n**3).bit_count() & 1

    def A228039(n):
        return (n**2).bit_count() & 1

else:

    def A365089(n):
        return bin(n**3).count("1") & 1

    def A228039(n):
        return bin(n**2).count("1") & 1


def A365100(n):
    return len({pow(x, n, n**3) for x in range(n**3)})


def A330271(n):
    return next(k for k in count(0) if integer_nthroot(n ^ k, 3)[1])


def A344220(n):
    return next(
        k
        for k in count(0)
        if (s := bin(n ^ k)[2:])[: (t := len(s) + 1 >> 1)] == s[: -t - 1 : -1]
    )


def A295520(n):
    return next(k for k in count(0) if isprime(n ^ k))


def A295793(n):
    return next(
        k
        for k in count(0)
        if next((m for m in range(n + 1) if isprime(k ^ m)), None) == n
    )


def A365101(n):
    return len({pow(x, n, n**4) for x in range(n**4)})


def A365102(n):
    return len({pow(x, n, n**5) for x in range(n**5)})


@lru_cache(maxsize=None)
def A365092(n):
    return (
        n - 1 << 1
        if n <= 2
        else (
            sum(A365092(p) + A365092(e) for p, e in factorint(n).items())
            if not isprime(n)
            else A365092(n - 1) + 1
        )
    )


def A365027(n):
    return int(
        factorial(7 * n)
        * factorial2(13 * n)
        * factorial2(n)
        // ((factorial2(7 * n) * factorial(3 * n)) ** 2 * factorial(n))
    )


def A365026(n):
    return int(
        factorial(5 * n)
        * factorial2(9 * n)
        * factorial2(n)
        // ((factorial2(5 * n) * factorial(n << 1)) ** 2 * factorial(n))
    )


def A365025_T(n, k):
    return int(
        factorial2(k)
        * factorial(r := ((m := n << 1) + 1) * k)
        * factorial2(((m << 1) + 1) * k)
        // ((factorial(n * k) * factorial2(r)) ** 2 * factorial(k))
    )


def A365025_gen():  # generator of terms
    for n in count(0):
        yield from (A365025_T(n - k, k) for k in range(n + 1))


def A364881(n):
    return (n * 5 ** (m := len(str((1 << n) // n))) >> n - m) % 10


def A000799(n):
    return (1 << n) // n


def A138255(n):
    return next(m for m in count(1) if not (1 << m) // m % n)


def A129794(n):
    return (1 << (n << 1)) // n


def A066601(n):
    return pow(3, n, n)


def A003176(n):
    return ((3 << n + 3) - 24) // n


def A082493(n):
    return (-pow(2, n, n)) % n


def A128092(n):
    return (m := 1 << n) - (m % n)


def A128093(n):
    return (m := 1 << n) + (n - k if (k := m % n) else -k)


def A364087_gen(startvalue=1):  # generator of terms
    return (
        n
        for n in count(max(startvalue, 1))
        if (n**11 << 2)
        < (
            n**4 * divisor_sigma(n)
            - 24
            * (
                (m := n + 1 >> 1) ** 2
                * (
                    0
                    if n & 1
                    else (m * (35 * m - 52 * n) + 18 * n**2) * divisor_sigma(m) ** 2
                )
                + sum(
                    (i * (i * (i * (70 * i - 140 * n) + 90 * n**2) - 20 * n**3) + n**4)
                    * divisor_sigma(i)
                    * divisor_sigma(n - i)
                    for i in range(1, m)
                )
            )
        )
        ** 2
    )


def A057660(n):
    return prod((p ** ((e << 1) + 1) + 1) // (p + 1) for p, e in factorint(n).items())


def A365076(n):
    return 1 + prod(
        (p ** ((e << 1) + 1) + 1) // (p + 1) for p, e in factorint(n).items()
    )


def A057661(n):
    return (
        1 + prod((p ** ((e << 1) + 1) + 1) // (p + 1) for p, e in factorint(n).items())
        >> 1
    )


def A126832(n):
    return n * divisor_sigma(n) % 5


def A365079(n):
    return (prod((e + (p & 1) << 1) - 1 for p, e in factorint(n).items()) >> 1) ** 2


def A331250(n):
    m, c = n**2 << 4, 0
    for k in count(1):
        if (k**2 << 2) - 1 > m:
            break
        for j in range((k >> 1) + 1, k + 1):
            for i in range(k - j + 1, j + 1):
                if ((-i + j + k) * (i - j + k) * (i + j - k) * (i + j + k)) > m:
                    break
                c += 1
    return c


def A365179(n):
    return 2 if n == 1 else (p := prime(n)) ** (6 if p % 3 == 2 else 7)


def A365196(n):
    return next(
        k for k in count(0) if max(factorint((1 << k) + n).values(), default=0) > 1
    )


def A182972_gen():  # generator of terms
    return (
        i for n in count(2) for i in range(1, 1 + (n - 1 >> 1)) if gcd(i, n - i) == 1
    )


def A182973_gen():  # generator of terms
    return (
        n - i
        for n in count(2)
        for i in range(1, 1 + (n - 1 >> 1))
        if gcd(i, n - i) == 1
    )


def A365075_gen():  # generator of terms
    c = 1
    for n in count(2):
        for i in range(1, 1 + (n - 1 >> 1)):
            if gcd(i, n - i) == 1:
                c *= 10
                yield (i * c // (n - i)) % 10


def A000982(n):
    return n**2 + 1 >> 1


def A132188(n):
    return n + (
        sum(1 for x in range(1, n + 1) for y in range(1, x) if is_square(x * y)) << 1
    )


def A362931(n):
    return n + (
        sum(
            1
            for x in range(1, n + 1)
            for y in range(1, x)
            if not (x * y << 1) % (x + y)
        )
        << 1
    )


def A362932(n):
    return (
        sum(
            (1 if T else -1)
            for x in range(1, n + 1)
            for y in range(1, x)
            if (T := is_square(x * y)) ^ (not (x * y << 1) % (x + y))
        )
        << 1
    )


def A365227(n):
    return sum(
        sum(Fraction(1, j) for j in range(1, k + 1) if gcd(j, k) == 1) / k
        for k in range(1, n + 1)
    ).numerator


def A365228(n):
    return sum(
        sum(Fraction(1, j) for j in range(1, k + 1) if gcd(j, k) == 1) / k
        for k in range(1, n + 1)
    ).denominator


def A362937(n):
    return ((n - 1) ** 2 >> 2) - sum(
        1 for x in range(1, n + 1) for y in range(1, x) if not (x * y << 1) % (x + y)
    )


def A362936(n):
    return ((n - 1) ** 2 >> 1) - (
        sum(
            1
            for x in range(1, n + 1)
            for y in range(1, x)
            if not (x * y << 1) % (x + y)
        )
        << 1
    )


def A362935(n):
    return ((n - 1) ** 2 >> 2) - sum(
        1 for x in range(1, n + 1) for y in range(1, x) if is_square(x * y)
    )


def A362934(n):
    return ((n - 1) ** 2 >> 1) - (
        sum(1 for x in range(1, n + 1) for y in range(1, x) if is_square(x * y)) << 1
    )


def A362933(n):
    return sum(
        (1 if T else -1)
        for x in range(1, n + 1)
        for y in range(1, x)
        if (T := is_square(x * y)) ^ (not (x * y << 1) % (x + y))
    )


def A002662(n):
    return (1 << n) - 1 - (n * (n + 1) >> 1)


def A353453(n):
    return (
        Matrix(
            n,
            n,
            lambda i, j: (
                abs(i - j) if min(i, j) < max(i, j) <= (min(i, j) << 1) + 1 else 0
            ),
        ).per()
        if n
        else 1
    )


def A353452(n):
    return Matrix(
        n,
        n,
        lambda i, j: abs(i - j) if min(i, j) < max(i, j) <= (min(i, j) << 1) + 1 else 0,
    ).det()


def A002720(n):
    return sum(factorial(k) * comb(n, k) ** 2 for k in range(n + 1))


def A365269(n):
    return prod(
        sum(factorial(m) * comb(k, m) ** 2 for m in range(k + 1))
        for k in range(1, n + 1)
    )


def A000085(n):
    return sum(
        factorial(n) // (factorial(n - (k << 1)) * factorial(k) * (1 << k))
        for k in range((n >> 1) + 1)
    )


def A289897(n):
    return prod(
        sum(
            factorial(k) // (factorial(k - (m << 1)) * factorial(m) * (1 << m))
            for m in range((k >> 1) + 1)
        )
        for k in range(1, n + 1)
    )


def A365296(n):
    return prod(p ** (e & -e) for p, e in factorint(n).items())


if sys.version_info >= (3, 10):

    def A363329(n):
        return prod((1 << e.bit_count()) - 1 for e in factorint(n).values())

else:

    def A363329(n):
        return prod((1 << bin(e).count("1")) - 1 for e in factorint(n).values())


def A359411(n):
    return prod(
        sum(1 for d in divisors(e, generator=True) if e | d == e)
        for e in factorint(n).values()
    )


def A339597(n):
    return ((m := n + 1) << 1) - (m & -m)


def A365300_gen():  # generator of terms
    aset, alist = set(), []
    for k in count(0):
        bset = set()
        for d in combinations_with_replacement(alist + [k], 3):
            if (m := sum(d) + k) in aset:
                break
            bset.add(m)
        else:
            yield k
            alist.append(k)
            aset.update(bset)


def A365301_gen():  # generator of terms
    aset, alist = set(), []
    for k in count(0):
        bset = set()
        for d in combinations_with_replacement(alist + [k], 4):
            if (m := sum(d) + k) in aset:
                break
            bset.add(m)
        else:
            yield k
            alist.append(k)
            aset.update(bset)


def A365302_gen():  # generator of terms
    aset, alist = set(), []
    for k in count(0):
        bset = set()
        for d in combinations_with_replacement(alist + [k], 5):
            if (m := sum(d) + k) in aset:
                break
            bset.add(m)
        else:
            yield k
            alist.append(k)
            aset.update(bset)


def A365303_gen():  # generator of terms
    aset, alist = set(), []
    for k in count(0):
        bset = set()
        for d in combinations_with_replacement(alist + [k], 6):
            if (m := sum(d) + k) in aset:
                break
            bset.add(m)
        else:
            yield k
            alist.append(k)
            aset.update(bset)


def A365304_gen():  # generator of terms
    aset, alist = set(), []
    for k in count(0):
        bset = set()
        for d in combinations_with_replacement(alist + [k], 7):
            if (m := sum(d) + k) in aset:
                break
            bset.add(m)
        else:
            yield k
            alist.append(k)
            aset.update(bset)


def A365305_gen():  # generator of terms
    aset, alist = set(), []
    for k in count(0):
        bset = set()
        for d in combinations_with_replacement(alist + [k], 8):
            if (m := sum(d) + k) in aset:
                break
            bset.add(m)
        else:
            yield k
            alist.append(k)
            aset.update(bset)


def A051912_gen():  # generator of terms
    aset1, aset2, aset3, alist = set(), set(), set(), []
    for k in count(0):
        bset2, bset3 = {k << 1}, {3 * k}
        if 3 * k not in aset3:
            for d in aset1:
                if (m := d + (k << 1)) in aset3:
                    break
                bset2.add(d + k)
                bset3.add(m)
            else:
                for d in aset2:
                    if (m := d + k) in aset3:
                        break
                    bset3.add(m)
                else:
                    yield k
                    alist.append(k)
                    aset1.add(k)
                    aset2.update(bset2)
                    aset3.update(bset3)


def A025582_gen():  # generator of terms
    aset1, aset2, alist = set(), set(), []
    for k in count(0):
        bset2 = {k << 1}
        if (k << 1) not in aset2:
            for d in aset1:
                if (m := d + k) in aset2:
                    break
                bset2.add(m)
            else:
                yield k
                alist.append(k)
                aset1.add(k)
                aset2.update(bset2)


def A087704(n):
    x, c = Fraction(n, 1), 0
    while x.denominator > 1 or x <= n:
        x = Fraction(5 * x.__floor__(), 3)
        c += 1
    return c


def A087705(n):
    x = Fraction(n, 1)
    while x.denominator > 1 or x <= n:
        x = Fraction(5 * x.__floor__(), 3)
    return int(x)


def A087706(n):
    x = Fraction(n, 1)
    while x.denominator > 1 or x <= n:
        x = Fraction(5 * x.__floor__(), 3)
    return int(x) // 5


def A365340(n):
    return ff(n << 2, n - 1)


def A365341(n):
    return ff(5 * n, n - 1)


def A052795(n):
    return ff(6 * n, n - 1)


def A061924(n):
    return ff(n << 2, n)


def A087707(n):
    x, c = Fraction(n), 0
    while x.denominator > 1 or x <= n:
        x = Fraction(5 * x.__ceil__(), 3)
        c += 1
    return c


def A087708(n):
    x = Fraction(n)
    while x.denominator > 1 or x <= n:
        x = Fraction(5 * x.__ceil__(), 3)
    return int(x)


def A087709(n):
    x = Fraction(n)
    while x.denominator > 1 or x <= n:
        x = Fraction(5 * x.__ceil__(), 3)
    return int(x) // 5


def A365367(n):
    x, c = Fraction(n), 0
    while x.denominator > 1 or x <= n:
        x = Fraction(5 * x.__round__(), 3)
        c += 1
    return c


def A365368(n):
    x = Fraction(n)
    while x.denominator > 1 or x <= n:
        x = Fraction(5 * x.__round__(), 3)
    return int(x)


def A365369(n):
    x = Fraction(n)
    while x.denominator > 1 or x <= n:
        x = Fraction(5 * x.__round__(), 3)
    return int(x) // 5


if sys.version_info >= (3, 10):

    def A365339(n):
        plist, qlist, c = tuple(totient(i) for i in range(1, n + 1)), [0] * (n + 1), 0
        for i in range(n):
            qlist[
                a := bisect.bisect(
                    qlist, plist[i], lo=1, hi=c + 1, key=lambda x: plist[x]
                )
            ] = i
            c = max(c, a)
        return c

    def A365399(n):
        plist, qlist, c = (
            tuple(divisor_count(i) for i in range(1, n + 1)),
            [0] * (n + 1),
            0,
        )
        for i in range(n):
            qlist[
                a := bisect.bisect(
                    qlist, plist[i], lo=1, hi=c + 1, key=lambda x: plist[x]
                )
            ] = i
            c = max(c, a)
        return c

    def A365474(n):
        m = 10**n
        plist, qlist, c = tuple(totient(i) for i in range(1, m + 1)), [0] * (m + 1), 0
        for i in range(m):
            qlist[
                a := bisect.bisect(
                    qlist, plist[i], lo=1, hi=c + 1, key=lambda x: plist[x]
                )
            ] = i
            c = max(c, a)
        return c

    def A365485(n):
        m = 10**n
        plist, qlist, c = (
            tuple(divisor_count(i) for i in range(1, m + 1)),
            [0] * (m + 1),
            0,
        )
        for i in range(m):
            qlist[
                a := bisect.bisect(
                    qlist, plist[i], lo=1, hi=c + 1, key=lambda x: plist[x]
                )
            ] = i
            c = max(c, a)
        return c

    def A365400(n):
        plist, qlist, c = tuple(totient(i) for i in range(1, n + 1)), [0] * (n + 1), 0
        for i in range(n):
            qlist[
                a := bisect.bisect(
                    qlist, plist[i], lo=1, hi=c + 1, key=lambda x: plist[x]
                )
            ] = i
            c = max(c, a)
        return 64 + primepi(n) - c

    def A365398(n):
        plist, qlist, c = (
            tuple(divisor_sigma(i) for i in range(1, n + 1)),
            [0] * (n + 1),
            0,
        )
        for i in range(n):
            qlist[
                a := bisect.bisect(
                    qlist, plist[i], lo=1, hi=c + 1, key=lambda x: plist[x]
                )
            ] = i
            c = max(c, a)
        return c

    def A365397(n):
        plist, qlist, c = (
            tuple(divisor_sigma(i) for i in range(1, n + 1)),
            [0] * (n + 1),
            0,
        )
        for i in range(n):
            qlist[
                a := bisect.bisect(
                    qlist, plist[i], lo=1, hi=c + 1, key=lambda x: plist[x]
                )
            ] = i
            c = max(c, a)
        return 64 + primepi(n) - c

    def A371156(n):
        def f(n):
            r = primefactors(n)
            return n * prod(p + 1 for p in r) // prod(r)

        plist, qlist, c = tuple(f(i) for i in range(1, n + 1)), [0] * (n + 1), 0
        for i in range(n):
            qlist[
                a := bisect.bisect(
                    qlist, plist[i], lo=1, hi=c + 1, key=lambda x: plist[x]
                )
            ] = i
            c = max(c, a)
        return c

else:

    def A365339(n):
        plist, qlist, rlist, c = (
            tuple(totient(i) for i in range(1, n + 1)),
            [0] * (n + 1),
            [1] * (n + 1),
            0,
        )
        for i in range(n):
            qlist[a := bisect.bisect(rlist, p := plist[i], lo=1, hi=c + 1)] = i
            rlist[a] = p
            c = max(c, a)
        return c

    def A365399(n):
        plist, qlist, rlist, c = (
            tuple(divisor_count(i) for i in range(1, n + 1)),
            [0] * (n + 1),
            [1] * (n + 1),
            0,
        )
        for i in range(n):
            qlist[a := bisect.bisect(rlist, p := plist[i], lo=1, hi=c + 1)] = i
            rlist[a] = p
            c = max(c, a)
        return c

    def A365474(n):
        return A365339(10**n)

    def A365485(n):
        return A365399(10**n)

    def A365400(n):
        plist, qlist, rlist, c = (
            tuple(totient(i) for i in range(1, n + 1)),
            [0] * (n + 1),
            [1] * (n + 1),
            0,
        )
        for i in range(n):
            qlist[a := bisect.bisect(rlist, p := plist[i], lo=1, hi=c + 1)] = i
            rlist[a] = p
            c = max(c, a)
        return 64 + primepi(n) - c

    def A365398(n):
        plist, qlist, rlist, c = (
            tuple(divisor_sigma(i) for i in range(1, n + 1)),
            [0] * (n + 1),
            [1] * (n + 1),
            0,
        )
        for i in range(n):
            qlist[a := bisect.bisect(rlist, p := plist[i], lo=1, hi=c + 1)] = i
            rlist[a] = p
            c = max(c, a)
        return c

    def A365397(n):
        plist, qlist, rlist, c = (
            tuple(divisor_sigma(i) for i in range(1, n + 1)),
            [0] * (n + 1),
            [1] * (n + 1),
            0,
        )
        for i in range(n):
            qlist[a := bisect.bisect(rlist, p := plist[i], lo=1, hi=c + 1)] = i
            rlist[a] = p
            c = max(c, a)
        return 64 + primepi(n) - c

    def A371156(n):
        def f(n):
            r = primefactors(n)
            return n * prod(p + 1 for p in r) // prod(r)

        plist, qlist, rlist, c = (
            tuple(f(i) for i in range(1, n + 1)),
            [0] * (n + 1),
            [1] * (n + 1),
            0,
        )
        for i in range(n):
            qlist[a := bisect.bisect(rlist, p := plist[i], lo=1, hi=c + 1)] = i
            rlist[a] = p
            c = max(c, a)
        return c


def A365373(n):
    return n * (n * (n * (n * (3 * n + 15) + 25) - 15) - 28) // 60


def A364633(n):
    return (n + 1) * (prime(n) // (n + 1) + 1) - prime(n) if n > 2 else 0


def A365481(n):
    return prod(p ** ((e >> 1) + (e & 1)) + 1 for p, e in factorint(n).items())


def A365479(n):
    return prod(p ** (e + (e & 1)) + 1 for p, e in factorint(n).items())


def A005282_gen():  # generator of terms
    aset1, aset2, alist = set(), set(), []
    for k in count(1):
        bset2 = {k << 1}
        if (k << 1) not in aset2:
            for d in aset1:
                if (m := d + k) in aset2:
                    break
                bset2.add(m)
            else:
                yield k
                alist.append(k)
                aset1.add(k)
                aset2.update(bset2)


def A096772_gen():  # generator of terms
    aset1, aset2, aset3, alist = set(), set(), set(), []
    for k in count(1):
        bset2, bset3 = {k << 1}, {3 * k}
        if 3 * k not in aset3:
            for d in aset1:
                if (m := d + (k << 1)) in aset3:
                    break
                bset2.add(d + k)
                bset3.add(m)
            else:
                for d in aset2:
                    if (m := d + k) in aset3:
                        break
                    bset3.add(m)
                else:
                    yield k
                    alist.append(k)
                    aset1.add(k)
                    aset2.update(bset2)
                    aset3.update(bset3)


def A060276_gen():  # generator of terms
    aset1, aset2, aset3, alist, k = set(), set(), set(), [], 2
    while True:
        bset2, bset3 = {k << 1}, {3 * k}
        if 3 * k not in aset3:
            for d in aset1:
                if (m := d + (k << 1)) in aset3:
                    break
                bset2.add(d + k)
                bset3.add(m)
            else:
                for d in aset2:
                    if (m := d + k) in aset3:
                        break
                    bset3.add(m)
                else:
                    yield k
                    alist.append(k)
                    aset1.add(k)
                    aset2.update(bset2)
                    aset3.update(bset3)
        k = nextprime(k)


def A062295_gen():  # generator of terms
    aset1, aset2, alist = set(), set(), []
    for k in (n**2 for n in count(1)):
        bset2 = {k << 1}
        if (k << 1) not in aset2:
            for d in aset1:
                if (m := d + k) in aset2:
                    break
                bset2.add(m)
            else:
                yield k
                alist.append(k)
                aset1.add(k)
                aset2.update(bset2)


def A034757_gen():  # generator of terms
    aset1, aset2, alist = set(), set(), []
    for k in count(1, 2):
        bset2 = {k << 1}
        if (k << 1) not in aset2:
            for d in aset1:
                if (m := d + k) in aset2:
                    break
                bset2.add(m)
            else:
                yield k
                alist.append(k)
                aset1.add(k)
                aset2.update(bset2)


def A287178_gen():  # generator of terms
    aset1, aset2, alist, n = set(), set(), [], 0
    for k in count(1, 2):
        bset2 = {k << 1}
        if (k << 1) not in aset2:
            for d in aset1:
                if (m := d + k) in aset2:
                    break
                bset2.add(m)
            else:
                yield k - n
                n = k
                alist.append(k)
                aset1.add(k)
                aset2.update(bset2)


def A101274_gen():  # generator of terms
    aset1, aset2, alist, n = {1}, set(), [1], 1
    for k in count(2):
        bset2 = {k << 1}
        if (k << 1) not in aset2:
            for d in aset1:
                if (m := d + k) in aset2:
                    break
                bset2.add(m)
            else:
                yield k - n
                n = k
                alist.append(k)
                aset1.add(k)
                aset2.update(bset2)


def A062292_gen():  # generator of terms
    aset1, aset2, alist = set(), set(), []
    for k in (n**3 for n in count(1)):
        bset2 = {k << 1}
        if (k << 1) not in aset2:
            for d in aset1:
                if (m := d + k) in aset2:
                    break
                bset2.add(m)
            else:
                yield k
                alist.append(k)
                aset1.add(k)
                aset2.update(bset2)


def A347570_gen():  # generator of terms
    asets, alists, klist = [set()], [[]], [1]
    while True:
        for i in range(len(klist) - 1, -1, -1):
            kstart, alist, aset = klist[i], alists[i], asets[i]
            for k in count(kstart):
                bset = set()
                for d in combinations_with_replacement(alist + [k], i):
                    if (m := sum(d) + k) in aset:
                        break
                    bset.add(m)
                else:
                    yield k
                    alists[i].append(k)
                    klist[i] = k + 1
                    asets[i].update(bset)
                    break
        klist.append(1)
        asets.append(set())
        alists.append([])


def A363993(n):
    return next(
        x[0] + n - 1
        for x in enumerate(accumulate(Fraction(1, k) for k in count(n)))
        if x[1] >= 2
    )


def A364609(n):
    return next(
        x[0] + n - 1
        for x in enumerate(accumulate(Fraction(1, k) for k in count(n)))
        if x[1] ** 2 >= 2
    )


def A224613(n):
    return prod(
        (p ** (e + 1) - 1) // (p - 1)
        for p, e in (Counter(factorint(n)) + Counter([2, 3])).items()
    )


def A363031(n):
    return divisor_sigma(6 * n + 1)


def A034444(n):
    return 1 << primenu(n)


def A064608(n):
    return sum(1 << primenu(m) for m in range(1, n + 1))


def A069212(n):
    return sum(3 ** primenu(m) for m in range(1, n + 1))


def A350961(n):
    return sum(3 ** primeomega(m) for m in range(1, n + 1))


@lru_cache(maxsize=None)
def A087192(n):
    return int(Fraction(4 * A087192(n - 1), 3).__ceil__()) if n > 1 else 1


def A365446(n):
    return sum(
        prod(
            (p ** (e + 1) - 1) // (p - 1)
            for p, e in (Counter(factorint(m)) + Counter([2, 3])).items()
        )
        for m in range(1, n + 1)
    )


def A365515_gen():  # generator of terms
    asets, alists, klist = [set()], [[]], [0]
    while True:
        for i in range(len(klist) - 1, -1, -1):
            kstart, alist, aset = klist[i], alists[i], asets[i]
            for k in count(kstart):
                bset = set()
                for d in combinations_with_replacement(alist + [k], i):
                    if (m := sum(d) + k) in aset:
                        break
                    bset.add(m)
                else:
                    yield k
                    alists[i].append(k)
                    klist[i] = k + 1
                    asets[i].update(bset)
                    break
        klist.append(0)
        asets.append(set())
        alists.append([])


def A365525(n):
    return sum(stirling(n, k << 2) for k in range((n >> 2) + 1))


def A061069(n):
    return len({divisor_sigma(i) for i in range(1, n + 1)})


def A061070(n):
    return len({totient(i) for i in range(1, n + 1)})


def A061071(n):
    return len({divisor_count(i) for i in range(1, n + 1)})


def A046970(n):
    return prod(1 - p**2 for p in primefactors(n))


def A063453(n):
    return prod(1 - p**3 for p in primefactors(n))


def A023900(n):
    return prod(1 - p for p in primefactors(n))


def A173557(n):
    return prod(p - 1 for p in primefactors(n))


def A305444(n):
    return prod(p - 2 for p in primefactors(n >> (~n & n - 1).bit_length()))


def A365376(n):
    if n == 0:
        return 1
    nset = set(range(1, n + 1))
    s, c = [
        set(p) for p in partitions(n, m=n, k=n) if max(p.values(), default=1) == 1
    ], n
    for a in chain.from_iterable(combinations(nset, m) for m in range(2, n + 1)):
        if sum(a) < n:
            c += 1
        else:
            aset = set(a)
            for p in s:
                if p.issubset(aset):
                    break
            else:
                c += 1
    return (1 << n) - c


def A365377(n):
    if n == 0:
        return 0
    nset = set(range(1, n + 1))
    s, c = [
        set(p) for p in partitions(n, m=n, k=n) if max(p.values(), default=1) == 1
    ], n
    for a in chain.from_iterable(combinations(nset, m) for m in range(2, n + 1)):
        if sum(a) < n:
            c += 1
        else:
            aset = set(a)
            for p in s:
                if p.issubset(aset):
                    break
            else:
                c += 1
    return c


def A067836_gen():  # generator of terms
    a, f = 2, 1
    yield 2
    while True:
        yield (a := nextprime((f := f * a) + 1) - f)


def A062894_gen():  # generator of terms
    a, f = 2, 1
    yield 1
    while True:
        yield primepi(a := nextprime((f := f * a) + 1) - f)


def A364824(n):
    a, f, p = 2, 1, prime(n)
    for i in count(1):
        if a == p:
            return i
        a = nextprime((f := f * a) + 1) - f


def A131577(n):
    return 1 << n - 1 if n else 0


def A088314(n):
    return len({tuple(sorted(set(p))) for p in partitions(n)})


def A070880(n):
    return (1 << n - 1) - len({tuple(sorted(set(p))) for p in partitions(n)})


def A182410(n):
    return len({tuple(sorted(set(p.values()))) for p in partitions(n)})


def A088887(n):
    return len({tuple(sorted(p.values())) for p in partitions(n)})


def A364831_gen():  # generator of terms
    yield 2
    yield from chain.from_iterable(
        (
            sorted(
                s
                for d in combinations_with_replacement("753", l)
                if isprime(s := int("".join(d)))
            )
            for l in count(1)
        )
    )


def A036241_gen():  # generator of terms
    aset2, aset3 = {3, 4, 5}, {6}
    yield from (alist := [1, 2, 3])
    for k in count(4):
        bset2, bset3 = set(), set()
        for a in alist:
            if (b2 := a + k) in aset2:
                break
            bset2.add(b2)
        else:
            for a2 in aset2:
                if (b3 := a2 + k) in aset3:
                    break
                bset3.add(b3)
            else:
                yield k
                alist.append(k)
                aset2.update(bset2)
                aset3.update(bset3)


def A062065_gen():  # generator of terms
    aset2, aset3, alist = set(), set(), [1]
    yield 1
    for k in count(2):
        bset2, bset3 = set(), set()
        if not (k in aset2 or k in aset3):
            for a in alist:
                if (b2 := a + k) in aset2 or b2 in aset3:
                    break
                bset2.add(b2)
            else:
                for a2 in aset2:
                    if (b3 := a2 + k) in aset2 or b3 in aset3:
                        break
                    bset3.add(b3)
                else:
                    yield k
                    alist.append(k)
                    aset2.update(bset2)
                    aset3.update(bset3)


def A364879(n):
    c, cn, m = 0, 0, n + 1 << 1
    for k in count(2):
        if isprime(k):
            c += k
            cn += k * m
        if k * (k + 1) - 1 >= cn:
            return k


def A010672_gen():  # generator of terms
    aset2, alist = set(), []
    for k in count(0):
        bset2 = set()
        for a in alist:
            if (b := a + k) in aset2:
                break
            bset2.add(b)
        else:
            yield k
            alist.append(k)
            aset2.update(bset2)


def A062559_gen():  # generator of terms
    aset2, alist = set(), []
    for k in count(0):
        if len(f := factorint(k).values()) == 1 and max(f) > 1:
            bset2 = set()
            for a in alist:
                if (b := a + k) in aset2:
                    break
                bset2.add(b)
            else:
                yield k
                alist.append(k)
                aset2.update(bset2)


def A062294_gen():  # generator of terms
    aset2, alist, k = set(), [], 0
    while k := nextprime(k):
        bset2 = set()
        for a in alist:
            if (b := a + k) in aset2:
                break
            bset2.add(b)
        else:
            yield k
            alist.append(k)
            aset2.update(bset2)


def A133743_gen():  # generator of terms
    aset2, alist = set(), []
    for k in map(lambda x: x**2, count(1)):
        bset2 = set()
        for a in alist:
            if (b := a + k) in aset2:
                break
            bset2.add(b)
        else:
            yield k
            alist.append(k)
            aset2.update(bset2)


def A133744_gen():  # generator of terms
    aset2, alist, bset2, blist, aqueue, bqueue = set(), [], set(), [], deque(), deque()
    for k in (n**2 for n in count(1)):
        cset2 = {k << 1}
        if (k << 1) not in aset2:
            for a in alist:
                if (m := a + k) in aset2:
                    break
                cset2.add(m)
            else:
                aqueue.append(k)
                alist.append(k)
                aset2.update(cset2)
        cset2 = set()
        for b in blist:
            if (m := b + k) in bset2:
                break
            cset2.add(m)
        else:
            bqueue.append(k)
            blist.append(k)
            bset2.update(cset2)
        if len(aqueue) > 0 and len(bqueue) > 0:
            yield aqueue.popleft() - bqueue.popleft()


def A079848_gen():  # generator of terms
    aset2, alist, k = set(), [], 0
    while k := nextprime(k):
        bset2 = set()
        for a in alist:
            if (b := k - a) in aset2:
                break
            bset2.add(b)
        else:
            yield k
            alist.append(k)
            aset2.update(bset2)


def A079849_gen():  # generator of terms
    aset2, alist, k, m = set(), [2], 2, 2
    while k := nextprime(k):
        bset2 = set()
        for a in alist:
            if (b := k - a) in aset2:
                break
            bset2.add(b)
        else:
            yield k - m
            alist.append(m := k)
            aset2.update(bset2)


def A133096_gen():  # generator of terms
    aset2, alist, bset2, blist, aqueue, bqueue, k = (
        set(),
        [],
        set(),
        [],
        deque(),
        deque(),
        1,
    )
    while k := nextprime(k):
        cset2 = set()
        for a in alist:
            if (m := k - a) in aset2:
                break
            cset2.add(m)
        else:
            aqueue.append(k)
            alist.append(k)
            aset2.update(cset2)
        cset2 = set()
        for b in blist:
            if (m := b + k) in bset2:
                break
            cset2.add(m)
        else:
            bqueue.append(k)
            blist.append(k)
            bset2.update(cset2)
        if len(aqueue) > 0 and len(bqueue) > 0:
            yield aqueue.popleft() - bqueue.popleft()


def A135257_gen():  # generator of terms
    aset2, alist = set(), []
    for k in count(0):
        if sum(factorint(k).values()) == 2:
            bset2 = set()
            for a in alist:
                if (b := k - a) in aset2:
                    break
                bset2.add(b)
            else:
                yield k
                alist.append(k)
                aset2.update(bset2)


def A133097_gen():  # generator of terms
    aset2, alist, bset2, blist, aqueue, bqueue = set(), [], set(), [], deque(), deque()
    for k in count(1):
        cset2 = {k << 1}
        if (k << 1) not in aset2:
            for a in alist:
                if (m := a + k) in aset2:
                    break
                cset2.add(m)
            else:
                aqueue.append(k)
                alist.append(k)
                aset2.update(cset2)
        cset2 = set()
        for b in blist:
            if (m := b + k) in bset2:
                break
            cset2.add(m)
        else:
            bqueue.append(k)
            blist.append(k)
            bset2.update(cset2)
        if len(aqueue) > 0 and len(bqueue) > 0:
            yield aqueue.popleft() - bqueue.popleft()


def A133605_gen():  # generator of terms
    aset2, alist = set(), []
    for k in count(1):
        bset2 = set()
        for a in alist:
            if (b := a + k) in aset2:
                break
            bset2.add(b)
        else:
            if k in aset2:
                yield k
            alist.append(k)
            aset2.update(bset2)


def A133604_gen():  # generator of terms
    aset2, alist = set(), []
    for k in count(1):
        bset2 = {r := k << 1}
        if r not in aset2:
            for d in alist:
                if (m := d + k) in aset2:
                    break
                bset2.add(m)
            else:
                if k in aset2:
                    yield k
                alist.append(k)
                aset2.update(bset2)


def A362942_gen():  # generator of terms
    blist, c = [], 0
    for n in count(0):
        i, j, b = 1, 1, set()
        while n - (i << 1) >= 0:
            b.add((blist[n - i] << 1) - blist[n - 2 * i])
            i += 1
            while j in b:
                j += 1
        blist.append(j)
        yield (c := c + j)


def A309890_gen():  # generator of terms
    blist = []
    for n in count(0):
        i, j, b = 1, 1, set()
        while n - (i << 1) >= 0:
            x, y = blist[n - 2 * i], blist[n - i]
            z = (y << 1) - x
            if x <= y <= z:
                b.add(z)
                while j in b:
                    j += 1
            i += 1
        blist.append(j)
        yield j


def A365323(n):
    a = {tuple(sorted(set(p))) for p in partitions(n)}
    return sum(
        1 for k in range(1, n) for d in partitions(k) if tuple(sorted(set(d))) not in a
    )


def A365314(n):
    a = set()
    for i in range(1, n + 1):
        if not n % i:
            a.update(tuple(sorted((i, j))) for j in range(1, n + 1) if j != i)
        else:
            for j in count(0, i):
                if j > n:
                    break
                k = n - j
                for d in divisors(k):
                    if d >= i:
                        break
                    a.add((d, i))
    return len(a)


def A365542(n):
    a = {tuple(sorted(set(p))) for p in partitions(n)}
    return sum(
        1
        for m in range(1, n)
        for b in combinations(range(1, n), m)
        if any(set(d).issubset(set(b)) for d in a)
    )


def A365321(n):
    a = set()
    for i in range(1, n + 1):
        for j in count(i, i):
            if j >= n:
                break
            for d in divisors(n - j):
                if d >= i:
                    break
                a.add((d, i))
    return (n * (n - 1) >> 1) - len(a)


def A365379(n):
    a = {tuple(sorted(set(p))) for p in partitions(n)}
    return sum(
        1
        for m in range(1, n + 1)
        for b in partitions(m)
        if any(set(d).issubset(set(b)) for d in a)
    )


def A365378(n):
    a = {tuple(sorted(set(p))) for p in partitions(n)}
    return sum(
        1
        for m in range(1, n)
        for b in partitions(m)
        if not any(set(d).issubset(set(b)) for d in a)
    )


def A365382(n):
    a = {tuple(sorted(set(p))) for p in partitions(n)}
    return sum(
        1
        for m in range(1, n)
        for b in partitions(m)
        if gcd(*b.keys()) == 1 and not any(set(d).issubset(set(b)) for d in a)
    )


def A365311(n):
    a = {tuple(sorted(set(p))) for p in partitions(n)}
    return sum(
        1
        for m in range(1, n + 1)
        for b in partitions(m, m=isqrt(1 + (n << 3)) >> 1)
        if max(b.values()) == 1 and any(set(d).issubset(set(b)) for d in a)
    )


def A365312(n):
    a = {tuple(sorted(set(p))) for p in partitions(n)}
    return sum(
        1
        for m in range(1, n + 1)
        for b in partitions(m, m=isqrt(1 + (n << 3)) >> 1)
        if max(b.values()) == 1 and not any(set(d).issubset(set(b)) for d in a)
    )


def A364910(n):
    return sum(1 for d in partitions(n << 1, k=n) if sum(set(d)) == n)


def A365315(n):
    a = set()
    for i in range(1, n + 1):
        for j in count(i, i):
            if j >= n:
                break
            for d in divisors(n - j):
                if d >= i:
                    break
                a.add((d, i))
    return len(a)


def A365320(n):
    a = set()
    for i in range(1, n + 1):
        if not n % i:
            a.update(tuple(sorted((i, j))) for j in range(1, n + 1) if j != i)
        else:
            for j in count(0, i):
                if j > n:
                    break
                k = n - j
                for d in divisors(k):
                    if d >= i:
                        break
                    a.add((d, i))
    return (n * (n - 1) >> 1) - len(a)


def A365630(n):
    return sum(1 for p in partitions(n) if len(p) == 4)


def A365631(n):
    return sum(1 for p in partitions(n) if len(p) == 5)


def A364809(n):
    return sum(1 for p in partitions(n) if len(p) <= 5)


def A364793(n):
    return sum(1 for p in partitions(n) if len(p) <= 4)


def A116608_T(n, k):
    return sum(1 for p in partitions(n) if len(p) == k)


def A116608_gen():  # generator of terms
    return (
        sum(1 for p in partitions(n) if len(p) == k)
        for n in count(1)
        for k in range(1, (isqrt((n << 3) + 1) - 1 >> 1) + 1)
    )


def A365322(n):
    return (1 << n) - len({tuple(sorted(set(p))) for p in partitions(n)})


def A364837(n):
    return int(str(1 << (1 << n))[0])


def A365676_gen():  # generator of terms
    return (
        sum(1 for p in partitions(n) if len(p) == k)
        for n in count(0)
        for k in range(n + 1)
    )


def A060177_gen():  # generator of terms
    return (
        sum(1 for p in partitions(n) if len(p) == k)
        for n in count(1)
        for k in range(isqrt((n << 3) + 1) - 1 >> 1, 0, -1)
    )


def A365535_gen():  # generator of terms
    return (
        n
        for n in count(2)
        if sum(f := factorint(n).values()) > 1 and all(d & 1 for d in f)
    )


def A002133(n):
    return sum(
        divisor_count(j) * divisor_count(n - j) for j in range(1, (n - 1 >> 1) + 1)
    ) + (
        (divisor_count(n + 1 >> 1) ** 2 if n - 1 & 1 else 0)
        + divisor_count(n)
        - divisor_sigma(n)
        >> 1
    )


def A364843(n):
    return ((t := isqrt((n << 3) - 1) - 1 >> 1) * (t + 1) >> 1) + 1


def A072873_gen(startvalue=1):  # generator of terms
    return (
        k
        for k in count(max(startvalue, 1))
        if not any(e % p for p, e in factorint(k).items())
    )


def A365617(n):
    return reduce(rf, range(1, n + 1), 1)


def A181821(n):
    return prod(
        prime(i) ** e
        for i, e in enumerate(
            sorted(map(primepi, factorint(n, multiple=True)), reverse=True), 1
        )
    )


def A102283(n):
    return (0, 1, -1)[n % 3]


if sys.version_info >= (3, 10):

    def A365737(n):
        plist, qlist, c = tuple(-totient(i) for i in range(1, n + 1)), [0] * (n + 1), 0
        for i in range(n):
            qlist[
                a := bisect.bisect(
                    qlist, plist[i], lo=1, hi=c + 1, key=lambda x: plist[x]
                )
            ] = i
            c = max(c, a)
        return c

    def A365740(n):
        plist = tuple(totient(i) for i in range(1, n + 1) if not isprime(i))
        m = len(plist)
        qlist, c = [0] * (m + 1), 0
        for i in range(m):
            qlist[
                a := bisect.bisect(
                    qlist, plist[i], lo=1, hi=c + 1, key=lambda x: plist[x]
                )
            ] = i
            c = max(c, a)
        return c

    def A365738(n):
        k = 10**n
        plist, qlist, c = tuple(-totient(i) for i in range(1, k + 1)), [0] * (k + 1), 0
        for i in range(k):
            qlist[
                a := bisect.bisect(
                    qlist, plist[i], lo=1, hi=c + 1, key=lambda x: plist[x]
                )
            ] = i
            c = max(c, a)
        return c

    def A365741(n):
        k = 10**n
        plist = tuple(totient(i) for i in range(1, k + 1) if not isprime(i))
        m = len(plist)
        qlist, c = [0] * (m + 1), 0
        for i in range(m):
            qlist[
                a := bisect.bisect(
                    qlist, plist[i], lo=1, hi=c + 1, key=lambda x: plist[x]
                )
            ] = i
            c = max(c, a)
        return c

else:

    def A365737(n):
        plist, qlist, rlist, c = (
            tuple(-totient(i) for i in range(1, n + 1)),
            [0] * (n + 1),
            [1] * (n + 1),
            0,
        )
        for i in range(n):
            qlist[a := bisect.bisect(rlist, p := plist[i], lo=1, hi=c + 1)] = i
            rlist[a] = p
            c = max(c, a)
        return c

    def A365740(n):
        plist = tuple(totient(i) for i in range(1, n + 1) if not isprime(i))
        m = len(plist)
        qlist, rlist, c = [0] * (m + 1), [1] * (m + 1), 0
        for i in range(m):
            qlist[a := bisect.bisect(rlist, p := plist[i], lo=1, hi=c + 1)] = i
            rlist[a] = p
            c = max(c, a)
        return c

    def A365738(n):
        k = 10**n
        plist, qlist, rlist, c = (
            tuple(-totient(i) for i in range(1, k + 1)),
            [0] * (k + 1),
            [1] * (k + 1),
            0,
        )
        for i in range(k):
            qlist[a := bisect.bisect(rlist, p := plist[i], lo=1, hi=c + 1)] = i
            rlist[a] = p
            c = max(c, a)
        return c

    def A365741(n):
        k = 10**n
        plist = tuple(totient(i) for i in range(1, k + 1) if not isprime(i))
        m = len(plist)
        qlist, rlist, c = [0] * (m + 1), [1] * (m + 1), 0
        for i in range(m):
            qlist[a := bisect.bisect(rlist, p := plist[i], lo=1, hi=c + 1)] = i
            rlist[a] = p
            c = max(c, a)
        return c


def A365742(n):
    return max(Counter(totient(i) for i in range(1, n + 1)).values())


def A365748(n):
    return max(Counter(totient(i) for i in range(1, 10**n + 1)).values())


def A365104(n):
    return len({pow(x, 5, 5**n) for x in range(5**n)})


def A364811(n):
    return len({pow(x, 4, 1 << n) for x in range(1 << n)})


def A364808(n):
    return sum(min(p.values()) for p in partitions(n))


def A264397(n):
    return sum(max(p.values()) for p in partitions(n))


def A365458(n):
    kmin, kmax = 0, 1
    while 3**kmax <= n:
        kmax <<= 1
    while True:
        kmid = kmax + kmin >> 1
        if 3**kmid > n:
            kmax = kmid
        else:
            kmin = kmid
        if kmax - kmin <= 1:
            break
    return 3**kmin


def A365459(n):
    kmin, kmax = 0, 1
    while 3**kmax <= n:
        kmax <<= 1
    while True:
        kmid = kmax + kmin >> 1
        if 3**kmid > n:
            kmax = kmid
        else:
            kmin = kmid
        if kmax - kmin <= 1:
            break
    return n - 3**kmin


def A363994(n):
    return sum(
        1
        for p in partitions(n)
        if max(
            list(
                Counter(
                    abs(d[0] - d[1])
                    for d in combinations(list(Counter(p).elements()), 2)
                ).values()
            ),
            default=1,
        )
        == 1
    )


def A364612(n):
    return sum(
        1
        for p in partitions(n)
        if max(
            list(
                Counter(
                    abs(d[0] - d[1])
                    for d in combinations(list(Counter(p).elements()), 2)
                ).values()
            ),
            default=1,
        )
        > 1
    )


def A325876(n):
    return (
        sum(
            1
            for p in partitions(n)
            if max(
                list(
                    Counter(
                        abs(d[0] - d[1])
                        for d in combinations(list(Counter(p).elements()), 2)
                    ).values()
                ),
                default=1,
            )
            == 1
        )
        - (n & 1 ^ 1)
        if n
        else 1
    )


def A365659(n):
    return (
        n >> 1
        if n & 1 or n == 0
        else (m := n >> 1)
        + sum(1 for p in partitions(m) if max(p.values(), default=1) == 1)
        - 2
    )


def A140106(n):
    return n - 2 >> 1 if n > 1 else 0


def A024924(n):
    return sum((p := prime(k)) * (n // p) for k in range(1, n + 1))


def A365103(n):
    return len({pow(x, 4, 1 << (n << 1)) for x in range(1 << (n << 1))})


def A105221(n):
    return sum(p for p in primefactors(n) if p < n)


def A363084_gen(startvalue=1):  # generator of terms
    for k in count(max(startvalue, 1)):
        a, b = 1, 1
        for p, e in factorint(k).items():
            if e & 1:
                a *= p
            else:
                b *= p
        if b > 1 and is_square(a * (b - 1)):
            yield k


def A365517_gen(startvalue=1):  # generator of terms
    for k in count(max(startvalue, 1)):
        a, b = 1, 1
        for p, e in factorint(k).items():
            if e & 1:
                a *= p
            else:
                b *= p
        if is_square(a * (b + 1)):
            yield k


def A065620(n):
    c, a, b = 0, -1, 1
    for j in bin(n)[-1:1:-1]:
        if int(j):
            c += (a := -a) * b
        b <<= 1
    return c


def A365657_gen(startvalue=1):
    for k in count(max(startvalue, 1)):
        m, flag = k**2, False
        for x in count(1):
            if (x4 := x**4) + 2 > m or flag:
                break
            for y in range(min(x, integer_nthroot(m - x4 - 1, 4)[0]), 0, -1):
                if (z4 := m - x4 - (y4 := y**4)) > y4 or flag:
                    break
                if integer_nthroot(z4, 4)[1]:
                    yield k
                    flag = True
                    break


def A365660(n):
    c = 0
    for p in partitions(n << 1):
        q, s = list(Counter(p).elements()), set()
        for l in range(1, len(q) + 1):
            for k in multiset_combinations(q, l):
                s.add(sum(k))
                if len(s) > n:
                    break
            else:
                continue
            break
        if len(s) == n:
            c += 1
    return c


def A365072(n):
    if n <= 1:
        return 1
    alist = [set(tuple(sorted(set(p))) for p in partitions(i)) for i in range(n)]
    c = 1
    for p in partitions(n, k=n - 1):
        s = set(p)
        for q in s:
            if tuple(sorted(s - {q})) in alist[q]:
                break
        else:
            c += 1
    return c


def A365006(n):
    if n <= 1:
        return 1
    alist = [set(tuple(sorted(set(p))) for p in partitions(i)) for i in range(n)]
    c = 1
    for p in partitions(n, k=n - 1):
        if max(p.values()) == 1:
            s = set(p)
            for q in s:
                if tuple(sorted(s - {q})) in alist[q]:
                    break
            else:
                c += 1
    return c


def A276107(n):
    return len(
        {
            tuple(sorted((p + q).items()))
            for p in (Counter(p) for p in partitions(n >> 1))
            for q in (Counter(q) for q in partitions(n + 1 >> 1))
        }
    )


def A002219(n):
    return len(
        {
            tuple(sorted((p + q).items()))
            for p, q in combinations_with_replacement(
                tuple(Counter(p) for p in partitions(n)), 2
            )
        }
    )


def A006827(n):
    return npartitions(n << 1) - len(
        {
            tuple(sorted((p + q).items()))
            for p, q in combinations_with_replacement(
                tuple(Counter(p) for p in partitions(n)), 2
            )
        }
    )


def A365068(n):
    if n <= 1:
        return 0
    alist, c = [set(tuple(sorted(set(p))) for p in partitions(i)) for i in range(n)], 0
    for p in partitions(n, k=n - 1):
        s = set(p)
        if any(set(t).issubset(s - {q}) for q in s for t in alist[q]):
            c += 1
    return c


def A321470_gen():  # generator of terms
    aset = {(1,)}
    yield 1
    for n in count(2):
        yield len(aset)
        aset = {
            tuple(sorted(p + q))
            for p in aset
            for q in (tuple(sorted(Counter(q).elements())) for q in partitions(n))
        }


def A363226(n):
    return sum(
        1
        for p in partitions(n)
        if max(p.values(), default=0) == 1
        and any(
            q[0] + q[1] == q[2]
            for q in combinations_with_replacement(sorted(Counter(p).elements()), 3)
        )
    )


def A364346(n):
    return sum(
        1
        for p in partitions(n)
        if max(p.values(), default=1) == 1
        and not any(
            q[0] + q[1] == q[2]
            for q in combinations_with_replacement(sorted(Counter(p).elements()), 3)
        )
    )


def A365002(n):
    aset = Counter(tuple(sorted(set(p))) for p in partitions(n))
    return sum(
        sum(aset[t] for t in aset if set(t).issubset(set(q)))
        for l in range(1, n + 1)
        for q in combinations(range(1, n + 1), l)
        if sum(q) <= n
    )


def A364909(n):
    if n == 0:
        return 1
    aset = tuple(set(p) for p in partitions(n) if max(p.values(), default=0) == 1)
    return sum(
        factorial(len(t)) for p in partitions(n) for t in aset if set(p).issubset(t)
    )


def A238628(n):
    return sum(1 for p in partitions(n) if n - max(p, default=0) in p)


def A238479(n):
    return sum(
        1 for p in partitions(n) if (m := max(p, default=0)) & 1 ^ 1 and m >> 1 in p
    )


def A363132(n):
    return (
        sum(
            1
            for s, p in partitions(n << 1, m=n, size=True)
            if n == s * min(p, default=0)
        )
        if n
        else 0
    )


@lru_cache(maxsize=None)
def A008284_T(n, k):
    if k == n or k == 1:
        return 1
    if k > n:
        return 0
    return A008284_T(n - 1, k - 1) + A008284_T(n - k, k)


def A327483_T(n, k):
    return A008284_T(1 << n, 1 << n - k)


def A327484(n):
    return sum(A008284_T(1 << n, 1 << k) for k in range(n + 1))


def A067538(n):
    return sum(A008284_T(n, d) for d in divisors(n, generator=True))


def A237984(n):
    return sum(1 for s, p in partitions(n, size=True) if not n % s and n // s in p)


def A327472(n):
    return (
        sum(1 for s, p in partitions(n, size=True) if n % s or n // s not in p)
        if n
        else 1
    )


def A240851(n):
    return sum(
        1
        for s, p in partitions(n, size=True)
        if max(p.values(), default=0) == 1 and (n % s or n // s not in p)
    )


def A240850(n):
    return sum(
        1
        for s, p in partitions(n, size=True)
        if max(p.values(), default=0) == 1 and not n % s and n // s in p
    )


def A363225(n):
    return sum(
        1
        for p in partitions(n)
        if any(
            q[0] + q[1] == q[2]
            for q in combinations_with_replacement(sorted(Counter(p).elements()), 3)
        )
    )


def A365689(n):
    return pow(n, (n + 1) ** (n + 2), 10)


def A120962(n):
    return pow(n, n**n, 10)


@lru_cache(maxsize=None)
def A008289_T(n, k):
    if k < 1 or n < k:
        return 0
    if n == 1:
        return 1
    return A008289_T(n - k, k) + A008289_T(n - k, k - 1)


def A365881(n):
    return A008284_T((m := 1 << n) ** 2, m)


def A323845(n):
    return (
        (m := 3 ** (n >> 1)) * (m + 1) >> 1
        if n & 1
        else (m := 3 ** ((n >> 1) - 1)) * (3 * m + 5) >> 1
    )


@lru_cache(maxsize=None)
def A087897_T(n, k):
    if n == 0:
        return 1
    if k < 3 or n < 0:
        return 0
    return A087897_T(n, k - 2) + A087897_T(n - k, k)


def A087897(n):
    return A087897_T(n, n - (n & 1 ^ 1))


def A365825(n):
    return npartitions(n) - (m := n >> 1) - (0 if n & 1 else npartitions(m) - 1)


def A056594(n):
    return (1, 0, -1, 0)[n & 3]


def A035363(n):
    return 0 if n & 1 else npartitions(n >> 1)


def A365203_gen():  # generator of terms
    yield (a := 1)
    for n in count(2):
        if a < n:
            b = a + n
        elif a == n:
            b = n**2
        elif a % n:
            b = a - n
        else:
            b = a // n
        yield (a := b)


def A365199_gen():  # generator of terms
    yield (a := 1)
    for n in count(2):
        if a < n:
            a += n
        elif a == n:
            a = n**2
        elif a % n:
            a -= n
        else:
            a //= n
        if a == 1:
            yield n


def A365108(n):
    c, qdict = n ** (n - 1), {}
    for p in range(1, n + 1):
        r, m = pow(p, n, n), p**n
        if r not in qdict:
            qdict[r] = tuple(nthroot_mod(r, n, n, all_roots=True))
        c = min(c, min(((m - q**n) // n for q in qdict[r] if q < p), default=c))
    return int(c)


def A001350(n):
    return lucas(n) - ((n & 1 ^ 1) << 1)


def A365857(n):
    return (
        sum(
            totient((n << 1) // k) * (lucas(k) - ((k & 1 ^ 1) << 1))
            for k in divisors(n << 1, generator=True)
        )
        // n
        >> 1
    )


def A032189(n):
    return (
        sum(
            totient(n // k) * (lucas(k) - ((k & 1 ^ 1) << 1))
            for k in divisors(n, generator=True)
        )
        // n
    )


def A000358(n):
    return (n & 1 ^ 1) + sum(
        totient(n // k) * (lucas(k) - ((k & 1 ^ 1) << 1))
        for k in divisors(n, generator=True)
    ) // n


def A008965(n):
    return sum(totient(d) * (1 << n // d) for d in divisors(n, generator=True)) // n - 1


def A365858(n):
    return sum(
        totient(((n << 1) - 1) // k) * (lucas(k) - ((k & 1 ^ 1) << 1))
        for k in divisors((n << 1) - 1, generator=True)
    ) // ((n << 1) - 1)


def A365859(n):
    m = n >> (~n & n - 1).bit_length()
    return sum(totient(k) * lucas(m // k) for k in divisors(m, generator=True)) // m


def A000204(n):
    return lucas(n)


def A364915(n):
    if n <= 1:
        return 1
    alist, c = [set(tuple(sorted(set(p))) for p in partitions(i)) for i in range(n)], 1
    for p in partitions(n, k=n - 1):
        s = set(p)
        if not any(set(t).issubset(s - {q}) for q in s for t in alist[q]):
            c += 1
    return c


def A364839(n):
    if n <= 1:
        return 0
    alist, c = [set(tuple(sorted(set(p))) for p in partitions(i)) for i in range(n)], 0
    for p in partitions(n, k=n - 1):
        if max(p.values(), default=0) == 1:
            s = set(p)
            if any(set(t).issubset(s - {q}) for q in s for t in alist[q]):
                c += 1
    return c


def A364350(n):
    if n <= 1:
        return 1
    alist, c = [set(tuple(sorted(set(p))) for p in partitions(i)) for i in range(n)], 1
    for p in partitions(n, k=n - 1):
        if max(p.values(), default=0) == 1:
            s = set(p)
            if not any(set(t).issubset(s - {q}) for q in s for t in alist[q]):
                c += 1
    return c


def A358331(n):
    divs = {d: n // d - 1 for d in divisors(n, generator=True)}
    return sum(
        1
        for s, p in partitions(n, m=max(divs, default=0), size=True)
        if s in divs
        and (t := integer_nthroot(prod(a**b for a, b in p.items()), s))[1]
        and divs[s] == t[0]
    )


def A067539(n):
    return sum(
        1
        for s, p in partitions(n, size=True)
        if integer_nthroot(prod(a**b for a, b in p.items()), s)[1]
    )


def A357710(n):
    return (
        sum(
            factorial(s) // prod(factorial(d) for d in p.values())
            for s, p in partitions(n, size=True)
            if integer_nthroot(prod(a**b for a, b in p.items()), s)[1]
        )
        if n
        else 0
    )


def A348719_gen():  # generator of terms
    c = 0
    yield 1
    for n in count(2):
        divs = tuple(divisors(n, generator=True))
        l, b = len(divs), sum(divs)
        if l >= 4 and 2 ** (l - 1) - l > c:
            m = sum(
                1
                for k in range(2, (l - 1 >> 1) + 1)
                for p in combinations(divs, k)
                if not ((s := sum(p)) % k or (b - s) % (l - k))
            )
            if l & 1 == 0:
                k = l >> 1
                m += sum(
                    1
                    for p in combinations(divs, k)
                    if 1 in p and not ((s := sum(p)) % k or (b - s) % k)
                )
            if m > c:
                yield n
                c = m


def A348716_gen():  # generator of terms
    c = 0
    yield 1
    for n in count(2):
        divs = tuple(divisors(n, generator=True))
        l, b = len(divs), sum(Fraction(1, d) for d in divs)
        if l >= 4 and 2 ** (l - 1) - l > c:
            m = sum(
                1
                for k in range(2, (l - 1 >> 1) + 1)
                for p in combinations(divs, k)
                if not (
                    (s := sum(Fraction(1, d) for d in p)).denominator
                    * k
                    % (s.numerator)
                    or (r := b - s).denominator * (l - k) % (r.numerator)
                )
            )
            if l & 1 == 0:
                k = l >> 1
                m += sum(
                    1
                    for p in combinations(divs, k)
                    if 1 in p
                    and not (
                        (s := sum(Fraction(1, d) for d in p)).denominator
                        * k
                        % (s.numerator)
                        or (r := b - s).denominator * k % (r.numerator)
                    )
                )
            if m > c:
                yield n
                c = m


@lru_cache(maxsize=None)
def A304792_T(n, i, s, l):
    if n == 0:
        return l
    if i < 1:
        return 0
    return A304792_T(n, i - 1, s, l) + A304792_T(
        n - i,
        min(n - i, i),
        (t := tuple(sorted(set(s + tuple(x + i for x in s))))),
        len(t),
    )


def A304792(n):
    return A304792_T(n, n, (0,), 1)


def A276024(n):
    return A304792_T(n, n, (0,), 1) - npartitions(n)


def A000712(n):
    return (
        sum(npartitions(k) * npartitions(n - k) for k in range(n + 1 >> 1)) << 1
    ) + (0 if n & 1 else npartitions(n >> 1) ** 2)


def A122768(n):
    return (
        (sum(npartitions(k) * npartitions(n - k) for k in range(1, n + 1 >> 1)) << 1)
        + (0 if n & 1 else npartitions(n >> 1) ** 2)
        + npartitions(n)
        if n
        else 0
    )


@lru_cache(maxsize=None)
def A000716(n):
    return sum(A000716(k) * divisor_sigma(n - k) for k in range(n)) * 3 // n if n else 1


@lru_cache(maxsize=None)
def A000713(n):
    return (
        sum(A000713(k) * ((divisor_sigma(n - k) << 1) + 1) for k in range(n)) // n
        if n
        else 1
    )


def A365918(n):
    return (n + 1) * npartitions(n) - A304792_T(n, n, (0,), 1)


@lru_cache(maxsize=None)
def A000629(n):
    return 1 + sum(comb(n, j) * A000629(j) for j in range(n)) if n else 1


def A364463(n):
    return sum(
        1
        for l in range(n + 1)
        for c in combinations(range(1, n + 1), l)
        if set(c).isdisjoint({c[i + 1] - c[i] for i in range(l - 1)})
    )


def A364466(n):
    return sum(
        1
        for l in range(n + 1)
        for c in combinations(range(1, n + 1), l)
        if not set(c).isdisjoint({c[i + 1] - c[i] for i in range(l - 1)})
    )


def A363260(n):
    return sum(
        1
        for s, p in map(
            lambda x: (x[0], tuple(sorted(Counter(x[1]).elements()))),
            partitions(n, size=True),
        )
        if set(p).isdisjoint({p[i + 1] - p[i] for i in range(s - 1)})
    )


def A364467(n):
    return sum(
        1
        for s, p in map(
            lambda x: (x[0], tuple(sorted(Counter(x[1]).elements()))),
            partitions(n, size=True),
        )
        if not set(p).isdisjoint({p[i + 1] - p[i] for i in range(s - 1)})
    )


def A364464(n):
    return sum(
        1
        for s, p in map(
            lambda x: (x[0], tuple(sorted(Counter(x[1]).elements()))),
            filter(
                lambda p: max(p[1].values(), default=1) == 1, partitions(n, size=True)
            ),
        )
        if set(p).isdisjoint({p[i + 1] - p[i] for i in range(s - 1)})
    )


def A364536(n):
    return sum(
        1
        for s, p in map(
            lambda x: (x[0], tuple(sorted(Counter(x[1]).elements()))),
            filter(
                lambda p: max(p[1].values(), default=1) == 1, partitions(n, size=True)
            ),
        )
        if not set(p).isdisjoint({p[i + 1] - p[i] for i in range(s - 1)})
    )


def A301854(n):
    return sum(
        sum(
            1
            for r in Counter(
                sum(q)
                for l in range(1, len(p) + 1)
                for q in multiset_combinations(p, l)
            ).values()
            if r == 1
        )
        for p in (tuple(Counter(x).elements()) for x in partitions(n))
    )


def A304796(n):
    return npartitions(n) + sum(
        sum(
            1
            for r in Counter(
                sum(q)
                for l in range(1, len(p) + 1)
                for q in multiset_combinations(p, l)
            ).values()
            if r == 1
        )
        for p in (tuple(Counter(x).elements()) for x in partitions(n))
    )


def A365097(n):
    c, a, q, m = 1, 1, 0, 1
    for k in count(2):
        m += 1
        if m == n:
            m = 0
            q += 1
            a = sympydigits(q, n).count(1)
        elif m == 1:
            a += 1
        elif m == 2:
            a -= 1
        c += a
        if c == k:
            return k


def A226238(n):
    return (n**n - n) // (n - 1)


def A023037(n):
    return (n**n - 1) // (n - 1) if n > 1 else n


def A366091(n):
    c = 0
    for k in count(0):
        if (a := 3 * k**2) > n:
            break
        for j in count(0):
            if (b := a + (j**2 << 1)) > n:
                break
            if is_square(n - b):
                c += 1
    return c


def A365926(n):
    return (
        len(
            {
                tuple(Matrix(n, n, p).charpoly().as_list())
                for p in product(range(n), repeat=n**2)
            }
        )
        if n
        else 1
    )


def A272659(n):
    return (
        len(
            {
                tuple(Matrix(n, n, p).charpoly().as_list())
                for p in product(range(3), repeat=n**2)
            }
        )
        if n
        else 1
    )


def A272662(n):
    return (
        len(
            {
                tuple(Matrix(n, n, p).charpoly().as_list())
                for p in product((-1, 1), repeat=n**2)
            }
        )
        if n
        else 1
    )


def A272661(n):
    return (
        len(
            {
                tuple(Matrix(n, n, p).charpoly().as_list())
                for p in product((0, 1), repeat=n**2)
            }
        )
        if n
        else 1
    )


def A272658(n):
    return (
        len(
            {
                tuple(Matrix(n, n, p).charpoly().as_list())
                for p in product((-1, 0, 1), repeat=n**2)
            }
        )
        if n
        else 1
    )


def A365452(n):
    return max(((i + 1) ** (n - i) * (i**2 + 1) - 1) // i for i in range(1, n + 1))


def A366144(n):
    return n * d if (q := divmod(n, d := int(divisor_count(n))))[1] else q[0]


def A366094(n):
    return (
        (
            p
            if ((m := sum(prime(i) for i in range(1, n + 1))) << 1)
            - (p := prevprime(m + 1))
            <= (k := nextprime(m))
            else k
        )
        if n
        else 2
    )


def A366092(n):
    return (
        min(
            (m := sum(prime(i) for i in range(1, n + 1))) - prevprime(m + 1),
            nextprime(m) - m,
        )
        if n
        else 2
    )


def A366093_gen():  # generator of terms
    c, s, p = 2, 0, 1
    yield 0
    for i in count(1):
        if (
            m := min(
                (s := s + (p := nextprime(p))) - prevprime(s + 1), nextprime(s) - s
            )
        ) > c:
            yield i
            c = m


def A366139(n):
    return int((s := bin(n))[(m := n % n.bit_length() + 2) :] + s[2:m], 2) if n else 0


def A366067_gen():  # generator of terms
    a, b = 578, Counter({2: 1, 17: 2})
    while True:
        yield a
        c = prod((e + 1 for e in b.values()))
        if (
            d := sum((Counter(factorint(e + 1)) for e in b.values()), start=Counter())
        ) <= b:
            a //= c
            b -= d
        else:
            a *= c
            b += d


def A366186_gen():  # generator of terms
    return filter(
        lambda k: k <= 3
        or all(
            c.is_integer for c in Poly(diff(bernoulli(k, symbolx), symbolx, 3)).coeffs()
        ),
        count(1),
    )


def A366187_gen():  # generator of terms
    return filter(
        lambda k: k <= 4
        or all(
            c.is_integer for c in Poly(diff(bernoulli(k, symbolx), symbolx, 4)).coeffs()
        ),
        count(1),
    )


def A366188_gen():  # generator of terms
    return filter(
        lambda k: k <= 5
        or all(
            c.is_integer for c in Poly(diff(bernoulli(k, symbolx), symbolx, 5)).coeffs()
        ),
        count(1),
    )


def A366169_gen():  # generator of terms
    return filter(
        lambda k: k <= 2
        or all(
            c.is_integer for c in Poly(diff(bernoulli(k, symbolx), symbolx, 2)).coeffs()
        ),
        count(1),
    )


def A366189(n):
    p = Poly(bernoulli(n, symbolx))
    for i in count(1):
        p = diff(p)
        if all(c.is_integer for c in p.coeffs()):
            return i


def A094960_gen():  # generator of terms
    return filter(
        lambda k: k <= 1
        or all(
            c.is_integer for c in Poly(diff(bernoulli(k, symbolx), symbolx)).coeffs()
        ),
        count(1),
    )


def A366161(n):
    return divisor_count(
        (m := n * gcd(*factorint(n).values())) >> (t := (m - 1 & ~m).bit_length())
    ) * (t << 1 | 1)


def A366196(n):
    return divisor_count(
        (m := n * gcd(*factorint(n).values())) >> (t := (m - 1 & ~m).bit_length())
    ) * (t + 1)


def A365876(n):
    if n == 1:
        return 1
    c = 0
    for v in range(1, n + 1 >> 1):
        u = n - (v << 1)
        if gcd(u, v) == 1:
            v2, u2 = v * v, v * (u << 2)
            if v2 + u2 >= 0:
                c += 1
            if v2 - u2 >= 0:
                c += 1
    return c


def A364384(n):
    if n == 1:
        return 1
    c = 0
    for v in range(0, n):
        for w in range(0, n - v):
            u = n - v - w
            if gcd(u, v, w) == 1:
                v2, w2, u2 = v * v, w * (u << 2), u << 1
                if v2 + w2 >= 0:
                    d, r = integer_nthroot(v2 + w2, 2)
                    if r and not ((d + v) % u2 or (d - v) % u2):
                        c += 1
                        if v > 0 and w > 0:
                            c += 1
                if v2 - w2 >= 0:
                    d, r = integer_nthroot(v2 - w2, 2)
                    if r and not ((d + v) % u2 or (d - v) % u2):
                        c += 1
                        if v > 0 and w > 0:
                            c += 1
    return c


def A364385(n):
    c = 0
    for v in range(0, n):
        for w in range(0, n - v):
            for u in range(1, n - v - w + 1):
                if gcd(u, v, w) == 1:
                    v2, w2, u2 = v * v, w * (u << 2), u << 1
                    if v2 + w2 >= 0:
                        d, r = integer_nthroot(v2 + w2, 2)
                        if r and not ((d + v) % u2 or (d - v) % u2):
                            c += 1
                            if v > 0 and w > 0:
                                c += 1
                    if v > 0 and v2 - w2 >= 0:
                        d, r = integer_nthroot(v2 - w2, 2)
                        if r and not ((d + v) % u2 or (d - v) % u2):
                            c += 1
                            if w > 0:
                                c += 1
    return c


def A365892_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        if n == 1:
            yield 1
        else:
            for v in range(1, n + 1 >> 1):
                u = n - (v << 1)
                if gcd(u, v) == 1:
                    v2, u2, a = v * v, v * (u << 2), u << 1
                    if v2 + u2 >= 0:
                        d, r = integer_nthroot(v2 + u2, 2)
                        if r and not ((d + v) % a and (d - v) % a):
                            yield n
                            break
                    if v2 - u2 >= 0:
                        d, r = integer_nthroot(v2 - u2, 2)
                        if r and not ((d + v) % a and (d - v) % a):
                            yield n
                            break


def A366168(n):
    return (
        lcm(*(c.q for c in Poly(diff(bernoulli(n, symbolx), symbolx, 2)).coeffs()))
        if n >= 3
        else 1
    )


def A195441(n):
    return prod(
        p
        for p in primerange((n + 2) // (2 | n & 1) + 1)
        if sum(sympydigits(n + 1, p)[1:]) >= p
    )


def A365877(n):
    if n == 1:
        return 1
    c = 1
    for m in range(2, n + 1):
        for v in range(1, m + 1 >> 1):
            u = m - (v << 1)
            if gcd(u, v) == 1:
                v2, u2 = v * v, v * (u << 2)
                if v2 + u2 >= 0:
                    c += 1
                if v2 - u2 >= 0:
                    c += 1
    return c


def A366165(n):
    a, l1, l2 = 10 ** ((n << 1) - 1), 10 ** (n - 1), 10**n
    for k in count(1):
        b = a - k
        if any(
            l1 <= d < l2 and d * l2 > b
            for d in takewhile(lambda m: m * m <= b, divisors(b))
        ):
            return k


def A366158(n):
    return len(
        {
            a[0] * (a[4] * a[8] - a[5] * a[7])
            - a[1] * (a[3] * a[8] - a[5] * a[6])
            + a[2] * (a[3] * a[7] - a[4] * a[6])
            for a in product(range(n + 1), repeat=9)
        }
    )


def A214749(n):
    return min(
        int(x)
        for x, y in diop_quadratic(n * (n - symboly) + symbolx * (symboly + 1))
        if x > 0
    )


def A214750(n):
    return min(
        int(x)
        for x, y in diop_quadratic(n * (n - symboly) + symbolx * (symboly + symbolx))
        if x > 0
    )


def A365248_gen(startvalue=2):  # generator of terms
    return filter(
        lambda n: not isprime(n + 1)
        and min(
            int(x)
            for x, y in diop_quadratic(n * (n - symboly) + symbolx * (symboly + 1))
            if x > 0
        )
        == n >> 1,
        count(max(startvalue + startvalue & 1, 2), 2),
    )


def A365249_gen(startvalue=3):  # generator of terms
    return filter(
        lambda n: not isprime(n)
        and min(
            int(x)
            for x, y in diop_quadratic(n * (n - symboly) + symbolx * (symboly + 1))
            if x > 0
        )
        == n - 1 >> 1,
        count(max(startvalue + startvalue & 1 ^ 1, 3), 2),
    )


def A110357(n):
    return min(
        int(x)
        for x, y in diop_quadratic(n * (n + symboly) - symbolx * (n - symboly))
        if x > 0 and y > 0
    )


def A180346_gen(startvalue=1):  # generator of terms
    p = max(startvalue - 1, 0)
    while p := nextprime(p):
        c, q, a, b = 0, 1, 10, 10
        for m in range(1, 1000):
            if m >= b:
                a = 10 * a % p
                b *= 10
            c = (c * a + m) % p
            q = q * a % p
            if m > 99 and not (c or (q - 1) % p):
                yield p
                break


def A057889(n):
    return int(bin(n >> (m := (~n & n - 1).bit_length()))[:1:-1], 2) << m


def A366275(n):
    if n:
        k, c, m = int(bin(n >> (r := (~n & n - 1).bit_length()))[:1:-1], 2) << r, 0, 1
        while k:
            c += 1
            m *= prime(c) ** (s := (~k & k - 1).bit_length())
            k >>= s + 1
        return m * prime(c)
    return 1


def A057890_gen(startvalue=0):  # generator of terms
    return filter(
        lambda n: int(bin(m := n >> (~n & n - 1).bit_length())[:1:-1], 2) == m,
        count(max(startvalue, 0)),
    )


def A139550(n):
    return A003418(n >> 1)


def A366368(n):
    return A003418(n >> 1) * A003418(n)


def A366369(n):
    return A003418(n) // A003418(n >> 1)


def A003558(n):
    m, k = 1, 2 % (c := (r := n << 1) + 1)
    while not (k == 1 or k == r):
        k = 2 * k % c
        m += 1
    return m


def A366192_gen():  # generator of terms
    return chain.from_iterable(
        (i, n - i) for n in count(2) for i in range(1, n) if gcd(i, n - i) > 1
    )


def A352911_gen():  # generator of terms
    return chain.from_iterable(
        (i, n - i) for n in count(2) for i in range(1, n) if gcd(i, n - i) == 1
    )


def A122895(n):
    return int(is_square(m := 5 * int(divisor_count(n)) ** 2 - 4) or is_square(m + 8))


def A007310(n):
    return (n + (n >> 1) << 1) - 1


def A366442(n):
    return divisor_sigma((n + (n >> 1) << 1) - 1)


def A366441(n):
    return divisor_count((n + (n >> 1) << 1) - 1)


def A366438_gen():  # generator of terms
    for n in count(1):
        f = factorint(n).values()
        if all(e & 1 for e in f):
            yield prod(e + 1 for e in f)


def A061395(n):
    return primepi(max(primefactors(n), default=0))


def A243055(n):
    return primepi(max(p := primefactors(n), default=0)) - primepi(min(p, default=0))


def A242411(n):
    return primepi(p[-1]) - primepi(p[-2]) if len(p := primefactors(n)) > 1 else 0


def A051119(n):
    return n // (m := max(f := factorint(n))) ** f[m] if n > 1 else 1


def A053585(n):
    return (m := max(f := factorint(n))) ** f[m] if n > 1 else 1


def A071178(n):
    return max(factorint(n).items())[1] if n > 1 else 0


def A365771(n):
    return comb(m := (n << 1) + 1, n) * comb(m + n - 2, n) // m if n else 1


def A366439_gen():  # generator of terms
    for n in count(1):
        f = factorint(n)
        if all(e & 1 for e in f.values()):
            yield prod((p ** (e + 1) - 1) // (p - 1) for p, e in f.items())


def A165817(n):
    return comb(3 * n - 1, n) if n else 1


def A366448(n):
    return len(
        {
            (a + d, a * d - b * c)
            for a in range(n + 1)
            for b in range(n + 1)
            for c in range(b + 1)
            for d in range(a + 1)
        }
    )


def A182202_gen():  # generator of terms
    a, b = 0, 1
    yield a
    while True:
        yield b
        a, b = b, b + (a | b)


def A032924(n):
    return int(bin(m := n + 1)[3:], 3) + (3 ** (m.bit_length() - 1) - 1 >> 1)


def A081605_gen():  # generator of terms
    a = -1
    for n in count(2):
        b = int(bin(n)[3:], 3) + (3 ** (n.bit_length() - 1) - 1 >> 1)
        yield from range(a + 1, b)
        a = b


def A032923(n):
    return (int(bin(m := n + 1)[3:], 16) << 1) + (
        (1 << (m.bit_length() - 1 << 2)) - 1
    ) // 15


def A032922(n):
    return (int(bin(m := n + 1)[3:], 15) << 1) + (15 ** (m.bit_length() - 1) - 1) // 14


def A032921(n):
    return (int(bin(m := n + 1)[3:], 14) << 1) + (14 ** (m.bit_length() - 1) - 1) // 13


def A032920(n):
    return (int(bin(m := n + 1)[3:], 13) << 1) + (13 ** (m.bit_length() - 1) - 1) // 12


def A032919(n):
    return (int(bin(m := n + 1)[3:], 12) << 1) + (12 ** (m.bit_length() - 1) - 1) // 11


def A032918(n):
    return (int(bin(m := n + 1)[3:], 11) << 1) + (11 ** (m.bit_length() - 1) - 1) // 10


def A032917(n):
    return (int(bin(m := n + 1)[3:]) << 1) + (10 ** (m.bit_length() - 1) - 1) // 9


def A032916(n):
    return (int(bin(m := n + 1)[3:], 9) << 1) + (9 ** (m.bit_length() - 1) - 1 >> 3)


def A032915(n):
    return (int(bin(m := n + 1)[3:], 8) << 1) + (
        (1 << 3 * (m.bit_length() - 1)) - 1
    ) // 7


def A032914(n):
    return (int(bin(m := n + 1)[3:], 7) << 1) + (7 ** (m.bit_length() - 1) - 1) // 6


def A032913(n):
    return (int(bin(m := n + 1)[3:], 6) << 1) + (6 ** (m.bit_length() - 1) - 1) // 5


def A032912(n):
    return (int(bin(m := n + 1)[3:], 5) << 1) + (5 ** (m.bit_length() - 1) - 1 >> 2)


def A032911(n):
    return (int(bin(m := n + 1)[3:], 4) << 1) + (
        (1 << (m.bit_length() - 1 << 1)) - 1
    ) // 3


def A259566(n):
    return int(bin(m := n)[3:], 3) * 3 + (3 ** m.bit_length() - 1 >> 1) if n > 1 else 1


def A081606_gen():  # generator of terms
    a = 0
    for n in count(1):
        b = int(bin(n)[2:], 3) << 1
        yield from range(a + 1, b)
        a = b


def A027424(n):
    return len({i * j for i in range(1, n + 1) for j in range(1, i + 1)})


def A027384(n):
    return len({i * j for i in range(1, n + 1) for j in range(1, i + 1)}) + 1


def A062854(n):
    ds = tuple(tuple((d, i // d) for d in divisors(i)) for i in range(1, n + 1))
    return sum(
        1
        for i in range(1, n + 1)
        if all(
            b <= q
            for p, q in ds[i - 1]
            for (b, c) in takewhile(lambda x: p < x[1], ds[-1])
        )
    )


def A027417(n):
    return len({i * j for i in range(1, 1 << n) for j in range(1, i + 1)}) + 1


def A108407(n):
    return (
        n
        + 1
        - sum(
            1
            for i in range(1, n + 2)
            if all(d <= i for d in takewhile(lambda d: d <= n, divisors((n + 1) * i)))
        )
    )


def A027428(n):
    return len({i * j for i in range(1, n + 1) for j in range(1, i)})


def A027427(n):
    return 1 + len({i * j for i in range(1, n + 1) for j in range(1, i)}) if n else 0


def A225253(n):
    return len(
        {
            x + y
            for x, y in combinations_with_replacement(
                {i * j for i in range(n + 1) for j in range(i + 1)}, 2
            )
        }
    )


def A225254(n):
    return len(
        {
            sum(x)
            for x in combinations_with_replacement(
                {i * j for i in range(n + 1) for j in range(i + 1)}, 3
            )
        }
    )


def A027419(n):
    return len({i * j for i in range(1, prime(n) + 1) for j in range(1, i + 1)}) + 1


def A366181(n):
    a, b, c, d = 10 ** (n - 1), 10**n, 10 ** ((n << 1) - 1), 10 ** (n << 1)
    return len(
        {
            i * j
            for i in range(a, b)
            for j in range(min(i, c // i), min(b, d // i + 1))
            if c <= i * j < d
        }
    )


def A062851(n):
    return n**2 - len({i * j for i in range(1, n + 1) for j in range(1, i + 1)})


def A062855(n):
    return (
        (n << 1)
        - 1
        - sum(
            1
            for i in range(1, n + 1)
            if all(d <= i for d in takewhile(lambda d: d < n, divisors(n * i)))
        )
    )


def A334454(n):
    return len({i * j for i in range(2, n + 1) for j in range(2, i + 1)})


def A333995(n):
    return (
        sum(
            1
            for i in range(1, n + 1)
            if all(d <= i for d in takewhile(lambda d: d < n, divisors(n * i)))
        )
        - int(isprime(n))
        if n > 1
        else 0
    )


def A333996(n):
    return (n * (n + 1) >> 1) - primepi(n) - 1


def A014684(n):
    return n - int(isprime(n))


def A113638(n):
    return n - int(isprime(n))


def A338714(n):
    f = Counter(factorint(n))
    return sum(
        1
        for i in range(1, n + 1)
        if (l := tuple(sorted((f + Counter(factorint(i))).values()))) == (1, 2)
        or l == (5,)
    )


def A338713(n):
    f = Counter(factorint(n))
    return sum(
        1
        for i in range(1, n + 1)
        if (l := tuple((f + Counter(factorint(i))).values())) == (1, 1) or l == (3,)
    )


def A296084(n):
    f = factorint(n).items()
    return (
        int(
            not (prod((p ** (e + 1) - 1) // (p - 1) for p, e in f) - 1)
            % (prod(e + 1 for p, e in f) - 1)
        )
        if n > 1
        else 0
    )


def A366608(n):
    return totient((1 << (n << 1)) + 1)


def A366607(n):
    return divisor_sigma((1 << (n << 1)) + 1)


def A366606(n):
    return divisor_count((1 << (n << 1)) + 1)


def A366605(n):
    return primenu((1 << (n << 1)) + 1)


def A366604(n):
    return primenu((1 << (n << 1)) - 1)


def A366658(n):
    return totient((1 << 3 * n) + 1)


def A366654(n):
    return totient((1 << 3 * n) - 1)


def A366671(n):
    return min(primefactors((1 << 3 * n) + 1))


def A365930(n):
    c, y, a, b = 0, 2, (1 << n) - 1, (1 << n - 1) - 1
    while y < n:
        c += (m := integer_nthroot(a, y)[0]) - (k := integer_nthroot(b, y)[0])
        y = (integer_log(b, k)[0] if m == k else y) + 1
    return c


def A214415_gen():  # generator of terms
    n, m = 2, 4
    while True:
        if prevprime(m) & nextprime(m) == 1:
            yield n
        n += 1
        m *= 2


def A060298(n):
    if n == 1:
        return 3
    c, y, a, b, t = 0, 2, 10**n - 1, 10 ** (n - 1) - 1, (10**n).bit_length()
    while y < t:
        c += (m := integer_nthroot(a, y)[0]) - (k := integer_nthroot(b, y)[0])
        y = (integer_log(b, k)[0] if m == k else y) + 1
    return c


def A062857(n):
    if n == 1:
        return 1
    c = Counter()
    for m in count(1):
        for i in range(1, m):
            ij = i * m
            c[ij] += 2
            if c[ij] >= n:
                return m
        c[m * m] = 1


def A062856(n):
    if n == 1:
        return 1
    c = Counter()
    for m in count(1):
        for i in range(1, m):
            ij = i * m
            c[ij] += 2
            if c[ij] >= n:
                return ij
        c[m * m] = 1


def A062858(n):
    c = Counter()
    for m in count(1):
        for i in range(1, m + 1):
            ij = i * m
            c[ij] += 1
            if c[ij] >= n:
                return ij


def A062859(n):
    c = Counter()
    for m in count(1):
        for i in range(1, m + 1):
            ij = i * m
            c[ij] += 1
            if c[ij] >= n:
                return m


def A027425(n):
    return len(
        {
            i * j * k
            for i in range(1, n + 1)
            for j in range(1, i + 1)
            for k in range(1, j + 1)
        }
    )


def A027426(n):
    return 1 + len(
        {
            i * j * k
            for i in range(1, n + 1)
            for j in range(1, i + 1)
            for k in range(1, j + 1)
        }
    )


def A027430(n):
    return len(
        {i * j * k for i in range(1, n + 1) for j in range(1, i) for k in range(1, j)}
    )


def A100436(n):
    return len(
        {
            i * j * k
            for i in range(1, n + 1)
            for j in range(1, i + 1)
            for k in range(1, j)
        }
    )


def A100435(n):
    return len(
        {
            i * j * k
            for i in range(1, n + 1)
            for j in range(1, i)
            for k in range(1, j + 1)
        }
    )


def A100438(n):
    return len(
        {
            i * j * k * l
            for i in range(1, n + 1)
            for j in range(1, i)
            for k in range(1, j)
            for l in range(1, k)
        }
    )


def A351203(n):
    c = 0
    for s, p in partitions(n, size=True):
        for q in permutations(Counter(p).elements(), s):
            if max(Counter(tuple(g) for k, g in groupby(q)).values(), default=0) > 1:
                c += 1
                break
    return c


def A144300(n):
    return npartitions(n) - divisor_count(n)


def A126256(n):
    s, c = (1,), {1}
    for i in range(n):
        s = (1,) + tuple(s[j] + s[j + 1] for j in range(len(s) - 1)) + (1,)
        c.update(set(s))
    return len(c)


def A126257(n):
    if n:
        s, c = (1,), {1}
        for i in range(n - 1):
            c.update(
                set(
                    s := (1,) + tuple(s[j] + s[j + 1] for j in range(len(s) - 1)) + (1,)
                )
            )
        return len(
            set((1,) + tuple(s[j] + s[j + 1] for j in range(len(s) - 1)) + (1,)) - c
        )
    return 1


def A126254(n):
    return len({i**j for i in range(1, n + 1) for j in range(1, n + 1)})


def A126255(n):
    return len({i**j for i in range(2, n + 1) for j in range(2, n + 1)})


def A061786(n):
    return len({i**2 + j**2 for i in range(1, n + 1) for j in range(1, i + 1)})


def A034868_gen():  # generator of terms
    yield from (s := (1,))
    for i in count(0):
        yield from (
            s := (1,)
            + tuple(s[j] + s[j + 1] for j in range(len(s) - 1))
            + ((s[-1] << 1,) if i & 1 else ())
        )


def A014631_gen():  # generator of terms
    s, c = (1,), set()
    for i in count(0):
        for d in s:
            if d not in c:
                yield d
                c.add(d)
        s = (
            (1,)
            + tuple(s[j] + s[j + 1] for j in range(len(s) - 1))
            + ((s[-1] << 1,) if i & 1 else ())
        )


def A265912_gen():  # generator of terms
    s, c = (1,), set()
    for i in count(0):
        for d in s:
            if d not in c:
                yield i
                c.add(d)
        s = (
            (1,)
            + tuple(s[j] + s[j + 1] for j in range(len(s) - 1))
            + ((s[-1] << 1,) if i & 1 else ())
        )


def A366703_gen():  # generator of terms
    for i in count(2):
        b = prime(i)
        b4 = b**4
        for j in range(1, i):
            d = prime(j)
            bd = b4 - d**4
            for q in divisors(bd, generator=True):
                bdq = bd // q
                for p in divisors(bdq):
                    bdpq = bdq // p
                    if q <= p:
                        break
                    if not (p + q) & 1:
                        c, a = p + q >> 1, q - p >> 1
                        if (
                            a < c < d
                            and c**2 + a**2 == bdpq
                            and isprime(a)
                            and isprime(c)
                        ):
                            yield from (a, b, c, d)


def A255352_gen():  # generator of terms
    for b in count(4):
        b4 = b**4
        for d in range(3, b):
            bd = b4 - d**4
            for q in divisors(bd, generator=True):
                bdq = bd // q
                for p in divisors(bdq):
                    bdpq = bdq // p
                    if q <= p:
                        break
                    if not (p + q) & 1:
                        c, a = p + q >> 1, q - p >> 1
                        if a < c < d and c**2 + a**2 == bdpq:
                            yield from (a, b, c, d)


def A365406_gen(startvalue=1):  # generator of terms
    return filter(
        lambda i: (a := (d := divisors(i))[len(d) - 1 >> 1]) == 1 << a.bit_length() - 1,
        count(max(startvalue, 1)),
    )


def A365408_gen(startvalue=1):  # generator of terms
    return filter(
        lambda i: (a := (d := divisors(i))[len(d) - 1 >> 1]) != 1 << a.bit_length() - 1,
        count(max(startvalue, 1)),
    )


def A120498_gen(startvalue=1):  # generator of terms
    for c in count(max(startvalue, 1)):
        pc = set(primefactors(c))
        for a in range(1, (c >> 1) + 1):
            b = c - a
            if gcd(a, b) == 1 and c > prod(
                set(primefactors(a)) | set(primefactors(b)) | pc
            ):
                yield c
                break


def A130510_gen(startvalue=1):  # generator of terms
    for c in count(max(startvalue, 1)):
        pc = set(primefactors(c))
        for a in range(1, (c >> 1) + 1):
            b = c - a
            if gcd(a, b) == 1 and c > prod(
                set(primefactors(a)) | set(primefactors(b)) | pc
            ):
                yield c


def A130511_gen():  # generator of terms
    for c in count(1):
        pc = set(primefactors(c))
        for a in range(1, (c >> 1) + 1):
            b = c - a
            if gcd(a, b) == 1 and c > prod(
                set(primefactors(a)) | set(primefactors(b)) | pc
            ):
                yield a


def A130512_gen():  # generator of terms
    for c in count(1):
        pc = set(primefactors(c))
        for a in range(1, (c >> 1) + 1):
            b = c - a
            if gcd(a, b) == 1 and c > (
                d := prod(set(primefactors(a)) | set(primefactors(b)) | pc)
            ):
                yield d


def A363838(n):
    return prod(
        b ** sum(n // b**i for i in range(1, integer_log(n, b)[0] + 1))
        for b in range(2, n + 1)
    )


def A365837(n):
    if n <= 1:
        return 1
    f = factorint(n)
    return prod(p ** (e & -2) for p, e in f.items()) // (
        min(f) ** 2 if all(e & 1 ^ 1 for e in f.values()) else 1
    )


def A359534_gen():  # generator of terms
    for a in "23456789":
        for l in count(0):
            for b in product("023456789", repeat=l):
                n = int(a + "".join(b))
                if "one" in "".join(
                    (d for d in num2words(n).replace(" and ", "") if d.isalpha())
                ):
                    yield n


def A261439_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: sum(int(d) for d in str(n)) > sum(int(d) for d in str(n**4)),
        count(max(startvalue, 1)),
    )


def A000537(n):
    return (n * (n + 1) >> 1) ** 2


def A319086(n):
    return (
        (-(((s := isqrt(n)) * (s + 1)) ** 3) * (2 * s + 1) >> 1)
        + sum(
            k**2 * (q := n // k) * (q + 1) * (2 * k * (2 * q + 1) + 3 * q * (q + 1))
            for k in range(1, s + 1)
        )
    ) // 12


def A364194(n):
    return (
        (((s := isqrt(n)) * (s + 1)) ** 3 * (2 * s + 1) * (1 - 3 * s * (s + 1)) >> 1)
        + sum(
            (q := n // k)
            * (q + 1)
            * k**3
            * (q * (15 * k + q * (15 * k + 12 * q + 18) + 2) - 2)
            for k in range(1, s + 1)
        )
    ) // 60


def A364269(n):
    return (
        (((s := isqrt(n)) * (s + 1)) ** 4 * (1 - s * (s + 1 << 1)) >> 2)
        + sum(
            ((q := n // k) * (q + 1)) ** 2 * k**3 * (3 * k**2 + (q * (q + 1 << 1) - 1))
            for k in range(1, s + 1)
        )
    ) // 12


def A364268(n):
    return (
        ((s := isqrt(n)) * (s + 1) * (2 * s + 1)) ** 2 * (1 - 3 * s * (s + 1)) // 6
        + sum(
            (q := n // k)
            * (q + 1)
            * (2 * q + 1)
            * k**2
            * (5 * k**2 + 3 * q * (q + 1) - 1)
            for k in range(1, s + 1)
        )
    ) // 30


def A143128(n):
    return (
        (-(((s := isqrt(n)) * (s + 1)) ** 2) * (2 * s + 1) >> 1)
        + sum(
            (q := n // k) * (q + 1) * k * (3 * k + 2 * q + 1) for k in range(1, s + 1)
        )
    ) // 6


def A002541(n):
    return (sum(n // k for k in range(1, isqrt(n) + 1)) << 1) - isqrt(n) ** 2 - n


def A008805(n):
    return (m := (n >> 1) + 1) * (m + 1) >> 1


def A049798(n):
    return sum((n + 1) % k for k in range(2, (n + 1 >> 1) + 1))


def A366760(n):
    return totient(factorial(n) + 1)


def A366759(n):
    return totient(factorial(n) - 1)


def A366757(n):
    return divisor_sigma(factorial(n) - 1)


def A366758(n):
    return divisor_sigma(factorial(n) + 1)


def A064144(n):
    return divisor_count(factorial(n) + 1)


def A064603(n):
    return (
        -((s := isqrt(n)) ** 3) * (s + 1) ** 2
        + sum(
            (q := n // k) * (4 * k**3 + q * (q * (q + 2) + 1)) for k in range(1, s + 1)
        )
    ) >> 2


def A064602(n):
    return (
        -((s := isqrt(n)) ** 2) * (s + 1) * (2 * s + 1)
        + sum((q := n // k) * (6 * k**2 + q * (2 * q + 3) + 1) for k in range(1, s + 1))
    ) // 6


def A318742(n):
    return -((s := isqrt(n)) ** 4) + sum(
        (q := n // k) * (3 * k * (k - 1) + q**2 + 1) for k in range(1, s + 1)
    )


def A064604(n):
    return (
        -((s := isqrt(n)) ** 2) * (s**2 * (s * (6 * s + 15) + 10) - 1)
        + sum(
            (q := n // k) * (30 * k**4 + q**2 * (q * (6 * q + 15) + 10) - 1)
            for k in range(1, s + 1)
        )
    ) // 30


def A248076(n):
    return (
        (s := isqrt(n)) ** 3 * (s + 1) ** 2 * (1 - 2 * s * (s + 1))
        + sum(
            (q := n // k) * (12 * k**5 + q * (q**2 * (q * (2 * q + 6) + 5) - 1))
            for k in range(1, s + 1)
        )
    ) // 12


def A319085(n):
    return (
        -(((s := isqrt(n)) * (s + 1) * (2 * s + 1)) ** 2) // 12
        + sum(k**2 * (q := n // k) * (q + 1) * (2 * q + 1) for k in range(1, s + 1))
    ) // 3


def A350124(n):
    return (
        -((s := isqrt(n)) ** 4) * (s + 1) * (2 * s + 1)
        + sum(
            (q := n // k)
            * (
                k * (3 * (k - 1))
                + q * (k * (9 * (k - 1)) + q * (k * (12 * k - 6) + 2) + 3)
                + 1
            )
            for k in range(1, s + 1)
        )
    ) // 6


def A309176(n):
    return (n**2 * (n + 1) >> 1) + (
        (s := isqrt(n)) ** 2 * (s + 1) * (2 * s + 1)
        - sum((q := n // k) * (6 * k**2 + q * (2 * q + 3) + 1) for k in range(1, s + 1))
    ) // 6


def A356125(n):
    return (-(((s := isqrt(n)) * (s + 1)) ** 3) >> 1) + sum(
        k * (q := n // k) * (q + 1) * (2 * k**2 + q * (q + 1)) for k in range(1, s + 1)
    ) >> 2


def A356249(n):
    return (
        -((s := isqrt(n)) ** 5) * (s + 1) ** 2
        + sum(
            (q := n // k) ** 2
            * (
                k * (3 * (k - 1))
                + q * (k * (k * (4 * k + 6) - 6) + q * (k * (3 * (k - 1)) + 1) + 2)
                + 1
            )
            for k in range(1, s + 1)
        )
        >> 2
    )


def A319914(n):
    return (
        ((s := isqrt(n)) + 1) * ((b := bernoulli(n + 1)) - bernoulli(n + 1, s + 1))
        + sum(
            k**n * (n + 1) * ((q := n // k) + 1) - b + bernoulli(n + 1, q + 1)
            for k in range(1, s + 1)
        )
    ) // (n + 1)


def A350128(n):
    return (
        ((s := isqrt(n)) + 1)
        * (1 - s)
        * (bernoulli(n + 1, s + 1) - (b := bernoulli(n + 1)))
        + sum(
            k**n * (n + 1) * (((q := n // k) + 1) * (q - 1))
            + (1 - 2 * k) * (b - bernoulli(n + 1, q + 1))
            for k in range(1, s + 1)
        )
    ) // (n + 1)


def A356239(n):
    return (
        -((bernoulli(n + 1, (s := isqrt(n)) + 1) - (b := bernoulli(n + 1))) ** 2)
        // (n + 1)
        + sum(k**n * (bernoulli(n + 1, n // k + 1) - b) << 1 for k in range(1, s + 1))
    ) // (n + 1)


def A356243(n):
    return (
        (
            ((s := isqrt(n)) * (s + 1) * (2 * s + 1))
            * ((b := bernoulli(n + 1)) - bernoulli(n + 1, s + 1))
            + sum(
                k**n * (n + 1) * ((q := n // k) * (q + 1) * (2 * q + 1))
                + 6 * k**2 * (bernoulli(n + 1, q + 1) - b)
                for k in range(1, s + 1)
            )
        )
        // (n + 1)
        // 6
    )


def A051336(n):
    return (
        (((s := isqrt(n - 1)) * (s + 1)) ** 2 >> 2)
        + (1 - s**2) * n
        + sum((q := (n - 1) // k) * (2 * n - k * (1 + q)) for k in range(1, s + 1))
    )


def A244049(n):
    return (
        (
            -n * (n + 3)
            - (s := isqrt(n)) ** 2 * (s + 1)
            + sum((q := n // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
        )
        >> 1
    ) + 1


def A004125(n):
    return n**2 + (
        (s := isqrt(n)) ** 2 * (s + 1)
        - sum((q := n // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
        >> 1
    )


def A271342(n):
    return -((s := isqrt(m := n >> 1)) ** 2) * (s + 1) + sum(
        (q := m // k) * ((k << 1) + q + 1) for k in range(1, s + 1)
    )


def A078471(n):
    return (
        (t := isqrt(m := n >> 1)) ** 2 * (t + 1)
        - sum((q := m // k) * ((k << 1) + q + 1) for k in range(1, t + 1))
        - (
            (s := isqrt(n)) ** 2 * (s + 1)
            - sum((q := n // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
            >> 1
        )
    )


def A326124(n):
    return (
        (t := isqrt(m := n >> 1)) ** 2 * (t + 1)
        - sum((q := m // k) * ((k << 1) + q + 1) for k in range(1, t + 1))
        - 3
        * (
            (s := isqrt(n)) ** 2 * (s + 1)
            - sum((q := n // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
            >> 1
        )
    )


def A243980(n):
    return (
        -((s := isqrt(n)) ** 2) * (s + 1)
        + sum((q := n // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
        << 1
    )


def A222548(n):
    return -((s := isqrt(n)) ** 3) + sum(
        (q := n // k) * ((k << 1) + q - 1) for k in range(1, s + 1)
    )


def A175254(n):
    return (
        ((s := isqrt(n)) ** 2 * (s + 1) * ((s + 1) * (2 * s + 1) - 6 * (n + 1)) >> 1)
        + sum(
            (q := n // k)
            * (-k * (q + 1) * (3 * k + 2 * q + 1) + 3 * (n + 1) * (2 * k + q + 1))
            for k in range(1, s + 1)
        )
    ) // 6


def A244048(n):
    return (
        -n * (n - 1)
        - (s := isqrt(n - 1)) ** 2 * (s + 1)
        + sum((q := (n - 1) // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
    ) >> 1


def A067436(n):
    return (
        (n**2 << 1)
        + (s := isqrt(n)) ** 2 * (s + 1)
        - sum((q := n // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
    )


def A123327(n):
    return n**2 + (
        (s := isqrt(n - 1)) ** 2 * (s + 1)
        - sum((q := (n - 1) // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
        >> 1
    )


def A294016(n):
    return (
        -((s := isqrt(n)) ** 2) * (s + 1)
        + sum((q := n // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
        - n**2
    )


def A327329(n):
    return -((s := isqrt(n)) ** 2) * (s + 1) + sum(
        (q := n // k) * ((k << 1) + q + 1) for k in range(1, s + 1)
    )


def A332490(n):
    return (
        n * (n + 1)
        - (s := isqrt(n - 1)) ** 2 * (s + 1)
        + sum((q := (n - 1) // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
        >> 1
    )


def A024919(n):
    return (
        -((s := isqrt(m := n >> 1)) ** 2) * (s + 1)
        + sum((q := m // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
        << 1
    ) + (
        (s := isqrt(n)) ** 2 * (s + 1)
        - sum((q := n // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
        >> 1
    )


def A076664(n):
    return (
        n * (n + 1) * (n + 2) // 3
        + (s := isqrt(n)) ** 2 * (s + 1)
        - sum((q := n // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
        >> 1
    )


def A256533(n):
    return (
        n
        * (
            -((s := isqrt(n)) ** 2) * (s + 1)
            + sum((q := n // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
        )
        >> 1
    )


def A072481(n):
    return (
        n * (n + 1) * ((n << 1) + 1)
        - (
            (s := isqrt(n)) ** 2 * (s + 1) * ((s + 1) * ((s << 1) + 1) - 6 * (n + 1))
            >> 1
        )
        - sum(
            (q := n // k)
            * (-k * (q + 1) * (3 * k + (q << 1) + 1) + 3 * (n + 1) * ((k << 1) + q + 1))
            for k in range(1, s + 1)
        )
    ) // 6


def A160664(n):
    return (
        -((s := isqrt(n)) ** 2) * (s + 1)
        + sum((q := n // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
        >> 1
    ) + 1


def A092406(n):
    return (
        (
            -((s := isqrt(n)) ** 2) * (s + 1)
            + sum((q := n // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
            >> 1
        )
        - 8
        if n > 3
        else (1 if n < 2 else n + 1)
    )


def A328366(n):
    return (
        (n * (n + 1) << 1)
        - (s := isqrt(n)) ** 2 * (s + 1)
        + sum((q := n // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
    )


def A299692(n):
    return n * (n + 1) + (
        -((s := isqrt(n)) ** 2) * (s + 1)
        + sum((q := n // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
        >> 1
    )


def A055064(n):
    return ((m := 1 << n) << n) + (
        (s := isqrt(m)) ** 2 * (s + 1)
        - sum((q := m // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
        >> 1
    )


def A364054_gen():  # generator of terms
    a, aset, p = 1, {0, 1}, 2
    while True:
        yield a
        for b in count(a % p, p):
            if b not in aset:
                aset.add(b)
                a, p = b, nextprime(p)
                break


def A366470_gen():  # generator of terms
    a, aset, p = 1, {0, 1}, 2
    while True:
        yield a
        for b in count(a, p):
            if b not in aset:
                aset.add(b)
                a = b % (p := nextprime(p))
                break


def A066186(n):
    return n * npartitions(n)


def A162362(n):
    return n * (npartitions(n) - n) - (
        (s := isqrt(n)) ** 2 * (s + 1)
        - sum((q := n // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
        >> 1
    )


def A256532(n):
    return n**3 + n * (
        (s := isqrt(n)) ** 2 * (s + 1)
        - sum((q := n // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
        >> 1
    )


def A294629(n):
    return (
        -((s := isqrt(n)) ** 2) * (s + 1)
        + sum((q := n // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
        - n**2
        << 2
    )


def A294017(n):
    return (
        ((s := isqrt(n)) ** 2 * (s + 1) * ((s + 1) * ((s << 1) + 1) - 6 * (n + 1)) >> 1)
        + sum(
            (q := n // k)
            * (-k * (q + 1) * (3 * k + (q << 1) + 1) + 3 * (n + 1) * ((k << 1) + q + 1))
            for k in range(1, s + 1)
        )
    ) // 3 - n * (n + 1) * ((n << 1) + 1) // 6


def A244050(n):
    return (
        ((s := isqrt(n)) ** 2 * (s + 1) * ((s + 1) * ((s << 1) + 1) - 6 * (n + 1)) >> 1)
        + sum(
            (q := n // k)
            * (-k * (q + 1) * (3 * k + (q << 1) + 1) + 3 * (n + 1) * ((k << 1) + q + 1))
            for k in range(1, s + 1)
        )
        << 1
    ) // 3


def A163180(n):
    return (
        divisor_count(n)
        + n**2
        + (
            (s := isqrt(n)) ** 2 * (s + 1)
            - sum((q := n // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
            >> 1
        )
    )


def A354801(n):
    return (
        n * (3 * n + 1)
        + (s := isqrt(n)) ** 2 * (s + 1)
        - sum((q := n // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
        >> 1
    )


def A244583(n):
    return (
        -((s := isqrt(p := prime(n))) ** 2) * (s + 1)
        + sum((q := p // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
        >> 1
    )


def A244824(n):
    return (
        -((s := isqrt(m := 1 << n)) ** 2) * (s + 1)
        + sum((q := m // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
        >> 1
    )


def A236632(n):
    return (s := isqrt(n)) ** 2 * (1 - s) + sum(
        (q := n // k) * ((k << 1) + q - 3) for k in range(1, s + 1)
    ) >> 1


def A168013(n):
    m = n * (n + 2)
    return (
        sum((q := m // k) * ((k << 1) + q + 1) for k in range(1, n + 1))
        - n**2 * (n + 1)
        >> 1
    )


def A168012(n):
    a, b = n * (n + 2), (n - 1) * (n + 1)
    return (
        (
            sum(
                (q := a // k) * ((s := k << 1) + q + 1) - (r := b // k) * (s + r + 1)
                for k in range(1, n)
            )
            >> 1
        )
        + 5 * n
        + 3
    )


def A168011(n):
    m = n * (n + 2)
    return (sum(m // k for k in range(1, n + 1)) << 1) - n**2


def A168010(n):
    a, b = n * (n + 2), (n - 1) * (n + 1)
    return (sum(a // k - b // k for k in range(1, n)) << 1) + 5


def A143238(n):
    return (
        -((s := isqrt(n)) ** 2) * (s + 1)
        + sum((q := n // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
        >> 1
    ) * divisor_sigma(n)


def A142337_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: isprime(
            -((s := isqrt(n)) ** 2) * (s + 1)
            + sum((q := n // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
            >> 1
        ),
        count(max(startvalue, 1)),
    )


def A072692(n):
    return (
        -((s := isqrt(m := 10**n)) ** 2) * (s + 1)
        + sum((q := m // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
        >> 1
    )


def A024920(n):
    return (s := isqrt(n)) ** 2 * (s + 1 - (n << 1)) + sum(
        (q := n // k) * ((n << 2) - (k << 1) - q - 1) for k in range(1, s + 1)
    ) >> 1


def A024917(n):
    return (
        -((s := isqrt(n)) ** 2) * (s + 1)
        + sum((q := n // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
        >> 1
    ) - n


def A143236(n):
    return (
        -((s := isqrt(n)) ** 2) + (sum(n // k for k in range(1, s + 1)) << 1)
    ) * divisor_count(n)


def A143274(n):
    return (-((s := isqrt(n)) ** 2) + (sum(n // k for k in range(1, s + 1)) << 1)) * n


def A156745(n):
    return n - (s := isqrt(n)) ** 2 + (sum(n // k for k in range(1, s + 1)) << 1)


def A059851(n):
    return (
        ((t := isqrt(m := n >> 1)) ** 2 << 1)
        - (s := isqrt(n)) ** 2
        + (
            sum(n // k for k in range(1, s + 1))
            - (sum(m // k for k in range(1, t + 1)) << 1)
            << 1
        )
    )


def A271860(n):
    return (
        ((t := isqrt(m := n >> 1)) ** 2 << 1)
        - (s := isqrt(n)) ** 2
        + (
            sum(n // k for k in range(1, s + 1))
            - (sum(m // k for k in range(1, t + 1)) << 1)
            << 1
        )
        << 1
    ) - n


def A161706(n):
    return (n * (n * (n * (n * (145 - 11 * n) - 635) + 1115) - 494) + 120) // 15 >> 3


def A061201(n):
    return (m := integer_nthroot(n, 3)[0]) ** 3 + 3 * sum(
        -((s := isqrt(r := n // i)) ** 2)
        + (sum(r // k for k in range(1, s + 1)) << 1)
        - sum(n // (i * j) for j in range(1, m + 1))
        for i in range(1, m + 1)
    )


def A094820(n):
    return ((s := isqrt(n)) * (1 - s) >> 1) + sum(n // k for k in range(1, s + 1))


def A057494(n):
    return -((s := isqrt(m := 10**n)) ** 2) + (
        sum(m // k for k in range(1, s + 1)) << 1
    )


def A060831(n):
    return ((t := isqrt(m := n >> 1)) + (s := isqrt(n))) * (t - s) + (
        sum(n // k for k in range(1, s + 1)) - sum(m // k for k in range(1, t + 1)) << 1
    )


def A263086(n):
    return (
        (t := isqrt(m := n >> 1)) ** 2
        - ((s := isqrt(n)) ** 2 << 1)
        + (
            (sum(n // k for k in range(1, s + 1)) << 1)
            - sum(m // k for k in range(1, t + 1))
            << 1
        )
    )


def A075997(n):
    return (
        n
        + (s := isqrt(n)) ** 2
        - ((t := isqrt(m := n >> 1)) ** 2 << 1)
        - (
            sum(n // k for k in range(1, s + 1))
            - (sum(m // k for k in range(1, t + 1)) << 1)
            << 1
        )
    )


def A078567(n):
    return (
        ((m := isqrt(n - 1)) ** 2 * (1 + m) ** 2 >> 2)
        - m**2 * n
        + sum((q := (n - 1) // i) * (2 * n - i * (1 + q)) for i in range(1, m + 1))
    )


def A153876(n):
    return ((t := isqrt(b := (1 << n - 1) - 1)) + (s := isqrt(a := (1 << n) - 1))) * (
        t - s
    ) + (
        sum(a // k for k in range(1, s + 1)) - sum(b // k for k in range(1, t + 1)) << 1
    )


def A059246(n):
    return (
        m := -((s := isqrt(n)) ** 2) + (sum(n // k for k in range(1, s + 1)) << 1)
    ) // gcd(n, m)


def A095256(n):
    return (
        -((s := isqrt(m := 10**n)) ** 2)
        + (sum(m // k for k in range(1, s + 1)) << 1)
        - (n + 1) ** 2
    )


def A139140(n):
    return (
        sum(divisor_count(k) for k in range(prime(n) + 1, prime(n + 1) + 1)) if n else 3
    )


def A153816(n):
    return -((s := isqrt(m := (10**n - 1) // 9)) ** 2) + (
        sum(m // k for k in range(1, s + 1)) << 1
    )


def A085683(n):
    return (
        -((s := isqrt(m := prime(n))) ** 2)
        + (sum(m // k for k in range(1, s + 1)) << 1)
        - 1
    )


def A330926(n):
    return (
        n
        + (s := isqrt(n - 1)) ** 2
        - ((t := isqrt(m := n - 1 >> 1)) ** 2 << 1)
        - (
            sum((n - 1) // k for k in range(1, s + 1))
            - (sum(m // k for k in range(1, t + 1)) << 1)
            << 1
        )
    )


def A351355(n):
    return (
        ((t := isqrt(m := n << 1)) + (s := isqrt(n))) * (t - s)
        + (
            sum(n // k for k in range(1, s + 1)) - sum(m // k for k in range(1, t + 1))
            << 1
        )
        + n * (n + 1)
    )


def A075995(n):
    return (
        -((s := isqrt(n)) ** 2)
        + (sum(n // k for k in range(1, s + 1)) << 1)
        - (n + 1 >> 1)
        if n > 1
        else 1
    )


def A351362(n):
    return (
        ((t := isqrt(m := (n << 1) - 1)) + (s := isqrt(r := n - 1))) * (t - s)
        + (
            sum(r // k for k in range(1, s + 1)) - sum(m // k for k in range(1, t + 1))
            << 1
        )
        + n * (n + 1)
        - 1
    )


def A098798(n):
    return (
        -((s := isqrt(n)) ** 2)
        + (sum(n // k for k in range(1, s + 1)) << 1)
        - divisor_sigma(n)
    )


def A140221_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: gcd(
            n, -((s := isqrt(n)) ** 2) + (sum(n // k for k in range(1, s + 1)) << 1)
        )
        == 1,
        count(max(startvalue, 1)),
    )


def A140237_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: not (
            -((s := isqrt(n)) ** 2) + (sum(n // k for k in range(1, s + 1)) << 1)
        )
        % divisor_count(n),
        count(max(startvalue, 1)),
    )


def A140238_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: gcd(
            divisor_count(n),
            -((s := isqrt(n)) ** 2) + (sum(n // k for k in range(1, s + 1)) << 1),
        )
        == 1,
        count(max(startvalue, 1)),
    )


def A230501(n):
    return (-((s := isqrt(n)) ** 2) + (sum(n // k for k in range(1, s + 1)) << 1)) // n


def A248517(n):
    return (
        ((t := isqrt(m := n >> 1)) + (s := isqrt(n))) * (t - s)
        + (
            sum(n // k for k in range(1, s + 1)) - sum(m // k for k in range(1, t + 1))
            << 1
        )
        - n
    )


def A299251(n):
    return (
        -((s := isqrt(m := (n + 1) ** 2 >> 2)) ** 2) - (n * (n + 1) >> 1) >> 1
    ) + sum(m // k for k in range(1, s + 1))


def A332569(n):
    return (
        -((s := isqrt(n)) ** 2) * (s + 1)
        + sum((q := n // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
        - divisor_sigma(n)
    )


def A338991(n):
    return ((s := isqrt(n)) + 1) * (n * (1 - s) + s**2) - sum(
        (q := n // k) * ((k - n << 1) + q + 1) for k in range(1, s + 1)
    )


def A356124_T(n, k):
    return (
        (s := isqrt(n)) * (s + 1) * (bernoulli(k + 1) - bernoulli(k + 1, s + 1))
        + sum(
            w**k * (k + 1) * ((q := n // w) * (q + 1))
            + (w * (bernoulli(k + 1, q + 1) - bernoulli(k + 1)) << 1)
            for w in range(1, s + 1)
        )
    ) // (k + 1) >> 1


def A356124_gen():  # generator of terms
    return (A356124_T(k + 1, n - k - 1) for n in count(1) for k in range(n))


def A356128(n):
    return (
        (s := isqrt(n)) * (s + 1) * (bernoulli(n + 2) - bernoulli(n + 2, s + 1))
        + sum(
            k ** (n + 1) * (n + 2) * (q := n // k) * (q + 1)
            + (k * (bernoulli(n + 2, q + 1) - bernoulli(n + 2)) << 1)
            for k in range(1, s + 1)
        )
    ) // (n + 2) >> 1


def A356129(n):
    return (
        (s := isqrt(n)) * (s + 1) * (bernoulli(n + 1) - bernoulli(n + 1, s + 1))
        + sum(
            k**n * (n + 1) * (q := n // k) * (q + 1)
            + (k * (bernoulli(n + 1, q + 1) - bernoulli(n + 1)) << 1)
            for k in range(1, s + 1)
        )
    ) // (n + 1) >> 1


def A356126(n):
    return (
        (
            -((s := isqrt(n)) ** 2)
            * (s + 1) ** 2
            * ((s << 1) + 1)
            * (s * (3 * (s + 1)) - 1)
            >> 1
        )
        + sum(
            k
            * (q := n // k)
            * (q + 1)
            * (15 * k**3 + ((q << 1) + 1) * (q * (3 * (q + 1)) - 1))
            for k in range(1, s + 1)
        )
    ) // 30


def A319649_T(n, k):
    return (
        ((s := isqrt(n)) + 1) * (bernoulli(k + 1) - bernoulli(k + 1, s + 1))
        + sum(
            w**k * (k + 1) * ((q := n // w) + 1)
            - bernoulli(k + 1)
            + bernoulli(k + 1, q + 1)
            for w in range(1, s + 1)
        )
    ) // (k + 1) + int(k == 0)


def A319649_gen():  # generator of terms
    return (A319649_T(k + 1, n - k - 1) for n in count(1) for k in range(n))


def A350123(n):
    return (
        -((s := isqrt(n)) ** 3) * (s + 1) * ((s << 1) + 1)
        + sum(
            (q := n // k) * (6 * k**2 * q + ((k << 1) - 1) * (q + 1) * ((q << 1) + 1))
            for k in range(1, s + 1)
        )
    ) // 6


def A350107(n):
    return (
        -((s := isqrt(n)) ** 3) * (s + 1)
        + sum(
            (q := n // k) * ((k << 1) * ((q << 1) + 1) - q - 1) for k in range(1, s + 1)
        )
        >> 1
    )


def A332623(n):
    return (
        n
        - (s := isqrt(n - 1)) ** 2 * (s + 2)
        + sum((q := (n - 1) // k) * ((k << 1) + q + 3) for k in range(1, s + 1))
    )


def A316296(n):
    return (
        ((s := isqrt(n)) + (t := isqrt(m := (n << 1) - 1))) * (s - t)
        + (
            sum(m // k for k in range(1, t + 1)) - sum(n // k for k in range(1, s + 1))
            << 1
        )
        - n
        + 1
    )


def A355947(n):
    return (s := isqrt(n)) ** 2 * (s - (n << 1) - 1) + sum(
        (q := n // k) * ((n << 2) - (k << 1) - q + 3) for k in range(1, s + 1)
    ) >> 1


def A092338(n):
    return divisor_count(n) + divisor_count(n - 1) - 1 if n > 1 else 1


def A052488(n):
    return int(n * harmonic(n))


def A102722(n):
    return (
        int(n * harmonic(n))
        + (s := isqrt(n)) ** 2
        - (sum(n // k for k in range(1, s + 1)) << 1)
    )


def A175346(n):
    return (
        (m := n**2) + (n << 1) + (sum(m // k for k in range(2, n)) << 1) if n > 1 else 1
    )


def A332264(n):
    return (
        ((s := isqrt(n)) ** 2 * (s + 1) * (6 - (s + 1) * ((s << 1) + 1)) >> 1)
        + sum(
            (q := n // k)
            * (k * (q + 1) * (3 * k + (q << 1) + 1) - 3 * ((k << 1) + q + 1))
            for k in range(1, s + 1)
        )
    ) // 6


def A258331(n):
    return prod(
        (p ** ((3 * e + 1) * 3) - 1) // (p**3 - 1) for p, e in factorint(n).items()
    )


def A175926(n):
    return prod((p ** (3 * e + 1) - 1) // (p - 1) for p, e in factorint(n).items())


def A202994(n):
    return prod((p ** ((e << 2) + 1) - 1) // (p - 1) for p, e in factorint(n).items())


def A065764(n):
    return prod((p ** ((e << 1) + 1) - 1) // (p - 1) for p, e in factorint(n).items())


def A024786(n):
    return sum(npartitions(n - (k << 1)) for k in range(1, (n >> 1) + 1))


def A087787(n):
    return sum(-npartitions(k) if n - k & 1 else npartitions(k) for k in range(n + 1))


def A366864_gen():  # generator of terms
    a, aset, p = 1, {0, 1}, 2
    for i in count(3):
        for b in count(a, p):
            if b not in aset:
                aset.add(b)
                c = b % (p := nextprime(p))
                if c > a:
                    yield i
                a = c
                break


def A366868_gen():  # generator of terms
    a, aset, p = 1, {0, 1}, 2
    for i in count(3):
        for b in count(a, p):
            if b not in aset:
                aset.add(b)
                c = b % (p := nextprime(p))
                if c > a:
                    yield a
                a = c
                break


def A366869_gen():  # generator of terms
    a, aset, p = 1, {0, 1}, 2
    for i in count(3):
        for b in count(a, p):
            if b not in aset:
                aset.add(b)
                c = b % (p := nextprime(p))
                if c > a:
                    yield c
                a = c
                break


def A364970(n):
    return (
        -((s := isqrt(n)) ** 2) * (s + 1) * (s + 2)
        + sum(
            (q := n // k) * (3 * k * (k + 1) + (q + 1) * (q + 2))
            for k in range(1, s + 1)
        )
    ) // 6


def A365409(n):
    return (
        -((s := isqrt(n)) ** 2) * comb(s + 3, 3)
        + sum(
            (q := n // k) * ((comb(k + 2, 3) << 2) + comb(q + 3, 3))
            for k in range(1, s + 1)
        )
        >> 2
    )


def A365439(n):
    return (
        -((s := isqrt(n)) ** 2) * comb(s + 4, 4)
        + sum(
            (q := n // k) * (5 * comb(k + 3, 4) + comb(q + 4, 4))
            for k in range(1, s + 1)
        )
    ) // 5


def A318743(n):
    return -((s := isqrt(n)) ** 5) + sum(
        (q := n // k) * (k**4 - (k - 1) ** 4 + q**3) for k in range(1, s + 1)
    )


def A318744(n):
    return -((s := isqrt(n)) ** 6) + sum(
        (q := n // k) * (k**5 - (k - 1) ** 5 + q**4) for k in range(1, s + 1)
    )


def A332469(n):
    return -((s := isqrt(n)) ** (n + 1)) + sum(
        (q := n // k) * (k**n - (k - 1) ** n + q ** (n - 1)) for k in range(1, s + 1)
    )


def A344725_T(n, k):
    return -((s := isqrt(n)) ** (k + 1)) + sum(
        (q := n // w) * (w**k - (w - 1) ** k + q ** (k - 1)) for w in range(1, s + 1)
    )


def A344725_gen():  # generator of terms
    return (A344725_T(k + 1, n - k) for n in count(1) for k in range(n))


def A345683(n):
    return (
        (m := factorial(n)) * (n - 1)
        + m // n
        + sum(
            (q := n // k) * (m // k - m // (k - 1)) + m // q
            for k in range(2, isqrt(n) + 1)
        )
    )


def A366475_gen():  # generator of terms
    a, aset, p = 1, {0, 1}, 1
    while True:
        p = nextprime(p)
        b = a % p
        for i in count(0):
            if b not in aset:
                aset.add(b)
                a = b
                break
            b += p
        yield i


def A366477(n):
    a, aset, p = 1, {0, 1}, 1
    for i in count(2):
        p = nextprime(p)
        b = a % p
        for j in count(0):
            if b not in aset:
                aset.add(b)
                a = b
                break
            b += p
        if j >= n:
            return i


def A350221(n):
    return (m := n**2) + sum(
        m // k**2 if k & 1 else -(m // k**2) for k in range(2, n + 1)
    )


def A350222(n):
    return (m := n**3) + sum(
        m // k**3 if k & 1 else -(m // k**3) for k in range(2, n + 1)
    )


def A153485(n):
    return (
        -n * (n + 1)
        - (s := isqrt(n)) ** 2 * (s + 1)
        + sum((q := n // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
    ) >> 1


def A279847(n):
    return (
        -n * (n + 1) * (2 * n + 1)
        - (s := isqrt(n)) ** 2 * (s + 1) * (2 * s + 1)
        + sum((q := n // k) * (6 * k**2 + q * (2 * q + 3) + 1) for k in range(1, s + 1))
    ) // 6


def A339804(n):
    return (
        n * (1 - n**2)
        + ((s := isqrt(n)) ** 4 << 1)
        + s**3 * (3 * (1 - n))
        + s**2 * (1 - 3 * n)
        + sum(
            (q := n // k)
            * (-6 * k**2 + n * (3 * ((k << 1) + q + 1)) - q * ((q << 1) + 3) - 1)
            for k in range(1, s + 1)
        )
    ) // 6


def A366911_gen():  # generator of terms
    a, aset, p = 1, {0, 1}, 2
    while True:
        k, b = divmod(a, p)
        for i in count(-k):
            if b not in aset:
                aset.add(b)
                a, p = b, nextprime(p)
                yield i
                break
            b += p


def A366912_gen():  # generator of terms
    a, aset, p, c = 1, {0, 1}, 2, 0
    while True:
        k, b = divmod(a, p)
        for i in count(-k):
            if b not in aset:
                aset.add(b)
                a, p = b, nextprime(p)
                yield c
                c += i
                break


def A366913(n):
    a, aset, p, c = 1, {0, 1}, 2, 0
    for i in count(1):
        if c == n:
            return i
        k, b = divmod(a, p)
        for j in count(-k):
            if b not in aset:
                aset.add(b)
                a, p = b, nextprime(p)
                c += j
                break
            b += p


def A339370(n):
    return (
        n * (1 - n)
        + (s := isqrt(n)) ** 2 * (s + 1 - (n << 1))
        - sum((q := n // k) * ((k - (n << 1) << 1) + q + 1) for k in range(1, s + 1))
        >> 1
    )


def A366915(n):
    return (
        -((t := isqrt(m := n >> 1)) ** 2) * (t + 1) * ((t << 1) + 1)
        + sum(
            (q := m // k) * (6 * k**2 + q * ((q << 1) + 3) + 1) for k in range(1, t + 1)
        )
        << 2
    ) // 3 + (
        (s := isqrt(n)) ** 2 * (s + 1) * ((s << 1) + 1)
        - sum(
            (q := n // k) * (6 * k**2 + q * ((q << 1) + 3) + 1) for k in range(1, s + 1)
        )
    ) // 6


def A366917(n):
    return (
        -((t := isqrt(m := n >> 1)) ** 3) * (t + 1) ** 2
        + sum(
            (q := m // k) * ((k**3 << 2) + q * (q * (q + 2) + 1))
            for k in range(1, t + 1)
        )
        << 2
    ) + (
        (s := isqrt(n)) ** 3 * (s + 1) ** 2
        - sum(
            (q := n // k) * ((k**3 << 2) + q * (q * (q + 2) + 1))
            for k in range(1, s + 1)
        )
        >> 2
    )


def A366919(n):
    return (
        (
            ((s := isqrt(m := n >> 1)) + 1)
            * (bernoulli(n + 1) - bernoulli(n + 1, s + 1))
            << n + 1
        )
        - ((t := isqrt(n)) + 1) * (bernoulli(n + 1) - bernoulli(n + 1, t + 1))
        + (
            sum(
                w**n * (n + 1) * ((q := m // w) + 1)
                - bernoulli(n + 1)
                + bernoulli(n + 1, q + 1)
                for w in range(1, s + 1)
            )
            << n + 1
        )
        - sum(
            w**n * (n + 1) * ((q := n // w) + 1)
            - bernoulli(n + 1)
            + bernoulli(n + 1, q + 1)
            for w in range(1, t + 1)
        )
    ) // (n + 1)


def A308313(n):
    return (
        (-1 if n & 1 else 1)
        * (
            (
                ((s := isqrt(m := n >> 1)) + 1)
                * (bernoulli(n + 1) - bernoulli(n + 1, s + 1))
                << n + 1
            )
            - ((t := isqrt(n)) + 1) * (bernoulli(n + 1) - bernoulli(n + 1, t + 1))
            + (
                sum(
                    w**n * (n + 1) * ((q := m // w) + 1)
                    - bernoulli(n + 1)
                    + bernoulli(n + 1, q + 1)
                    for w in range(1, s + 1)
                )
                << n + 1
            )
            - sum(
                w**n * (n + 1) * ((q := n // w) + 1)
                - bernoulli(n + 1)
                + bernoulli(n + 1, q + 1)
                for w in range(1, t + 1)
            )
        )
        // (n + 1)
    )


def A366842(n):
    return sum(1 for p in partitions(n) if gcd(*(q for q in p if q & 1)) > 1)


def A366936_T(n, k):
    if k:
        return (
            (
                (
                    ((s := isqrt(m := n >> 1)) + 1)
                    * (bernoulli(k + 1) - bernoulli(k + 1, s + 1))
                    << k + 1
                )
                - ((t := isqrt(n)) + 1) * (bernoulli(k + 1) - bernoulli(k + 1, t + 1))
                + (
                    sum(
                        w**k * (k + 1) * ((q := m // w) + 1)
                        - bernoulli(k + 1)
                        + bernoulli(k + 1, q + 1)
                        for w in range(1, s + 1)
                    )
                    << k + 1
                )
                - sum(
                    w**k * (k + 1) * ((q := n // w) + 1)
                    - bernoulli(k + 1)
                    + bernoulli(k + 1, q + 1)
                    for w in range(1, t + 1)
                )
            )
            // (k + 1)
            if n
            else -1
        )
    else:
        return (
            (s := isqrt(n)) ** 2
            - ((t := isqrt(m := n >> 1)) ** 2 << 1)
            + (
                (sum(m // k for k in range(1, t + 1)) << 1)
                - sum(n // k for k in range(1, s + 1))
                << 1
            )
        )


def A366936_gen():
    return (A366936_T(k + 1, n - k - 1) for n in count(1) for k in range(n))


def A366922(n):
    c = 0
    a, b = divmod(10**n - 1, 3)
    while b == 0:
        a, b = divmod(a, 3)
        c += 1
    return c


def A366937(n):
    return (
        ((s := isqrt(m := n >> 1)) * (s + 1) ** 2 * ((s << 2) + 5) << 1)
        - (t := isqrt(n)) * (t + 1) ** 2 * (t + 2)
        - sum(
            (((q := m // w) + 1) * (q * ((q << 2) + 5) + 6 * w * ((w << 1) + 1)) << 1)
            for w in range(1, s + 1)
        )
        + sum(
            ((q := n // w) + 1) * (q * (q + 2) + 3 * w * (w + 1))
            for w in range(1, t + 1)
        )
    ) // 6


def A366938(n):
    return (
        ((s := isqrt(m := n >> 1)) * (s + 1) ** 3 * (s + 2) << 4)
        - (t := isqrt(n)) * (t + 1) ** 2 * (t + 2) * (t + 3)
        - sum(
            (
                ((q := m // w) + 1)
                * (q * (q + 1) * (q + 2) + (w * (w + 1) * ((w << 1) + 1) << 1))
                << 4
            )
            for w in range(1, s + 1)
        )
        + sum(
            ((q := n // w) + 1) * (q * (q + 2) * (q + 3) + (w * (w + 1) * (w + 2) << 2))
            for w in range(1, t + 1)
        )
    ) // 24


def A366939(n):
    return (
        (rf(s := isqrt(m := n >> 1), 3) * (s + 1) * ((s**2 << 2) + 13 * s + 8) << 3)
        - rf(t := isqrt(n), 5) * (t + 1)
        + sum(
            (
                ((q := m // w) + 1)
                * (
                    -q * (q + 2) * ((q**2 << 2) + 13 * q + 8)
                    - 5 * w * (w + 1) * ((r := w << 1) + 1) * (r + 3)
                )
                << 3
            )
            for w in range(1, s + 1)
        )
        + sum(rf(q := n // w, 5) + 5 * (q + 1) * rf(w, 4) for w in range(1, t + 1))
    ) // 120


def A366029_gen(startvalue=1):  # generator of terms
    return filter(
        lambda k: pow(k - 1, (m := (1 << k) - 1) - 1, m * k**2) == 1,
        count(max(startvalue, 1)),
    )


def A333505(n):
    return (
        (
            (s := isqrt(m := n - 1 >> 1)) ** 2 * (s + 1)
            - sum((q := m // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
            << 1
        )
        - (
            (t := isqrt(n - 1)) ** 2 * (t + 1)
            - sum((q := (n - 1) // k) * ((k << 1) + q + 1) for k in range(1, t + 1))
            >> 1
        )
        + (m + 1 if n & 1 else -m - 1)
    )


def A366972(n):
    return (
        -((s := isqrt(n)) ** 2)
        + (sum(n // k for k in range(4, s + 1)) << 1)
        + n
        + (n >> 1)
        + n // 3
        if n > 8
        else (0, 0, 0, 0, 1, 2, 3, 4, 6)[n]
    )


def A366968(n):
    return (
        -((s := isqrt(n)) ** 2)
        + (sum(n // k for k in range(3, s + 1)) << 1)
        + n
        + (n >> 1)
        if n > 3
        else int(n > 2)
    )


def A366967(n):
    return (
        (s := isqrt(n)) ** 2 * (1 - s**2)
        + sum((q := n // k) * (3 * k * (k - 1) + q**2 - 1) for k in range(1, s + 1))
    ) // 6


def A366970(n):
    return (
        -(s := isqrt(n)) * (s * (s**2 - (s << 1) - 1) + 8)
        + sum(
            ((q := n // w) + 1) * (q * (q - 4) + 3 * (w**2 - 3 * w + 4))
            for w in range(1, s + 1)
        )
    ) // 6


def A366969(n):
    return n + (
        -(s := isqrt(n)) * (s * (s - 2) - 7)
        + sum(((q := n // w) + 1) * (q + (w << 1) - 8) for w in range(1, s + 1))
        >> 1
    )


def A366971(n):
    return -comb((s := isqrt(n)) + 1, 4) * (s + 1) + sum(
        comb((q := n // w) + 1, 4) + (q + 1) * comb(w, 3) for w in range(1, s + 1)
    )


def A366978(n):
    return (
        -((s := isqrt(n)) ** 2) * comb(s + n, n)
        + sum(
            (q := n // j) * ((n + 1) * comb(j + n - 1, n) + comb(q + n, n))
            for j in range(1, s + 1)
        )
    ) // (n + 1)


def A366977_T(n, k):
    return (
        -((s := isqrt(n)) ** 2) * comb(s + k, k)
        + sum(
            (q := n // j) * ((k + 1) * comb(j + k - 1, k) + comb(q + k, k))
            for j in range(1, s + 1)
        )
    ) // (k + 1)


def A366977_gen():  # generator of terms
    return (A366977_T(k + 1, n - k - 1) for n in count(1) for k in range(n))


def A366844(n):
    return sum(
        1
        for p in partitions(n)
        if all(d == 1 for d in p.values()) and all(d & 1 for d in p) and gcd(*p) == 1
    )


def A366985(n):
    return (
        -(s := isqrt(n)) * (s * (s * (s * (s + 11) + 45) + 85) + 74)
        + sum(
            ((q := n // w) + 1)
            * (q * (q * (q + 9) + 26) + ((w + 4) * (w * (w + 2) + 3) << 2))
            for w in range(1, s + 1)
        )
    ) // 3 >> 3


def A366984(n):
    return (
        -(s := isqrt(n)) * (s * (s * (s + 7) + 17) + 17)
        + sum(
            ((q := n // w) + 1) * (q * (q + 5) + 3 * (w * (w + 3) + 4))
            for w in range(1, s + 1)
        )
    ) // 6


def A366983(n):
    return (
        -(s := isqrt(n)) * (s * (s + 4) + 5)
        + sum(((q := n // w) + 1) * (q + (w << 1) + 4) for w in range(1, s + 1))
        >> 1
    )


def A257644(n):
    return (
        -(s := isqrt(n)) * (s * (s + 4) + 5)
        + sum(((q := n // w) + 1) * (q + (w << 1) + 4) for w in range(1, s + 1))
        >> 1
    ) + 1


def A051201(n):
    return ((m := isqrt((n << 2) + 1) + 1 >> 1) * (m - 1) >> 1) + sum(
        n // k for k in range(1, n // m + 1)
    )


def A210256(n):
    return (
        ((m := isqrt((n + 1 << 2) + 1) + 1 >> 1) * (m - 1) >> 1)
        + sum((n + 1) // k for k in range(1, (n + 1) // m + 1))
        - ((r := isqrt((n << 2) + 1) + 1 >> 1) * (r - 1) >> 1)
        - sum(n // k for k in range(1, n // r + 1))
    )


def A071764(n):
    return (
        ((s := isqrt(n - 1)) * (s - 1) + 1 + (n >> 1) + (n * (n + 1) >> 1) >> 1)
        - sum((n - 1) // k for k in range(1, s + 1))
        if n
        else 1
    )


def A350108(n):
    return (
        -((s := isqrt(n)) ** 4) * (s + 1)
        + sum(
            (q := n // k)
            * (k**2 * (3 * (q + 1)) + k * (q * ((q << 1) - 3) - 3) + q + 1)
            for k in range(1, s + 1)
        )
        >> 1
    )


def A365931(n):
    if n == 1:
        return 0
    c, y, a = 2 - n, 2, (1 << n) - 1
    while y < n:
        x = integer_nthroot(a, y)[0]
        c += ((z := integer_log(a, x)[0] + 1) - y) * x
        y = z
    return c


def A111490(n):
    return n * (n + 1) + (
        (s := isqrt(n)) ** 2 * (s + 1)
        - sum((q := n // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
        >> 1
    )


def A326123(n):
    return (
        (
            -((s := isqrt(r := n << 1)) ** 2) * (s + 1)
            + sum((q := r // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
            >> 1
        )
        - (t := isqrt(m := n >> 1)) ** 2 * (t + 1)
        + sum((q := m // k) * ((k << 1) + q + 1) for k in range(1, t + 1))
        + 3
        * (
            (u := isqrt(n)) ** 2 * (u + 1)
            - sum((q := n // k) * ((k << 1) + q + 1) for k in range(1, u + 1))
            >> 1
        )
    )


def A067435(n):
    return (
        n * ((n << 1) - 1)
        + (
            (s := isqrt(r := n << 1)) ** 2 * (s + 1)
            - sum((q := r // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
            >> 1
        )
        + (t := isqrt(m := n >> 1)) ** 2 * (t + 1)
        - sum((q := m // k) * ((k << 1) + q + 1) for k in range(1, t + 1))
        - 3
        * (
            (u := isqrt(n)) ** 2 * (u + 1)
            - sum((q := n // k) * ((k << 1) + q + 1) for k in range(1, u + 1))
            >> 1
        )
        - (x := isqrt(m := n - 1 >> 1)) ** 2 * (x + 1)
        + sum((q := m // k) * ((k << 1) + q + 1) for k in range(1, x + 1))
        + (
            (y := isqrt(n - 1)) ** 2 * (y + 1)
            - sum((q := (n - 1) // k) * ((k << 1) + q + 1) for k in range(1, y + 1))
            >> 1
        )
    )


def A050482(n):
    return (p := prime(n)) ** 2 + (
        (s := isqrt(p)) ** 2 * (s + 1)
        - sum((q := p // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
        >> 1
    )


def A294630(n):
    return (
        (
            (
                (s := isqrt(n)) ** 2
                * (s + 1)
                * ((s + 1) * ((s << 1) + 1) - 6 * (n + 1))
                >> 1
            )
            + sum(
                (q := n // k)
                * (
                    -k * (q + 1) * (3 * k + (q << 1) + 1)
                    + 3 * (n + 1) * ((k << 1) + q + 1)
                )
                for k in range(1, s + 1)
            )
            << 2
        )
        - (n * (n + 1) * ((n << 1) + 1) << 1)
    ) // 3


def A166248(n):
    return abs(
        n * (n - 1)
        + (
            (s := isqrt(n)) ** 2 * (s + 1)
            - sum((q := n // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
            >> 1
        )
    )


def A014288(n):
    return sum(factorial(k) for k in range(n + 1)) >> 1


def A346870(n):
    return (
        (t := isqrt(m := n >> 1)) ** 2 * (t + 1)
        - sum((q := m // k) * ((k << 1) + q + 1) for k in range(1, t + 1))
        - 3
        * (
            (s := isqrt(n)) ** 2 * (s + 1)
            - sum((q := n // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
            >> 1
        )
        - n * (n + 2)
    )


def A347154(n):
    return (
        (t := isqrt(m := n >> 1)) ** 2 * (t + 1)
        - sum((q := m // k) * ((k << 1) + q + 1) for k in range(1, t + 1))
        - 3
        * (
            (s := isqrt(n)) ** 2 * (s + 1)
            - sum((q := n // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
            >> 1
        )
        - n * (n + 1)
    )


@lru_cache(maxsize=None)
def A344527_T(n, k):
    if n == 0:
        return 0
    c, j, k1 = 1, 2, n // 2
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * A344527_T(k1, k)
        j, k1 = j2, n // j2
    return n * (n ** (k - 1) - 1) - c + j


def A344527_gen():  # generator of terms
    return (A344527_T(k + 1, n - k) for n in count(1) for k in range(n))


def A332468(n):
    return A344527_T(n, n)


@lru_cache(maxsize=None)
def A344429(n, e=None):
    if e is None:
        e = n
    if n <= 1:
        return 1
    c, j = 1, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c -= (harmonic(j2 - 1, -e) - harmonic(j - 1, -e)) * A344429(k1, e)
        j, k1 = j2, n // j2
    return c - (harmonic(n, -e) - harmonic(j - 1, -e))


def A366843(n):
    return sum(1 for p in partitions(n) if all(d & 1 for d in p) and gcd(*p) == 1)


def A366852(n):
    return sum(1 for p in partitions(n) if all(d & 1 for d in p) and gcd(*p) > 1)


def A366750(n):
    return sum(
        1
        for p in partitions(n)
        if all(d == 1 for d in p.values()) and all(d & 1 for d in p) and gcd(*p) > 1
    )


def A344596(n):
    return A071778(n) - A071778(n - 1)


def A344597(n):
    return A082540(n) - A082540(n - 1)


@lru_cache(maxsize=None)
def A070888_aux(n):
    if n <= 1:
        return 1
    c, j = 1, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (harmonic(j - 1) - harmonic(j2 - 1)) * A070888_aux(k1)
        j, k1 = j2, n // j2
    return c + harmonic(j - 1) - harmonic(n)


def A070888(n):
    return A070888_aux(n).numerator


def A070889(n):
    return A070888_aux(n).denominator


def A068337(n):
    return factorial(n) * A070888_aux(n)


def A070892_gen():  # generator of terms
    c = 2
    for n in count(1):
        if (d := abs(A070888_aux(n))) < c:
            yield n
            c = d


def A083118_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: not (n % 10 and n & 15 and n % 25), count(max(startvalue, 1))
    )


def A366585_gen():  # generator of terms
    a = 1
    while True:
        c = a + int(str(a)[0])
        yield int("".join(str(i) for i in range(a, c)))
        a = c


def A366610_gen():  # generator of terms
    a, c = 1, 0
    while c := c + 1:
        yield c
        c, r = divmod(
            (
                w := ((t := int(str(a := a + int(str(a)[0]))[0])) + 1)
                * 10 ** (len(str(a)) - 1)
                - 1
            )
            - a,
            t,
        )
        a = w - r


def A367052(n):
    return (
        sum(
            1
            for p in product((0, 1), repeat=n**2)
            if all(d == 0 or d == -1 for d in Matrix(n, n, p).charpoly().as_list()[1:])
        )
        if n
        else 1
    )


def A367051(n):
    return (
        sum(
            1
            for p in product((0, 1), repeat=n**2)
            if all(
                d == 0 or d == -1 or d == 1
                for d in Matrix(n, n, p).charpoly().as_list()
            )
        )
        if n
        else 1
    )


def A308474(n):
    return n**3 * totient(n) >> 1 if n > 1 else 1


def A308473(n):
    return n * (n - totient(n) - 1) >> 1 if n > 1 else 0


def A366248(n):
    return (
        isqrt(666 // 10 ** (3 - n << 1)) if n < 3 else isqrt(666 * 10 ** (n - 3 << 1))
    ) % 10


def A367064(n):
    f = factorint(n)
    return (
        prod(1 - d ** (e << 1) for d, e in f.items()) ** (1 << len(f) - 1)
        if n > 1
        else 1
    )


def A004003(n):
    return (
        isqrt(
            resultant(
                chebyshevu(n << 1, symbolx / 2), chebyshevu(n << 1, I * symbolx / 2)
            )
        )
        if n
        else 1
    )


def A334124(n):
    return (
        isqrt(
            resultant(
                chebyshevu(n << 1, symbolx / 2), chebyshevt(n << 1, I * symbolx / 2)
            )
            * (1 << (n << 1))
        )
        if n
        else 1
    )


def A334088(n):
    return (
        isqrt(
            resultant(
                chebyshevt(n << 1, symbolx / 2), chebyshevt(n << 1, I * symbolx / 2)
            )
        )
        if n
        else 1
    )


def A127606(n):
    return (
        isqrt(
            resultant(
                chebyshevt((n << 1) + 1, I * symbolx / 2),
                chebyshevu(n << 1, symbolx / 2),
            )
        )
        << n
        if n
        else 1
    )


def A216675(n):
    return (
        0
        if n & 1
        else resultant(chebyshevu(n, symbolx / 2), chebyshevu(n, I * symbolx / 2))
    )


def A188890(n):
    return (
        isqrt(resultant(chebyshevu(n << 1, symbolx), chebyshevu(n << 1, I * symbolx)))
        if n
        else 1
    )


def A349073(n):
    return chebyshevu(n << 1, n)


def A349074(n):
    return chebyshevu(3 * n, n)


def A341576(n):
    return sum(chebyshevu(k, Fraction(n - k, 2)) for k in range(n + 1))


def A367083_gen():  # generator of terms
    yield 1
    a, b = 1, 4
    while True:
        while (a := a * 3) < b:
            yield a
        yield from (b, a)
        b <<= 2


def A367084_gen():  # generator of terms
    a, b, c = 1, 4, -1
    while True:
        while (a := a * 3) < b:
            yield (c := c + 1)
        b <<= 2
        c += 2


def A367085_gen():  # generator of terms
    a, b, c = 1, 4, 0
    while True:
        while (a := a * 3) < b:
            yield (c := c + 1)
        b <<= 2
        c += 1


def A360506_gen():  # generator of terms
    a, b, c = 3, 1, 0
    for i in count(1):
        if i >= a:
            a *= 3
        c += i * b
        yield c
        b *= a


def A349071(n):
    return chebyshevt(n, n << 1)


def A349072(n):
    return chebyshevt(n, 3 * n)


def A099156(n):
    return chebyshevu(n - 1, 2) << n - 1 if n else 0


def A014664(n):
    return n_order(2, prime(n))


def A002326(n):
    return n_order(2, (n << 1) + 1)


def A006125(n):
    return 1 << (n * (n - 1) >> 1)


def A309816(n):
    return (~(m := n_order(2, prime(n))) & m - 1).bit_length()


def A062117(n):
    return n_order(3, prime(n)) if n != 2 else 0


def A367169(n):
    return sum(e for e in factorint(n).values() if not (e & -e) ^ e)


def A367168(n):
    return prod(p**e for p, e in factorint(n).items() if not (e & -e) ^ e)


def A366958_gen():  # generator of terms
    return chain.from_iterable(
        sorted(
            int("".join(str(d) for d in t))
            for a in range(9)
            for c in combinations_with_replacement(range(a, a + 2), l)
            for t in multiset_permutations((a, a + 1) + c)
            if t[0]
        )
        for l in count(0)
    )


def A366959_gen():  # generator of terms
    return chain.from_iterable(
        sorted(
            int("".join(str(d) for d in t))
            for a in range(8)
            for c in combinations_with_replacement(range(a, a + 3), l)
            for t in multiset_permutations((a, a + 2) + c)
            if t[0]
        )
        for l in count(0)
    )


def A366966_gen():  # generator of terms
    return chain.from_iterable(
        sorted(
            int("".join(str(d) for d in t))
            for c in combinations_with_replacement(range(10), l)
            for t in multiset_permutations((0, 9) + c)
            if t[0]
        )
        for l in count(0)
    )


def A366960_gen():  # generator of terms
    return chain.from_iterable(
        sorted(
            int("".join(str(d) for d in t))
            for a in range(7)
            for c in combinations_with_replacement(range(a, a + 4), l)
            for t in multiset_permutations((a, a + 3) + c)
            if t[0]
        )
        for l in count(0)
    )


@lru_cache(maxsize=None)
def A364973(n):
    return (
        1
        if n == 1
        else int(
            factorial(3 * n - 2)
            * (
                Fraction(1, factorial(n) ** 3)
                - sum(
                    Fraction(
                        prod(((3 * m - 1) * A364973(m)) ** e for m, e in p.items()),
                        factorial(3 * n - s) * prod(factorial(c) for c in p.values()),
                    )
                    for s, p in partitions(n, k=n - 1, size=True)
                )
            )
        )
    )


def A037904(n):
    return int(max(s := str(n))) - int(min(s))


def A367175(n):
    return divisor_sigma(n) - (sum(primefactors(n)) << 1)


def A367176_gen(startvalue=2):  # generator of terms
    return filter(
        lambda n: isprime(divisor_sigma(n) - (sum(primefactors(n)) << 1)),
        count(max(startvalue, 2)),
    )


def A367081(n):
    for k in count(1):
        a, c = (1 << k) - 1, 0
        for i in range(k - 2, 0, -1):
            if isprime(a ^ (1 << i)):
                c += 1
            if c >= n + 1:
                break
        if c == n:
            return k


def A367191(n):
    return (
        max(diop_quadratic(symbolx * (symbolx + n) + n**2 - symboly**2))[0] if n else 0
    )


def A300728(n):
    return (
        min(
            (
                d[0]
                for d in diop_quadratic(symbolx * (symbolx + n) + n**2 - symboly**2)
                if d[0] > 0
            ),
            default=0,
        )
        if n
        else 1
    )


def A366981(n):
    return sum(int(not n % d) for d in range(3, 6))


def A301573(n):
    return next(
        k
        for k in count(0)
        if perfect_power(n + k) or perfect_power(n - k) or n - k == 1 or n + k == 1
    )


def A366928(n):
    return next(
        m
        for m in count(0)
        if next(
            k
            for k in count(0)
            if perfect_power(m + k) or perfect_power(m - k) or m - k == 1 or m + k == 1
        )
        == n
    )


def A366420(n):
    m = n**4
    return len(
        {(pow(x, n, m) + pow(y, n, m)) % m for x in range(n**3) for y in range(x + 1)}
    )


def A366419(n):
    m = n**3
    return len(
        {(pow(x, n, m) + pow(y, n, m)) % m for x in range(n**2) for y in range(x + 1)}
    )


def A367296_gen():  # generator of terms
    a, b, c, l = 8, 9, 1, 0
    while True:
        if a <= c:
            if c < b:
                yield l
            a *= 10
            b *= 10
        c <<= 1
        l += 1


def A172404_gen():  # generator of terms
    a, b, c, l = 3, 4, 1, 0
    while True:
        if a <= c:
            if c < b:
                yield l
            a *= 10
            b *= 10
        c <<= 1
        l += 1


def A367097(n):
    return next(
        k
        for k in count(1)
        if len(
            {
                sum(s)
                for s in multiset_combinations(
                    {primepi(i): j for i, j in factorint(k).items()}, 2
                )
            }
        )
        == n
    )


def A367326(n):
    f = factorint(n).items()
    return (
        n
        * (
            n * prod(e + 1 for p, e in f)
            - (prod((p ** (e + 1) - 1) // (p - 1) for p, e in f) << 1)
        )
        + prod((p ** (e + 1 << 1) - 1) // (p**2 - 1) for p, e in f)
        if n
        else 0
    )


def A094471(n):
    f = factorint(n).items()
    return n * prod(e + 1 for p, e in f) - prod(
        (p ** (e + 1) - 1) // (p - 1) for p, e in f
    )


def A366131(n):
    return (1 << n) - (3 ** (n - 1 >> 1) << 1) if n else 0


def A167936(n):
    return (1 << n) - 3 ** (n >> 1)


def A367327(n):
    f = factorint(n).items()
    return (
        n * (n - 1) * ((n << 1) - 1) // 6
        - n
        * (
            n * prod(e + 1 for p, e in f)
            - (prod((p ** (e + 1) - 1) // (p - 1) for p, e in f) << 1)
        )
        - prod((p ** (e + 1 << 1) - 1) // (p**2 - 1) for p, e in f)
        if n
        else 0
    )


def A367222(n):
    c, mlist = 1, []
    for m in range(1, n + 1):
        t = set()
        for p in partitions(m):
            t.add(tuple(sorted(p.keys())))
        mlist.append([set(d) for d in t])
    for k in range(1, n + 1):
        for w in combinations(range(1, n + 1), k):
            ws = set(w)
            for s in mlist[k - 1]:
                if s <= ws:
                    c += 1
                    break
    return c


def A367223(n):
    c, mlist = 0, []
    for m in range(1, n + 1):
        t = set()
        for p in partitions(m):
            t.add(tuple(sorted(p.keys())))
        mlist.append([set(d) for d in t])
    for k in range(1, n + 1):
        for w in combinations(range(1, n + 1), k):
            ws = set(w)
            for s in mlist[k - 1]:
                if s <= ws:
                    break
            else:
                c += 1
    return c


def A364914(n):
    c, mlist = 0, []
    for m in range(1, n + 1):
        t = set()
        for p in partitions(m, k=m - 1):
            t.add(tuple(sorted(p.keys())))
        mlist.append([set(d) for d in t])
    for k in range(2, n + 1):
        for w in combinations(range(1, n + 1), k):
            ws = set(w)
            for d in w:
                for s in mlist[d - 1]:
                    if s <= ws:
                        c += 1
                        break
                else:
                    continue
                break
    return c


def A367133(n):
    return Matrix(n, n, [int(isprime(i)) for i in range(1, n**2 + 1)]).rank()


def A367077(n):
    return Matrix(n, n, [int(isprime(i)) for i in range(1, n**2 + 1)]).det()


def A367203(n):
    return prod(p ** (e - 1) + p ** (e & -2) for p, e in factorint(n).items())


def A365402(n):
    return prod(e + 1 for e in factorint(n).values() if e & 1)


def A367368(n):
    f = factorint(n).items()
    return (
        (n * (n + 1) >> 1)
        - n * prod(e + 1 for p, e in f)
        + prod((p ** (e + 1) - 1) // (p - 1) for p, e in f)
        if n
        else 0
    )


def A367197(n):
    return prod(
        (
            (p ** (e + 1) - 1 << 1) // (p**2 - 1)
            if e & 1
            else (p ** (e + 1) - 1) // (p - 1)
        )
        for p, e in factorint(n).items()
    )


def A367086_gen():  # generator of terms
    a, b, c, i = 1, 4, -1, 1
    while True:
        while (a := a * 3) < b:
            c += 1
            yield i
        b <<= 2
        i += 1
        c += 2


def A367493(n):
    return sum((n - d) ** n for d in divisors(n, generator=True))


def A285087_gen(startvalue=1):  # generator of terms
    return filter(lambda n: isprime(npartitions(n**2 - 1)), count(max(startvalue, 1)))


def A365043(n):
    mlist = tuple(
        {tuple(sorted(p.keys())) for p in partitions(m, k=m - 1)}
        for m in range(1, n + 1)
    )
    return sum(
        1
        for k in range(2, n + 1)
        for w in combinations(range(1, n + 1), k)
        if w[:-1] in mlist[w[-1] - 1]
    )


def A365044(n):
    mlist = tuple(
        {tuple(sorted(p.keys())) for p in partitions(m, k=m - 1)}
        for m in range(1, n + 1)
    )
    return (
        n
        + 1
        + sum(
            1
            for k in range(2, n + 1)
            for w in combinations(range(1, n + 1), k)
            if w[:-1] not in mlist[w[-1] - 1]
        )
    )


def A163190(n):
    return sum((1 + d) ** n for d in divisors(n, generator=True)) if n else 1


def A367396(n):
    return sum(
        1
        for k in range(3, n + 1)
        for w in (set(d) for d in combinations(range(1, n + 1), k))
        if any({a, k - a} <= w for a in range(1, k + 1 >> 1))
    )


def A367400(n):
    return (
        (n * (n + 1) >> 1)
        + 1
        + sum(
            1
            for k in range(3, n + 1)
            for w in (set(d) for d in combinations(range(1, n + 1), k))
            if not any({a, k - a} <= w for a in range(1, k + 1 >> 1))
        )
    )


def A367517(n):
    return prod(i**3 + j**3 for i in range(1, n) for j in range(i + 1, n + 1))


def A367204(n):
    return n * (n - 3) >> 1 if n & 1 else n * (n - 4) >> 2


def A211379(n):
    return n * (n * (n - 8) + 16 - (n & 1)) >> 3


def A211380(n):
    return n * (n * (n * (n - 11) + 43) - 58 + (n & 1)) >> 3


def A367550(n):
    return (
        prod(
            (i2 := i**2) * (i2 + (j2 := j**2)) + j2**2
            for i in range(1, n)
            for j in range(i + 1, n + 1)
        )
        * factorial(n) ** 2
    ) ** 2 * 3**n


def A367543(n):
    return (
        prod(i * (i - j) + j**2 for i in range(1, n) for j in range(i + 1, n + 1))
        * factorial(n)
    ) ** 2


def A367542(n):
    return (
        prod(i * (i + j) + j**2 for i in range(1, n) for j in range(i + 1, n + 1))
        * factorial(n)
    ) ** 2 * 3**n


def A324403(n):
    return (
        prod(i**2 + j**2 for i in range(1, n) for j in range(i + 1, n + 1))
        * factorial(n)
    ) ** 2 << n


def A306728(n):
    return (
        prod(
            i * (i + 1) + j * (j + 1) for i in range(1, n) for j in range(i + 1, n + 1)
        )
        * factorial(n)
    ) ** 2 * (n + 1) << n


if sys.version_info >= (3, 10):

    def A367516(n):
        return 1 << sum(1 for e in factorint(n).values() if e.bit_count() & 1 ^ 1)

    def A367512(n):
        return sum(1 for e in factorint(n).values() if e.bit_count() & 1 ^ 1)

    def A367515(n):
        return 1 << sum(1 for e in factorint(n).values() if e.bit_count() & 1)

    def A293439(n):
        return sum(1 for e in factorint(n).values() if e.bit_count() & 1)

    def A102392(n):
        return n * (n.bit_count() & 1)

    def A367514(n):
        return prod(p**e for p, e in factorint(n).items() if e.bit_count() & 1)

    def A367513(n):
        return prod(p**e for p, e in factorint(n).items() if e.bit_count() & 1 ^ 1)

    def A102391(n):
        return 0 if n.bit_count() & 1 else n

else:

    def A367516(n):
        return 1 << sum(1 for e in factorint(n).values() if bin(e).count("1") & 1 ^ 1)

    def A367512(n):
        return sum(1 for e in factorint(n).values() if bin(e).count("1") & 1 ^ 1)

    def A367515(n):
        return 1 << sum(1 for e in factorint(n).values() if bin(e).count("1") & 1)

    def A293439(n):
        return sum(1 for e in factorint(n).values() if bin(e).count("1") & 1)

    def A102392(n):
        return n * (bin(n).count("1") & 1)

    def A367514(n):
        return prod(p**e for p, e in factorint(n).items() if bin(e).count("1") & 1)

    def A367513(n):
        return prod(p**e for p, e in factorint(n).items() if bin(e).count("1") & 1 ^ 1)

    def A102391(n):
        return 0 if bin(n).count("1") & 1 else n


def A367554(n):
    return (
        sum(
            totient(d) * comb(26 // d, n // d)
            for d in divisors(gcd(n, 26), generator=True)
        )
        // 26
    )


@lru_cache(maxsize=None)
def A092124(n):
    return ((1 << (1 << n)) + 2) * A092124(n - 1) if n else 2


@lru_cache(maxsize=None)
def A333447(n):
    return (
        (1 << ((m := 1 << n) << 1) - 1) - (k := 1 << m - 1) + (k + 1) * A333447(n - 1)
        if n
        else 2
    )


@lru_cache(maxsize=None)
def A367033(n):
    return 1 - (m := 1 << (1 << n - 1)) + (m + 2) * A367033(n - 1) if n > 1 else 1


def A366130(n):
    a = tuple(
        set(p.keys()) for p in partitions(n + 1, k=n) if max(p.values(), default=0) == 1
    )
    return sum(
        1
        for k in range(2, n + 1)
        for w in (set(d) for d in combinations(range(1, n + 1), k))
        if any(s <= w for s in a)
    )


def A366371(n):
    return (
        sum(factorint(n).values())
        if n & 1
        else sum(factorint(n >> (~n & n - 1).bit_length()).values()) << 1
    )


def A367546(n):
    return sum(n**k for k in range(n + 1) if gcd(n, k) == 1)


def A367545(n):
    return sum((-(1 << k) if k & 1 else 1 << k) for k in range(n + 1) if gcd(n, k) == 1)


def A367544(n):
    return sum(1 << k for k in range(n + 1) if gcd(n, k) == 1)


def A349136(n):
    return totient(n) + 1 >> 1 if n & 1 else 0


def A367547(n):
    return sum(10**k for k in range(n + 1) if gcd(n, k) == 1)


def A367566(n):
    return prod(
        p
        for p in primerange(n + 2)
        if all((m := n * pow(k, n, p) % p) == 1 or m == p - 1 for k in range(1, p))
    )


def A367679(n):
    return (
        prod(
            i * (i * (i * (i - j) + j**2) - j**3) + j**4
            for i in range(1, n)
            for j in range(i + 1, n + 1)
        )
        * factorial(n) ** 2
    ) ** 2


def A367670(n):
    return (
        prod(
            (k := j**4) ** 2 + (m := i**4) * (m + k)
            for i in range(1, n)
            for j in range(i + 1, n + 1)
        )
        * factorial(n) ** 4
    ) ** 2 * 3**n


def A367668(n):
    return (
        prod(
            (k := j**2) ** 2 + (m := i**2) * (m - k)
            for i in range(1, n)
            for j in range(i + 1, n + 1)
        )
        * factorial(n) ** 2
    ) ** 2


def A324438(n):
    return (
        prod(i**5 + j**5 for i in range(1, n) for j in range(i + 1, n + 1)) ** 2
        * factorial(n) ** 5
        << n
    )


def A324426(n):
    return (
        prod(i**3 + j**3 for i in range(1, n) for j in range(i + 1, n + 1)) ** 2
        * factorial(n) ** 3
        << n
    )


def A324437(n):
    return (
        prod(i**4 + j**4 for i in range(1, n) for j in range(i + 1, n + 1))
        * factorial(n) ** 2
    ) ** 2 << n


def A324439(n):
    return (
        prod(i**6 + j**6 for i in range(1, n) for j in range(i + 1, n + 1))
        * factorial(n) ** 3
    ) ** 2 << n


def A324440(n):
    return (
        prod(i**7 + j**7 for i in range(1, n) for j in range(i + 1, n + 1)) ** 2
        * factorial(n) ** 7
        << n
    )


def A079478(n):
    return (
        prod(i + j for i in range(1, n) for j in range(i + 1, n + 1)) ** 2
        * factorial(n)
        << n
    )


def A000178(n):
    return prod(i ** (n - i + 1) for i in range(2, n + 1))


def A098694(n):
    return (
        prod(((k + 1) * ((k << 1) + 1) << 1) ** (n - k) for k in range(1, n + 1)) << n
    )


def A168467(n):
    return (
        prod(((m := k + 1 << 1) * (m + 1)) ** (n - k) for k in range(1, n + 1)) * 3**n
        << n
    )


def A202768(n):
    return (
        (
            prod(
                ((m := k + 1 << 1) * (m + 1)) ** (n - 1 - k) // (k + 1)
                for k in range(1, n - 1)
            )
            * 3 ** (n - 1)
            << n - 1
        )
        // n
        if n
        else 1
    )


def A367688(n):
    c = 0
    for p in sieve.primerange(n**4 + 1):
        s = set()
        for k in combinations_with_replacement({pow(x, n, p) for x in range(p)}, 2):
            s.add(sum(k) % p)
            if len(s) == p:
                break
        else:
            c += 1
    return c


def A367369(n):
    for p in sieve.primerange(n**4 + 1):
        s = set()
        for k in combinations_with_replacement({pow(x, n, p) for x in range(p)}, 2):
            s.add(sum(k) % p)
            if len(s) == p:
                break
        else:
            return p


def A367700(n):
    return (5 * 20**n + (34 << 3 * n) + 216 * 3**n) // 85


def A332705(n):
    return (5**n + (1 << n + 1)) << (n << 1) + 1


def A291066(n):
    return (5**n - (1 << n)) << (n << 1) + 1


def A083233(n):
    return 3 << 3 * n - 2 if n else 1


def A365607(n):
    return ((3 << 3 * n) + (3 ** (n - 1) << 4)) // 5 - 8


def A365608(n):
    return ((3 << 3 * n - 1) - (3 ** (n - 1) << 5)) // 5 + 4


def A365606(n):
    return ((1 << 3 * n - 1) + (3 ** (n - 1) << 4)) // 5 + 4


if sys.version_info >= (3, 10):

    def A367680(n):
        k = max(d.bit_count() for d in range(1, n + 1))
        ylist = []
        for i in range(1, k + 1):
            ylist.append([d for d in range(1, n + 1) if d.bit_count() == i])
        c = 0
        cset = set()
        for p in product(*ylist):
            s = 0
            for i in range(k):
                s += p[i]
                if s >= n:
                    break
            if s == n and p[: i + 1] not in cset:
                cset.add(p[: i + 1])
                c += 1
        return c

else:

    def A367680(n):
        k = max(bin(d).count("1") for d in range(1, n + 1))
        ylist = []
        for i in range(1, k + 1):
            ylist.append([d for d in range(1, n + 1) if bin(d).count("1") == i])
        c = 0
        cset = set()
        for p in product(*ylist):
            s = 0
            for i in range(k):
                s += p[i]
                if s >= n:
                    break
            if s == n and p[: i + 1] not in cset:
                cset.add(p[: i + 1])
                c += 1
        return c


def A367625_gen(startvalue=0):  # generator of terms
    if startvalue <= 0:
        yield 0
    for n in count(max(startvalue, 1)):
        s = bin(n)[2:]
        c, l = 2, len(s)
        for i in range(1, l + 1):
            c += int(s[l - i]) << 1
            if c <= i:
                break
        else:
            yield n


def A367626_gen():  # generator of terms
    a = 0
    yield 1
    for n in count(1):
        s = bin(n)[2:]
        c, l = 2, len(s)
        for i in range(1, l + 1):
            if (c := c + (2 if s[l - i] == "1" else 0)) <= i:
                break
        else:
            yield n - a << 1
            a = n


def A367627_gen():  # generator of terms
    a = 0
    yield 0
    for n in count(1):
        s = bin(n)[2:]
        c, l = 2, len(s)
        for i in range(1, l + 1):
            if (c := c + (2 if s[l - i] == "1" else 0)) <= i:
                break
        else:
            yield (n - a).bit_length()
            a = n


def A014486_gen():  # generator of terms
    yield 0
    for l in count(1):
        for s in multiset_permutations("0" * l + "1" * (l - 1)):
            c, m = 0, (l << 1) - 1
            for i in range(m):
                if s[i] == "1":
                    c += 2
                if c < i:
                    break
            else:
                yield (1 << m) + int("".join(s), 2)


def A063171_gen():  # generator of terms
    yield 0
    for l in count(1):
        for s in multiset_permutations("0" * l + "1" * (l - 1)):
            c, m = 0, (l << 1) - 1
            for i in range(m):
                if s[i] == "1":
                    c += 2
                if c < i:
                    break
            else:
                yield 10**m + int("".join(s))


def A071152_gen():  # generator of terms
    yield 0
    for l in count(1):
        for s in multiset_permutations("0" * l + "1" * (l - 1)):
            c, m = 0, (l << 1) - 1
            for i in range(m):
                if s[i] == "1":
                    c += 2
                if c < i:
                    break
            else:
                yield 10**m + int("".join(s)) << 1


def A061384_gen():  # generator of terms
    for l in count(1):
        for i in range(1, min(9, l) + 1):
            yield from sorted(
                int(str(i) + "".join(map(str, j)))
                for s, p in partitions(l - i, k=9, size=True)
                for j in multiset_permutations(
                    [0] * (l - 1 - s) + list(Counter(p).elements())
                )
            )


def A367707(n):
    return (
        (5 ** (n + 1) << (n << 1) + 1) - (51 << (3 * n + 1)) + (3 ** (n + 3) << 4)
    ) // 85 - 8


def A367706(n):
    return (
        (7 * 5**n << (n << 1) + 1) + (17 << (3 * n + 1)) - (3 ** (n + 3) << 5)
    ) // 85 + 24


def A367702(n):
    return (
        (5**n << (n << 1) + 5) - (17 << (3 * n + 2)) + (3 ** (n + 4) << 3)
    ) // 85 - 24


def A367701(n):
    return (
        (3 * 5**n << (n << 1) + 3) + (51 << (3 * n + 1)) - (3 ** (n + 3) << 4)
    ) // 85 + 8


def A036771(n):
    return factorial(3 * n) * comb(3 * n + 1, n) // 3**n >> n


def A069710_gen():  # generator of terms
    for l in count(1):
        for i in range(1, min(9, l) + 1):
            yield from sorted(
                q
                for q in (
                    int(str(i) + "".join(map(str, j)))
                    for s, p in partitions(l - i, k=9, size=True)
                    for j in multiset_permutations(
                        [0] * (l - 1 - s) + list(Counter(p).elements())
                    )
                )
                if isprime(q)
            )


def A285228_gen():  # generator of terms
    for l in count(2):
        for i in range(1, 10):
            yield from sorted(
                q
                for q in (
                    int(str(i) + "".join(map(str, j)))
                    for s, p in partitions((l << 3) - i, m=l - 1, k=9, size=True)
                    for j in multiset_permutations(
                        [0] * (l - 1 - s) + list(Counter(p).elements())
                    )
                )
                if isprime(q)
            )


def A367629(n):
    return (1 << (m := 1 << n + 1)) - (m << 1)


def A107584(n):
    return (1 << (n << 1)) - (n << 2)


def A109925(n):
    return sum(1 for i in range(n.bit_length()) if isprime(n - (1 << i)))


def A367186_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue, 1)):
        c = 0
        for i in range(n.bit_length() - 1, -1, -1):
            if isprime(n - (1 << i)):
                c += 1
            if c > 1:
                yield n
                break


def A118955_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: any(isprime(n - (1 << i)) for i in range(n.bit_length() - 1, -1, -1)),
        count(max(startvalue, 1)),
    )


def A156695_gen(startvalue=1):  # generator of terms
    for n in count(max(startvalue + (startvalue & 1 ^ 1), 1), 2):
        l = n.bit_length() - 1
        for a in range(l, 0, -1):
            c = n - (1 << a)
            for b in range(min(a, l - 1), 0, -1):
                if isprime(c - (1 << b)):
                    break
            else:
                continue
            break
        else:
            yield n


def A006285_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: not any(
            isprime(n - (1 << i)) for i in range(n.bit_length() - 1, -1, -1)
        ),
        count(max(startvalue + (startvalue & 1 ^ 1), 1), 2),
    )


def A285227_gen():  # generator of terms
    yield 7
    for l in count(2):
        for i in range(1, 10):
            yield from sorted(
                q
                for q in (
                    int(str(i) + "".join(map(str, j)))
                    for s, p in partitions(7 * l - i, m=l - 1, k=9, size=True)
                    for j in multiset_permutations(
                        [0] * (l - 1 - s) + list(Counter(p).elements())
                    )
                )
                if isprime(q)
            )


def A367782_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: (comb(n << 1, n) % n) & 1,
        count(max(startvalue + (startvalue & 1 ^ 1), 1), 2),
    )


@lru_cache(maxsize=None)
def A367794(n):
    return (
        sum(A367794(k) * A367794(n - 1 - (k << 2)) for k in range(n + 3 >> 2))
        if n
        else 1
    )


@lru_cache(maxsize=None)
def A367692(n):
    return 1 + sum(A367692(k) * A367692(n - 1 - (k << 2)) for k in range(n + 3 >> 2))


@lru_cache(maxsize=None)
def A366860(n):
    return n - A366860(A366860(n - 1) // 3) if n else 0


def A285431_gen():  # generator of terms
    a, l = [1, 1], 0
    while True:
        yield from a[l:]
        c = sum(([1, 1, 0] if d else [1, 1] for d in a), start=[])
        l, a = len(a), c


def A286389_gen():  # generator of terms
    a, l, s = [1, 1], 0, 0
    yield 0
    while True:
        yield from map(lambda n: n + s, accumulate(a[l:]))
        c = sum(([1, 1, 0] if d else [1, 1] for d in a), start=[])
        l, a, s = len(a), c, sum(a)


def A367593_gen():  # generator of terms
    yield from (0, 1, 10)
    for l in count(1):
        m = 10 ** (l + 1)
        for d in product("0123456789", repeat=l):
            for a, b, c in ((1, 0, 0), (1, 1, 0), (1, 4, 2), (1, 5, 5), (1, 7, 5)):
                k = a * m + int(s := "".join(d)) * 10 + b
                r = b * m + int(s[::-1]) * 10 + a
                if c * (k + 1) == r - 1:
                    yield k
            a, b = 1, 9
            k = a * m + int(s := "".join(d)) * 10 + b
            r = b * m + int(s[::-1]) * 10 + a
            if not (r - 1) % (k + 1):
                yield k
        a, b, c = 2, 6, 3
        for d in product("0123456789", repeat=l):
            k = a * m + int(s := "".join(d)) * 10 + b
            r = b * m + int(s[::-1]) * 10 + a
            if c * (k + 1) == r - 1:
                yield k


def A367740_gen():  # generator of terms
    yield from (-1, 0, 0)
    for l in count(1):
        m = 10 ** (l + 1)
        for d in product("0123456789", repeat=l):
            for a, b, c in ((1, 0, 0), (1, 1, 0), (1, 4, 2), (1, 5, 5), (1, 7, 5)):
                k = a * m + int(s := "".join(d)) * 10 + b
                r = b * m + int(s[::-1]) * 10 + a
                if c * (k + 1) == r - 1:
                    yield c
            a, b = 1, 9
            k = a * m + int(s := "".join(d)) * 10 + b
            r = b * m + int(s[::-1]) * 10 + a
            p, q = divmod(r - 1, k + 1)
            if not q:
                yield p
        a, b, c = 2, 6, 3
        for d in product("0123456789", repeat=l):
            k = a * m + int(s := "".join(d)) * 10 + b
            r = b * m + int(s[::-1]) * 10 + a
            if c * (k + 1) == r - 1:
                yield c


def A367834(n):
    return (
        prod(i**8 + j**8 for i in range(1, n) for j in range(i + 1, n + 1))
        * factorial(n) ** 4
    ) ** 2 << n


def A367865(n):
    return prod(p * (p - 1) + 1 for p in primefactors(n))


def A367866(n):
    return prod(p * (p + 1) + 1 for p in primefactors(n))


def A278692_gen():  # generator of terms
    a, b = 4, 14
    yield from (a, b)
    while True:
        a, b = b, b**2 // a
        yield b


def A019495_gen():  # generator of terms
    a, b = 4, 11
    yield from (a, b)
    while True:
        a, b = b, (b**2 - 1) // a
        yield b


def A045547_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: 2
        == reduce(
            lambda x, y: x * y % 10,
            (
                (1, 1, 2, 6, 4)[a] * ((6, 2, 4, 8)[i * a & 3] if i * a else 1)
                for i, a in enumerate(sympydigits(n, 5)[-1:0:-1])
            ),
        )
        * 6
        % 10,
        count(max(startvalue, 1)),
    )


def A173670(n):
    return (
        reduce(
            lambda x, y: x * y % 10,
            (
                (1, 1, 2, 6, 4)[a] * ((6, 2, 4, 8)[i * a & 3] if i * a else 1)
                for i, a in enumerate(sympydigits(1 << n, 5)[-1:0:-1], n)
            ),
        )
        * 6
        % 10
        if n
        else 1
    )


def A063944(n):
    return (
        reduce(
            lambda x, y: x * y % 10,
            (
                (1, 1, 2, 6, 4)[a] * ((6, 2, 4, 8)[i * a & 3] if i * a else 1)
                for i, a in enumerate(sympydigits(factorial(n), 5)[-1:0:-1])
            ),
        )
        * 6
        % 10
        if n > 1
        else 1
    )


def A058376_gen():  # generator of terms
    a, k, i = [0] * 4, 0, 1
    for n in count(2):
        m = (
            reduce(
                lambda x, y: x * y % 10,
                (
                    (1, 1, 2, 6, 4)[a] * ((6, 2, 4, 8)[i * a & 3] if i * a else 1)
                    for i, a in enumerate(sympydigits(n, 5)[-1:0:-1])
                ),
            )
            * 6
            % 10
            >> 1
        ) - 1
        a[m] += 1
        if a[m] > k:
            if m != i:
                yield n
            i, k = m, a[m]


def A045548_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: 4
        == reduce(
            lambda x, y: x * y % 10,
            (
                (
                    (6, 2, 4, 8, 6, 2, 4, 8, 2, 4, 8, 6, 6, 2, 4, 8, 4, 8, 6, 2)[
                        (a << 2) | (i * a & 3)
                    ]
                    if i * a
                    else (1, 1, 2, 6, 4)[a]
                )
                for i, a in enumerate(sympydigits(n, 5)[-1:0:-1])
            ),
            6,
        ),
        count(max(startvalue, 1)),
    )


def A045549_gen(startvalue=2):  # generator of terms
    return filter(
        lambda n: 6
        == reduce(
            lambda x, y: x * y % 10,
            (
                (
                    (6, 2, 4, 8, 6, 2, 4, 8, 2, 4, 8, 6, 6, 2, 4, 8, 4, 8, 6, 2)[
                        (a << 2) | (i * a & 3)
                    ]
                    if i * a
                    else (1, 1, 2, 6, 4)[a]
                )
                for i, a in enumerate(sympydigits(n, 5)[-1:0:-1])
            ),
            6,
        ),
        count(max(startvalue, 2)),
    )


def A045550_gen(startvalue=1):  # generator of terms
    return filter(
        lambda n: 8
        == reduce(
            lambda x, y: x * y % 10,
            (
                (
                    (6, 2, 4, 8, 6, 2, 4, 8, 2, 4, 8, 6, 6, 2, 4, 8, 4, 8, 6, 2)[
                        (a << 2) | (i * a & 3)
                    ]
                    if i * a
                    else (1, 1, 2, 6, 4)[a]
                )
                for i, a in enumerate(sympydigits(n, 5)[-1:0:-1])
            ),
            6,
        ),
        count(max(startvalue, 1)),
    )


def A008904(n):
    return (
        reduce(
            lambda x, y: x * y % 10,
            (
                (
                    (6, 2, 4, 8, 6, 2, 4, 8, 2, 4, 8, 6, 6, 2, 4, 8, 4, 8, 6, 2)[
                        (a << 2) | (i * a & 3)
                    ]
                    if i * a
                    else (1, 1, 2, 6, 4)[a]
                )
                for i, a in enumerate(sympydigits(n, 5)[-1:0:-1])
            ),
            6,
        )
        if n > 1
        else 1
    )


def A178969(n):
    return (
        reduce(
            lambda x, y: x * y % 10,
            (
                (
                    (6, 2, 4, 8, 6, 2, 4, 8, 2, 4, 8, 6, 6, 2, 4, 8, 4, 8, 6, 2)[
                        (a << 2) | (i * a & 3)
                    ]
                    if i * a
                    else (1, 1, 2, 6, 4)[a]
                )
                for i, a in enumerate(sympydigits(1 << 10**n, 5)[-1:0:-1])
            ),
            6,
        )
        if n
        else 8
    )


def A065881(n):
    return int(str(n).rstrip("0")[-1])


def A116081(n):
    return pow(int(str(n).rstrip("0")[-1]), n, 10)


def A367799_gen():  # generator of terms
    c = Counter()
    for n in count(0):
        c[
            m := (
                reduce(
                    lambda x, y: x * y % 10,
                    (
                        (
                            (
                                6,
                                2,
                                4,
                                8,
                                6,
                                2,
                                4,
                                8,
                                2,
                                4,
                                8,
                                6,
                                6,
                                2,
                                4,
                                8,
                                4,
                                8,
                                6,
                                2,
                            )[(a << 2) | (i * a & 3)]
                            if i * a
                            else (1, 1, 2, 6, 4)[a]
                        )
                        for i, a in enumerate(sympydigits(n, 5)[-1:0:-1])
                    ),
                    6,
                )
                if n > 1
                else 1
            )
        ] += 1
        yield c[m]


def A073095_gen(startvalue=2):  # generator of terms
    for n in count(max(startvalue, 2)):
        s, s2 = sympydigits(n, 5)[-1:0:-1], sympydigits(n << 1, 5)[-1:0:-1]
        if (
            reduce(
                lambda x, y: x * y % 10,
                (
                    (
                        (6, 2, 4, 8, 6, 2, 4, 8, 2, 4, 8, 6, 6, 2, 4, 8, 4, 8, 6, 2)[
                            (a << 2) | (i * a & 3)
                        ]
                        if i * a
                        else (1, 1, 2, 6, 4)[a]
                    )
                    for i, a in enumerate(s)
                ),
                6,
            )
            == crt(
                [2, 5],
                [
                    0,
                    reduce(
                        lambda x, y: x * y % 5,
                        (
                            (
                                1,
                                0,
                                0,
                                0,
                                0,
                                1,
                                1,
                                0,
                                0,
                                0,
                                1,
                                2,
                                1,
                                0,
                                0,
                                1,
                                3,
                                3,
                                1,
                                0,
                                1,
                                4,
                                1,
                                4,
                                1,
                            )[5 * a + b]
                            for a, b in zip_longest(s2, s, fillvalue=0)
                        ),
                    ),
                ],
            )[0]
        ):
            yield n


def A037453_gen(startvalue=1):  # generator of terms
    yield from filter(
        lambda n: all(x < 3 for x in sympydigits(n, 5)[1:]), count(max(startvalue, 1))
    )


def A208279(n):
    if n == 0:
        return 1
    s = sympydigits(n, 5)[1:]
    return (
        0
        if any(x > 2 for x in s)
        else ((6, 2, 4, 8)[a & 3] if (a := s.count(1)) else 6)
    )


def A077429_gen():  # generator of terms
    for m in count(0):
        s = bin(m)[2:]
        if len(s) & 1:
            s = "0" + s
        n = int(
            "".join(
                {"00": "0", "01": "1", "10": "4", "11": "9"}[s[i : i + 2]]
                for i in range(0, len(s), 2)
            )
        )
        if set(str(n**2)) <= {"0", "1", "4", "9"}:
            yield n


def A368207(n):
    c = 0
    for d2 in divisors(n):
        if d2**2 > n:
            break
        c += (d2 << 2) - 2 if d2**2 < n else (d2 << 1) - 1
    for wx in range(1, (n >> 1) + 1):
        for d1 in divisors(wx):
            if d1**2 > wx:
                break
            for d2 in divisors(m := n - wx):
                if d2**2 > m:
                    break
                if wx < d1 * d2:
                    k = 1
                    if d1**2 != wx:
                        k <<= 1
                    if d2**2 != m:
                        k <<= 1
                    c += k
    return c


def A066839(n):
    return sum(takewhile(lambda x: x**2 <= n, divisors(n)))


def A038548(n):
    return divisor_count(n) + 1 >> 1


def A072499(n):
    return prod(takewhile(lambda x: x**2 <= n, divisors(n)))


def A368276(n):
    c = sum(takewhile(lambda x: x**2 <= n, divisors(n)))
    for wx in range(1, (n >> 1) + 1):
        for d1 in divisors(wx):
            if d1**2 > wx:
                break
            m = n - wx
            c += sum(
                1 for d in takewhile(lambda x: x**2 <= m, divisors(m)) if wx < d * d1
            )
    return c


def A368277_gen(startvalue=2):  # generator of terms
    p = max(nextprime(startvalue - 1), 2)
    while True:
        c = sum(takewhile(lambda x: x**2 <= p, divisors(p))) & 1
        for wx in range(1, (p >> 1) + 1):
            for d1 in divisors(wx):
                if d1**2 > wx:
                    break
                m = p - wx
                c = (
                    c
                    + sum(
                        1
                        for d in takewhile(lambda x: x**2 <= m, divisors(m))
                        if wx < d * d1
                    )
                    & 1
                )
        if c ^ 1:
            yield p
        p = nextprime(p)


def A368278_gen(startvalue=2):  # generator of terms
    p = max(nextprime(startvalue - 1), 2)
    while True:
        c = sum(takewhile(lambda x: x**2 <= p, divisors(p))) & 1
        for wx in range(1, (p >> 1) + 1):
            for d1 in divisors(wx):
                if d1**2 > wx:
                    break
                m = p - wx
                c = (
                    c
                    + sum(
                        1
                        for d in takewhile(lambda x: x**2 <= m, divisors(m))
                        if wx < d * d1
                    )
                    & 1
                )
        if c:
            yield p
        p = nextprime(p)


def A367379(n):
    return (n**2 * (n + 1) >> 1) - (
        ((s := isqrt(n)) ** 2 * (s + 1) * ((s + 1) * (2 * s + 1) - 6 * (n + 1)) >> 1)
        + sum(
            (q := n // k)
            * (-k * (q + 1) * (3 * k + 2 * q + 1) + 3 * (n + 1) * (2 * k + q + 1))
            for k in range(1, s + 1)
        )
    ) // 6


def A367367(n):
    kmin, kmax = 1, 1
    while kmax * (n - 1) ** kmax >= n**kmax - 1:
        kmax <<= 1
    while True:
        kmid = kmax + kmin >> 1
        if kmid * (n - 1) ** kmid < n**kmid - 1:
            kmax = kmid
        else:
            kmin = kmid
        if kmax - kmin <= 1:
            break
    return kmin


def A368341_gen(startvalue=0):  # generator of terms
    for n in count(max(startvalue, 0)):
        c = 0
        for d2 in divisors(n):
            if d2**2 > n:
                break
            c += (d2 << 2) - 2 if d2**2 < n else (d2 << 1) - 1
            if c > n:
                break
        if c <= n:
            for wx in range(1, (n >> 1) + 1):
                for d1 in divisors(wx):
                    if d1**2 > wx:
                        break
                    for d2 in divisors(m := n - wx):
                        if d2**2 > m:
                            break
                        if wx < d1 * d2:
                            k = 1
                            if d1**2 != wx:
                                k <<= 1
                            if d2**2 != m:
                                k <<= 1
                            c += k
                            if c > n:
                                break
        if c == n:
            yield n


def A000042(n):
    return (10**n - 1) // 9


def A368346(n):
    return (1 << n + 1) // 15 - (n + 1 >> 2)


def A367360(n):
    return (0, 10, 40, 90, 60, 50, 60, 90, 40, 10)[n % 10] + int(str((n + 1) ** 2)[0])


def A367361(n):
    return (60, 20, 40, 80)[n & 3] + int(str(1 << n + 1)[0]) if n else 12


def A367362(n):
    return (n % 10) * 10 + int(str(n + 1)[0])


def A028864_gen():  # generator of terms
    yield from (2, 3, 5, 7)
    a, b = {"1": 0, "2": 1, "3": 1, "4": 2, "5": 2, "6": 2, "7": 2, "8": 3, "9": 3}, (
        1,
        3,
        7,
        9,
    )
    for l in count(1):
        for d in combinations_with_replacement("123456789", l):
            k = 10 * int("".join(d))
            for e in b[a[d[-1]] :]:
                if isprime(m := k + e):
                    yield m


def A028867_gen():  # generator of terms
    yield from (2, 3, 5, 7)
    a, b = {"1": 1, "2": 1, "3": 2, "4": 2, "5": 2, "6": 2, "7": 3, "8": 3, "9": 4}, (
        1,
        3,
        7,
        9,
    )
    for l in count(1):
        mlist = []
        for d in combinations_with_replacement("987654321", l):
            k = 10 * int("".join(d))
            for e in b[: a[d[-1]]]:
                if isprime(m := k + e):
                    mlist.append(m)
        yield from sorted(mlist)


def A367951_gen():  # generator of terms
    a, l = [1], 0
    while True:
        yield from a[l:]
        c = sum(([1, 3] if d == 1 else [d - 2, d, d, d + 2] for d in a), start=[])
        l, a = len(a), c


def A367953_gen():  # generator of terms
    a, l = [2], 0
    while True:
        yield from a[l:]
        c = sum(([2, 2, 4] if d == 2 else [d - 2, d, d, d + 2] for d in a), start=[])
        l, a = len(a), c


def A039986_gen():  # generator of terms
    for l in count(1):
        xlist = []
        for p in combinations_with_replacement("0123456789", l):
            flag = False
            for q in multiset_permutations(p):
                if isprime(m := int("".join(q))):
                    if flag or q[0] == "0":
                        flag = False
                        break
                    else:
                        flag = True
                        r = m
            if flag:
                xlist.append(r)
        yield from sorted(xlist)


def A028948_gen():  # generator of terms
    x = 0
    while True:
        yield x
        x = (y := (x * 4001 + 1200) // 1000) >> (~y & y - 1).bit_length()


def A368540(n):
    return prod(p**e for p, e in factorint(n).items() if not e or (e & -e) ^ e)


def A368544(n):
    return prod(e + 1 for p, e in factorint(n).items() if is_square(p - 1))


def A367870(n):
    f = factorint(n >> (~n & n - 1).bit_length())
    return n * prod(e + 1 for e in f.values()) - prod(
        (p ** (e + 1) - 1) // (p - 1) for p, e in f.items()
    )


def A245579(n):
    return n * prod(e + 1 for e in factorint(n >> (~n & n - 1).bit_length()).values())


def A368595(n):
    return sum(
        map(
            lambda x: (x[0] + 1) * (1 << x[0]),
            filter(lambda x: x[1] == "1", enumerate(bin(n)[-2:1:-1])),
        )
    ) - (n & 1)


def A034387(n):
    return sum(primerange(n + 1))


def A046992(n):
    return (n + 1) * len(p := list(primerange(n + 1))) - sum(p)


def A002815(n):
    return n + (n + 1) * len(p := list(primerange(n + 1))) - sum(p)


def A122515(n):
    return (
        -(n + 1) * len(p := list(primerange(n + 1)))
        + (sum(p) << 1)
        + sum(primerange(n + 1, prime(n) + 1))
    )


def A152535(n):
    return (n - 1) * (p := prime(n)) - sum(primerange(p))


def A046933(n):
    return prime(n + 1) - prime(n) - 1


def A136556(n):
    return comb((1 << n) - 1, n)


def A368600(n):
    xlist = [[] for i in range(n)]
    for l in range(1, n + 1):
        for c in combinations(range(1, n + 1), l):
            for p in c:
                xlist[p - 1].append(c)
    return comb((1 << n) - 1, n) - len(
        {e for e in (tuple(sorted(d)) for d in product(*xlist)) if len(set(e)) == n}
    )


def A368601(n):
    xlist = [[] for i in range(n)]
    for l in range(1, n + 1):
        for c in combinations(range(1, n + 1), l):
            for p in c:
                xlist[p - 1].append(c)
    return len(
        {e for e in (tuple(sorted(d)) for d in product(*xlist)) if len(set(e)) == n}
    )


def A368649(n):
    return 5 * n + 1 + isqrt(5 * n * n) >> 1


def A368359(n):
    return 10 * (comb(n << 1, n) // (n + 1) % 10) + int(
        str(comb(n + 1 << 1, n + 1) // (n + 2))[0]
    )


def A368361(n):
    return (10, 30, 50, 70, 90)[n % 5] + int(str((n << 1) + 3)[0])


def A368360(n):
    return (0, 20, 40, 60, 80)[n % 5] + int(str(n + 1 << 1)[0])


def A013928(n):
    return sum(mobius(k) * ((n - 1) // k**2) for k in range(1, isqrt(n - 1) + 1))


def A107079(n):
    return 1 + sum(mobius(k) * ((n - 1) // k**2) for k in range(1, isqrt(n - 1) + 1))


def A368673(n):
    return (
        sum(mobius(k) * ((n - 1) // k**2) for k in range(1, isqrt(n - 1) + 1))
        - (1 << len(f := factorint(n)))
        + int(max(f.values(), default=1) == 1)
    )


@lru_cache(maxsize=None)
def A366889(n):
    return (
        1
        if n == 1
        else -sum(
            (1 << (~(m := int(divisor_sigma(d))) & m - 1).bit_length())
            * A366889(n // d)
            for d in divisors(n, generator=True)
            if d > 1
        )
    )


def A359548(n):
    return (
        0 if (m := (~n & n - 1).bit_length()) > 1 else (-1 if m == 1 else 1)
    ) * prod(-1 if e == 2 else 0 for e in factorint(n >> m).values())


def A368694(n):
    return A366889(A163511(n))


def A351565(n):
    return (m := 1 + (n >> (~n & n - 1).bit_length())) >> (~m & m - 1).bit_length()


def A336699(n):
    return A351565(A000593(n))


def A110963(n):
    return (
        1 + (m := n >> (~n & n - 1).bit_length()) >> (m + 1 & -m - 1).bit_length()
    ) + 1


@lru_cache(maxsize=None)
def A353366(n):
    return (
        1
        if n == 1
        else -sum(
            (
                (
                    1 + (m := d >> (~d & d - 1).bit_length())
                    >> (m + 1 & -m - 1).bit_length()
                )
                + 1
            )
            * A353366(n // d)
            for d in divisors(n, generator=True)
            if d > 1
        )
    )


def A103391(n):
    return (n - 1 >> (n - 1 & -n + 1).bit_length()) + 2 if n > 1 else 1


def A057979(n):
    return n >> 1 if n & 1 else 1


def A152271(n):
    return n + 1 >> 1 if n & 1 else 1


def A368733(n):
    return hyperexpand(hyper((-1 - n, -n, 1 - n), (2, 3), -3))


def A344560(n):
    return hyperexpand(
        hyper((Rational(-n, 3), Rational(1 - n, 3), Rational(2 - n, 3)), (1, 1), -27)
    )


def A344559(n):
    return (
        hyperexpand(
            hyper(
                (Rational(-n, 3), Rational(1 - n, 3), Rational(2 - n, 3)), (1, 1), -27
            )
        )
        - 1
    ) // 6


def A344854(n):
    return (
        (
            hyperexpand(
                hyper(
                    (Rational(-n, 3), Rational(1 - n, 3), Rational(2 - n, 3)),
                    (1, 1),
                    -27,
                )
            )
            - 1
        )
        // 3
        << n - 1
        if n
        else 0
    )


def A097861(n):
    return hyperexpand(hyper(((1 - n) * S.Half, -n * S.Half), (1,), 4)) - 1 >> 1


def A279756(n):
    return next(
        dropwhile(
            lambda x: not isprime(x), count(2 if (p := prime(n)) == 2 else p + 2, p)
        )
    )


def A367805(n):
    if n == 1:
        return 0
    else:
        p = prime(n)
        return next(dropwhile(lambda x: not isprime(x * p + 2), count(1)))


def A367821(n):
    if str(n).rstrip("0") == "1":
        return -1
    r, m = 9, 10
    while True:
        k, b = integer_log(m - 1, n)
        if n**k >= r:
            return k
        r *= 10
        m *= 10


def A368866(n):
    k = 1
    for m in count(1):
        k <<= 1
        s = sympydigits(k, n)[1:]
        if any(s[i] == s[i + 1] for i in range(len(s) - 1)):
            return m


def A368884(n):
    return prod(p**e for p, e in factorint(n).items() if e == 2)


def A368886(n):
    return prod(p**e for p, e in factorint(n).items() if e != 2)


def A368885(n):
    return 1 << sum(1 for e in factorint(n).values() if e == 2)


def A368843(n):
    l = len(s := bin(n)[2:])
    return sum(
        1
        for i in range(l - 2)
        for j in range(1, l - i + 1 >> 1)
        if s[i : i + (j << 1) + 1 : j] == "111"
    )


def A368842(n):
    l = len(s := bin(n)[2:])
    return sum(
        1
        for i in range(l - 2)
        for j in range(1, l - i + 1 >> 1)
        if s[i : i + (j << 1) + 1 : j] in {"000", "111"}
    )


def A368844(n):
    l = len(s := bin(n)[3:])
    return sum(
        1
        for i in range(l - 2)
        for j in range(1, l - i + 1 >> 1)
        if s[i : i + (j << 1) + 1 : j] == "000"
    )


def A368857(n):
    if n == 0:
        return 0
    l = len(s := bin(n)[2:])
    return 1 + max(
        (k - 1 - i) // j
        for i in range(l)
        for j in range(1, l - i + 3 >> 1)
        for k in range(i + 1, l + 1, j)
        if len(set(s[i:k:j])) == 1
    )


def A068598(n):
    if n == 0:
        return 1
    v = tuple(tuple(p.keys()) for p in partitions(n) if max(p.values(), default=0) == 1)
    G = empty_graph(v)
    G.add_edges_from((a, b) for a, b in combinations(v, 2) if set(a).isdisjoint(set(b)))
    return sum(1 for c in find_cliques(G))


def A367681(n):
    v = tuple(
        int(q, 2)
        for q in ("".join(p) for p in product("01", repeat=n))
        if "11" not in q + q[0]
    )
    G = empty_graph(v)
    e = tuple(
        (a, b)
        for a, b in combinations(v, 2)
        if (lambda m: (m & -m) ^ m if m else 1)(a ^ b)
    )
    G.add_edges_from(e)
    return sum(1 for c in find_cliques(G))


def A284707(n):
    k = 1 << n
    G = empty_graph(range(k))
    G.add_edges_from(
        (a, b)
        for a in range(k)
        for b in range(a)
        if (lambda m: (m & -m) ^ m if m else 1)(a ^ b)
    )
    return sum(1 for c in find_cliques(G))


def A290607(n):
    k = 1 << (n << 1)
    G = empty_graph(range(k))
    G.add_edges_from(
        (a, b)
        for a in range(k)
        for b in range(a)
        if (
            s := tuple(
                c - d & 3
                for c, d in zip_longest(
                    sympydigits(a, 4)[-1:0:-1], sympydigits(b, 4)[-1:0:-1], fillvalue=0
                )
            )
        ).count(2)
        == 0
        or s.count(0) > len(s) - 2
    )
    return sum(1 for c in find_cliques(G))


def A289201(n):
    G = empty_graph((i, j) for i in range(n) for j in range(n))
    G.add_edges_from(
        ((i, j), (i + k, j + l))
        for i in range(n)
        for j in range(n)
        for (k, l) in (
            (1, 2),
            (1, -2),
            (-1, 2),
            (-1, -2),
            (2, 1),
            (2, -1),
            (-2, 1),
            (-2, -1),
        )
        if 0 <= i + k < n and 0 <= j + l < n
    )
    return sum(1 for c in find_cliques(complement(G)))


def A290610(n):
    G = empty_graph(combinations(range((n << 1) - 1), n - 1))
    G.add_edges_from((a, b) for a, b in combinations(G, 2) if not set(a).isdisjoint(b))
    return sum(1 for c in find_cliques(G))


def A290606(n):
    k = 1 << n - 1
    G = empty_graph(range(k))
    G.add_edges_from(
        (a, b)
        for a in range(k)
        for b in range(a)
        if (lambda m: not (m & -m) ^ m if m else False)(a ^ b)
    )
    return sum(1 for c in find_cliques(complement(power(G, 2))))


def A296101(n):
    k = 1 << (n << 1)
    G = empty_graph(range(k))
    G.add_edges_from(
        (a, b)
        for a in range(k)
        for b in range(a)
        if (
            s := tuple(
                c - d & 3
                for c, d in zip_longest(
                    sympydigits(a, 4)[-1:0:-1], sympydigits(b, 4)[-1:0:-1], fillvalue=0
                )
            )
        ).count(2)
        > 0
        and s.count(0) <= len(s) - 2
    )
    return sum(1 for c in find_cliques(G))


def A321242(n):
    G = empty_graph((i, j) for i in range(n) for j in range(n))
    G.add_edges_from(
        ((i, j), (i + k, j + l))
        for i in range(n)
        for j in range(n)
        for (k, l) in (
            (3, 4),
            (3, -4),
            (-3, 4),
            (-3, -4),
            (4, 3),
            (4, -3),
            (-4, 3),
            (-4, -3),
        )
        if 0 <= i + k < n and 0 <= j + l < n
    )
    return sum(1 for c in find_cliques(complement(G)))


def A321247(n):
    G = empty_graph((i, j) for i in range(n) for j in range(n))
    G.add_edges_from(
        ((i, j), (i + k, j + l))
        for i in range(n)
        for j in range(n)
        for (k, l) in (
            (5, 0),
            (-5, 0),
            (0, 5),
            (0, -5),
            (3, 4),
            (3, -4),
            (-3, 4),
            (-3, -4),
            (4, 3),
            (4, -3),
            (-4, 3),
            (-4, -3),
        )
        if 0 <= i + k < n and 0 <= j + l < n
    )
    return sum(1 for c in find_cliques(complement(G)))


def A321248(n):
    return sum(
        1
        for c in find_cliques(
            complement(cartesian_product(star_graph(n), path_graph(n)))
        )
    )


def A321250(n):
    return sum(
        1
        for c in find_cliques(
            complement(cartesian_product(cycle_graph(n), cycle_graph(n)))
        )
    )


def A288490_gen():  # generator of terms
    f, g, h, p = 1, 1, 0, 0
    while True:
        yield f + 3 * (g + h) + p
        a, b = f + (g << 1), g + (h << 1)
        f, g, h, p = (
            a * (f * (a + (b << 1) - h) + g**2),
            f * (p * a + b * (a + (g << 1)) + 2 * h**2) + g**2 * (g + (b << 1)),
            f * (g * (b + (h << 1)) + 3 * h**2)
            + g * (g * ((b << 1) + 3 * h) + (h << 1) ** 2)
            + p * (f * b + g * a),
            b * (g * (3 * p + b + (h << 1)) + h**2),
        )


def A297536_gen():  # generator of terms
    f, g, h, p = 0, 1, 0, 0
    while True:
        yield f + 3 * (g + h) + p
        a, b = f + (g << 1), g + (h << 1)
        f, g, h, p = (
            a * (f * (a + (b << 1) - h) + g**2),
            f * (p * a + b * (a + (g << 1)) + 2 * h**2) + g**2 * (g + (b << 1)),
            f * (g * (b + (h << 1)) + 3 * h**2)
            + g * (g * ((b << 1) + 3 * h) + (h << 1) ** 2)
            + p * (f * b + g * a),
            b * (g * (3 * p + b + (h << 1)) + h**2),
        )


def A360685(n):
    k = 1 << n - 1
    G = empty_graph(range(k))
    G.add_edges_from(
        (a, b)
        for a in range(k)
        for b in range(a)
        if (lambda m: not (m & -m) ^ m if m else False)(a ^ b)
    )
    return (c := Counter(len(c) for c in find_cliques(complement(power(G, 2)))))[max(c)]


def A290609(n):
    return sum(1 for c in find_cliques(complement(mycielski_graph(n))))


def A291742(n):
    v = tuple(
        int(q, 2)
        for q in ("".join(p) for p in product("01", repeat=n))
        if "11" not in q
    )
    G = empty_graph(v)
    e = tuple(
        (a, b)
        for a, b in combinations(v, 2)
        if (lambda m: (m & -m) ^ m if m else 1)(a ^ b)
    )
    G.add_edges_from(e)
    return sum(1 for c in find_cliques(G))


def A290611(n):
    G = empty_graph(combinations(range(n), 3))
    G.add_edges_from((a, b) for a, b in combinations(G, 2) if len(set(a) & set(b)) != 2)
    return sum(1 for c in find_cliques(G))


def A301460(n):
    G = hypercube_graph(n)
    for a in product((0, 1), repeat=n - 1):
        G = contracted_nodes(G, (0,) + a, (1,) + tuple(1 - d for d in a))
    return sum(1 for c in find_cliques(complement(G)))


def A369233(n):
    m = 1 << n
    return next(
        b
        for b in count(2)
        if (s := sympydigits(m, b)[1:])[: (t := len(s) + 1 >> 1)] == s[: -t - 1 : -1]
    )


def A016026(n):
    return next(
        b
        for b in count(2)
        if (s := sympydigits(n, b)[1:])[: (t := len(s) + 1 >> 1)] == s[: -t - 1 : -1]
    )


def A016038_gen(startvalue=0):  # generator of terms
    return filter(
        lambda n: all(
            (s := sympydigits(n, b)[1:])[: (t := len(s) + 1 >> 1)] != s[: -t - 1 : -1]
            for b in range(2, n - 1)
        ),
        count(max(startvalue, 0)),
    )


def A367686(n):
    G = empty_graph(
        v
        for v in product((0, 1, 2), repeat=n)
        if not any(len(list(g)) & 1 and k == 2 for k, g in groupby(v))
    )
    for a, b in combinations(G, 2):
        r = tuple(islice((i for i in range(n) if a[i] != b[i]), 3))
        if len(r) == 1:
            if a[r[0]] == 2 or b[r[0]] == 2:
                G.add_edge(a, b)
        elif len(r) == 2:
            if not (
                r[0] + 1 == r[1]
                and a[r[0]]
                and b[r[0]]
                and a[r[0]] == a[r[1]]
                and b[r[0]] == b[r[1]]
            ):
                G.add_edge(a, b)
        else:
            G.add_edge(a, b)
    return sum(1 for c in find_cliques(G))


def A368189(n):
    if n <= 1:
        return 0
    G = empty_graph(
        v
        for v in product((0, 1, 2), repeat=n)
        if not any(len(list(g)) & 1 and k == 2 for k, g in groupby(v))
    )
    for a, b in combinations(G, 2):
        r = tuple(islice((i for i in range(n) if a[i] != b[i]), 3))
        if len(r) == 1 and a[r[0]] != 2 and b[r[0]] != 2:
            G.add_edge(a, b)
        elif (
            len(r) == 2
            and r[0] + 1 == r[1]
            and a[r[0]]
            and b[r[0]]
            and a[r[0]] == a[r[1]]
            and b[r[0]] == b[r[1]]
        ):
            G.add_edge(a, b)
    return sum(1 for c in simple_cycles(G))


def A369308(n):
    return prod(0 if e & 1 else (e >> 1) + 1 for e in factorint(n).values())


def A369307(n):
    return prod(2 if e & 1 else e >> 1 for e in factorint(n).values())


def A368958(n):
    if n <= 1:
        return 1
    clist = tuple(
        {
            j
            for j in range(1, n + 1)
            if j != i and gcd(i, j) == 1 and not isprime(abs(i - j))
        }
        for i in range(1, n + 1)
    )

    def f(p, q):
        if (l := len(p)) == n - 1:
            yield len(clist[q] - p)
        for d in clist[q] - p if l else set(range(1, n + 1)) - p:
            yield from f(p | {d}, d - 1)

    return sum(f(set(), 0))


def A369310(n):
    return prod(2 if e <= 2 else e - 1 for e in factorint(n).values())


def A365933(n):
    if n == 1:
        return 1
    a, b, x, y = 1, 1, 1 % n, 11 % n
    while x != y:
        if a == b:
            a <<= 1
            x, b = y, 0
        y = (10 * y + 1) % n
        b += 1
    return 9 * b


def A367484(n):
    m = 3**n
    return len(
        {(pow(x, 4, m) + pow(y, 4, m)) % m for x in range(m) for y in range(x + 1)}
    )


def A083116(n):
    if not (n % 10 and n % 16 and n % 25):
        return 0
    for l in count(1):
        k = (10**l - 1) // 9
        for a in range(1, 10):
            if not (m := a * k) % n:
                return m


def A083117(n):
    if not (n % 10 and n % 16 and n % 25):
        return 0
    for l in count(1):
        k = (10**l - 1) // 9
        for a in range(1, 10):
            b, c = divmod(a * k, n)
            if not c:
                return b


def A243110_gen():  # generator of terms
    p, c = 5, 2
    yield 3
    while p := next_prime(p):
        if p - 1 > c * (k := n_order(10, p)):
            c = (p - 1) // k
            yield int(p)


def A359446_gen():  # generator of terms
    p, c = 5, 2
    yield 1
    while p := next_prime(p):
        if p - 1 > c * (k := n_order(10, p)):
            c = (p - 1) // k
            yield int(k)


def A359503(n):
    return sum(
        sum(takewhile(lambda x: x**2 <= i, divisors(i))) for i in range(1, n + 1)
    )


def A084188(n):
    return isqrt(1 << (n << 1) + 1)


def A084186(n):
    a, b = 2, (1 << n + 2) - 1
    c = (b >> 1) ^ 1
    for k in count(1 - n):
        if isqrt(a) & b == c:
            return k
        a <<= 2


def A084187(n):
    a, b = 2, (1 << n + 2) - 1
    c = (b + 1 >> 1) | 1
    for k in count(1 - n):
        if isqrt(a) & b == c:
            return k
        a <<= 2


def A368373(n):
    return (Fraction(n + 1, 2) - Fraction(n, harmonic(n))).denominator


def A368366(n):
    return ((m := n**n) * (n + 1) ** n >> n) - m * factorial(n)


def A368371(n):
    return ((1 << n + 1) - 2) ** n - n**n * (1 << (n * (n + 1) >> 1))


def A369395(n):
    return n**n * ((n + 1) ** n - (factorial(n) << n))


def A368368(n):
    return (n * (n + 1) * ((n << 1) + 1) // 6) ** n - n**n * factorial(n) ** 2


def A368369(n):
    return (m := n**n) * (m - factorial2((n << 1) - 1))


def A368370(n):
    return comb(n + 2, 3) ** n - (n**n * factorial(n) ** 2 * (n + 1) >> n)


def A368372(n):
    return (Fraction(n + 1, 2) - Fraction(n, harmonic(n))).numerator


def A368367(n):
    return sum(factorial(i) for i in range(1, n + 1)) ** n - n**n * prod(
        i ** (n - i + 1) for i in range(2, n + 1)
    )


def A369394(n):
    return sum(prime(i) for i in range(1, n + 1)) ** n - n**n * primorial(n)


def A132377(n):
    return primepi(n) ** n


def A367458(n):
    G = empty_graph((i, j) for i in range(n) for j in range(n))
    G.add_edges_from(
        ((i, j), (i + k, j + l))
        for i in range(n)
        for j in range(n)
        for (k, l) in (
            (1, 4),
            (1, -4),
            (-1, 4),
            (-1, -4),
            (4, 1),
            (4, -1),
            (-4, 1),
            (-4, -1),
        )
        if 0 <= i + k < n and 0 <= j + l < n
    )
    return sum(1 for c in find_cliques(complement(G)))


def A367457(n):
    G = empty_graph((i, j) for i in range(n) for j in range(n))
    G.add_edges_from(
        ((i, j), (i + k, j + l))
        for i in range(n)
        for j in range(n)
        for (k, l) in (
            (1, 3),
            (1, -3),
            (-1, 3),
            (-1, -3),
            (3, 1),
            (3, -1),
            (-3, 1),
            (-3, -1),
        )
        if 0 <= i + k < n and 0 <= j + l < n
    )
    return sum(1 for c in find_cliques(complement(G)))


def A367089(n):
    G = empty_graph((i, j) for i in range(n) for j in range(n))
    G.add_edges_from(
        ((i, j), (i + k, j + l))
        for i in range(n)
        for j in range(n)
        for (k, l) in (
            (2, 3),
            (2, -3),
            (-2, 3),
            (-2, -3),
            (3, 2),
            (3, -2),
            (-3, 2),
            (-3, -2),
        )
        if 0 <= i + k < n and 0 <= j + l < n
    )
    return sum(1 for c in find_cliques(complement(G)))


def A368374(n):
    if n == 0:
        return 1
    m = (n << 1) - 1
    kmin, kmax = m, m
    while factorial(kmax) << kmax > (kmax - m) ** kmax:
        kmax <<= 1
    while True:
        kmid = kmax + kmin >> 1
        if factorial(kmid) << kmid <= (kmid - m) ** kmid:
            kmax = kmid
        else:
            kmin = kmid
        if kmax - kmin <= 1:
            break
    return kmin + 1


def A369568(n):
    return n * (3 * n + 8) - 3 >> 4 if n & 1 else 3 * n * (n + 2) >> 4


def A368881(n):
    return 1 + (n * (n * (n * (n + 10) + 11) + 2)) // 24


def A369687(n):
    return sum(p ** totient(n // p) for p in primefactors(n))


def A007434(n):
    return prod(p ** (e - 1 << 1) * (p**2 - 1) for p, e in factorint(n).items())


def A059376(n):
    return prod(p ** (3 * (e - 1)) * (p**3 - 1) for p, e in factorint(n).items())


def A368743(n):
    return prod(
        p ** (e - 1 << 1) * (p**e * (p * (q := p + 1) + 1) - q)
        for p, e in factorint(n).items()
    )


def A366779(n):
    return reduced_totient(reduced_totient(reduced_totient(n)))


def A369629_gen():  # generator of terms
    ccount = Counter({0: 1})
    yield 1
    for i in count(1):
        bcount = Counter()
        for a in ccount:
            bcount[a + (j := i**4)] += ccount[a]
            bcount[a - j] += ccount[a]
        ccount = bcount
        yield (ccount[0] + ccount[1])


def A158092_gen():  # generator of terms
    ccount = Counter({0: 1})
    for i in count(1):
        bcount = Counter()
        for a in ccount:
            bcount[a + (j := i**2)] += ccount[a]
            bcount[a - j] += ccount[a]
        ccount = bcount
        yield (ccount[0])


def A369628_gen():  # generator of terms
    ccount = Counter({0: 1})
    yield 0
    for i in count(1):
        bcount = Counter(ccount)
        for a in ccount:
            bcount[a + i] += ccount[a]
            bcount[a - i] += ccount[a]
        ccount = bcount
        yield (ccount[1])


def A369698(n):
    return ((n * (n + 1)) ** (m := n << 1) >> m) - n**n * factorial(n) ** 3


def A368744(n):
    return ((n << 1) >> (~n & n - 1).bit_length()) - n


def A369767(n):
    c = {j: 1 for j in range(n + 1)}
    for i in range(2, n + 1):
        d = Counter()
        for k in c:
            for j in range(0, i * n + 1, i):
                d[j + k] += c[k]
        c = d
    return max(c.values())


def A369766(n):
    c = {0: 1, 1: 1}
    for i in range(2, n + 1):
        d = Counter()
        for k in c:
            for j in range(0, i * i + 1, i):
                d[j + k] += c[k]
        c = d
    return max(c.values())


def A369764(n):
    c = {0: 1, 1: -1}
    for i in range(2, n + 1):
        d = Counter(c)
        for k in c:
            d[k + i**3] -= c[k]
        c = d
    return max(c.values())


def A369708(n):
    c = {0: 1}
    for i in range(2, n + 1):
        p, d = prime(i), Counter(c)
        for k in c:
            d[k + p] += c[k]
        c = d
    return max(c.values())


def A025591(n):
    c = {0: 1, 1: 1}
    for i in range(2, n + 1):
        d = Counter(c)
        for k in c:
            d[k + i] += c[k]
        c = d
    return max(c.values())


def A359320(n):
    c = {0: 1, 1: 1}
    for i in range(2, n + 1):
        j, d = i**4, Counter(c)
        for k in c:
            d[k + j] += c[k]
        c = d
    return max(c.values())


def A214282(n):
    return comb(n - 1, (n + 1 >> 1) & (-1 ^ (n & 1)))


def A214283(n):
    return -comb(n - 1, (n >> 1) | (n & 1))


def A216972(n):
    return 2 if n & 3 == 2 else n


def A369770(n):
    c = {0: 1}
    for k in range(1, n + 1):
        d = Counter(c)
        for j in c:
            a = c[j]
            for i in range(1, k + 1):
                d[j + i] += comb(k, i) * k**i * a
        c = d
    return max(c.values())


def A065048(n):
    c = {1: 1}
    for k in range(1, n + 1):
        d = Counter()
        for j in c:
            d[j] += k * c[j]
            d[j + 1] += c[j]
        c = d
    return max(c.values())


def A369791_gen():  # generator of terms
    c, a = {0: 1}, []
    while True:
        a.append(max(c.values()))
        yield a[-1]
        d = Counter(c)
        for k in c:
            for b in a:
                d[k + b] += c[k]
        c = d


def A369790(n):
    c = {0: 1}
    for k in range(1, n + 1):
        d = Counter(c)
        for j in c:
            a = c[j]
            d[j + k] -= 3 * a
            d[j + 2 * k] += 3 * a
            d[j + 3 * k] -= a
        c = d
    return len(set(c.values())) + int(max(c) + 1 > len(c))


def A369786(n):
    c = {0: 1}
    for k in range(1, n + 1):
        m, d = k**2, Counter(c)
        for j in c:
            d[j + m] += c[j]
        c = d
    return len(set(c.values())) + int(max(c) + 1 > len(c))


def A369787(n):
    c = {0: 1}
    for k in range(1, n + 1):
        m, d = k * (k + 1) >> 1, Counter(c)
        for j in c:
            d[j + m] += c[j]
        c = d
    return len(set(c.values())) + int(max(c) + 1 > len(c))


def A369788(n):
    c = {0: 1}
    for k in range(1, n + 1):
        m, d = prime(k), Counter(c)
        for j in c:
            d[j + m] += c[j]
        c = d
    return len(set(c.values())) + int(max(c) + 1 > len(c))


def A369789(n):
    c = {0: 1}
    for k in range(1, n + 1):
        m, d = prime(k), Counter(c)
        for j in c:
            a = c[j]
            d[j + m] += a << 1
            d[j + (m << 1)] += a
        c = d
    return len(set(c.values())) + int(max(c) + 1 > len(c))


def A369765(n):
    c = {0: 1, 1: 1}
    for k in range(1, n):
        p, d = prime(k), Counter(c)
        for j in c:
            d[j + p] += c[j]
        c = d
    return max(c.values())


def A369774(n):
    c = {0: 1}
    for k in range(1, n + 1):
        d = Counter(c)
        for j in c:
            a = c[j]
            for i in range(1, k + 1):
                d[j + i] -= a
        c = d
    return max(c.values())


def A369773(n):
    c = {0: 1}
    for k in range(1, n + 1):
        d = Counter(c)
        for j in c:
            a = c[j]
            for i in range(1, k + 1):
                d[j + i] += a if i & 1 else -a
        c = d
    return max(c.values())


def A369775(n):
    if n == 0:
        return 1
    c, p = {0: 1}, list(primerange(prime(n) + 1))
    for k in range(1, n + 1):
        d = Counter(c)
        for j in c:
            a = c[j]
            for i in p[:k]:
                d[j + i] += a
        c = d
    return max(c.values())


def A359328(n):
    if n == 0:
        return 1
    c, p = {0: 1}, list(primerange(prime(n) + 1))
    for k in range(1, n + 1):
        d = Counter()
        for j in c:
            a = c[j]
            for i in p[:k]:
                d[j + i] += a
        c = d
    return max(c.values())


def A369758(n):
    return prod(
        (p ** ((3 if e == 1 else e) + 1 + (e & 1 ^ 1)) - 1) // (p - 1)
        for p, e in factorint(n).items()
    )


def A369305(n):
    return (
        (
            1,
            10,
            19,
            55,
            91,
            175,
            259,
            385,
            511,
            637,
            763,
            847,
            931,
            967,
            1003,
            1012,
            1021,
            1022,
        )[n]
        if n < 18
        else 1023
    )


def A369879(n):
    c = {0: 1}
    for k in range(1, n + 1):
        d = Counter(c)
        for j in c:
            d[j + k] -= c[j]
        c = d
    return len(set(c.values())) + int(max(c) + 1 > len(c))


def A039822(n):
    c = {0: 1}
    for k in range(1, n + 1):
        d = Counter(c)
        for j in c:
            d[j + k] += c[j]
        c = d
    return len(set(c.values())) + int(max(c) + 1 > len(c))


def A368810(n):
    return ((n << 1) * harmonic(n)).p


def A115107(n):
    return ((n + 1 << 1) * harmonic(n) - (n << 2)).p


def A369875(n):
    c = {0: 1}
    for d in divisors(n, generator=True):
        b = Counter(c)
        for j in c:
            a = c[j]
            b[j + d] += a
            b[j - d] += a
        c = b
    return c[n]


def A369874(n):
    c = {0: 1}
    for d in divisors(n, generator=True):
        b = Counter(c)
        for j in c:
            a = c[j]
            b[j + d] += a
            b[j - d] += a
        c = b
    return c[0]


def A369873(n):
    c = {0: 1}
    for d in divisors(n, generator=True):
        b = Counter()
        for j in c:
            a = c[j]
            b[j + d] += a
            b[j - d] += a
        c = b
    return c[0]


def A316706(n):
    c = {0: 1}
    for k in range(1, n + 1):
        b = Counter(c)
        for j in c:
            a = c[j]
            b[j + k] += a
            b[j - k] += a
        c = b
    return c[n]


def A367736_gen():  # generator of terms
    c, b = {0: 1}, 1
    while True:
        yield b
        d = Counter(c)
        for k in c:
            e = c[k]
            d[k + b] += e
            d[k - b] += e
        c = d
        b = c[b]


def A368548(n):
    x = (
        sum(
            comb(d - 2 + ((n + 1) // d >> 1), d - 1)
            for d in divisors(n + 1 >> 1, generator=True)
        )
        if n & 1
        else 0
    )
    y = (
        sum(
            comb((d - 5 >> 1) + (n + 1) // d, d - 3 >> 1)
            for d in divisors((n + 1) >> (~(n + 1) & n).bit_length(), generator=True)
            if d >= 3
        )
        << 1
    )
    return x + y


def A367843(n):
    c = {0: 1}
    for k in range(1, n + 1):
        p, b = prime(k), Counter(c)
        for j in c:
            b[j + p] -= c[j]
        c = b
    return max(map(abs, c.values()))


def A369983(n):
    c = {0: 1}
    for k in range(1, n + 1):
        d = Counter(c)
        for j in c:
            a = c[j]
            d[j + k] -= 3 * a
            d[j + 2 * k] += 3 * a
            d[j + 3 * k] -= a
        c = d
    return max(map(abs, c.values()))


def A369711(n):
    c = {0: 1}
    for k in range(1, n + 1):
        d = Counter(c)
        for j in c:
            a = c[j]
            d[j + k] -= 3 * a
            d[j + 2 * k] += 3 * a
            d[j + 3 * k] -= a
        c = d
    return max(c.values())


def A369709(n):
    c = {0: 1}
    for k in range(1, n + 1):
        d = Counter(c)
        for j in c:
            a = c[j]
            d[j + k] += 3 * a
            d[j + 2 * k] += 3 * a
            d[j + 3 * k] += a
        c = d
    return max(c.values())


def A369987(n):
    c = {0: 1}
    for k in range(1, n + 1):
        m, b = k**3, Counter(c)
        for j in c:
            b[j + m] -= c[j]
        c = b
    return max(map(abs, c.values()))


def A370070(n):
    return (
        sum(comb((1 << i) + (1 << n - i - 1) - 2, (1 << i) - 1) for i in range(n >> 1))
        << 1
    ) + (comb(((1 << (n >> 1)) - 1) << 1, (1 << (n >> 1)) - 1) if n & 1 else 0)


def A370110(n):
    return (
        (0, 0, 0, 0, 24, 252, 1032, 2836, 6332, 12496, 22328)[n - 1]
        if n < 12
        else n * (n * (n * (4 * n - 56) + 185) + 903) - 5142 << 1
    )


def A369834(n):
    return len(
        {
            Matrix([p[i:0:-1] + p[: n - i] for i in range(n)]).det()
            for p in permutations(range(n))
        }
    )


def A369835(n):
    return len(
        {
            Matrix([p[i:0:-1] + p[: n - i] for i in range(n)]).per()
            for p in permutations(range(n))
        }
    )


def A369832(n):
    return (
        len(
            {
                Matrix([p[i:0:-1] + p[: n - i] for i in range(n)]).det()
                for p in permutations(primerange(prime(n) + 1))
            }
        )
        if n
        else 1
    )


def A369833(n):
    return (
        len(
            {
                Matrix([p[i:0:-1] + p[: n - i] for i in range(n)]).per()
                for p in permutations(primerange(prime(n) + 1))
            }
        )
        if n
        else 1
    )


def A369405(n):
    return (10**n - 1) // 9 * 10 ** (n << 1)


def A370198(n):
    G = empty_graph((i, j) for i in range(n) for j in range(n))
    G.add_edges_from(
        ((i, j), (i + k, j + l))
        for i in range(n)
        for j in range(n)
        for (k, l) in (
            (3, 4),
            (3, -4),
            (-3, 4),
            (-3, -4),
            (4, 3),
            (4, -3),
            (-4, 3),
            (-4, -3),
        )
        if 0 <= i + k < n and 0 <= j + l < n
    )
    return (x := Counter(len(c) for c in find_cliques(complement(G))))[max(x)]


def A369830(n):
    return len(
        {
            Matrix([p[i:0:-1] + p[: n - i] for i in range(n)]).det()
            for p in permutations(range(1, n + 1))
        }
    )


def A369831(n):
    return len(
        {
            Matrix([p[i:0:-1] + p[: n - i] for i in range(n)]).per()
            for p in permutations(range(1, n + 1))
        }
    )


def A369946(n):
    return (
        min(
            Matrix([p[i : i + n] for i in range(n)]).det()
            for p in permutations(primerange(prime((n << 1) - 1) + 1))
        )
        if n
        else 1
    )


def A369947(n):
    return (
        max(
            Matrix([p[i : i + n] for i in range(n)]).det()
            for p in permutations(primerange(prime((n << 1) - 1) + 1))
        )
        if n
        else 1
    )


def A369949(n):
    return (
        len(
            {
                Matrix([p[i : i + n] for i in range(n)]).det()
                for p in permutations(primerange(prime((n << 1) - 1) + 1))
            }
        )
        if n
        else 1
    )


def A289203(n):
    return (1, 1, 2, 6)[n - 1] if n < 5 else 2 - (n & 1)


def A369944(n):
    return len(
        {
            Matrix([p[i : i + n] for i in range(n)]).det()
            for p in permutations(range((n << 1) - 1))
        }
    )


def A369952(n):
    return (
        len(
            {
                Matrix([p[i : i + n] for i in range(n)]).per()
                for p in permutations(primerange(prime((n << 1) - 1) + 1))
            }
        )
        if n
        else 1
    )


def A369945(n):
    return len(
        {
            Matrix([p[i : i + n] for i in range(n)]).per()
            for p in permutations(range((n << 1) - 1))
        }
    )


def A369942(n):
    return len(
        {
            Matrix([p[i : i + n] for i in range(n)]).det()
            for p in permutations(range(1, n << 1))
        }
    )


def A369943(n):
    return len(
        {
            Matrix([p[i : i + n] for i in range(n)]).per()
            for p in permutations(range(1, n << 1))
        }
    )


def A368774(n):
    if n == 1:
        return 0
    l = len(s := bin(n)[2:])
    q = sturm(sum(int(s[i]) * symbolx ** (l - i - 1) for i in range(l)))
    a = [1 if (k := LT(p).subs(symbolx, -oo)) == nan else sign(k) for p in q[:-1]] + [
        sign(q[-1])
    ]
    b = [1 if (k := LT(p).subs(symbolx, oo)) == nan else sign(k) for p in q[:-1]] + [
        sign(q[-1])
    ]
    return sum(1 for i in range(len(a) - 1) if a[i] != a[i + 1]) - sum(
        1 for i in range(len(b) - 1) if b[i] != b[i + 1]
    )


def A368824(n):
    for m in count(2):
        l = len(s := bin(m)[2:])
        q = sturm(sum(int(s[i]) * symbolx ** (l - i - 1) for i in range(l)))
        a = [
            1 if (k := LT(p).subs(symbolx, -oo)) == nan else sign(k) for p in q[:-1]
        ] + [sign(q[-1])]
        b = [
            1 if (k := LT(p).subs(symbolx, oo)) == nan else sign(k) for p in q[:-1]
        ] + [sign(q[-1])]
        if n == sum(1 for i in range(len(a) - 1) if a[i] != a[i + 1]) - sum(
            1 for i in range(len(b) - 1) if b[i] != b[i + 1]
        ):
            return l - 1


def A362344(n):
    c = 0
    for s in product([0, 1], repeat=n):
        q = sturm(symbolx**n + sum(int(s[i]) * symbolx**i for i in range(n)))
        a = [
            1 if (k := LT(p).subs(symbolx, -oo)) == nan else sign(k) for p in q[:-1]
        ] + [sign(q[-1])]
        b = [
            1 if (k := LT(p).subs(symbolx, oo)) == nan else sign(k) for p in q[:-1]
        ] + [sign(q[-1])]
        c = max(
            c,
            sum(1 for i in range(len(a) - 1) if a[i] != a[i + 1])
            - sum(1 for i in range(len(b) - 1) if b[i] != b[i + 1]),
        )
    return c


def A369152(n):
    return sum(len(str(comb(n, k))) for k in range(n + 1))


def A370189(n):
    return sum(comb(n, j) * n**j * (-1 if j - 1 & 2 else 1) for j in range(1, n + 1, 2))


def A121626(n):
    return sum(comb(n, j) * n**j * (-1 if j & 2 else 1) for j in range(0, n + 1, 2))


def A115415(n):
    return sum(
        comb(n, j) * n ** (n - j) * (-1 if j & 2 else 1) for j in range(0, n + 1, 2)
    )


def A115416(n):
    return sum(
        comb(n, j) * n ** (n - j) * (-1 if j - 1 & 2 else 1) for j in range(1, n + 1, 2)
    )


def A146559(n):
    return ((1, 1, 0, -2)[n & 3] << ((n >> 1) & -2)) * (-1 if n & 4 else 1)


def A121625(n):
    return n**n * ((1, 1, 0, -2)[n & 3] << ((n >> 1) & -2)) * (-1 if n & 4 else 1)


def A009545(n):
    return ((0, 1, 2, 2)[n & 3] << ((n >> 1) & -2)) * (-1 if n & 4 else 1)


def A370359(n):
    return n**n * ((0, 1, 2, 2)[n & 3] << ((n >> 1) & -2)) * (-1 if n & 4 else 1)


def A369901(n):
    b = n.bit_length() - 1
    c = n & (1 << b) - 1
    return (((c << 1) | 1) << (b + 1)) | 1


def A370223_gen():  # generator of terms
    a, b, s, p = 1, 1, 0, 1
    for n in count(1):
        s += a
        p *= a
        yield s**n - n**n * p
        a, b = b, a + b


def A370209(n):
    p = prime(n)
    return next(
        (p << k) * m
        for k in count(p.bit_length() - 1)
        if isprime(m := (p << k + 1) + 1)
    )


def A369689(n):
    for j in count(0):
        b = 10**j
        a = b * 10 + 1
        for k in sorted(sqrt_mod(n, a, all_roots=True)):
            m = (k**2 - n) // a
            if m > 0 and b <= m + n < a - 1:
                return k


def A056453(n):
    return (1 << (n + 1 >> 1)) - 2


def A187272(n):
    return (n << (n + 1 >> 1) if n & 1 else 3 * n << (n - 2 >> 1)) if n else 0


@lru_cache(maxsize=None)
def A007055(n):
    return (
        (n << (n + 1 >> 1) if n & 1 else 3 * n << (n - 2 >> 1))
        - sum(totient(n // d) * A007055(d) for d in proper_divisors(n, generator=True))
        if n
        else 1
    )


def A056458(n):
    return sum(mobius(n // d) << (1 + d >> 1) for d in divisors(n, generator=True))


def A187274(n):
    return n << n + 1 if n & 1 else 5 * (n >> 1) << n


def A056463(n):
    return sum(
        mobius(n // d) * ((1 << (d + 1 >> 1)) - 2) for d in divisors(n, generator=True)
    )


def A056476(n):
    return (
        sum(mobius(n // d) << (d - 1 >> 1) for d in divisors(n, generator=True))
        if n
        else 1
    )


def A056481(n):
    return (
        sum(mobius(n // d) << (d - 1 >> 1) for d in divisors(n, generator=True))
        if n > 1
        else 0
    )


@lru_cache(maxsize=None)
def A165137(n):
    return (
        (n * bell((n >> 1) + 1) if n & 1 else (a := n >> 1) * (bell(a) + bell(a + 1)))
        - sum(totient(n // d) * A165137(d) for d in proper_divisors(n, generator=True))
        if n
        else 1
    )


def A187273(n):
    return n * 3 ** (1 + (n >> 1)) if n & 1 else (n << 1) * 3 ** (n >> 1)


def A187275(n):
    return n * 5 ** (1 + (n >> 1)) if n & 1 else 3 * n * 5 ** (n >> 1)


@lru_cache(maxsize=None)
def A165135(n):
    return 9 * (
        n * 10 ** (n >> 1) if n & 1 else 11 * (a := n >> 1) * 10 ** (a - 1)
    ) - sum(totient(n // d) * A165135(d) for d in proper_divisors(n, generator=True))


@lru_cache(maxsize=None)
def A007056(n):
    return (
        (n * 3 ** (1 + (n >> 1)) if n & 1 else (n << 1) * 3 ** (n >> 1))
        - sum(totient(n // d) * A007056(d) for d in proper_divisors(n, generator=True))
        if n
        else 1
    )


def A370458(n):
    return prod((1 << (1 << i)) - 1 for i in range(n + 1))


def A187277(n):
    return n * (n * ((n << 1) | 1) - 2)


@lru_cache(maxsize=None)
def A007058(n):
    return (
        (n * 5 ** (1 + (n >> 1)) if n & 1 else 3 * n * 5 ** (n >> 1))
        - sum(totient(n // d) * A007058(d) for d in proper_divisors(n, generator=True))
        if n
        else 1
    )


@lru_cache(maxsize=None)
def A007057(n):
    return (
        (n << n + 1 if n & 1 else 5 * (n >> 1) << n)
        - sum(totient(n // d) * A007057(d) for d in proper_divisors(n, generator=True))
        if n
        else 1
    )


def A006356(n):
    return sum(
        comb(j, a) * comb(k, j) * comb(n + k - i, k - 1) * (-1 if j - k & 1 else 1)
        for k in range(1, n + 2)
        for i in range(k, n + 2)
        for j in range(k + 1)
        if (a := -3 * k + 2 * j + i) >= 0
    )


def A002464(n):
    return factorial(n) + sum(
        (-1 if k & 1 else 1)
        * factorial(n - k)
        * sum(comb(k - 1, t - 1) * comb(n - k, t) << t for t in range(1, k + 1))
        for k in range(1, n + 1)
    )


def A106497_gen():  # generator of terms
    for j in count(0):
        b = 10**j
        a = b * 10 + 1
        for k in sorted(sqrt_mod(0, a, all_roots=True)):
            if a * b <= k**2 < a * (a - 1):
                yield k


def A102567_gen():  # generator of terms
    for j in count(0):
        b = 10**j
        a = b * 10 + 1
        for k in sorted(sqrt_mod(0, a, all_roots=True)):
            if a * b <= k**2 < a * (a - 1):
                yield k**2 // a


def A116136_gen():  # generator of terms
    for j in count(0):
        b = 10**j
        a = b * 10 + 1
        for k in sorted(sqrt_mod(1, a, all_roots=True)):
            if a * (b + 3) <= k**2 - 1 < a * (a + 2):
                yield (k**2 - 1) // a


def A116267_gen():  # generator of terms
    for j in count(0):
        b = 10**j
        a = b * 10 + 1
        for k in sorted(sqrt_mod(1, a, all_roots=True)):
            if a * (b + 3) <= k**2 - 1 < a * (a + 2):
                yield k - 2


def A116260_gen():  # generator of terms
    for j in count(0):
        b = 10**j
        a = b * 10 + 1
        for k in sorted(sqrt_mod(0, a, all_roots=True)) + [a]:
            if a * (b + 4) <= k**2 < a * (a + 3):
                yield k - 2


def A116254_gen():  # generator of terms
    for j in count(0):
        b = 10**j
        a = b * 10 + 1
        for k in sorted(sqrt_mod(-1, a, all_roots=True)):
            if a * (b + 4) <= k**2 + 1 < a * (a + 3):
                yield k - 2


def A370486_gen():  # generator of terms
    for j in count(0):
        b = 10**j
        a = b * 10 + 1
        for k in sorted(sqrt_mod(0, a, all_roots=True)):
            if a * (b + 4) <= k**2 < a * (a + 3):
                yield k - 2


def A116275_gen():  # generator of terms
    for j in count(0):
        b = 10**j
        a = b * 10 + 1
        for k in sorted(sqrt_mod(2, a, all_roots=True)):
            if a * (b + 3) <= k**2 - 2 < a * (a + 2):
                yield k - 2


def A115426_gen():  # generator of terms
    for j in count(0):
        b = 10**j
        a = b * 10 + 1
        for k in sorted(sqrt_mod(2, a, all_roots=True)):
            if a * (b - 2) <= k**2 - 2 < a * (a - 3):
                yield (k**2 - 2) // a


def A116288_gen():  # generator of terms
    for j in count(0):
        b = 10**j
        a = b * 10 + 1
        for k in sorted(sqrt_mod(4, a, all_roots=True)):
            if a * b <= k**2 - 4 < a * (a - 1):
                yield k - 2


def A079842(n):
    smax, m = 0, 0
    for s, p in sorted(partitions(n, size=True), key=itemgetter(0), reverse=True):
        if s < smax:
            break
        for a in multiset_permutations(Counter(p).elements()):
            if is_square(k := int("".join(str(d) for d in a))):
                m = max(k, m)
        if m > 0:
            smax = s
    return m


def A370512(n):
    smax, m = 0, 0
    for s, p in sorted(partitions(n, size=True), key=itemgetter(0), reverse=True):
        if s < smax:
            break
        q = tuple(Counter(p).elements())
        c = sum((Counter(str(d)) for d in q), start=Counter())
        if len(tuple(filter(lambda x: x & 1, c.values()))) <= 1:
            for a in multiset_permutations(q):
                if (b := "".join(str(d) for d in a)) == b[::-1] and is_square(
                    k := int(b)
                ):
                    m = max(k, m)
            if m > 0:
                smax = s
    return m


def A370255(n):
    if n == 0:
        return 1
    m = n
    a, b = divmod(m, 10)
    while not b:
        m = a
        a, b = divmod(m, 10)
    return m ** (10 * n)


def A004151(n):
    a, b = divmod(n, 10)
    while not b:
        n = a
        a, b = divmod(n, 10)
    return n


def A004719(n):
    return int(str(n).replace("0", ""))


def A069870(n):
    d = 10**n
    smin, m = n + 1, d
    if n == 3 or n % 3:
        for s in range(1, n + 1):
            if s > smin:
                break
            m = min(
                (
                    k
                    for k in (
                        int("".join(str(d) for d in a))
                        for p in partitions(n, m=s)
                        for a in multiset_permutations(Counter(p).elements())
                    )
                    if isprime(k)
                ),
                default=d,
            )
            if m < d:
                smin = s
    if m == d:
        return 0
    else:
        return m


def A116381(n):
    return (
        sum(
            1
            for p in partitions(n)
            for a in multiset_permutations(Counter(p).elements())
            if isprime(int("".join(str(d) for d in a)))
        )
        if n == 3 or n % 3
        else 0
    )


def A073901(n):
    return (
        sum(
            1
            for p in partitions(n, k=9)
            for a in multiset_permutations(Counter(p).elements())
            if isprime(int("".join(str(d) for d in a)))
        )
        if n == 3 or n % 3
        else 0
    )


def A069869(n):
    smax, m = 0, 0
    if n == 3 or n % 3:
        for s, p in sorted(partitions(n, size=True), key=itemgetter(0), reverse=True):
            if s < smax:
                break
            for a in multiset_permutations(Counter(p).elements()):
                if isprime(k := int("".join(str(d) for d in a))):
                    m = max(k, m)
            if m > 0:
                smax = s
    return m


def A116341_gen():  # generator of terms
    for j in count(0):
        b = 10**j
        a = b * 10 + 1
        for k in sorted(sqrt_mod(23, a, all_roots=True)):
            if a * (b - 7) <= k**2 - 23 < a * (a - 8) and k > 4:
                yield k - 4


def A116333_gen():  # generator of terms
    for j in count(0):
        b = 10**j
        a = b * 10 + 1
        for k in sorted(sqrt_mod(22, a, all_roots=True)):
            if a * (b - 6) <= k**2 - 22 < a * (a - 7) and k > 4:
                yield k - 4


def A116327_gen():  # generator of terms
    for j in count(0):
        b = 10**j
        a = b * 10 + 1
        for k in sorted(sqrt_mod(21, a, all_roots=True)):
            if a * (b - 5) <= k**2 - 21 < a * (a - 6) and k > 4:
                yield k - 4


def A116196_gen():  # generator of terms
    for j in count(0):
        b = 10**j
        a = b * 10 + 1
        for k in sorted(sqrt_mod(21, a, all_roots=True)):
            if a * (b - 5) <= k**2 - 21 < a * (a - 6) and k > 4:
                yield (k**2 - 21) // a


def A116202_gen():  # generator of terms
    for j in count(0):
        b = 10**j
        a = b * 10 + 1
        for k in sorted(sqrt_mod(22, a, all_roots=True)):
            if a * (b - 6) <= k**2 - 22 < a * (a - 7) and k > 4:
                yield (k**2 - 22) // a


def A231530(n):
    return sum(
        stirling(n + 1, (k << 1) + 1, kind=1) * (-1 if k & 1 else 1)
        for k in range((n >> 1) + 1)
    )


def A009454(n):
    return sum(
        stirling(n, (k << 1) + 1, kind=1, signed=True) * (-1 if k & 1 else 1)
        for k in range(n + 1 >> 1)
    )


def A003703(n):
    return sum(
        stirling(n, k << 1, kind=1, signed=True) * (-1 if k & 1 else 1)
        for k in range((n >> 1) + 1)
    )


def A231531(n):
    return sum(
        stirling(n + 1, k << 1, kind=1) * (1 if k & 1 else -1)
        for k in range((n + 1 >> 1) + 1)
    )


def A101686(n):
    return prod(i**2 + 1 for i in range(1, n + 1))


def A105750(n):
    return sum(
        stirling(n + 1, n + 1 - (k << 1), kind=1) * (-1 if k & 1 else 1)
        for k in range((n + 1 >> 1) + 1)
    )


def A370548(n):
    return (a := factorial(n)) // gcd(
        a,
        sum(
            stirling(n + 1, n + 1 - (k << 1), kind=1) * (-1 if k & 1 else 1)
            for k in range((n + 1 >> 1) + 1)
        ),
    )


def A105751(n):
    return sum(
        stirling(n + 1, n - (k << 1), kind=1) * (-1 if k & 1 else 1)
        for k in range((n >> 1) + 1)
    )


def A370550(n):
    return (a := factorial(n)) // gcd(
        a,
        sum(
            stirling(n + 1, n - (k << 1), kind=1) * (-1 if k & 1 else 1)
            for k in range((n >> 1) + 1)
        ),
    )


def A370547(n):
    return (
        a := sum(
            stirling(n + 1, n + 1 - (k << 1), kind=1) * (-1 if k & 1 else 1)
            for k in range((n + 1 >> 1) + 1)
        )
    ) // gcd(a, factorial(n))


def A370549(n):
    return (
        a := sum(
            stirling(n + 1, n - (k << 1), kind=1) * (-1 if k & 1 else 1)
            for k in range((n >> 1) + 1)
        )
    ) // gcd(a, factorial(n))


def A370551(n):
    return (
        a := sum(
            stirling(n + 1, (k << 1) + 1, kind=1) * (-1 if k & 1 else 1)
            for k in range((n >> 1) + 1)
        )
    ) // gcd(a, factorial(n))


def A370552(n):
    return (a := factorial(n)) // gcd(
        a,
        sum(
            stirling(n + 1, (k << 1) + 1, kind=1) * (-1 if k & 1 else 1)
            for k in range((n >> 1) + 1)
        ),
    )


def A370553(n):
    return (
        a := sum(
            stirling(n + 1, k << 1, kind=1) * (1 if k & 1 else -1)
            for k in range((n + 1 >> 1) + 1)
        )
    ) // gcd(a, factorial(n))


def A370554(n):
    return (a := factorial(n)) // gcd(
        a,
        sum(
            stirling(n + 1, k << 1, kind=1) * (1 if k & 1 else -1)
            for k in range((n + 1 >> 1) + 1)
        ),
    )


def A116210_gen():  # generator of terms
    for j in count(0):
        b = 10**j
        a = b * 10 + 1
        for k in sorted(sqrt_mod(23, a, all_roots=True)):
            if a * (b - 7) <= k**2 - 23 < a * (a - 8) and k > 4:
                yield (k**2 - 23) // a


def A079840(n):
    smax, m = 0, 0
    for s, p in sorted(partitions(n, size=True), key=itemgetter(0), reverse=True):
        if s < smax:
            break
        if n % 10 or "0" in "".join(str(d % 10) for d in p):
            for a in multiset_permutations(Counter(p).elements()):
                if not (k := int("".join(str(d) for d in a))) % n:
                    m = max(k, m)
            if m > 0:
                smax = s
    return m


def A370606_gen():  # generator of terms
    a = 1
    while True:
        for q in count(a, a):
            if isprime(q + 1):
                yield q + 1
                a = (q & -q) << 1
                break


def A370607_gen():  # generator of terms
    a = 1
    while True:
        for q in count(a, a):
            if isprime(q + 1):
                yield (b := q & -q).bit_length() - 1
                a = b << 1
                break


def A370370(n):
    c, a = 1, [n**i for i in range(n)]
    for i in range(n):
        for j in range(i + 1, n + 1):
            for p in permutations(range(i, j)):
                if p[-1] != 0:
                    m = sum(p[k] * a[k] for k in range(len(p)))
                    if is_square(m):
                        c += 1
    return c


def A370671(n):
    return (n - 2) * (n ** (n - 1) - 1) // (n - 1) ** 2 if n > 1 else 0


def A369490(n):
    return 3 ** (n + 1) + (1 << n + 2 if n & 1 else -(1 << n + 2))


def A369404(n):
    return (3 << n) + (-5 if n & 1 else 5)


def A258025_gen(startvalue=1):  # generator of terms >= startvalue
    c = max(startvalue, 1)
    p = prime(c)
    q = nextprime(p)
    r = nextprime(q)
    for k in count(c):
        if p + r > (q << 1):
            yield k
        p, q, r = q, r, nextprime(r)


def A064113_gen(startvalue=1):  # generator of terms >= startvalue
    c = max(startvalue, 1)
    p = prime(c)
    q = nextprime(p)
    r = nextprime(q)
    for k in count(c):
        if p + r == (q << 1):
            yield k
        p, q, r = q, r, nextprime(r)


def A258026_gen(startvalue=1):  # generator of terms >= startvalue
    c = max(startvalue, 1)
    p = prime(c)
    q = nextprime(p)
    r = nextprime(q)
    for k in count(c):
        if p + r < (q << 1):
            yield k
        p, q, r = q, r, nextprime(r)


def A369797(n):
    return (a := 3 * n - 2) // gcd(
        a, a * sum(factorial(k) for k in range(n - 2)) + n * factorial(n - 2) >> 1
    )


def A356360(n):
    return (a := (n << 1) - 1) // gcd(
        a, a * sum(factorial(k) for k in range(n - 2)) + n * factorial(n - 2) >> 1
    )


def A128059(n):
    return a if isprime(a := (n << 1) - 1) else 1


def A145737(n):
    return a if isprime(a := (n << 1) + 1) and n > 1 else 1


def A260191_gen(startvalue=3):  # generator of terms >= startvalue
    c = max(startvalue, 3)
    if c <= 3:
        yield 3
    for n in count(c + (c & 1 ^ 1), 2):
        if (~(m := n - 1 >> 1) & m - 1).bit_length() & 1:
            yield n


def A370676(n):
    a = 10 ** (n - 1)
    b = a * 10
    count = 0
    for i in range(0, a, 9):
        for j, k in ((0, 0), (2, 2), (3, 6), (5, 8), (6, 3), (8, 5)):
            k1 = i + j
            if k1 > 0:
                l = len(s1 := str(k1))
                if l >= n:
                    break
                m = n - l
                c = 10 ** (m - 1)
                d = c * 10
                lb = max(c, a // k1)
                lb = max(lb, k1 - k)
                if u := lb % 9:
                    lb -= u
                ub = min(d, (b - 1) // k1)
                for t in range(lb, ub + 1, 9):
                    k2 = t + k
                    if k2 >= k1 and sorted(s1 + str(k2)) == sorted(str(k1 * k2)):
                        count += 1
    return count


def A370675(n):
    a = 10 ** (n - 1)
    b = a * 10
    a2 = a * b
    b2 = b**2
    count = 0
    if a9 := a % 9:
        a -= a9
    a3 = max(1, a)
    for i in range(a, b, 9):
        for j, k in ((0, 0), (2, 2), (3, 6), (5, 8), (6, 3), (8, 5)):
            k1 = i + j
            s1 = str(k1)
            if k1 >= a3:
                lb = max(k1, a2 // k1)
                if u := lb % 9:
                    lb -= u
                ub = min(b - 1, b2 // k1)
                for t in range(lb, ub + 1, 9):
                    k2 = t + k
                    if k2 >= k1 and sorted(s1 + str(k2)) == sorted(str(k1 * k2)):
                        count += 1
    return count


def A114258_gen():  # generator of terms
    for l in count(1):
        a = isqrt(10 ** ((l << 1) - 1))
        if a9 := a % 9:
            a -= a9
        for b in range(a, 10**l, 9):
            for c in (0, 2):
                k = b + c
                if sorted(str(k) * 2) == sorted(str(k**2)):
                    yield k


def A114261_gen():  # generator of terms
    for l in count(1):
        a = integer_nthroot(10 ** (5 * l - 1), 5)[0]
        if a9 := a % 9:
            a += 9 - a9
        for b in range(a, 10**l, 9):
            if sorted(str(b) * 5) == sorted(str(b**5)):
                yield b


def A114260_gen():  # generator of terms
    for l in count(1):
        a = integer_nthroot(10 ** (4 * l - 1), 4)[0]
        if a9 := a % 9:
            a += 9 - a9
        for b in range(a, 10**l, 9):
            if sorted(str(b) * 4) == sorted(str(b**4)):
                yield b


def A370680(n):
    a = 10 ** (n - 1)
    b, c = 10 * a, 0
    for x in range(a, b):
        s = set(str(x))
        for y in range(x, b):
            if len(s | set(str(y))) < len(set(str(x * y))):
                c += 1
    return c


def A370678(n):
    a = 10 ** (n - 1)
    b, c = 10 * a, 0
    for x in range(a, b):
        s = set(str(x))
        for y in range(x, b):
            if len(s | set(str(y))) > len(set(str(x * y))):
                c += 1
    return c


def A370679(n):
    a = 10 ** (n - 1)
    b, c = 10 * a, 0
    for x in range(a, b):
        s = set(str(x))
        for y in range(x, b):
            if len(s | set(str(y))) == len(set(str(x * y))):
                c += 1
    return c


def A369818(n):
    alist = [0, 1, n + 1, n * (n + 1) + 1, (n + 3 >> 1) * n**2 + (3 * n + 2 >> 1)]
    aset = set(sum(d) for d in combinations_with_replacement(alist, n))
    blist = []
    for i in range(n):
        blist.append(set(sum(d) for d in combinations_with_replacement(alist, i)))
    for k in count(max(alist[-1] + 1, (n**3 >> 1) * (1 + (n >> 2)))):
        for i in range(n):
            if any((n - i) * k + d in aset for d in blist[i]):
                break
        else:
            return k


def A369817(n):
    return (n + 3 >> 1) * n**2 + (3 * n + 2 >> 1)


def A369819(n):
    alist = [
        0,
        1,
        n + 1,
        n * (n + 1) + 1,
        (n + 3 >> 1) * n**2 + (3 * n + 2 >> 1),
        A369818(n),
    ]
    aset = set(sum(d) for d in combinations_with_replacement(alist, n))
    blist = []
    for i in range(n):
        blist.append(set(sum(d) for d in combinations_with_replacement(alist, i)))
    for k in count(alist[-1] + 1):
        for i in range(n):
            if any((n - i) * k + d in aset for d in blist[i]):
                break
        else:
            return k


def A370754(n):
    return 2 + (n + 3 >> 1) * n**2 + (3 * n >> 1)


def A370684_gen(startvalue=1):  # generator of terms >= startvalue
    return filter(
        lambda k: all(comb(k, j) % (j * k) for j in range(2, k)),
        count(max(startvalue, 1)),
    )


def A370662(n):
    a, b = divmod(n, 3)
    return 3 * int(bin(a)[2:], 3) + b - 1


def A370455(n):
    return (
        ~(m := prime(n + 1) * prime(n + 2) - prime(n) * prime(n + 3)) & m - 1
    ).bit_length()


def A052410(n):
    return integer_nthroot(n, gcd(*factorint(n).values()))[0] if n > 1 else 1


def A370688_gen():  # generator of terms
    kmax, mlist, dlist = 10, [7, 7, 4], [6, 6, 3]
    yield from (0, 1, 2, 3, 5, 6, 7)
    while True:
        klist = []
        for i, p in enumerate((2, 5, 7)):
            while (k := p ** mlist[i]) <= kmax:
                klist.append(k)
                mlist[i] += dlist[i]
        yield from sorted(klist)
        kmax *= 10


def A370757(n):
    m2, m5 = (~n & n - 1).bit_length(), multiplicity(5, n)
    r = max(m2, m5)
    w, m = (
        10**r,
        10 ** (t := n_order(10, n2) if (n2 := (n >> m2) // 5**m5) > 1 else 1) - 1,
    )
    c = w // n
    s = str(m * w // n - c * m).zfill(t)
    l = len(s)
    for k in count(1):
        m2, m5 = (~k & k - 1).bit_length(), multiplicity(5, k)
        r = max(m2, m5)
        w, m = (
            10**r,
            10 ** (t := n_order(10, k2) if (k2 := (k >> m2) // 5**m5) > 1 else 1) - 1,
        )
        c = w // k
        if any(s[i:] + s[:i] == str(m * w // k - c * m).zfill(t) for i in range(l)):
            return k


def A368382_gen():  # generator of terms
    a, aset, p = 1, {0, 1}, 2
    while True:
        yield a
        for b in count(a % p, p):
            if b not in aset:
                aset.add(b)
                a, p = b, 3 if p == 2 else p + 2
                break


def A368383(n):
    a, aset, p = 1, {0, 1}, 2
    for c in count(1):
        if a == n:
            return c
        for b in count(a % p, p):
            if b not in aset:
                aset.add(b)
                a, p = b, 3 if p == 2 else p + 2
                break


def A006509_gen():  # generator of terms
    a, aset, p = 1, {1}, 2
    while True:
        yield a
        if (b := a - p) > 0 and b not in aset:
            a = b
        elif (b := a + p) not in aset:
            a = b
        else:
            a = 0
        aset.add(a)
        p = nextprime(p)


def A112877_gen():  # generator of terms
    a, aset, p = 1, {1}, 2
    for c in count(2):
        if (b := a - p) > 0 and b not in aset:
            a = b
        elif (b := a + p) not in aset:
            a = b
        else:
            a = 0
            yield c
        aset.add(a)
        p = nextprime(p)


def A117129_gen():  # generator of terms
    a, aset, p = 1, {1}, 2
    for c in count(2):
        if (b := a - p) > 0 and b not in aset:
            a = b
        elif (b := a + p) not in aset:
            a = b
        else:
            a = 0
            yield p
        aset.add(a)
        p = nextprime(p)


def A368956(n):
    return 3**n - (1 << n + 1) - 1


def A206369(n):
    return prod(
        (lambda x: x[0] + int((x[1] << 1) >= p + 1))(divmod(p ** (e + 1), p + 1))
        for p, e in factorint(n).items()
    )


def A370906(n):
    return sum(
        (1 if k & 1 else -1)
        * prod(
            (lambda x: x[0] + int((x[1] << 1) >= p + 1))(divmod(p ** (e + 1), p + 1))
            for p, e in factorint(k).items()
        )
        for k in range(1, n + 1)
    )


def A370905(n):
    return sum(
        prod(
            (lambda x: x[0] + int((x[1] << 1) >= p + 1))(divmod(p ** (e + 1), p + 1))
            for p, e in factorint(k).items()
        )
        for k in range(1, n + 1)
    )


def A242491_gen():  # generator of terms
    return (
        int("".join(str(d) if d < 4 else str(d + 1) for d in sympydigits(n, 8)[1:]))
        for n in count(1)
    )


def A039145_gen(startvalue=0):  # generator of terms >= startvalue
    return filter(
        lambda k: (s := str(k)).count("4") == s.count("9"), count(max(startvalue, 0))
    )


def A001651(n):
    return (n << 1) - (n >> 1) - 1


def A369304(n):
    return ((n + 1 << 1) - (n >> 1)) ** 2 // 3 - 2


def A022998(n):
    return n if n & 1 else n << 1


def A190577(n):
    return n * (n * (n * (n + 12) + 44) + 48)


def A370950(n):
    """requires 2 <= n <= 62"""
    if n & 1 and (~(m := n - 1 >> 1) & m - 1).bit_length() & 1:
        return 0
    t = "".join(gmpy2digits(d, n) for d in range(1, n))
    k = mpz("".join(gmpy2digits(d, n) for d in range(n - 1, 0, -1)), n)
    k2 = mpz(t, n)
    c = 0
    start = isqrt(k2)
    end = isqrt(k)
    d = (n * (n - 1) >> 1) % (n - 1)
    for r in sqrt_mod_iter(d, n - 1):
        e = start % (n - 1)
        start2 = start
        if e != r:
            start2 += (r - e) % (n - 1)
        for i in range(start2, end + 1, n - 1):
            if i % n:
                j = i**2
                s = "".join(sorted(gmpy2digits(j, n)))
                if s == t:
                    c += 1
    return c


def A092118_gen():  # generator of terms
    for j in count(0):
        b = 10**j
        a = b * 10 + 1
        ab, aa = a * b, a * a
        for k in sorted(sqrt_mod(0, a, all_roots=True)):
            if ab <= (m := k**2) < aa:
                yield m


def A370951_gen():  # generator of terms
    a, aset, p, q = 1, {1}, 2, 0
    for c in count(2):
        if (b := a - p) > 0 and b not in aset:
            a = b
        elif (b := a + p) not in aset:
            a = b
        else:
            a = 0
            if q:
                yield c - q
            q = c
        aset.add(a)
        p = nextprime(p)


def A370823(n):
    return (a := 3**n - 1 << n - 1) // gcd(a, 3**n - (1 << n))


def A370824(n):
    return (a := 3**n - (1 << n)) // gcd(a, 3**n - 1 << n - 1)


def A105951(n):
    return (
        (1 << n + 1) + 1 + (1 << m + 2 if (m := n >> 1) & 1 else -(1 << m + 2))
        if n & 1
        else -(1 << n + 1) - 1
    )


def A103145(n):
    return (n * (n * (n + 21) + 74) + 18) // 6


def A370932(n):
    t = accumulate(
        ((-j if i & 1 else j) for i, j in enumerate(sympydigits(n, 3)[1:])),
        func=lambda x, y: (x + y) % 3,
    )
    return int("".join(str(-d % 3 if i & 1 else d) for i, d in enumerate(t)), 3)


def A370849(n):
    return min(
        (max(primefactors(a := int("".join(s)))), a)
        for i in range(1, 10)
        for j in range(i + 1, 10)
        for s in product(str(i) + str(j), repeat=n)
    )[1]


def A370361(n):
    return min(
        (max(primefactors(a := int("".join(s)))), a)
        for i in range(10)
        for j in range(i + 1, 10)
        for k in range(1, n)
        for s in multiset_permutations(str(i) * k + str(j) * (n - k))
        if s[0] != "0" and s[-1] != "0"
    )[0]


def A370825(n):
    return (a := 3 ** (n + 1) - 3 >> 1) // gcd(a, (1 << n + 1) - 2)


def A370826(n):
    return (a := (1 << n + 1) - 2) // gcd(a, 3 ** (n + 1) - 3 >> 1)


def A005730(n):
    return 1 if isprime(n) else prod(primefactors(n)) << (not n % 6)


def A005729(n):
    c, p = 1, 2
    while p < n:
        if n % p:
            for m in count(2):
                if (p**m - 1) // (p - 1) > n:
                    break
                for r in count(1):
                    q = (p ** (m * r) - 1) // (p**r - 1)
                    if q > n:
                        break
                    if not n % q:
                        c *= p
                        break
                else:
                    continue
                if q <= n:
                    break
        else:
            c *= p if p & 1 or n % 6 else p**2
        p = nextprime(p)
    return c


def A005731(n):
    c, p = 1, 2
    while p < n:
        if n % p:
            for m in count(2):
                if (p**m - 1) // (p - 1) > n:
                    break
                for r in count(1):
                    q = (p ** (m * r) - 1) // (p**r - 1)
                    if q > n:
                        break
                    if not n % q:
                        c *= p
                        break
                else:
                    continue
                if q <= n:
                    break
        p = nextprime(p)
    return c


def A370252(n):
    c, p = n, 2
    while p < n:
        if n % p:
            for m in count(2):
                if (p**m - 1) // (p - 1) > n:
                    break
                for r in count(1):
                    q = (p ** (m * r) - 1) // (p**r - 1)
                    if q > n:
                        break
                    if not n % q:
                        c *= p
                        break
                else:
                    continue
                if q <= n:
                    break
        else:
            c *= p if p & 1 or n % 6 else p**2
        p = nextprime(p)
    return c


def A370349(n):
    return ((n << 2) + 10) * (n + 1) ** 2 // 9


def A141530(n):
    return (m := (n << 1) - 1) * (n * (m - 1) - 1)


def A370532(n):
    return 10 * (n - 2) if n > 2 else 4 * n - 3


def A318780(n):
    return next(
        k
        for k in count(
            integer_nthroot(
                (n**n - n) // (n - 1) ** 2 + n ** (n - 2) * (n - 1) - 1, n
            )[0]
        )
        if len(set(sympydigits(k**n, n)[1:])) == n
    )


def A185122(n):
    m = n
    j = 0
    if n > 3:
        for j in range(1, n):
            if gcd((n * (n - 1) >> 1) + j, n - 1) == 1:
                break
    if j == 0:
        for i in range(2, n):
            m = n * m + i
    elif j == 1:
        for i in range(1, n):
            m = n * m + i
    else:
        for i in range(2, 1 + j):
            m = n * m + i
        for i in range(j, n):
            m = n * m + i
    m -= 1
    while True:
        if len(set(sympydigits(m := nextprime(m), n)[1:])) == n:
            return m


def A370828(n):
    return (a := 5**n - 3**n << n - 1) // gcd(a, 3 ** (n - 1) * (5**n - (1 << n)))


def A370827(n):
    return (a := 3 ** (n - 1) * (5**n - (1 << n))) // gcd(a, 5**n - 3**n << n - 1)


def A066328(n):
    return sum(map(primepi, primefactors(n)))


def A049363(n):
    return (n**n - n) // (n - 1) ** 2 + n ** (n - 2) * (n - 1) - 1 if n > 1 else 1


def A318779(n):
    return next(
        k
        for k in (
            k**n
            for k in count(
                integer_nthroot(
                    (n**n - n) // (n - 1) ** 2 + n ** (n - 2) * (n - 1) - 1, n
                )[0]
            )
        )
        if len(set(sympydigits(k, n)[1:])) == n
    )


def A370259(n):
    return (chebyshevt(n, n + 1) - 1) // n**3


def A370261(n):
    return isqrt((chebyshevt((m := n << 1), m + 1) - 1) // ((n + 1) * m**3))


def A318725(n):
    c, flag = 1, False
    for k in count(1):
        m = k
        if flag:
            a, b = divmod(m, n)
            while not b:
                m = a
                a, b = divmod(m, n)
        c *= m
        if len(set(sympydigits(c, n)[1:])) == n:
            return k
        if not (flag or c % n):
            flag = True


def A245340(n):
    a, aset = 0, set()
    for m in count(1):
        if a == n:
            return m - 1
        aset.add(a)
        a = next(a for a in count(a % m, m) if a not in aset)


def A371566_gen():  # generator of terms
    from sympy.abc import x

    p = 2
    while True:
        if Poly(
            x * (x * (x * (x * (x - 1) - 1) - 1) - 1) - 1, x, modulus=p
        ).is_irreducible:
            yield p
        p = nextprime(p)


def A370830_gen():  # generator of terms
    from sympy.abc import x

    p = 2
    while True:
        if Poly(x * (x * (x * (x - 1) - 1) - 1) - 1, x, modulus=p).is_irreducible:
            yield p
        p = nextprime(p)


def A106284_gen():  # generator of terms
    from sympy.abc import x

    p = 2
    while True:
        if (
            len(
                Poly(
                    x * (x * (x * (x * (x - 1) - 1) - 1) - 1) - 1, x, modulus=p
                ).ground_roots()
            )
            == 0
        ):
            yield p
        p = nextprime(p)


def A106283_gen():  # generator of terms
    from sympy.abc import x

    p = 2
    while True:
        if (
            len(Poly(x * (x * (x * (x - 1) - 1) - 1) - 1, x, modulus=p).ground_roots())
            == 0
        ):
            yield p
        p = nextprime(p)


def A106278(n):
    from sympy.abc import x

    return len(
        Poly(
            x * (x * (x * (x * (x - 1) - 1) - 1) - 1) - 1, x, modulus=prime(n)
        ).ground_roots()
    )


def A106281_gen():  # generator of terms
    from sympy.abc import x

    p = 2
    while True:
        if (
            len(
                Poly(
                    x * (x * (x * (x * (x - 1) - 1) - 1) - 1) - 1, x, modulus=p
                ).ground_roots()
            )
            == 5
        ):
            yield p
        p = nextprime(p)


def A370956_gen():  # generator of terms
    a, aset, b, c = 0, set(), 0, -1
    for n in count(1):
        aset.add(a)
        if a == b:
            if n - 1 > c:
                c = n - 1
                yield c
            while b in aset:
                b += 1
        a = next(a for a in count(a % n, n) if a not in aset)


def A370959_gen():  # generator of terms
    a, aset, b, c = 0, set(), 0, -1
    for n in count(1):
        aset.add(a)
        if a == b:
            if n - 1 > c:
                c = n - 1
                yield a
            while b in aset:
                b += 1
        a = next(a for a in count(a % n, n) if a not in aset)


def A371194(n):
    m, j = 1, 0
    if n > 3:
        for j in range(1, n):
            if gcd((n * (n - 1) >> 1) + j, n - 1) == 1:
                break
    if j == 0:
        for i in range(2, n):
            m = n * m + i
    elif j == 1:
        for i in range(1, n):
            m = n * m + i
    else:
        for i in range(2, 1 + j):
            m = n * m + i
        for i in range(j, n):
            m = n * m + i
    m -= 1
    while True:
        s = sympydigits(m := nextprime(m), n)[1:]
        if 0 not in s and len(set(s)) == n - 1:
            return m


def A371193(n):
    return (1 << n) - 1 << (n - 1 << 2) if n else 0


def A163839(n):
    return (1 << n) - 1 << (n << 2) - 2 if n else 0


def A060073(n):
    return (n ** (n - 1) - 1) // (n - 1) ** 2


def A371210(n):
    return (m := n + 1 >> 1) * factorial(m) if n & 1 else factorial(n >> 1)


def A048679_gen():  # generator of terms
    return map(
        lambda n: int(bin(n)[2:].replace("01", "1"), 2),
        filter(lambda n: not (n << 1) & n, count(0)),
    )


def A371163_gen():  # generator of terms
    c = 0
    for n in count(0):
        if not (n << 1) & n:
            if int(bin(n)[2:].replace("01", "1"), 2) == c:
                yield c
            c += 1


def A048678(n):
    return int(bin(n)[2:].replace("1", "01"), 2)


def A371033(n):
    c = 0
    for i in range(n):
        c <<= n - i
        if i & 1 ^ 1:
            c += (1 << n - i) - 1
    return c


def A371032(n):
    c = 0
    for i in range(n):
        c = (m := 10 ** (n - i)) * c
        if i & 1 ^ 1:
            c += (m - 1) // 9
    return c


def A371281(n):
    return reduce(lambda a, b: a * b % 10, map(int, str(n)), 1)


def A068792(n):
    return ((n ** (n - 1) - 1) // (n - 1)) ** 2


def A123668(n):
    return (
        n * ((n ** (n - 1) - 1) // (n - 1)) ** 2 + (n - 1) * (n ** (2 * n - 3) - 1)
        if n > 2
        else 4 * n - 3
    )


def A062813(n):
    return (m := n**n) - (m - n) // (n - 1) ** 2 if n > 1 else 0


def A068793(n):
    return ((m := n**n) * (m * (n - 2) + 2) - n**2 + n - 1) // (n - 1) ** 2


def A126646(n):
    return (1 << n + 1) - 1


def A007018_gen():  # generator of terms
    a = 1
    while True:
        yield a
        a *= a + 1


def A100016_gen():  # generator of terms
    yield (a := 1)
    while a := a * nextprime(a):
        yield a


@lru_cache(maxsize=None)
def A139145(n):
    return (m := A139145(n >> 1)) * (m + (n & 1)) if n > 1 else 1


def A074839_gen():  # generator of terms
    yield (a := 1)
    while a := a + nextprime(a):
        yield a


def A006279_gen():  # generator of terms
    a, b = 1, 1
    yield a
    while True:
        yield b
        a, b = b, a * (a * b + 1)


def A129868(n):
    return ((m := 1 << n) - 1) * ((m << 1) + 1)


def A280049_gen():  # generator of terms
    return map(
        lambda n: int(bin(n)[2:]), filter(lambda n: (n & -n).bit_length() & 1, count(1))
    )


def A371222(n):
    return reduce(lambda a, b: a * b % 3, sympydigits(n, 3)[1:], 1)


def A371054_gen():  # generator of terms
    return (
        3 ** (l - a) * (3**a - 1 >> 1) + 3**b - 1
        for l in count(3)
        for a in range(1, l - 1)
        for b in range(1, l - a)
    )


def A371056_gen():  # generator of terms
    return (
        3 ** (l - a) * (3**a - 1) + (3**b - 1 >> 1)
        for l in count(3)
        for a in range(1, l - 1)
        for b in range(1, l - a)
    )


def A371050_gen():  # generator of terms
    return (
        (3**b * (3 ** (l - a) - 1 >> 1) + 3**b - 1) * 3 ** (a - b)
        for l in count(3)
        for a in range(2, l)
        for b in range(1, a)
    )


def A371051_gen():  # generator of terms
    return (
        (10**b * (10 ** (l - a) - 1) + (10**b - 1 << 1)) // 9 * 10 ** (a - b)
        for l in count(3)
        for a in range(2, l)
        for b in range(1, a)
    )


def A371372(n):
    return (
        sum(
            comb((d << 1) - 1, d) * totient((n << 1) // d)
            for d in divisors(n << 1, generator=True)
        )
        // n
        >> 2
        if n
        else 0
    )


def A371382(n):
    return n**2 + (q := n + isqrt(5 * n**2) >> 1) * (q + 1)


def A371388(n):
    return n * ((n + isqrt(5 * n**2) & -2) - n)


def A371381(n):
    return (n << 1) * (n - 1) + 1 + (q := n + isqrt(5 * n**2) >> 1) * (q - (n - 1 << 1))


def A370998(n):
    ptuple = tuple(prime(k) for k in range(1, n + 1))
    return (
        next(filter(lambda m: not any(isprime(p + m) for p in ptuple), count(2, 2)))
        >> 1
    )


def A371052_gen():  # generator of terms
    return (
        (3**b * (3**a - 1) + (3**b - 1 >> 1)) * 3 ** (l - a - b)
        for l in count(3)
        for a in range(1, l - 1)
        for b in range(1, l - a)
    )


def A371053_gen():  # generator of terms
    return (
        (10**b * (10**a - 1 << 1) + 10**b - 1) // 9 * 10 ** (l - a - b)
        for l in count(3)
        for a in range(1, l - 1)
        for b in range(1, l - a)
    )


def A371399(n):
    return sum(
        comb(k + n, k) * comb((n << 1) - k, n) * (-1 if k & 1 else 1) << n - k
        for k in range(n + 1)
    )


def A371384(n):
    return (l := len(s := str(n))) // gcd(l, sum(map(int, s)))


def A371383(n):
    return (l := sum(map(int, (s := str(n))))) // gcd(l, len(s))


def A371070(n):
    CM = (
        lambda x, y, z, t, u, v: (x * y * z << 2)
        + (a := x + y - t) * (b := x + z - u) * (c := y + z - v)
        - x * c**2
        - y * b**2
        - z * a**2
    )
    TR1 = lambda x, y, z: not (x + y < z or x + z < y or y + z < x)
    TR = (
        lambda x, y, z, t, u, v: TR1(t, u, v)
        and TR1(x, y, t)
        and TR1(x, z, u)
        and TR1(y, z, v)
    )
    c, d, sq = 0, set(), tuple(x**2 for x in range(n + 1))
    for s, w in partitions(n, m=6, k=n - 5, size=True):
        if s == 6:
            for v in multiset_permutations(Counter(w).elements()):
                if (
                    TR(*v)
                    and (
                        M := CM(
                            sq[v[0]], sq[v[1]], sq[v[2]], sq[v[3]], sq[v[4]], sq[v[5]]
                        )
                    )
                    > 0
                    and M not in d
                ):
                    d.add(M)
                    c += 1
    return c


def A181790_gen():  # generator of terms
    for j in count(9):
        b = 10**j
        a = b * 10 + 1
        for k in sorted(sqrt_mod(0, a, all_roots=True)):
            if a * b <= k**2 < a * (a - 1) and len(set(str(m := k**2 // a))) == 10:
                yield m


def A181789_gen():  # generator of terms
    for j in count(9):
        b = 10**j
        a = b * 10 + 1
        for k in sorted(sqrt_mod(0, a, all_roots=True)):
            if a * b <= (m := k**2) < a * (a - 1) and len(set(str(m // a))) == 10:
                yield m


def A370980(n):
    return n * (n - 1 >> 1) + 1


def A186995(n):
    p = 2
    while True:
        s = sympydigits(p, n)[1:]
        for i, j in enumerate(s[::-1]):
            m = n**i
            for k in range(n):
                if k != j and isprime(p + (k - j) * m):
                    break
            else:
                continue
            break
        else:
            return p
        p = nextprime(p)


def A371475(n):
    if n == 1:
        return 2
    p, r = 5, (n << 1) + 1
    while True:
        s = sympydigits(p, r)[1:]
        for i, j in enumerate(s[::-1]):
            m = r**i
            for k in range(j & 1, r, 2):
                if k != j and isprime(p + (k - j) * m):
                    break
            else:
                continue
            break
        else:
            return p
        p = nextprime(p)


def A369793(n):
    return sum(
        1
        for m in range(1, (n**2 >> 2) + 1)
        if (d := divisors(m))[((l := len(d)) - 1) >> 1] + d[l >> 1] == n
    )


def A323745(n):
    p = 2
    while True:
        m = 1
        for j in sympydigits(p, n)[:0:-1]:
            for k in range(1, n):
                if k != j and isprime(p + (k - j) * m):
                    break
            else:
                m *= n
                continue
            break
        else:
            return p
        p = nextprime(p)


def A371509(n):
    if n == 1:
        return 2
    p, r = 5, (n << 1) + 1
    while True:
        m = 1
        for j in sympydigits(p, r)[:0:-1]:
            for k in range(2 - (j & 1), r, 2):
                if k != j and isprime(p + (k - j) * m):
                    break
            else:
                m *= r
                continue
            break
        else:
            return p
        p = nextprime(p)


def A371474_gen():  # generator of terms
    return filter(lambda k: not comb(k**2, k) % (k**3), count(1))


def A006003(n):
    return n * (n**2 + 1) >> 1


def A002623(n):
    return ((n + 2) * (n + 4) * ((n << 1) + 3) >> 3) // 3


def A004613_gen(startvalue=1):  # generator of terms >= startvalue
    return filter(
        lambda n: all(p & 3 == 1 for p in primefactors(n)), count(max(startvalue, 1))
    )


def A371055_gen():  # generator of terms
    return (
        10 ** (l - a) * ((10**a - 1) // 9) + ((10**b - 1) // 9 << 1)
        for l in count(3)
        for a in range(1, l - 1)
        for b in range(1, l - a)
    )


def A371057_gen():  # generator of terms
    return (
        10 ** (l - a) * ((10**a - 1) // 9 << 1) + ((10**b - 1) // 9)
        for l in count(3)
        for a in range(1, l - 1)
        for b in range(1, l - a)
    )


def A370848_gen():  # generator of terms
    for l in count(1):
        k = (10**l - 1) // 9
        for m in range(l):
            a = 10**m
            for j in (1, 2, 4, 6):
                p = k + a * j
                if isprime(p) and not isprime(sum(map(int, str(nextprime(p))))):
                    yield p


def A370851_gen():  # generator of terms
    for l in count(1):
        k = (10**l - 1) // 9
        for m in range(l):
            a = 10**m
            for j in (1, 2, 4, 6):
                p = k + a * j
                if isprime(p) and not (
                    isprime(s := prod(map(int, str(nextprime(p))))) or s == 1
                ):
                    yield p


def A264828_gen(startvalue=1):  # generator of terms >= startvalue
    return filter(
        lambda n: not (isprime(n) or (n & 1 ^ 1 and isprime(n >> 1))),
        count(max(startvalue, 1)),
    )


def A370759_gen(startvalue=4):  # generator of terms >= startvalue
    return filter(
        lambda n: not (isprime(n + 5) or (n & 1 and isprime((n >> 1) + 3))),
        count(max(startvalue, 4)),
    )


def A371402(n):
    return (
        (
            (~n & n - 1).bit_length() + 2 << (n << 1)
            if n & 1
            else ((m := (~n & n - 1).bit_length()) + 1 << (n << 1) + 1) - m
        )
        if n
        else 0
    )


def A371459(n):
    return int(bin(n)[3::2], 2) if n > 1 else 0


def A371347(n):
    return nextprime((m := prime(n)) ** m)


def A371346(n):
    return prevprime((m := prime(n)) ** m)


def A370071_gen():  # generator of terms
    a, b = 1, 2
    yield from (0, 1)
    while True:
        s = sorted(str(b))
        l = len(s)
        m = int("".join(s[::-1]))
        u = int("".join(s))
        for i in count(2):
            if i**2 > m:
                break
            startcount = max(2, integer_log(u, i)[0])
            k = i**startcount
            for j in count(startcount):
                if k > m:
                    break
                t = sorted(str(k))
                if ["0"] * (l - len(t)) + t == s:
                    yield b
                    break
                k *= i
            else:
                continue
            if k <= m:
                break
        a, b = b, a + b


def A370796(n):
    return (
        -primepi(((p := prime(n)) + 1) ** 2) + primepi((nextprime(p) - 1) ** 2)
        if n > 1
        else 2
    )


def A371462_gen(startvalue=0):  # generator of terms >= startvalue
    return filter(
        lambda n: sum(map(int, (s := str(n)))) ** 2 << 1
        == len(s) * sum(int(d) ** 2 for d in s),
        count(max(startvalue, 0)),
    )


def A371588(n):
    a, b = 1, 2
    while True:
        s = sorted(str(b))
        l = len(s)
        m = int("".join(s[::-1]))
        u = int("".join(s))
        for i in count(max(2, integer_nthroot(u, n)[0])):
            if (k := i**n) > m:
                break
            t = sorted(str(k))
            if ["0"] * (l - len(t)) + t == s:
                return b
                break
        a, b = b, a + b


def A371589(n):
    a, b = 1, 2
    while True:
        s = sorted(str(b))
        m = int("".join(s[::-1]))
        u = int("".join(s))
        for i in count(max(2, integer_nthroot(u, n)[0])):
            if (k := i**n) > m:
                break
            t = sorted(str(k))
            if t == s:
                return i
                break
        a, b = b, a + b


def A115419(n):
    return ((n - 1 << 1) & -7 | 8) + (n - 1 & 7)


def A115420(n):
    return ((n - 1 << 1) & -15 | 16) + (n - 1 & 15)


def A115421(n):
    return ((n - 1 << 1) & -31 | 32) + (n - 1 & 31)


def A007429(n):
    return prod(
        (p * (p ** (e + 1) - 1) - (p - 1) * (e + 1)) // (p - 1) ** 2
        for p, e in factorint(n).items()
    )


def A371003(n):
    return comb((n << 1) - 1, n) - n - ((m := (n - 1) ** 2) * (m + 3) >> 2)


def A106277(n):
    from sympy.abc import x

    return len(
        Poly(x * (x * (x * (x - 1) - 1) - 1) - 1, x, modulus=prime(n)).ground_roots()
    )


def A047461(n):
    return (n - 1 << 2) | (n & 1)


def A369801(n):
    return (n - 2 << 2) - (n & 1) if n >= 7 else (1, 3, 6, 10, 15)[n - 2]


def A047452(n):
    return (n << 2) - 2 - (n & 1)


def A047470(n):
    return (n - 1 << 2) - (n & 1 ^ 1)


def A075123(n):
    return (n - 2 << 2) - 2 - (n & 1) if n > 3 else n


def A047617(n):
    return (n - 1 << 2) + 1 + (n & 1)


def A047524(n):
    return (n << 2) - 1 - (n & 1)


def A047535(n):
    return (n << 2) - (n & 1 ^ 1)


def A047398(n):
    return ((n << 2) | (n & 1)) - 2


def A047615(n):
    return (n << 2) - 3 - (n & 1)


def A371463_gen(startvalue=0):  # generator of terms >= startvalue
    return filter(
        lambda n: 5 * sum(s := tuple(map(int, str(n)))) ** 2
        == len(s) * sum(d**2 for d in s) << 2,
        count(max(startvalue, 0)),
    )


def A371464_gen(startvalue=0):  # generator of terms >= startvalue
    return filter(
        lambda n: 10 * sum(s := tuple(map(int, str(n)))) ** 2
        == 9 * len(s) * sum(d**2 for d in s),
        count(max(startvalue, 0)),
    )


def A371532(n):
    return n * (n * (5 * n + 6 << 2) + 10) // 3 + 1


def A371515(n):
    return n * (n * (32 * n + 18) + 6) + 1


def A039269_gen(startvalue=0):  # generator of terms >= startvalue
    return filter(
        lambda n: (s := sympydigits(n, 12)[1:]).count(8) == s.count(9),
        count(max(startvalue, 0)),
    )


def A371651(n):
    p = 3
    while True:
        if n == primeomega(p - 2) == primeomega(p + 2):
            return p
        p = nextprime(p)


def A371573(n):
    return n if (p := min(factorint(n).items(), default=(1, 1)))[1] == 1 else n // p[0]


def A371670(n):
    p = n**4
    while p := prevprime(p):
        pset = set(q := tuple(pow(x, n, p) for x in range(p)))
        if not all(
            any(
                (k - a[0] - a[1]) % p in pset
                for a in combinations_with_replacement(q, 2)
            )
            for k in range(p)
        ):
            return p


def A368055(n):
    p = 1
    while p := nextprime(p):
        pset = set(q := tuple(pow(x, n, p) for x in range(p)))
        if not all(
            any(
                (k - a[0] - a[1]) % p in pset
                for a in combinations_with_replacement(q, 2)
            )
            for k in range(p)
        ):
            return p


def A309805(n):
    return n**2 - (m := n >> 1) * (m + 1)


def A133090(n):
    return (n << 1) - 1 if n & 1 else n - 1


def A371706(n):
    m = n
    for k in count(1):
        if "1" in str(m):
            return k
        m *= n


def A275533(n):
    return next(
        m for m in count(1) if not any("1" in str(m**k) for k in range(1, n + 1))
    )


def A178316_gen():  # generator of terms
    yield from (2, 5)
    r = "".maketrans("69", "96")
    for l in count(1):
        for a in "125689":
            for d in product("0125689", repeat=l):
                s = a + "".join(d)
                m = int(s)
                if isprime(m) and isprime(int(s[::-1].translate(r))):
                    yield m


def A366494(n):
    return sum(
        totient(d) // n_order(10, d)
        for d in divisors(10 * n - 1, generator=True)
        if d > 1
    )


def A006694(n):
    return sum(
        totient(d) // n_order(2, d)
        for d in divisors((n + 1 << 1) - 1, generator=True)
        if d > 1
    )


def A081844(n):
    return (
        sum(
            totient(d) // n_order(2, d)
            for d in divisors((n + 1 << 1) - 1, generator=True)
            if d > 1
        )
        + 1
    )


def A023142(n):
    m = n >> (~n & n - 1).bit_length()
    a, b = divmod(m, 5)
    while not b:
        m = a
        a, b = divmod(m, 5)
    return (
        sum(totient(d) // n_order(10, d) for d in divisors(m, generator=True) if d > 1)
        + 1
    )


def A128858(n):
    return n_order(10, 10 * n - 1)


def A128857(n):
    return n * (10 ** n_order(10, (m := 10 * n - 1)) - 1) // m


def A275028_gen():  # generator of terms
    r, t = "".maketrans("69", "96"), set("0125689")
    for l in count(1):
        if l % 10:
            m = l**2
            if set(s := str(m)) <= t and is_square(int(s[::-1].translate(r))):
                yield m


def A371845_gen():  # generator of terms
    for l in count(1):
        m = 10**l
        for a in range(1, 10):
            b = (a * 10**4 + 2345) * m
            yield from primerange(b, b + m)


def A371833_gen():  # generator of terms
    for l in count(1):
        m = 10**l
        for a in range(1, 10):
            b = (a * 10**3 + 234) * m
            yield from primerange(b, b + m)


def A018847_gen():  # generator of terms
    r, t, u = "".maketrans("69", "96"), set("0125689"), {0, 1, 2, 5, 8}
    for x in count(1):
        for y in range(10 ** (x - 1), 10**x):
            if y % 10 in u:
                s = str(y)
                if set(s) <= t and isprime(m := int(s + s[-2::-1].translate(r))):
                    yield m
        for y in range(10 ** (x - 1), 10**x):
            s = str(y)
            if set(s) <= t and isprime(m := int(s + s[::-1].translate(r))):
                yield m


def A371865_gen():  # generator of terms
    for l in count(1):
        m = 10**l
        for a in range(1, 10):
            b = (a * 10**8 + 23456789) * m
            yield from primerange(b, b + m)


def A000374(n):
    return (
        sum(
            totient(d) // n_order(2, d)
            for d in divisors(n >> (~n & n - 1).bit_length(), generator=True)
            if d > 1
        )
        + 1
    )


def A023138(n):
    m = n >> (~n & n - 1).bit_length()
    a, b = divmod(m, 3)
    while not b:
        m = a
        a, b = divmod(m, 3)
    return (
        sum(totient(d) // n_order(6, d) for d in divisors(m, generator=True) if d > 1)
        + 1
    )


def A023141(n):
    a, b = divmod(n, 3)
    while not b:
        n = a
        a, b = divmod(n, 3)
    return (
        sum(totient(d) // n_order(9, d) for d in divisors(n, generator=True) if d > 1)
        + 1
    )


def A023139(n):
    a, b = divmod(n, 7)
    while not b:
        n = a
        a, b = divmod(n, 7)
    return (
        sum(totient(d) // n_order(7, d) for d in divisors(n, generator=True) if d > 1)
        + 1
    )


def A023136(n):
    return (
        sum(
            totient(d) // n_order(4, d)
            for d in divisors(n >> (~n & n - 1).bit_length(), generator=True)
            if d > 1
        )
        + 1
    )


def A023137(n):
    a, b = divmod(n, 5)
    while not b:
        n = a
        a, b = divmod(n, 5)
    return (
        sum(totient(d) // n_order(5, d) for d in divisors(n, generator=True) if d > 1)
        + 1
    )


def A371511(n):
    m, j = n, 0
    if n > 3:
        for j in range(1, n - 1):
            if gcd((n * (n - 1) >> 1) + j, n - 1) == 1:
                break
    if j == 0:
        for i in range(2, n - 1):
            m = n * m + i
    elif j == 1:
        for i in range(1, n - 1):
            m = n * m + i
    else:
        for i in range(2, 1 + j):
            m = n * m + i
        for i in range(j, n - 1):
            m = n * m + i
    m -= 1
    while True:
        s = sympydigits(m := nextprime(m), n)[1:]
        if n - 1 not in s and len(set(s)) == n - 1:
            return m


def A371512(n):
    m, j = 1, 0
    if n > 3:
        for j in range(1, n - 1):
            if gcd((n * (n - 1) >> 1) + j, n - 1) == 1:
                break
    if j == 0:
        for i in range(2, n - 1):
            m = n * m + i
    elif j == 1:
        for i in range(1, n - 1):
            m = n * m + i
    else:
        for i in range(2, 1 + j):
            m = n * m + i
        for i in range(j, n - 1):
            m = n * m + i
    m -= 1
    while True:
        s = sympydigits(m := nextprime(m), n)[1:]
        if (not (0 in s or n - 1 in s)) and len(set(s)) == n - 2:
            return m


def A371653_gen():  # generator of terms
    for l in count(1):
        xlist = []
        for p in combinations_with_replacement("987654321", l):
            if isprime(int("".join(p))):
                xlist.extend(int("".join(d)) for d in multiset_permutations(p))
        yield from sorted(xlist)


def A371654_gen():  # generator of terms
    for l in count(1):
        xlist = []
        for p in combinations_with_replacement("0123456789", l):
            if isprime(int("".join(p))):
                xlist.extend(
                    int("".join(d))
                    for d in multiset_permutations(p)
                    if d[0] != "0" and d[-1] != "0"
                )
        yield from sorted(xlist)


def A371811_gen(startvalue=1):  # generator of terms >= startvalue
    for n in count(max(startvalue, 1)):
        f = factorint(n)
        if len(f) == 2 and max(f.values()) == 1:
            q, p = sorted(f.keys())
            try:
                discrete_log(p, q, 2)
            except:
                continue
            yield n


def A371821_gen(startvalue=1):  # generator of terms >= startvalue
    for n in count(max(startvalue, 1)):
        f = sorted(factorint(n, multiple=True))
        if len(f) > 1:
            c = 0
            for p in f:
                c = ((c << p.bit_length()) + p) % n
            if not c:
                yield n


def A371641(n):
    for m in count(4):
        f = factorint(m)
        if sum(f.values()) > 1:
            c = 0
            for p in sorted(f):
                a = pow(n, integer_log(p, n)[0] + 1, m)
                for _ in range(f[p]):
                    c = (c * a + p) % m
            if not c:
                return m


def A337486_gen():  # generator of terms
    c = 1
    for n in count(1):
        a, b = divmod(c, n)
        if not b:
            c = a
            yield n
        else:
            c *= n


def A370969_gen():  # generator of terms
    c, m = 1, 1
    for n in count(2):
        a, b = divmod(c, n)
        if not b:
            yield n - m
            c, m = a, n
        else:
            c *= n


@lru_cache(maxsize=None)
def A008336(n):
    if n == 1:
        return 1
    a, b = divmod(c := A008336(n - 1), n - 1)
    return c * (n - 1) if b else a


def A008336_gen():  # generator of terms
    m = 1
    for n in count(1):
        yield m
        a, b = divmod(m, n)
        m = m * n if b else a


def A371900_gen(startvalue=2):  # generator of terms >= startvalue
    for n in count(max(startvalue, 2)):
        if not isprime(n + 1):
            q = min(primefactors(n + 1))
            for m in range(4, q**2):
                f = factorint(m)
                if sum(f.values()) > 1:
                    c = 0
                    for p in sorted(f):
                        a = pow(n, integer_log(p, n)[0] + 1, m)
                        for _ in range(f[p]):
                            c = (c * a + p) % m
                    if not c:
                        yield n
                        break


def A033880(n):
    return divisor_sigma(n) - (n << 1)


def A033879(n):
    return (n << 1) - divisor_sigma(n)


def A152016(n):
    return n * (n * (n * (n - 1) - 1) - 1)


def A371696_gen(startvalue=4):  # generator of terms >= startvalue
    for n in count(max(startvalue, 4)):
        f = factorint(n)
        if sum(f.values()) > 1:
            c = 0
            for p in sorted(f, reverse=True):
                a = pow(10, len(s := str(p)), n)
                q = int(s[::-1])
                for _ in range(f[p]):
                    c = (c * a + q) % n
            if not c:
                yield n


def A371666_gen(startvalue=4):  # generator of terms >= startvalue
    for n in count(max(startvalue, 4)):
        f = factorint(n)
        if sum(f.values()) > 1:
            c = 0
            for p in sorted(f, reverse=True):
                a, q = p.bit_length(), int(bin(p)[:1:-1], 2)
                for _ in range(f[p]):
                    c = (c << a) + q
            if c == n:
                yield n


def A055773(n):
    return prod(primerange((n >> 1) + 1, n + 1))


def A371948_gen(startvalue=2):  # generator of terms >= startvalue
    for n in count(max(startvalue, 2)):
        if not isprime(n + 1):
            q = min(primefactors(n + 1))
            for m in range(4, q**2):
                f = factorint(m)
                if sum(f.values()) > 1:
                    c = 0
                    for p in sorted(f, reverse=True):
                        a = pow(n, integer_log(p, n)[0] + 1, m)
                        for _ in range(f[p]):
                            c = (c * a + p) % m
                    if not c:
                        yield n
                        break


def A116667(n):
    s = set(str(n))
    for i in range(9, -1, -1):
        if str(i) not in s:
            return i
    return 10


def A067898(n):
    s = set(str(n))
    for i in range(10):
        if str(i) not in s:
            return i
    return 10


def A371390_gen():  # generator of terms
    xlist, p = [2, 3, 5, 7, 1], 11
    for k in count(1):
        if len(set(xlist)) == 1:
            yield k
        p = nextprime(p)
        xlist = xlist[1:] + [p % 10]


def A322843_gen(startvalue=4):  # generator of terms >= startvalue
    for m in count(max(startvalue, 4)):
        f = factorint(m, multiple=True)
        if len(f) > 1:
            c = 0
            a = {p: pow(10, len(str(p)), m) for p in f}
            for g in multiset_permutations(f):
                c = 0
                for p in g:
                    c = (c * a[p] + p) % m
                if not c:
                    yield m
                    break


@lru_cache(maxsize=None)
def A358552(n):
    if n == 1:
        return 1
    if isprime(n):
        return 1 + A358552(primepi(n))
    return max(A358552(p) for p in primefactors(n))


def A371908_gen():  # generator of terms
    m = 1
    for n in count(1, 2):
        a, b = divmod(m, n)
        m = m * n if b else a
        yield (~m & m - 1).bit_length()
        a, b = divmod(m, n + 1)
        m = m * (n + 1) if b else a


def A371965(n):
    return sum(comb((n - i << 1) - 3, n - i - 3) for i in range(n - 2))


def A371964(n):
    return sum(comb((n - i << 1) - 4, n - i - 4) for i in range(n - 3))


def A371963(n):
    return sum(comb((n - i << 1) - 3, n - i - 4) for i in range(n - 3))


def A086330(n):
    a, c = 0, 1
    for m in range(2, n):
        c = c * m % n
        if c == 0:
            break
        a += c
    return a


def A371035(n):
    a, c, p = 0, 1, prime(n)
    for m in range(2, p):
        c = c * m % p
        a += c
    return a


def A226570(n):
    a, c = 0, 1
    for m in range(2, n):
        c = c * m % n
        if c == 0:
            break
        a = (a + c) % n
    return a


def A100083_gen(startvalue=1):  # generator of terms >= startvalue
    for n in count(max(startvalue, 1)):
        a, c = 0, 1
        for m in range(2, n):
            c = c * m % n
            if c == 0:
                break
            a = (a + c) % n
        if not a:
            yield n


def A372010(n):
    return 10 ** (a := n >> 1) * (10 ** (a - (n & 1 ^ 1)) + 1) - 1


def A014682(n):
    return (3 * n + 1 if n & 1 else n) >> 1


def A370952_gen():  # generator of terms
    a, aset = 1, {0, 1}
    for p in count(3, 2):
        yield a
        for b in count(a % p, p):
            if b not in aset:
                aset.add(b)
                a = b
                break


def A370975_gen():  # generator of terms
    a, aset = 1, {0, 1}
    for p in count(3, 2):
        for b in count(a % p, p):
            if b not in aset:
                aset.add(b)
                yield (b - a) // p
                a = b
                break


def A372052(n):
    a, aset = 1, {0, 1}
    for p in count(3, 2):
        if a == n:
            return p >> 1
        for b in count(a % p, p):
            if b not in aset:
                aset.add(b)
                a = b
                break


def A371561_gen():  # generator of terms
    for l in count(1):
        for a in range(l, -1, -1):
            a3 = 3**a
            for b in range(l - a, -1, -1):
                b3 = a3 * 5**b
                for c in range(l - a - b, -1, -1):
                    d = l - a - b - c
                    d3 = b3 * 7**c * 9**d
                    while d3 > 9:
                        d3 = prod(int(x) for x in str(d3))
                    if d3 == 5:
                        yield (10 ** (a + b + c + d) - 1) // 3 + (
                            10**d * (10**c * (10**b + 1) + 1) - 3 << 1
                        ) // 9


def A028356(n):
    return (1, 2, 3, 4, 3, 2)[n % 6]


def A212801_T(m, n):
    return simplify(
        prod(
            2 - exp(2 * I * h * pi / m) - exp(2 * I * k * pi / n)
            for k in range(1, n)
            for h in range(1, m)
        )
    )


def A371093(n):
    return ((m := 3 * n) & ~(m + 1)).bit_length()


def A371560(n):
    return factorial(n) ** 4 * (n + 1) ** 3


def A224900(n):
    return factorial(n) ** 3 * (n + 1) ** 2


def A172492(n):
    return factorial(n) ** 3 * (n + 1)


def A090443(n):
    return factorial(n) ** 3 * (n + 2) * (n + 1) ** 2 >> 1


def A090444(n):
    return factorial(n) ** 4 * (n + 3) * (n + 2) ** 2 * (n + 1) ** 3 // 12


def A010790(n):
    return factorial(n) ** 2 * (n + 1)


def A126120(n):
    return 0 if n & 1 else comb(n, m := n >> 1) // (m + 1)


def A371623_gen(startvalue=1):  # generator of terms >= startvalue
    p = max(startvalue - 1, 0)
    while p := nextprime(p):
        if isprime(q := p << 1 | 1) and sorted(str(p)) == sorted(str(q)):
            yield p


def A372029_gen():  # generator of terms
    c = {
        "1": "12357",
        "2": "2357",
        "3": "357",
        "4": "57",
        "5": "57",
        "6": "7",
        "7": "7",
    }
    for l in count(1):
        for d in combinations_with_replacement("1234567", l):
            for e in c[d[-1]]:
                n = int("".join(d) + (a := e))
                if not isprime(n):
                    for p in factorint(n, multiple=True):
                        s = str(p)
                        if s[0] < a or sorted(s) != list(s):
                            break
                        a = s[-1]
                    else:
                        yield n


def A372046_gen(startvalue=4):  # generator of terms >= startvalue
    for n in count(max(startvalue, 4)):
        f = factorint(n)
        if sum(f.values()) > 1:
            c = 0
            for p in sorted(f):
                a = pow(10, len(s := str(p)), n)
                q = int(s[::-1])
                for _ in range(f[p]):
                    c = (c * a + q) % n
            if not c:
                yield n


def A272799_gen(startvalue=1):  # generator of terms >= startvalue
    return filter(
        lambda k: max(factorint((k << 1) - 1).values(), default=1) == 1
        and max(factorint((k << 1) + 1).values()) == 1,
        count(max(startvalue, 1)),
    )


def A067874_gen(startvalue=2):  # generator of terms >= startvalue
    return filter(
        lambda k: max(factorint(k - 1).values(), default=1) == 1
        and max(factorint(k + 1).values()) == 1,
        count(max(startvalue + (startvalue & 1), 2), 2),
    )


def A372277_gen(startvalue=4):  # generator of terms >= startvalue
    for n in count(max(startvalue, 4)):
        f = factorint(n)
        if sum(f.values()) > 1:
            c = 0
            for p in sorted(f):
                a = pow(2, len(s := bin(p)[2:]), n)
                q = int(s[::-1], 2)
                for _ in range(f[p]):
                    c = (c * a + q) % n
            if not c:
                yield n


def A371597(n):
    return sum(
        filter(
            lambda m: (d := divisors(m))[((l := len(d)) - 1) >> 1] + d[l >> 1] == n,
            range(1, (n**2 >> 2) + 1),
        )
    )


def A369110(n):
    c = {n}
    while n < 4 or n > 5:
        c.add(n := (d := divisors(n))[((l := len(d)) - 1) >> 1] + d[l >> 1])
    if n == 5:
        c.add(6)
    return len(c)


def A371924(n):
    m = prime(n) - 1
    b, k = 1, 1 % m
    while k:
        b += 1
        k = k * b % m
    return b


def A370482(n):
    return isprime(n) + (n & 1 ^ 1)


def A370469_T(n, k):
    return comb(k - 1, n - 1) << n


def A306284(n):
    y, a = 0, set()
    for x in count(0):
        if y in a:
            return x
        a.add(y)
        y = (y + (x << 1) + 1) % n


def A138191(n):
    return (1, 1, 2, 1)[n & 3]


def A371124(n):
    y, a = 0, {}
    for x in count(0):
        if y in a:
            return a[y]
        a[y] = x
        y = (y + (x << 1) + 1) % n


def A371252_gen():  # generator of terms
    a, b, c = 1, 9, 297
    yield from (a, b)
    for k in count(3):
        yield c
        a, b, c = (
            b,
            c,
            (
                3888 * a
                - 4338 * b
                + 738 * c
                + k
                * (
                    -42120 * a
                    + 43839 * b
                    - 7263 * c
                    + k
                    * (
                        154548 * a
                        - 162865 * b
                        + 29297 * c
                        + k
                        * (
                            -238302 * a
                            + 274917 * b
                            - 60393 * c
                            + k
                            * (
                                174636 * a
                                - 233053 * b
                                + 66698 * c
                                + k
                                * (
                                    -60750 * a
                                    + 97800 * b
                                    - 37350 * c
                                    + k * (8100 * a - 16300 * b + 8300 * c)
                                )
                            )
                        )
                    )
                )
            )
            // (k**3 * (k * (k * (100 * k - 300) + 281) - 78)),
        )


def A059074_gen():  # generator of terms
    a, b, c, d = 1, 0, 1, 346
    yield from (a, b, c)
    for k in count(4):
        yield d
        a, b, c, d = (
            b,
            c,
            d,
            (
                k
                * (
                    -222912 * a
                    - 151968 * b
                    + 185062 * c
                    + 4179 * d
                    + k
                    * (
                        588384 * a
                        + 462000 * b
                        - 474198 * c
                        - 38670 * d
                        + k
                        * (
                            -856512 * a
                            - 725040 * b
                            + 672688 * c
                            + 75248 * d
                            + k
                            * (
                                995616 * a
                                + 849696 * b
                                - 777792 * c
                                - 92992 * d
                                + k
                                * (
                                    -739584 * a
                                    - 651264 * b
                                    + 592384 * c
                                    + 62720 * d
                                    + k
                                    * (
                                        271872 * a
                                        + 253440 * b
                                        - 235008 * c
                                        - 24064 * d
                                        + k * (36864 * (c - b - a) + 4096 * d)
                                        + 8192
                                    )
                                    - 28672
                                )
                                + 23680
                            )
                            - 7904
                        )
                        + 1416
                    )
                    + 14382
                )
                - 1611
            )
            // (k * (k * (384 * k - 1680) + 2520) - 1611),
        )


def A372289(n):
    return (n << (e := (~n & n - 1).bit_length())) + ((1 << (e << 1)) - 1) // 3


def A372228(n):
    return max(max(primefactors(n), default=1), max(primefactors(n ** (n - 1) + 1)))


def A372229(n):
    return max(
        max(primefactors(n), default=1), max(primefactors(n ** (n - 1) - 1), default=1)
    )


def A370397(n):
    return prod(range(5, (n << 2) + 2, 4)) >> (n << 1)


def A372204(n):
    return len(num2words(n, ordinal=True, lang="it"))


def A026858(n):
    return len(num2words(n, lang="it"))


def A371094(n):
    return ((m := 3 * n + 1) << (e := (~m & m - 1).bit_length())) + (
        (1 << (e << 1)) - 1
    ) // 3


def A372351(n):
    return ((m := 6 * n - 2) << (e := (~m & m - 1).bit_length())) + (
        (1 << (e << 1)) - 1
    ) // 3


def A372385(n):
    return Matrix(
        n - 1,
        n - 1,
        [
            jacobi_symbol(i - j, (n << 1) | 1)
            for i in range(n - 1)
            for j in range(n - 1)
        ],
    ).det()


def A086893(n):
    return (1 << n + 1 if n & 1 else 5 << n - 1) // 3


def A372381(n):
    return prod(1 << (e + 1).bit_length() - 1 for e in factorint(n).values())


def A372380(n):
    return prod((e + 1).bit_length() for e in factorint(n).values())


def A372379(n):
    return prod(
        p ** ((1 << (e + 1).bit_length() - 1) - 1) for p, e in factorint(n).items()
    )


def A370612(n):
    return next(
        k
        for k in count(max(factorial(n - 1), 2))
        if 0
        not in (s := set.union(*(set(sympydigits(p, n)[1:]) for p in primefactors(k))))
        and len(s) == n - 1
    )


def A372394(n):
    return Matrix(
        n - 1 << 1,
        n - 1 << 1,
        [
            jacobi_symbol(i * (i + 5 * j + 14) + j * (5 * j + 30) + 44, (n << 1) | 1)
            for i in range(n - 1 << 1)
            for j in range(n - 1 << 1)
        ],
    ).det()


def A372409(n):
    return Matrix(
        n - 1,
        n - 1,
        [
            jacobi_symbol(i - j, (n << 1) | 1) if i else 1
            for i in range(n - 1)
            for j in range(n - 1)
        ],
    ).det()


def A120286(n):
    return sum(Fraction(n - i + 1, i**2) for i in range(1, n + 1)).numerator


def A370774(n):
    return sum(Fraction(n - i + 1, i**2) for i in range(1, n + 1)).denominator


def A370048(n):
    return (
        0
        if n < 2
        else 1
        + sum(
            (x := comb((k := m << 1), m + 1) * comb(n - 1 - k, m))
            + x * (k + 1) * (n - 1 - 3 * m) // (m * (n - 1 - k))
            for m in range(1, (n + 2) // 3)
        )
    )


def A163493(n):
    return (
        2
        + sum(
            (x := comb((k := m << 1) - 1, m) * comb(n - k, m))
            + (x * (n - 3 * m) << 1) // (n - k)
            for m in range(1, n // 3 + 1)
        )
        if n
        else 1
    )


def A372457(n):
    if n == 1:
        return 1
    p, m, r = 7, None, None
    while m is None or p**n <= m:
        if (
            k := min((r >> 1 for r in sqrt_mod_iter(-3, p**n) if r & 1), default=None)
        ) is not None:
            m = (r := k if r is None else min(r, k)) * (r + 1) + 1
        while (p := nextprime(p)) % 6 != 1:
            pass
    return r


def A372060(n):
    if n < 3:
        return n
    l1, l2, s, b, k = 2, 1, 3, set(), 3
    while True:
        for i in count(s):
            if not (i in b or i & l1) and i & l2:
                if i == n:
                    return k
                k += 1
                l2, l1 = l1, i
                b.add(i)
                while s in b:
                    b.remove(s)
                    s += 1
                break


def A364722_gen(startvalue=1):  # generator of terms >= startvalue
    if startvalue <= 1:
        yield 1
    if startvalue <= 3:
        yield 3
    for k in count(max(startvalue, 4)):
        for d in (r >> 1 for r in sqrt_mod_iter(-3, k) if r & 1):
            try:
                discrete_log(k, d, 2)
            except:
                continue
            yield k
            break


def A364724_gen():  # generator of terms
    yield 0
    for k in count(2):
        m = None
        for d in sqrt_mod_iter(-3, k):
            r = d >> 1 if d & 1 else d + k >> 1
            try:
                m = (
                    discrete_log(k, r, 2)
                    if m is None
                    else min(m, discrete_log(k, r, 2))
                )
            except:
                continue
        if m is not None:
            yield m


def A125611(n):
    m = 7**n
    r = sorted(nthroot_mod(1, 6, m, all_roots=True))
    for i in count(0, m):
        for p in r:
            if isprime(i + p):
                return i + p


def A125612(n):
    m = 11**n
    r = sorted(nthroot_mod(1, 10, m, all_roots=True))
    for i in count(0, m):
        for p in r:
            if isprime(i + p):
                return i + p


def A125646(n):
    m = (p := prime(n)) ** 5
    r = sorted(nthroot_mod(1, p - 1, m, all_roots=True))
    for i in count(0, m):
        for a in r:
            if isprime(i + a):
                return i + a


def A070183_gen(startvalue=2):  # generator of terms >= startvalue
    p = max(nextprime(startvalue - 1), 2)
    while True:
        if is_nthpow_residue(2, 6, p) and not is_nthpow_residue(2, 36, p):
            yield p
        p = nextprime(p)


def A014755_gen(startvalue=2):  # generator of terms >= startvalue
    p = max(nextprime(startvalue - 1), 2)
    while True:
        if p & 7 == 1 and is_nthpow_residue(3, 4, p) and is_nthpow_residue(-3, 4, p):
            yield p
        p = nextprime(p)


def A372304(n):
    return sum(comb(n, k) * (k ^ k >> 1) for k in range(n + 1))


def A372264(n):
    return factorial(n) - (n - 1) ** 2


def A371217(n):
    return n + (
        (n - 1)
        * sum(
            factorial(n - 1) // ((i + 1) * factorial(n - i - 2)) for i in range(n - 1)
        )
        << 1
    )


def A372494(n):
    k = (1 << n) - 1
    k2 = k >> 1
    return min(
        (d >> 1 if d & 1 else (d >> 1) + k2 for d in sqrt_mod_iter(-3, k)), default=-1
    )


def A145296_gen():  # generator of terms
    p = 1
    while p := nextprime(p):
        if p & 3 == 1:
            yield min(sqrt_mod_iter(-1, p**3))


def A145299_gen():  # generator of terms
    p = 1
    while p := nextprime(p):
        if p & 3 == 1:
            yield min(sqrt_mod_iter(-1, p**6))


def A145298_gen():  # generator of terms
    p = 1
    while p := nextprime(p):
        if p & 3 == 1:
            yield min(sqrt_mod_iter(-1, p**5))


def A145297_gen():  # generator of terms
    p = 1
    while p := nextprime(p):
        if p & 3 == 1:
            yield min(sqrt_mod_iter(-1, p**4))


def A059321_gen():  # generator of terms
    p = 1
    while p := nextprime(p):
        if p & 3 == 1:
            yield min(sqrt_mod_iter(-1, p**2))


def A227220(n):
    k, a = 10**n << 1, (10**n - 1) // 3 << 2
    m = (a << 2) + 1
    return (
        min(
            b
            for b in ((d >> 1) * ((d >> 1) + 1) for d in sqrt_mod_iter(m, k) if d & 1)
            if b % k == a
        )
        >> 1
    )


def A227219(n):
    k, a = 10**n << 1, 10 * (10**n - 1) // 9
    m = (a << 2) + 1
    return (
        min(
            b
            for b in ((d >> 1) * ((d >> 1) + 1) for d in sqrt_mod_iter(m, k) if d & 1)
            if b % k == a
        )
        >> 1
    )


def A229262(n):
    if n == 2:
        return 153
    c = n * (n + 1) >> 1
    k, a = 10 ** len(str(c)) << 1, c << 1
    m = (a << 2) + 1
    return (
        min(
            (
                b
                for b in (
                    (d >> 1) * ((d >> 1) + 1) for d in sqrt_mod_iter(m, k) if d & 1
                )
                if b > a and b % k == a
            )
        )
        >> 1
    )


def A068858_gen():  # generator of terms
    a = 3
    while True:
        yield a
        b = a + 1
        for d in sqrt_mod_iter(1, a):
            if d**2 - 1 == a:
                d += a
            if d & 1:
                d += a
            if d < b:
                b = d
        a = b**2 - 1


def A068859_gen():  # generator of terms
    a = 3
    while True:
        yield a
        b = a + 1
        for d in sqrt_mod_iter(1, a):
            if d == 1 or d**2 - 1 == a:
                d += a
            if d < b:
                b = d
        a = b**2 - 1


def A068857_gen():  # generator of terms
    yield 0
    a = 8
    while True:
        yield a
        b = a + 1
        for d in sqrt_mod_iter(1, a):
            if d == 1 or d**2 - 1 == a:
                d += a
            if d & 1 and d < b:
                b = d
        a = b**2 - 1


def A068776_gen():  # generator of terms
    a = 8
    while True:
        yield a >> 3
        b = a + 1
        for d in sqrt_mod_iter(1, a):
            if d == 1 or d**2 - 1 == a:
                d += a
            if d & 1 and d < b:
                b = d
        a = b**2 - 1


def A068142_gen():  # generator of terms
    a = 168
    while True:
        yield a >> 3
        b = a + 1
        for d in sqrt_mod_iter(1, a):
            if d == 1 or d**2 - 1 == a:
                d += a
            if d & 1 and d < b:
                b = d
        a = b**2 - 1


def A068513_gen():  # generator of terms
    a = 120
    while True:
        yield a >> 3
        b = a + 1
        for d in sqrt_mod_iter(1, a):
            if d == 1 or d**2 - 1 == a:
                d += a
            if d & 1 and d < b:
                b = d
        a = b**2 - 1


def A054495(n):
    return next(
        d
        for d in divisors(n)
        if is_square(m := 5 * (n // d) ** 2 - 4) or is_square(m + 8)
    )


def A054494(n):
    return next(
        d
        for d in sorted(divisors(n, generator=True), reverse=True)
        if is_square(m := 5 * d**2 - 4) or is_square(m + 8)
    )


def A359437(n):
    p = 1
    while p := nextprime(p):
        if (
            len(
                set(
                    filter(
                        lambda x: isprime(p * (x + 1) - x),
                        (
                            (d**2 + p) // (p + 1)
                            for d in sqrt_mod_iter(-p, p + 1)
                            if isprime(d)
                        ),
                    )
                )
                | set(
                    filter(
                        lambda x: isprime(p * (x - 1) + x),
                        (
                            (d**2 - p) // (p - 1)
                            for d in sqrt_mod_iter(p, p - 1)
                            if isprime(d)
                        ),
                    )
                )
            )
            == n
        ):
            return p


def A049595_gen(startvalue=2):  # generator of terms >= startvalue
    p = max(startvalue - 1, 1)
    while p := nextprime(p):
        if is_nthpow_residue(2, 63, p):
            yield p


@lru_cache(maxsize=None)
def A056971(n):
    if n <= 1:
        return 1
    h = (n + 1).bit_length() - 2
    b = (1 << h) - 1
    r = n - 1 - (b << 1)
    r1 = r - (r // (b + 1)) * (r - b - 1)
    r2 = r - r1
    return comb(n - 1, b + r1) * A056971(b + r1) * A056971(b + r2)


def A056972(n):
    return factorial((1 << n) - 1) // prod(
        ((1 << k) - 1) ** (1 << n - k) for k in range(1, n + 1)
    )


def A372546(n):
    return primenu(n * (n ** (n - 1) + 1))


def A372599(n):
    return primenu(n * (n ** (n - 1) - 1))


def A339758(n):
    m = (n << 1) + 1
    r = 1 << m
    a = sorted(nthroot_mod(m, m, r, all_roots=True))
    for i in count(0):
        for k in a:
            if isprime(k + i * r):
                return int(k + i * r)


def A116300_gen():  # generator of terms
    for l in count(1):
        m = 10**l + 1
        k, r, dlist = m * (m - 11) / 10, m * (m - 2), []
        for a in sqrt_mod_iter(85, m):
            d = ((a if a & 1 else a + m) >> 1) - 4
            if k < d * (d + 9) <= r:
                dlist.append(d)
        yield from sorted(dlist)


def A255867(n):
    if n == 0:
        return 1
    k = 0
    for p in primefactors(resultant(symbolx**n + 17, (symbolx + 1) ** n + 17)):
        for d in (
            a
            for a in sorted(nthroot_mod(-17, n, p, all_roots=True))
            if pow(a + 1, n, p) == -17 % p
        ):
            k = min(d, k) if k else d
            break
    return int(k)


def A255832(n):
    k, t = 0, (n << 1) + 1
    for p in primefactors(resultant(symbolx**t + 2, (symbolx + 1) ** t + 2)):
        for d in (
            a
            for a in sorted(nthroot_mod(-2, t, p, all_roots=True))
            if pow(a + 1, t, p) == -2 % p
        ):
            k = min(d, k) if k else d
            break
    return int(k)


def A255869(n):
    if n == 0:
        return 1
    k = 0
    for p in primefactors(resultant(symbolx**n + 19, (symbolx + 1) ** n + 19)):
        for d in (
            a
            for a in sorted(nthroot_mod(-19, n, p, all_roots=True))
            if pow(a + 1, n, p) == -19 % p
        ):
            k = min(d, k) if k else d
            break
    return int(k)


def A118119(n):
    return next(filter(lambda m: gcd(m**n + 1, (m + 1) ** n + 1) > 1, count(1)))


def A255852(n):
    if n == 0:
        return 1
    k = 0
    for p in primefactors(resultant(symbolx**n + 2, (symbolx + 1) ** n + 2)):
        for d in (
            a
            for a in sorted(nthroot_mod(-2, n, p, all_roots=True))
            if pow(a + 1, n, p) == -2 % p
        ):
            k = min(d, k) if k else d
            break
    return int(k)


def A255831_T(m, n):
    return resultant(symbolx**m + n, (symbolx + 1) ** m + n)


def A240929(n):
    return (
        n
        * (
            n
            * (
                n
                * (
                    n
                    * (
                        n
                        * (n * (n * (n * (156190 * n - 140571) + 29400) - 30870) + 3990)
                        - 8379
                    )
                    - 3100
                )
                - 1620
            )
            - 5040
        )
        // 362880
    )


def A197083(n):
    return n * (n * (n * (n * (66 * n + 275) + 440) + 325) + 94) // 120


def A255853(n):
    if n == 0:
        return 1
    k = 0
    for p in primefactors(resultant(symbolx**n + 3, (symbolx + 1) ** n + 3)):
        for d in (
            a
            for a in sorted(nthroot_mod(-3, n, p, all_roots=True))
            if pow(a + 1, n, p) == -3 % p
        ):
            k = min(d, k) if k else d
            break
    return int(k)


def A255854(n):
    if n == 0:
        return 1
    k = 0
    for p in primefactors(resultant(symbolx**n + 4, (symbolx + 1) ** n + 4)):
        for d in (
            a
            for a in sorted(nthroot_mod(-4, n, p, all_roots=True))
            if pow(a + 1, n, p) == -4 % p
        ):
            k = min(d, k) if k else d
            break
    return int(k)


def A255855(n):
    if n == 0:
        return 1
    k = 0
    for p in primefactors(resultant(symbolx**n + 5, (symbolx + 1) ** n + 5)):
        for d in (
            a
            for a in sorted(nthroot_mod(-5, n, p, all_roots=True))
            if pow(a + 1, n, p) == -5 % p
        ):
            k = min(d, k) if k else d
            break
    return int(k)


def A255856(n):
    if n == 0:
        return 1
    k = 0
    for p in primefactors(resultant(symbolx**n + 6, (symbolx + 1) ** n + 6)):
        for d in (
            a
            for a in sorted(nthroot_mod(-6, n, p, all_roots=True))
            if pow(a + 1, n, p) == -6 % p
        ):
            k = min(d, k) if k else d
            break
    return int(k)


def A255857(n):
    if n == 0:
        return 1
    k = 0
    for p in primefactors(resultant(symbolx**n + 7, (symbolx + 1) ** n + 7)):
        for d in (
            a
            for a in sorted(nthroot_mod(-7, n, p, all_roots=True))
            if pow(a + 1, n, p) == -7 % p
        ):
            k = min(d, k) if k else d
            break
    return int(k)


def A372652(n):
    a, m, f = (
        set(range(1, 2 * n + 1)),
        n * (2 * n) ** (2 * n),
        [[b**c for c in range(2 * n + 1)] for b in range(2 * n + 1)],
    )
    for b in combinations(a, n):
        clist = sorted(a - set(b))
        for d in permutations(range(n)):
            k = sum(f[b[i]][clist[d[i]]] for i in range(n))
            if k < m and is_square(k):
                m = k
    return m


def A372653(n):
    a, m, f = (
        set(range(1, 2 * n + 1)),
        0,
        [[b**c for c in range(2 * n + 1)] for b in range(2 * n + 1)],
    )
    for b in combinations(a, n):
        clist = sorted(a - set(b))
        for d in permutations(range(n)):
            k = sum(f[b[i]][clist[d[i]]] for i in range(n))
            if k > m and is_square(k):
                m = k
    return m


def A345508(n):
    return (10, 13, 16, 18, 19, 21, 22)[n - 1] if n < 8 else n + 16


def A345509(n):
    return (25, 28, 31, 33, 34, 36, 37)[n - 1] if n < 8 else n + 31


def A345510(n):
    return (34, 37, 40, 42, 43, 45, 46)[n - 1] if n < 8 else n + 40


def A345397(n):
    return (70, 71, 73, 74, 77, 78, 79, 80, 82, 83)[n - 1] if n < 11 else n + 74


def A346803(n):
    return (63, 65, 68, 71, 72, 74, 75)[n - 1] if n < 8 else n + 69


def A372473(n):
    if n == 0:
        return 1
    for l in count(n):
        m = 1 << l
        for d in multiset_permutations("0" * n + "1" * (l - n)):
            k = m + int("0" + "".join(d), 2)
            if max(factorint(k).values(), default=0) == 1:
                return sum(mobius(a) * (k // a**2) for a in range(1, isqrt(k) + 1))


def A372541(n):
    if n == 0:
        return 1
    for l in count(n):
        m = 1 << l
        for d in multiset_permutations("0" * (l - n) + "1" * n):
            k = m + int("0" + "".join(d), 2)
            if max(factorint(k).values(), default=0) == 1:
                return sum(mobius(a) * (k // a**2) for a in range(1, isqrt(k) + 1))


def A057627(n):
    return n - sum(mobius(k) * (n // k**2) for k in range(1, isqrt(n) + 1))


def A100112(n):
    b = 0
    k, r = integer_nthroot(n, 2)
    a, c = (mobius(k), k - 1) if r else (0, k)
    for i in range(1, c + 1):
        m, j = mobius(i), i**2
        a += m * (n // j)
        b += m * ((n - 1) // j)
    return a if a > b else 0


def A372644(n):
    return next((k for k in range(1, n) if integer_nthroot(n**2 - k**2, 3)[1]), -1)


def A285329(n):
    m = prod(primefactors(n)) - 1
    return sum(mobius(k) * (m // k**2) for k in range(1, isqrt(m) + 1))


def A372540(n):
    return (
        next(
            sum(mobius(a) * (k // a**2) for a in range(1, isqrt(k) + 1))
            for k in count(1 << n)
            if max(factorint(k).values(), default=0) == 1
        )
        if n
        else 1
    )


if sys.version_info >= (3, 10):

    def A372685_gen():  # generator of terms
        p, a = 1, {}
        while p := nextprime(p):
            if (c := p.bit_count()) not in a:
                yield p
            a[c] = p

else:

    def A372685_gen():  # generator of terms
        p, a = 1, {}
        while p := nextprime(p):
            if (c := bin(p).count("1")) not in a:
                yield p
            a[c] = p


def A372474(n):
    for l in count(n):
        m = 1 << l
        for d in multiset_permutations("0" * n + "1" * (l - n)):
            k = m + int("0" + "".join(d), 2)
            if isprime(k):
                return primepi(k)


def A372517(n):
    for l in count(n - 1):
        m = 1 << l
        for d in multiset_permutations("0" * (l - n + 1) + "1" * (n - 1)):
            k = m + int("0" + "".join(d), 2)
            if isprime(k):
                return primepi(k)


def A372631_gen(startvalue=2):  # generator of terms >= startvalue
    for m in count(max(startvalue, 2)):
        m2 = m**2
        for k in diop_quadratic(
            m2 * (m2 + 1) - symbolx * (symbolx - 1) - 2 * symboly**2
        ):
            if (r := int(k[0])) < m2 and is_square(r):
                yield m
                break


def A372754(n):
    return next(
        b
        for b in count(2)
        if (s := sympydigits(fibonacci(n), b)[1:])[: (t := len(s) + 1 >> 1)]
        == s[: -t - 1 : -1]
    )


def A048158_T(n, k):
    return n % k


def A372727_T(n, k):
    return n % k if k else n


def A372651(n):
    return prod(r for r in quadratic_residues(n) if r)


def A372772(n):
    return sum(
        1 for d in divisors(n, generator=True) if (p := pow(d, n, n)) and not n % p
    )


@lru_cache(maxsize=None)
def A373195(n):
    if n == 1:
        return 1
    i = A373195(n - 1) + 1
    if sum(1 for p in combinations(range(1, n), 5) if is_square(n * prod(p))) > 0:
        a = [set(p) for p in combinations(range(1, n + 1), 6) if is_square(prod(p))]
        for q in combinations(range(1, n), i - 1):
            t = set(q) | {n}
            if not any(s <= t for s in a):
                return i
        else:
            return i - 1
    else:
        return i


@lru_cache(maxsize=None)
def A373178(n):
    if n == 1:
        return 1
    i = A373178(n - 1) + 1
    if sum(1 for p in combinations(range(1, n), 4) if is_square(n * prod(p))) > 0:
        a = [set(p) for p in combinations(range(1, n + 1), 5) if is_square(prod(p))]
        for q in combinations(range(1, n), i - 1):
            t = set(q) | {n}
            if not any(s <= t for s in a):
                return i
        else:
            return i - 1
    else:
        return i


@lru_cache(maxsize=None)
def A373119(n):
    if n == 1:
        return 1
    i = A373119(n - 1) + 1
    if sum(1 for p in combinations(range(1, n), 3) if is_square(n * prod(p))) > 0:
        a = [set(p) for p in combinations(range(1, n + 1), 4) if is_square(prod(p))]
        for q in combinations(range(1, n), i - 1):
            t = set(q) | {n}
            if not any(s <= t for s in a):
                return i
        else:
            return i - 1
    else:
        return i


@lru_cache(maxsize=None)
def A372306(n):
    if n == 1:
        return 1
    i = A372306(n - 1) + 1
    if sum(1 for p in combinations(range(1, n), 2) if is_square(n * prod(p))) > 0:
        a = [set(p) for p in combinations(range(1, n + 1), 3) if is_square(prod(p))]
        for q in combinations(range(1, n), i - 1):
            t = set(q) | {n}
            if not any(s <= t for s in a):
                return i
        else:
            return i - 1
    else:
        return i


def A373042(n):
    return sum(1 for p in combinations(range(1, n + 1), 3) if is_square(prod(p)))


def A373043(n):
    return sum(1 for k in range(3, n) for j in range(2, k) if is_square(j * k * n))


def A373114(n):
    a = dict(zip(primerange(n + 1), range(c := primepi(n))))
    return n - min(
        sum(
            sum(e for p, e in factorint(m).items() if b[a[p]]) & 1 ^ 1
            for m in range(1, n + 1)
        )
        for b in product((0, 1), repeat=c)
    )


def A360659(n):
    a = dict(zip(primerange(n + 1), range(c := primepi(n))))
    return (
        min(
            sum(
                sum(e for p, e in factorint(m).items() if b[a[p]]) & 1 ^ 1
                for m in range(1, n + 1)
            )
            for b in product((0, 1), repeat=c)
        )
        << 1
    ) - n


def A014550(n):
    return int(bin(n ^ n >> 1)[2:])


def A064784(n):
    return (m := n * (n + 1) >> 1) - isqrt(m) ** 2


def A128549(n):
    return (isqrt(m := n * (n + 1) >> 1) + 1) ** 2 - m


def A061398(n):
    p = prime(n)
    q = nextprime(p)
    r = isqrt(p - 1) + 1
    return (
        sum(mobius(k) * ((q - 1) // k**2) for k in range(r, isqrt(q - 1) + 1))
        + sum(mobius(k) * ((q - 1) // k**2 - (p - 1) // k**2) for k in range(1, r))
        - 1
    )


def A373198(n):
    p = prime(n)
    q = nextprime(p)
    r = isqrt(p - 1) + 1
    return sum(
        mobius(k) * ((q - 1) // k**2) for k in range(r, isqrt(q - 1) + 1)
    ) + sum(mobius(k) * ((q - 1) // k**2 - (p - 1) // k**2) for k in range(1, r))


def A053462(n):
    m = 10**n - 1
    return sum(mobius(k) * (m // k**2) for k in range(1, isqrt(m) + 1))


def A138383(n):
    if n == 0:
        return 3
    q = nextprime(p := prime(n))
    return (q - p) * (p + q + 1) >> 1


def A371201(n):
    if n == 0:
        return 1
    q = nextprime(p := prime(n))
    return (q - p) * (p + q - 1) >> 1


def A054265(n):
    return ((p := prime(n)) + (q := nextprime(p))) * (q - p - 1) >> 1


def A054268_gen():  # generator of terms
    for l in count(1):
        c = []
        for m in range(1, 10):
            k = m * (10**l - 1) // 9 << 1
            for a, b in diop_quadratic(
                (symbolx - symboly - 1) * (symbolx + symboly) - k
            ):
                if isprime(b) and a == nextprime(b):
                    c.append(b)
        yield from sorted(c)


def A373206_gen():  # generator of terms
    yield from (
        1,
        751,
        1001,
        2001,
        2751,
        3001,
        4001,
        5001,
        5376,
        6001,
        6751,
        7001,
        8001,
        9001,
    )
    for i in count(10000, 10000):
        for j in (1, 625, 1249, 4193, 7057, 8751, 9375, 9376):
            m = i + j
            if pow(m, m, 100 * 10 ** (len(str(m)))) == m:
                yield m


def A373205_gen():  # generator of terms
    for i in count(0, 100):
        for j in (1, 25, 49, 51, 57, 75, 76, 93):
            m = i + j
            if pow(m, m, 10 * 10 ** (len(str(m)))) == m:
                yield m


def A114370_gen():  # generator of terms
    for l in count(1):
        c = []
        for m in range(1, 10):
            k = m * (10**l - 1) // 9 << 1
            for a, b in diop_quadratic((x - y) * (x + y - 1) - k):
                if isprime(b) and a == nextprime(b):
                    c.append(b)
        yield from sorted(c)


def A082576_gen():  # generator of terms
    yield from (
        1,
        5,
        6,
        9,
        11,
        16,
        21,
        25,
        31,
        36,
        41,
        49,
        51,
        56,
        57,
        61,
        71,
        75,
        76,
        81,
        91,
        93,
        96,
        99,
    )
    for i in count(100, 100):
        for j in (1, 25, 49, 51, 57, 75, 76, 93, 99):
            m = i + j
            if pow(m, m, 10 ** (len(str(m)))) == m:
                yield m


def A230366(n):
    return sum(k**2 % n for k in range(1, (n >> 1) + 1))


def A048153(n):
    return sum(k**2 % n for k in range(1, n))


def A104589_gen():  # generator of terms
    a, b = 1, 1
    while True:
        yield a
        a += b
        b += a if isprime(a) else 0


def A355967_gen():  # generator of terms
    a, b = 1, 1
    while True:
        a += b
        if isprime(a):
            b += a
            yield primepi(a)


def A215573(n):
    return n * (n - 1) * ((n << 1) - 1) // 6 % n


def A131502(n):
    c = [-comb(n, i) if i & 1 else comb(n, i) for i in range(n + 1)]
    return sum(
        1
        for p in permutations(range(n + 1))
        if p[0] < p[-1] and not sum(c[i] * p[i] for i in range(n + 1))
    )


def A130783(n):
    return (n + 1) * ((1 << n) - comb(n, n >> 1)) >> 1


def A329851(n):
    c = [-comb(n, i) if i & 1 else comb(n, i) for i in range(n + 1)]
    return (
        sum(
            abs(sum(c[i] * p[i] for i in range(n + 1)))
            for p in permutations(range(n + 1))
            if p[0] < p[-1]
        )
        << 1
    )


def A229836(n):
    return primepi(n**n) - primepi(factorial(n) - 1)


def A087865_gen():  # generator of terms
    k = 1
    while True:
        k *= 3
        if isprime(p := primepi(k)):
            yield p


@lru_cache(maxsize=None)
def A358685(n):
    return (
        3
        if n == 1
        else A358685(n - 1)
        + sum(
            1
            for p in product("13579", repeat=n - 1)
            for q in (
                [1, 7]
                if sum(map(int, p)) % 3 == 0
                else ([3, 9] if sum(map(int, p)) % 3 == 2 else [1, 3, 7, 9])
            )
            if isprime(10 * int("".join(p)) + q)
        )
    )


def A057716(n):
    return n + (n + n.bit_length()).bit_length()


def A006995(n):
    if n == 1:
        return 0
    a = 1 << (l := n.bit_length() - 2)
    m = a | (n & a - 1)
    return (
        (m << l + 1) + int(bin(m)[:1:-1] or "0", 2)
        if a & n
        else (m << l) + int(bin(m)[-2:1:-1] or "0", 2)
    )


def A057148(n):
    if n == 1:
        return 0
    a = 1 << n.bit_length() - 2
    s = bin(a | (n & a - 1))[2:]
    return int(s + (s[::-1] if a & n else s[-2::-1]))


def A176923(n):
    if n == 1:
        return 0
    a = 1 << n.bit_length() - 2
    s = bin(a | (n & a - 1))[2:]
    return int(s + (s[::-1] if a & n else s[-2::-1])) ** 2


def A372403(n):
    m, p = (1 << n) - 1, 2
    q = isqrt(m)
    r = m - sum(mobius(k) * (m // k**2) for k in range(1, q + 1))
    while p <= q:
        r -= integer_log(m, p)[0] - 1
        p = nextprime(p)
    return r


def A164126(n):
    if n == 1:
        return 1
    m = (a := 1 << (l := n.bit_length() - 2)) | (n & a - 1)
    k = (
        (m << l + 1) + int(bin(m)[:1:-1] or "0", 2)
        if a & n
        else (m << l) + int(bin(m)[-2:1:-1] or "0", 2)
    )
    m = (a := 1 << (l := (n + 1).bit_length() - 2)) | (n + 1 & a - 1)
    return (
        (m << l + 1) + int(bin(m)[:1:-1] or "0", 2)
        if a & n + 1
        else (m << l) + int(bin(m)[-2:1:-1] or "0", 2)
    ) - k


def A102460(n):
    return int(is_square(m := 5 * (n**2 - 4)) or is_square(m + 40))


def A262065(n):
    if n == 1:
        return 0
    y = 60 * (x := 60 ** integer_log(n >> 1, 60)[0])
    return int(
        (c := n - x) * x + mpz(gmpy2digits(c, 60)[-2::-1] or "0", 60)
        if n < x + y
        else (c := n - y) * y + mpz(gmpy2digits(c, 60)[::-1] or "0", 60)
    )


def A029803(n):
    if n == 1:
        return 0
    y = (x := 1 << (m := n.bit_length() - 2) - m % 3) << 3
    return (
        (c := n - x) * x + int(oct(c)[-2:1:-1] or "0", 8)
        if n < x + y
        else (c := n - y) * y + int(oct(c)[:1:-1] or "0", 8)
    )


def A014190(n):
    if n == 1:
        return 0
    y = 3 * (x := 3 ** integer_log(n >> 1, 3)[0])
    return int(
        (c := n - x) * x + int(gmpy2digits(c, 3)[-2::-1] or "0", 3)
        if n < x + y
        else (c := n - y) * y + int(gmpy2digits(c, 3)[::-1] or "0", 3)
    )


def A029952(n):
    if n == 1:
        return 0
    y = 5 * (x := 5 ** integer_log(n >> 1, 5)[0])
    return int(
        (c := n - x) * x + int(gmpy2digits(c, 5)[-2::-1] or "0", 5)
        if n < x + y
        else (c := n - y) * y + int(gmpy2digits(c, 5)[::-1] or "0", 5)
    )


def A084019(n):
    if n == 1:
        return 9
    y = 10 * (x := 10 ** (len(str(n >> 1)) - 1))
    if n < x + y:
        c = n - x
        c = 10 ** len(str(c)) - 1 - c
        return c * x + int(str(c)[-2::-1] or 0)
    else:
        c = n - y
        c = 10 ** len(str(c)) - 1 - c
        return c * y + int(str(c)[::-1] or 0)


def A099280(n):
    if n == 0:
        return 1
    m = 1 << n - 1
    k = (m << 1) + 1
    y = 10 * (x := 10 ** (len(str(m)) - 1))
    return (
        (c := k - x) * x + int(str(c)[-2::-1] or 0)
        if k < x + y
        else (c := k - y) * y + int(str(c)[::-1] or 0)
    )


def A043269(n):
    if n == 1:
        return 0
    y = 10 * (x := 10 ** (len(str(n >> 1)) - 1))
    return (
        int((s := str(n - x))[-1]) + (sum(int(d) for d in s[:-1]) << 1)
        if n < x + y
        else sum(map(int, str(n - y))) << 1
    )


if sys.version_info >= (3, 10):

    def A043261(n):
        if n == 1:
            return 0
        a = 1 << n.bit_length() - 2
        m = a | (n & a - 1)
        return (m.bit_count() << 1) - (0 if a & n else m & 1)

else:

    def A043261(n):
        if n == 1:
            return 0
        a = 1 << n.bit_length() - 2
        m = a | (n & a - 1)
        return (bin(m).count("1") << 1) - (0 if a & n else m & 1)


def A029730(n):
    if n == 1:
        return 0
    y = (x := 1 << (n.bit_length() - 2 & -4)) << 4
    return (
        (c := n - x) * x + int(hex(c)[-2:1:-1] or "0", 16)
        if n < x + y
        else (c := n - y) * y + int(hex(c)[:1:-1] or "0", 16)
    )


def A029955(n):
    if n == 1:
        return 0
    y = 9 * (x := 9 ** integer_log(n >> 1, 9)[0])
    return int(
        (c := n - x) * x + int(gmpy2digits(c, 9)[-2::-1] or "0", 9)
        if n < x + y
        else (c := n - y) * y + int(gmpy2digits(c, 9)[::-1] or "0", 9)
    )


def A002113(n):
    return palindrome(n)


def A076890(n):
    if n == 1:
        return 0
    y = 10 * (x := 10 ** (len(str(n + 1 >> 1)) - 1))
    return primepi(
        (c := n + 1 - x) * x + int(str(c)[-2::-1] or 0)
        if n < x + y
        else (c := n + 1 - y) * y + int(str(c)[::-1] or 0)
    )


def A091582(n):
    if n == 1:
        return 1
    y = 10 * (x := 10 ** (len(str(n >> 1)) - 1))
    return npartitions(
        (c := n - x) * x + int(str(c)[-2::-1] or 0)
        if n < x + y
        else (c := n - y) * y + int(str(c)[::-1] or 0)
    )


def A112875(n):
    if n == 1:
        return 0
    y = 10 * (x := 10 ** (len(str(n >> 1)) - 1))
    return (
        int((s := str(n - x))[-1]) * prod(int(d) for d in s[:-1]) ** 2
        if n < x + y
        else prod(map(int, str(n - y))) ** 2
    )


def A014192(n):
    if n == 1:
        return 0
    y = (x := 1 << (n.bit_length() - 2 & -2)) << 2
    return (
        (c := n - x) * x + int(gmpy2digits(c, 4)[-2::-1] or "0", 4)
        if n < x + y
        else (c := n - y) * y + int(gmpy2digits(c, 4)[::-1] or "0", 4)
    )


def A029953(n):
    if n == 1:
        return 0
    y = 6 * (x := 6 ** integer_log(n >> 1, 6)[0])
    return int(
        (c := n - x) * x + int(gmpy2digits(c, 6)[-2::-1] or "0", 6)
        if n < x + y
        else (c := n - y) * y + int(gmpy2digits(c, 6)[::-1] or "0", 6)
    )


def A029954(n):
    if n == 1:
        return 0
    y = 7 * (x := 7 ** integer_log(n >> 1, 7)[0])
    return int(
        (c := n - x) * x + int(gmpy2digits(c, 7)[-2::-1] or "0", 7)
        if n < x + y
        else (c := n - y) * y + int(gmpy2digits(c, 7)[::-1] or "0", 7)
    )


def A029956(n):
    if n == 1:
        return 0
    y = 11 * (x := 11 ** integer_log(n >> 1, 11)[0])
    return int(
        (c := n - x) * x + int(gmpy2digits(c, 11)[-2::-1] or "0", 11)
        if n < x + y
        else (c := n - y) * y + int(gmpy2digits(c, 11)[::-1] or "0", 11)
    )


def A029957(n):
    if n == 1:
        return 0
    y = 12 * (x := 12 ** integer_log(n >> 1, 12)[0])
    return int(
        (c := n - x) * x + int(gmpy2digits(c, 12)[-2::-1] or "0", 12)
        if n < x + y
        else (c := n - y) * y + int(gmpy2digits(c, 12)[::-1] or "0", 12)
    )


def A029958(n):
    if n == 1:
        return 0
    y = 13 * (x := 13 ** integer_log(n >> 1, 13)[0])
    return int(
        (c := n - x) * x + int(gmpy2digits(c, 13)[-2::-1] or "0", 13)
        if n < x + y
        else (c := n - y) * y + int(gmpy2digits(c, 13)[::-1] or "0", 13)
    )


def A029959(n):
    if n == 1:
        return 0
    y = 14 * (x := 14 ** integer_log(n >> 1, 14)[0])
    return int(
        (c := n - x) * x + int(gmpy2digits(c, 14)[-2::-1] or "0", 14)
        if n < x + y
        else (c := n - y) * y + int(gmpy2digits(c, 14)[::-1] or "0", 14)
    )


def A029960(n):
    if n == 1:
        return 0
    y = 15 * (x := 15 ** integer_log(n >> 1, 15)[0])
    return int(
        (c := n - x) * x + int(gmpy2digits(c, 15)[-2::-1] or "0", 15)
        if n < x + y
        else (c := n - y) * y + int(gmpy2digits(c, 15)[::-1] or "0", 15)
    )


def A118594(n):
    if n == 1:
        return 0
    y = 3 * (x := 3 ** integer_log(n >> 1, 3)[0])
    return int(
        (s := gmpy2digits(n - x, 3)) + s[-2::-1]
        if n < x + y
        else (s := gmpy2digits(n - y, 3)) + s[::-1]
    )


def A118595(n):
    if n == 1:
        return 0
    y = (x := 1 << (n.bit_length() - 2 & -2)) << 2
    return int(
        (s := gmpy2digits(n - x, 4)) + s[-2::-1]
        if n < x + y
        else (s := gmpy2digits(n - y, 4)) + s[::-1]
    )


def A118596(n):
    if n == 1:
        return 0
    y = 5 * (x := 5 ** integer_log(n >> 1, 5)[0])
    return int(
        (s := gmpy2digits(n - x, 5)) + s[-2::-1]
        if n < x + y
        else (s := gmpy2digits(n - y, 5)) + s[::-1]
    )


def A118597(n):
    if n == 1:
        return 0
    y = 6 * (x := 6 ** integer_log(n >> 1, 6)[0])
    return int(
        (s := gmpy2digits(n - x, 6)) + s[-2::-1]
        if n < x + y
        else (s := gmpy2digits(n - y, 6)) + s[::-1]
    )


def A118598(n):
    if n == 1:
        return 0
    y = 7 * (x := 7 ** integer_log(n >> 1, 7)[0])
    return int(
        (s := gmpy2digits(n - x, 7)) + s[-2::-1]
        if n < x + y
        else (s := gmpy2digits(n - y, 7)) + s[::-1]
    )


def A118599(n):
    if n == 1:
        return 0
    y = (x := 1 << (m := n.bit_length() - 2) - m % 3) << 3
    return int(
        (s := oct(n - x)[2:]) + s[-2::-1]
        if n < x + y
        else (s := oct(n - y)[2:]) + s[::-1]
    )


def A118600(n):
    if n == 1:
        return 0
    y = 9 * (x := 9 ** integer_log(n >> 1, 9)[0])
    return int(
        (s := gmpy2digits(n - x, 9)) + s[-2::-1]
        if n < x + y
        else (s := gmpy2digits(n - y, 9)) + s[::-1]
    )


def A373448(n):
    if n == 0:
        return 0
    k = 10**n
    a = 1 << (l := k.bit_length() - 2)
    m = a | (k & a - 1)
    return (
        (m << l + 1) + int(bin(m)[:1:-1] or "0", 2)
        if a & k
        else (m << l) + int(bin(m)[-2:1:-1] or "0", 2)
    )


def A372074_gen():  # generator of terms
    yield (a := 1)
    while True:
        yield (a := (s := sum(map(int, str(a)))) + a * 10 ** len(str(s)))


def A372075_gen():  # generator of terms
    yield (a := 1)
    while True:
        yield (a := a + 10 ** len(s := str(a)) * sum(map(int, s)))


def A016052_gen():  # generator of terms
    yield (a := 3)
    while True:
        yield (a := a + sum(map(int, str(a))))


def A007412(n):
    return n + (k := integer_nthroot(n, 3)[0]) + int(n >= (k + 1) ** 3 - k)


def A030140(n):
    return (n + (k := isqrt(n)) + int(n >= k * (k + 1) + 1)) ** 2


def A140823(n):
    return n + (k := integer_nthroot(n, 4)[0]) + int(n >= (k + 1) ** 4 - k)


def A000037(n):
    return n + (k := isqrt(n)) + int(n >= k * (k + 1) + 1)


def A014132(n):
    return n + (isqrt((n << 3) - 7) + 1 >> 1)


def A057717(n):
    return n + (m := len(str(n - 1))) + (n >= 10**m - m) if n else 0


def A109470(n):
    return (
        (m := n + (k := integer_nthroot(n, 3)[0]) + int(n >= (k + 1) ** 3 - k))
        * (m + 1)
        >> 1
    ) - ((r := integer_nthroot(m, 3)[0]) * (r + 1) >> 1) ** 2


def A086849(n):
    return ((m := n + (k := isqrt(n)) + int(n >= k * (k + 1) + 1)) * (m + 1) >> 1) - (
        (r := isqrt(m)) * (r + 1) * ((r << 1) + 1) // 6
    )


def A329598(n):
    return (
        k := (r := isqrt(m := n + 1 << 1)) + int((m << 2) > (r << 2) * (r + 1) + 1) - 1
    ) * (k * (-k - 3) + 6 * n - 2) // 6 + (n * (n + 3) >> 1)


def A373767_gen():  # generator of terms
    k, c = 0, 0
    for i in count(1):
        for n in range(i**3 + 1, (i + 1) ** 3):
            k += 1
            c += n
            if is_square(c):
                yield k


def A064524(n):
    return n - integer_nthroot(n, 3)[0]


def A210826(n):
    return prod((1, -1, 0)[e % 3] for e in factorint(n).values())


def A139179(n):
    return n - integer_nthroot(n, 4)[0]


def A057048(n):
    return -isqrt(m := 1 << n + 1) + isqrt(m << 2)


def A017911(n):
    return -isqrt(m := 1 << n) + isqrt(m << 2)


def A017979(n):
    return integer_nthroot(1 << n, 3)[0]


def A018025(n):
    return -integer_nthroot(m := 17**n, 3)[0] + integer_nthroot(m << 3, 3)[0]


def A018046(n):
    return -integer_nthroot(m := 3**n << 3 * n, 3)[0] + integer_nthroot(m << 3, 3)[0]


def A018010(n):
    return -integer_nthroot(m := 3**n << (n << 1), 3)[0] + integer_nthroot(m << 3, 3)[0]


def A017980(n):
    return -integer_nthroot(m := 1 << n, 3)[0] + integer_nthroot(m << 3, 3)[0]


def A017983(n):
    return -integer_nthroot(m := 3**n, 3)[0] + integer_nthroot(m << 3, 3)[0]


def A166447(n):
    return n * ((m := isqrt(n)) + (n - m * (m + 1) >= 1))


def A169985(n):
    return int(
        (m := isqrt(k := (lambda x: (x[1] << 1) + x[0])(fib2(n << 1))))
        + (k - m * (m + 1) >= 1)
    )


def A088828(n):
    return (s := (m := isqrt(k := (n << 1) - 1)) + (k - m * (m + 1) >= 1)) + k + (s & 1)


def A004202(n):
    return n + comb((m := isqrt(k := n << 1)) + (k - m * (m + 1) >= 1) + 1, 2)


def A057211(n):
    return int(bool(isqrt(n << 3) + 1 & 2))


def A057212(n):
    return int(not isqrt(n << 3) + 1 & 2)


def A070169(n):
    return (m := isqrt(k := 3 * n**4)) + (k - m * (m + 1) >= 1)


def A216124_gen(startvalue=3):  # generator of terms >= startvalue
    q = max(3, nextprime(startvalue - 1))
    p = prevprime(q)
    r = nextprime(q)
    while True:
        if q == (m := isqrt(k := p * r)) + (k - m * (m + 1) >= 1):
            yield q
        p, q, r = q, r, nextprime(r)


def A017920(n):
    return (m := isqrt(k := 5**n)) + (k - m * (m + 1) >= 1)


def A017919(n):
    return isqrt(5**n)


def A017921(n):
    return isqrt(5**n) + (n & 1)


def A115366(n):
    return sum(1 for k in range(1, 10**n + 1) if isprime(k * (k + 3) + 1))


def A165453(n):
    return (k := (m := isqrt(n)) + (n - m * (m + 1) >= 1)) * (3 * n + 1 - k**2) // 3


def A027924(n):
    return isqrt((n * (n + 1)) ** 2 << 1) + 1 >> 1


def A100665(n):
    return int((m := isqrt(k := fib(n))) + (k - m * (m + 1) >= 1))


def A200216(n):
    return (
        14
        + 12 * (lucas(k := 30 * n - 15) if n & 1 else -lucas(k := 30 * n - 15))
        + lucas(k << 1)
    ) // 20


def A309407(n):
    if n == 0:
        return 1
    a, b = integer_nthroot(12 * n + 9, 2)
    return a - (c := isqrt(3 * n + 2)) - (b & (c & 1 ^ 1))


def A168038(n):
    return (isqrt(n << 3) + 1 >> 1) ** 2


def A093995(n):
    return (isqrt(n << 3) + 1 >> 1) ** 2


def A085903(n):
    return (1 << n) - 1 if n & 1 else ((1 << (n >> 1)) - 1) ** 2


def A062872(n):
    return isqrt(factorial(n) * n**n << 2) + 1 >> 1


def A062871(n):
    return isqrt(factorial(n) * n**n)


def A077163(n):
    return n ** (isqrt(n << 3) + 1 >> 1)


def A057062(n):
    return isqrt(prime(n) << 3) + 1 >> 1


def A130080(n):
    a, b = integer_nthroot(10 ** (n - 1), 6)
    return a + (not b)


def A373868(n):
    return n + (k := integer_nthroot(n, 5)[0]) + (n >= (k + 1) ** 5 - k)


def A018178(n):
    return -integer_nthroot(m := 11**n << n, 5)[0] + integer_nthroot(m << 5, 5)[0]


def A018064(n):
    return -integer_nthroot(m := 7**n, 4)[0] + integer_nthroot(m << 4, 4)[0]


def A130084(n):
    return (lambda x: x[0] + (not x[1]))(integer_nthroot(10 ** (n - 1), 10))


def A130081(n):
    return (lambda x: x[0] + (not x[1]))(integer_nthroot(10 ** (n - 1), 7))


def A130083(n):
    return (lambda x: x[0] + (not x[1]))(integer_nthroot(10 ** (n - 1), 9))


def A130082(n):
    return (lambda x: x[0] + (not x[1]))(integer_nthroot(10 ** (n - 1), 8))


def A018133(n):
    i, j = iroot_rem(7**n, 5)
    return int(i) + int(
        j << 5 >= 10 * i * ((i * ((i * (i + 1) << 1) + 1) << 2) + 1) + 1
    )


def A018136(n):
    i, j = iroot_rem(1 << 3 * n, 5)
    return int(i) + int(
        j << 5 >= 10 * i * ((i * ((i * (i + 1) << 1) + 1) << 2) + 1) + 1
    )


def A018124(n):
    i, j = iroot_rem(1 << (n << 1), 5)
    return int(i) + int(
        j << 5 >= 10 * i * ((i * ((i * (i + 1) << 1) + 1) << 2) + 1) + 1
    )


def A018151(n):
    i, j = iroot_rem(13**n, 5)
    return int(i) + int(
        j << 5 >= 10 * i * ((i * ((i * (i + 1) << 1) + 1) << 2) + 1) + 1
    )


def A018130(n):
    i, j = iroot_rem(6**n, 5)
    return int(i) + int(
        j << 5 >= 10 * i * ((i * ((i * (i + 1) << 1) + 1) << 2) + 1) + 1
    )


def A018157(n):
    i, j = iroot_rem(15**n, 5)
    return int(i) + int(
        j << 5 >= 10 * i * ((i * ((i * (i + 1) << 1) + 1) << 2) + 1) + 1
    )


def A018160(n):
    i, j = iroot_rem(1 << (n << 2), 5)
    return int(i) + int(
        j << 5 >= 10 * i * ((i * ((i * (i + 1) << 1) + 1) << 2) + 1) + 1
    )


def A005875(n):
    return A004018(n) + (sum(A004018(n - k**2) for k in range(1, isqrt(n) + 1)) << 1)


def A016728(n):
    if n == 0:
        return 1
    return sum(A005875(i) for i in range(n * (n - 1) + 1, n * (n + 1) + 1))


def A289761(n):
    return (n + (m := n % 6)) * (n - (k := m - 3)) // 3 + k


def A289873(n):
    return (n + (m := n % 6)) * (n - (k := m - 3)) // 3 + k - n


def A046895(n):
    return (
        1
        + (
            (
                -((s := isqrt(n)) ** 2) * (s + 1)
                + sum((q := n // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
                & -1
            )
            << 2
        )
        + (
            (
                (t := isqrt(m := n >> 2)) ** 2 * (t + 1)
                - sum((q := m // k) * ((k << 1) + q + 1) for k in range(1, t + 1))
                & -1
            )
            << 4
        )
    )


def A373882(n):
    return (
        1
        + (
            (
                -((s := isqrt(a := 10**n)) ** 2) * (s + 1)
                + sum((q := a // k) * ((k << 1) + q + 1) for k in range(1, s + 1))
                & -1
            )
            << 2
        )
        + (
            (
                (t := isqrt(m := a >> 2)) ** 2 * (t + 1)
                - sum((q := m // k) * ((k << 1) + q + 1) for k in range(1, t + 1))
                & -1
            )
            << 4
        )
    )


def A101455(n):
    return (0, 1, 0, -1)[n & 3]


def A050470(n):
    return prod(
        (p ** (e + 1 << 1) - (m := (0, 1, 0, -1)[p & 3])) // (p**2 - m)
        for p, e in factorint(n).items()
    )


def A002173(n):
    return prod(
        ((m := p**2 * (0, 1, 0, -1)[p & 3]) ** (e + 1) - 1) // (m - 1)
        for p, e in factorint(n).items()
    )


def A000141(n):
    if n == 0:
        return 1
    f = [(p, e, (0, 1, 0, -1)[p & 3]) for p, e in factorint(n).items()]
    return (prod((p ** (e + 1 << 1) - c) // (p**2 - c) for p, e, c in f) << 2) - prod(
        ((k := p**2 * c) ** (e + 1) - 1) // (k - 1) for p, e, c in f
    ) << 2


def A175361(n):
    c = 1
    for m in range(1, n + 1):
        f = [(p, e, (0, 1, 0, -1)[p & 3]) for p, e in factorint(m).items()]
        c += (
            prod((p ** (e + 1 << 1) - a) // (p**2 - a) for p, e, a in f) << 2
        ) - prod(((k := p**2 * a) ** (e + 1) - 1) // (k - 1) for p, e, a in f) << 2
    return c


def A055412(n):
    c = 1
    for m in range(1, n**2 + 1):
        f = [(p, e, (0, 1, 0, -1)[p & 3]) for p, e in factorint(m).items()]
        c += (
            prod((p ** (e + 1 << 1) - a) // (p**2 - a) for p, e, a in f) << 2
        ) - prod(((k := p**2 * a) ** (e + 1) - 1) // (k - 1) for p, e, a in f) << 2
    return c


def A008457(n):
    return prod(
        (p ** (3 * (e + 1)) - (1 if p & 1 else 15)) // (p**3 - 1)
        for p, e in factorint(n).items()
    )


def A000143(n):
    return (
        prod(
            (p ** (3 * (e + 1)) - (1 if p & 1 else 15)) // (p**3 - 1)
            for p, e in factorint(n).items()
        )
        << 4
        if n
        else 1
    )


def A341397(n):
    return (
        sum(
            (
                prod(
                    (p ** (3 * (e + 1)) - (1 if p & 1 else 15)) // (p**3 - 1)
                    for p, e in factorint(m).items()
                )
                for m in range(1, n + 1)
            )
        )
        << 4
    ) + 1


def A350740(n):
    return A046895(n * (n + 1)) - A046895(n * (n - 1)) if n else 1


def A000132(n):
    return A000118(n) + (sum(A000118(n - k**2) for k in range(1, isqrt(n) + 1)) << 1)


def A175360(n):
    return A046895(n) + (sum(A046895(n - k**2) for k in range(1, isqrt(n) + 1)) << 1)


def A373883(n):
    return A175360(10**n)


def A373883(n):
    return A175360(10**n)


def A373352(n):
    if n == 1:
        return 1
    k, s = -1, 0
    while k := k + n:
        if s < (t := isqrt(k) + 1):
            a, b = integer_nthroot(pow(s := t, 2, n), 2)
            if b:
                return gcd(n, t - a)


def A373461(n):
    if n == 1:
        return 1
    k, s = -1, 0
    while k := k + n:
        if s < (t := isqrt(k) + 1):
            a, b = integer_nthroot(pow(s := t, 2, n), 2)
            if b:
                return t - a


def A362502(n):
    k, s = 0, 0
    while k := k + 1:
        if s < (t := isqrt(k * n) + 1):
            if is_square(pow(s := t, 2, n)):
                return k


def A117609(n):
    return sum(A005875(i) for i in range(n + 1))


def A373881(n):
    return A117609(10**n)


def A008451(n):
    return A000141(n) + (sum(A000141(n - k**2) for k in range(1, isqrt(n) + 1)) << 1)


def A341396(n):
    return sum(A008451(i) for i in range(n + 1))


def A373885(n):
    return A341396(10**n)


def A008452(n):
    return A000143(n) + (sum(A000143(n - k**2) for k in range(1, isqrt(n) + 1)) << 1)


def A186690(n):
    return (1 if n & 1 else -1) * prod(
        (p ** (e + 1) - 1) // (p - 1) if p & 1 else 1 << e
        for p, e in factorint(n).items()
    )


def A373663(n):
    return ((n + 1) * (n + 2) + 6 if n & 1 else (n + 2) * (n + 3) - 4) >> 1


def A373662(n):
    return ((n + 1) * (n + 2) - 1 if n & 1 else n * (n + 1) + 5) >> 1


def A373468_gen(startvalue=2):  # generator of terms >= startvalue
    p = max(1, startvalue - 1)
    while p := nextprime(p):
        if is_nthpow_residue(2, 16, p) and not is_nthpow_residue(2, 32, p):
            yield p


def A059287_gen(startvalue=2):  # generator of terms >= startvalue
    p = max(1, startvalue - 1)
    while p := nextprime(p):
        if is_nthpow_residue(2, 8, p) and not is_nthpow_residue(2, 16, p):
            yield p


def A070184_gen(startvalue=2):  # generator of terms >= startvalue
    p = max(1, startvalue - 1)
    while p := nextprime(p):
        if is_nthpow_residue(2, 8, p) and not is_nthpow_residue(2, 64, p):
            yield p


def A055411(n):
    return A046895(m := n**2) + (sum(A046895(m - k**2) for k in range(1, n + 1)) << 1)


def A055410(n):
    return (
        1
        + (
            (
                -(s := n**2) * (n + 1)
                + sum((q := s // k) * ((k << 1) + q + 1) for k in range(1, n + 1))
                & -1
            )
            << 2
        )
        + (
            (
                (t := isqrt(m := s >> 2)) ** 2 * (t + 1)
                - sum((q := m // k) * ((k << 1) + q + 1) for k in range(1, t + 1))
                & -1
            )
            << 4
        )
    )


def A002804(n):
    return (1 << n) + (3**n >> n) - 2


def A374012(n):
    if n == 1:
        return 1
    for k in count(1):
        try:
            next(power_representation(n, 6, k))
        except:
            continue
        return k


def A188462(n):
    if n == 1:
        return 1
    for k in count(1):
        try:
            next(power_representation(n, 5, k))
        except:
            continue
        return k


def A002377(n):
    if n == 1:
        return 1
    for k in count(1):
        try:
            next(power_representation(n, 4, k))
        except:
            continue
        return k


def A002376(n):
    if n == 1:
        return 1
    for k in count(1):
        try:
            next(power_representation(n, 3, k))
        except:
            continue
        return k


def A018886(n):
    return (3**n & -(1 << n)) - 1


def A174420(n):
    return ((m := 3**n) & -(k := 1 << n)) + k - m - (m >> n) - 2


def A252486(n):
    m = n**6
    for k in count(2):
        try:
            next(power_representation(m, 6, k))
        except:
            continue
        return k


def A252476(n):
    for k in count(1):
        try:
            next(power_representation(k**6, 6, n))
        except:
            continue
        for m in range(2, n):
            try:
                next(power_representation(k**6, 6, m))
            except:
                continue
            break
        else:
            return k


def A297446(n):
    return pow(3, n, (1 << n) - 1) - 1 if n > 2 else n


def A185187(n):
    return ((m := 3**n) & -(1 << n)) + m - 1 if n > 2 else 23


def A261572(n):
    for k in count(1):
        try:
            next(power_representation(k**6, 6, n))
        except:
            continue
        return k


def A086539_gen():  # generator of terms
    alist, a, b = [1], 1, 0
    yield 1
    while a := next(m for m in count(a + 1) if all(gcd(m, d) == 1 for d in alist)):
        yield a
        alist = alist[(b := b ^ 1) :] + [a]


def A373965_gen():  # generator of terms
    alist, a, b = [1], 1, 0
    yield 1
    while a := next(m for m in count(a + 1) if all(gcd(m, d) == 1 for d in alist)):
        if (x := integer_nthroot(a, 2))[1]:
            yield x[0]
        alist = alist[(b := b ^ 1) :] + [a]


def A005478_gen():  # generator of terms
    a, b = 1, 1
    while True:
        if isprime(b):
            yield b
        a, b = b, a + b


def A374025(n):
    return max(
        sum(int(d) for d in str(m**5))
        for m in range(
            (lambda x: x[0] + (x[1] ^ 1))(integer_nthroot(10 ** (n - 1), 5)),
            1 + integer_nthroot(10**n - 1, 5)[0],
        )
    )


def A373914(n):
    return max(
        sum(int(d) for d in str(m**4))
        for m in range(
            (lambda x: x[0] + (x[1] ^ 1))(integer_nthroot(10 ** (n - 1), 4)),
            1 + integer_nthroot(10**n - 1, 4)[0],
        )
    )


def A372842(n):
    return 3 * (n + 1) ** (n - 1) - (n - 1) ** (n - 1) >> 2


def A372844(n):
    return 5 * (n + 1) ** (n - 1) - (13 * (n - 1) ** 2 - 4) * (n - 3) ** (n - 3) >> 3


def A372843(n):
    return (((n + 1) ** (n - 1) << 1) - ((n << 1) - 1) * (n - 2) ** (n - 2)) // 3


def A372845(n):
    return (
        18 * (n + 1) ** (n - 1)
        - (n * (n * (59 * ((n << 1) - 9)) + 659) - 192) * (n - 4) ** (n - 4)
    ) // 30


def A373727(n):
    return max(
        sum(int(d) for d in str(m**3))
        for m in range(
            (lambda x: x[0] + (x[1] ^ 1))(integer_nthroot(10 ** (n - 1), 3)),
            1 + integer_nthroot(10**n - 1, 3)[0],
        )
    )


def A348300(n):
    return max(sum(int(d) for d in str(m**2)) for m in range(10 ** (n - 1), 10**n))


def A373893(n):
    return (
        len(
            continued_fraction(
                sum(Fraction(1 if k & 1 else -1, k) for k in range(1, n + 1))
            )
        )
        - 1
    )


def A055573(n):
    return len(continued_fraction(harmonic(n)))


def A374088(n):
    return sum(
        1
        for d in diop_quadratic(symbolx * (symbolx + symboly) + symboly**2 - n)
        if d[0] > 0 and d[1] > 0
    )


def A374090(n):
    return next(
        m
        for m in (3 * k**2 if n & 1 else k for k in count(0))
        if sum(
            1
            for d in diop_quadratic(symbolx * (symbolx + symboly) + symboly**2 - m)
            if d[0] > 0 and d[1] > 0
        )
        == n
    )


def A374091(n):
    if n == 0:
        return 0
    for k in count(1):
        m = 5 * k**2 if n & 1 else k
        c = set()
        for z in range(2, isqrt(m - 1) + 1):
            w = m - z**2
            for x in divisors(w):
                y = z - x
                if y > 0 and x * y == w:
                    c.add((x, y))
        if len(c) == n:
            return m


def A374158(n):
    return next(
        m
        for m in count(0)
        if sum(
            1
            for d in diop_quadratic(symbolx**2 + 3 * symboly**2 - m)
            if d[0] > 0 and d[1] > 0
        )
        == n
    )


def A374159(n):
    return next(
        m
        for m in count(0)
        if sum(
            1
            for d in diop_quadratic(symbolx**2 + 7 * symboly**2 - m)
            if d[0] > 0 and d[1] > 0
        )
        == n
    )


def A374160(n):
    return next(
        m
        for m in count(0)
        if sum(
            1
            for d in diop_quadratic(symbolx**2 + 11 * symboly**2 - m)
            if d[0] > 0 and d[1] > 0
        )
        == n
    )


def A374161(n):
    return next(
        m
        for m in count(0)
        if sum(
            1
            for d in diop_quadratic(symbolx**2 + 19 * symboly**2 - m)
            if d[0] > 0 and d[1] > 0
        )
        == n
    )


def A103586(n):
    return (m := n.bit_length()) + (n >= (1 << m) - m) if n else 1


def A062289(n):
    return n + (m := n.bit_length()) - (not n >= (1 << m) - m)


def A177712(n):
    return n + (m := n.bit_length()) + (n >= (1 << m) - m) << 1


def A374157(n):
    return -n if n & 2 else n


def A057077(n):
    return -1 if n & 2 else 1


def A374148(n):
    return 1 + isqrt(3 * ((1 << n - 1) - 1) ** 2) if n else 0


def A067240(n):
    return (1 << m - 1 if (m := (~n & n - 1).bit_length()) else 0) + sum(
        (p & -2) * p ** (e - 1) for p, e in factorint(n >> m).items()
    )


def A008475(n):
    return sum(p**e for p, e in factorint(n).items())


def A081403(n):
    return sum(p ** (e << 1) for p, e in factorint(n).items())


def A171453(n):
    return sum(p ** (e - 1) for p, e in factorint(n).items())


def A374140(n):
    return (
        Matrix(
            n, n, [abs(j - k) if j != k else 1 for j in range(n) for k in range(n)]
        ).per()
        if n
        else 1
    )


def A374139(n):
    return Matrix(
        n, n, [abs(j - k) if j != k else 1 for j in range(n) for k in range(n)]
    ).det()


def A374070(n):
    return (
        Matrix(
            n,
            n,
            [
                composite(abs(j - k)) if j != k else 0
                for j in range(n)
                for k in range(n)
            ],
        ).per()
        if n
        else 1
    )


def A071081(n):
    return Matrix(
        n,
        n,
        [composite(abs(j - k)) if j != k else 0 for j in range(n) for k in range(n)],
    ).det()


@lru_cache(maxsize=None)
def A000198(n):
    if n <= 7:
        return (1, 1, 3, 3, 5, 9, 21)[n - 1]
    if (r := n % 9) in {0, 3, 6}:
        return 3 ** (m := n // 3) * A000198(m)
    elif r in {1, 2, 4}:
        return A000198(n - 1)
    elif r == 5:
        return max(A000198(n - 2), 5 * A000198(n - 5), 21 * A000198(n - 7))
    elif r == 7:
        return 21 * A000198(n - 7)
    elif r == 8:
        return max(A000198(n - 1), 5 * A000198(n - 5))


def A000568(n):
    return int(
        sum(
            Fraction(
                1
                << (
                    sum(p[r] * p[s] * gcd(r, s) for r, s in product(p.keys(), repeat=2))
                    - sum(p.values())
                    >> 1
                ),
                prod(q ** p[q] * factorial(p[q]) for q in p),
            )
            for p in partitions(n)
            if all(q & 1 for q in p)
        )
    )


def A151879(n):
    return int(
        sum(
            Fraction(
                1
                << (
                    sum(p[r] * p[s] * lcm(r, s) for r, s in product(p.keys(), repeat=2))
                    - sum(p.values())
                    >> 1
                ),
                prod(q ** p[q] * factorial(p[q]) for q in p),
            )
            for p in partitions(n)
            if all(q & 1 for q in p)
        )
    )


def A093934(n):
    return int(
        sum(
            Fraction(
                1
                << (
                    sum(p[r] * p[s] * gcd(r, s) for r, s in product(p.keys(), repeat=2))
                    + sum(p.values())
                    >> 1
                ),
                prod(q ** p[q] * factorial(p[q]) for q in p),
            )
            for p in partitions(n)
            if all(q & 1 for q in p)
        )
    )


def A007150(n):
    return (
        ~(
            m := int(
                sum(
                    Fraction(
                        1
                        << (
                            sum(
                                p[r] * p[s] * gcd(r, s)
                                for r, s in product(p.keys(), repeat=2)
                            )
                            - sum(p.values())
                            >> 1
                        ),
                        prod(q ** p[q] * factorial(p[q]) for q in p),
                    )
                    for p in partitions(n)
                    if all(q & 1 for q in p)
                )
            )
        )
        & m - 1
    ).bit_length()


def A374257(n):
    return (
        next(m for m in count(1) if len(list(power_representation(m, n, n))) == 3)
        if n > 1
        else -1
    )


@lru_cache(maxsize=None)
def A002638(n):
    return (
        A000568(n)
        - sum(
            A002638(d) * A000568(n // d)
            for d in divisors(n, generator=True)
            if 1 < d < n
        )
        if n > 1
        else -1
    )


def A259105(n):
    return sum(mobius(d) * A000568(n // d) for d in divisors(n, generator=True))


def A259106(n):
    return A002638(n) + mobius(n)


def A000595(n):
    return int(
        sum(
            Fraction(
                1
                << sum(p[r] * p[s] * gcd(r, s) for r, s in product(p.keys(), repeat=2)),
                prod(q ** p[q] * factorial(p[q]) for q in p),
            )
            for p in partitions(n)
        )
    )


def A000662(n):
    return int(
        sum(
            Fraction(
                1
                << sum(
                    r * s * t // lcm(r, s, t) * p[r] * p[s] * p[t]
                    for r, s, t in product(p.keys(), repeat=3)
                ),
                prod(q ** p[q] * factorial(p[q]) for q in p),
            )
            for p in partitions(n)
        )
    )


def A001377(n):
    return int(
        sum(
            Fraction(
                1
                << sum(
                    prod(r) // lcm(*r) * prod(p[d] for d in r)
                    for r in product(p.keys(), repeat=4)
                ),
                prod(q ** p[q] * factorial(p[q]) for q in p),
            )
            for p in partitions(n)
        )
    )


def A051241(n):
    return int(
        sum(
            Fraction(
                1
                << sum(
                    prod(r) // lcm(*r) * prod(p[d] for d in r)
                    for r in product(p.keys(), repeat=5)
                ),
                prod(q ** p[q] * factorial(p[q]) for q in p),
            )
            for p in partitions(n)
        )
    )


def A001173(n):
    return (
        int(
            sum(
                Fraction(
                    1
                    << sum(
                        p[r] * p[s] * gcd(r, s) for r, s in product(p.keys(), repeat=2)
                    ),
                    prod(q ** p[q] * factorial(p[q]) for q in p),
                )
                for p in partitions(n)
            )
        )
        >> 1
    )


def A000088(n):
    return int(
        sum(
            Fraction(
                1
                << sum(p[r] * p[s] * gcd(r, s) for r, s in combinations(p.keys(), 2))
                + sum((q >> 1) * r + (q * r * (r - 1) >> 1) for q, r in p.items()),
                prod(q**r * factorial(r) for q, r in p.items()),
            )
            for p in partitions(n)
        )
    )


def A007149(n):
    return (
        ~(
            m := int(
                sum(
                    Fraction(
                        1
                        << sum(
                            p[r] * p[s] * gcd(r, s)
                            for r, s in combinations(p.keys(), 2)
                        )
                        + sum(
                            (q >> 1) * r + (q * r * (r - 1) >> 1) for q, r in p.items()
                        ),
                        prod(q**r * factorial(r) for q, r in p.items()),
                    )
                    for p in partitions(n)
                )
            )
        )
        & m - 1
    ).bit_length()


def A116508(n):
    return comb(n * (n - 1) >> 1, n)


def A337518(n):
    return (
        int(
            sum(
                Fraction(
                    1
                    << sum(
                        p[r] * p[s] * gcd(r, s) for r, s in combinations(p.keys(), 2)
                    )
                    + sum((q >> 1) * r + (q * r * (r - 1) >> 1) for q, r in p.items()),
                    prod(q**r * factorial(r) for q, r in p.items()),
                )
                % 3
                for p in partitions(n)
            )
        )
        % 3
    )


def A000666(n):
    return int(
        sum(
            Fraction(
                1
                << sum(p[r] * p[s] * gcd(r, s) for r, s in combinations(p.keys(), 2))
                + sum(
                    ((q >> 1) + 1) * r + (q * r * (r - 1) >> 1) for q, r in p.items()
                ),
                prod(q**r * factorial(r) for q, r in p.items()),
            )
            for p in partitions(n)
        )
    )


def A001349(n):
    if n == 0:
        return 1

    @lru_cache(maxsize=None)
    def b(n):
        return int(
            sum(
                Fraction(
                    1
                    << sum(
                        p[r] * p[s] * gcd(r, s) for r, s in combinations(p.keys(), 2)
                    )
                    + sum((q >> 1) * r + (q * r * (r - 1) >> 1) for q, r in p.items()),
                    prod(q**r * factorial(r) for q, r in p.items()),
                )
                for p in partitions(n)
            )
        )

    @lru_cache(maxsize=None)
    def c(n):
        return n * b(n) - sum(c(k) * b(n - k) for k in range(1, n))

    return sum(mobius(n // d) * c(d) for d in divisors(n, generator=True)) // n


def A327235(n):
    if n == 0:
        return 1

    @lru_cache(maxsize=None)
    def b(n):
        return int(
            sum(
                Fraction(
                    1
                    << sum(
                        p[r] * p[s] * gcd(r, s) for r, s in combinations(p.keys(), 2)
                    )
                    + sum((q >> 1) * r + (q * r * (r - 1) >> 1) for q, r in p.items()),
                    prod(q**r * factorial(r) for q, r in p.items()),
                )
                for p in partitions(n)
            )
        )

    @lru_cache(maxsize=None)
    def c(n):
        return n * b(n) - sum(c(k) * b(n - k) for k in range(1, n))

    def a(n):
        return (
            sum(mobius(n // d) * c(d) for d in divisors(n, generator=True)) // n
            if n
            else 1
        )

    return 1 + b(n) - sum(a(i) for i in range(1, n + 1))


def A327075(n):
    if n <= 1:
        return 1 - n

    @lru_cache(maxsize=None)
    def b(n):
        return int(
            sum(
                Fraction(
                    1
                    << sum(
                        p[r] * p[s] * gcd(r, s) for r, s in combinations(p.keys(), 2)
                    )
                    + sum((q >> 1) * r + (q * r * (r - 1) >> 1) for q, r in p.items()),
                    prod(q**r * factorial(r) for q, r in p.items()),
                )
                for p in partitions(n)
            )
        )

    @lru_cache(maxsize=None)
    def c(n):
        return n * b(n) - sum(c(k) * b(n - k) for k in range(1, n))

    return (
        b(n)
        - b(n - 1)
        - sum(mobius(n // d) * c(d) for d in divisors(n, generator=True)) // n
    )


def A002854(n):
    return int(
        sum(
            Fraction(
                1
                << sum(p[r] * p[s] * gcd(r, s) for r, s in combinations(p.keys(), 2))
                + sum(((q >> 1) - 1) * r + (q * r * (r - 1) >> 1) for q, r in p.items())
                + any(q & 1 for q in p),
                prod(q**r * factorial(r) for q, r in p.items()),
            )
            for p in partitions(n)
        )
    )


def A003049(n):
    @lru_cache(maxsize=None)
    def b(n):
        return int(
            sum(
                Fraction(
                    1
                    << sum(
                        p[r] * p[s] * gcd(r, s) for r, s in combinations(p.keys(), 2)
                    )
                    + sum(
                        ((q >> 1) - 1) * r + (q * r * (r - 1) >> 1)
                        for q, r in p.items()
                    )
                    + any(q & 1 for q in p),
                    prod(q**r * factorial(r) for q, r in p.items()),
                )
                for p in partitions(n)
            )
        )

    @lru_cache(maxsize=None)
    def c(n):
        return n * b(n) - sum(c(k) * b(n - k) for k in range(1, n))

    return sum(mobius(n // d) * c(d) for d in divisors(n, generator=True)) // n


def A002494(n):
    return (
        int(
            sum(
                Fraction(
                    1
                    << sum(
                        p[r] * p[s] * gcd(r, s) for r, s in combinations(p.keys(), 2)
                    )
                    + sum((q >> 1) * r + (q * r * (r - 1) >> 1) for q, r in p.items()),
                    prod(q**r * factorial(r) for q, r in p.items()),
                )
                for p in partitions(n)
            )
            - sum(
                Fraction(
                    1
                    << sum(
                        p[r] * p[s] * gcd(r, s) for r, s in combinations(p.keys(), 2)
                    )
                    + sum((q >> 1) * r + (q * r * (r - 1) >> 1) for q, r in p.items()),
                    prod(q**r * factorial(r) for q, r in p.items()),
                )
                for p in partitions(n - 1)
            )
        )
        if n
        else 1
    )


def A000719(n):
    if n == 0:
        return 0

    @lru_cache(maxsize=None)
    def b(n):
        return int(
            sum(
                Fraction(
                    1
                    << sum(
                        p[r] * p[s] * gcd(r, s) for r, s in combinations(p.keys(), 2)
                    )
                    + sum((q >> 1) * r + (q * r * (r - 1) >> 1) for q, r in p.items()),
                    prod(q**r * factorial(r) for q, r in p.items()),
                )
                for p in partitions(n)
            )
        )

    @lru_cache(maxsize=None)
    def c(n):
        return n * b(n) - sum(c(k) * b(n - k) for k in range(1, n))

    return b(n) - sum(mobius(n // d) * c(d) for d in divisors(n, generator=True)) // n


def A139415(n):
    if n == 0:
        return 0

    @lru_cache(maxsize=None)
    def b(n):
        return int(
            sum(
                Fraction(
                    1
                    << sum(
                        p[r] * p[s] * gcd(r, s) for r, s in combinations(p.keys(), 2)
                    )
                    + sum((q >> 1) * r + (q * r * (r - 1) >> 1) for q, r in p.items()),
                    prod(q**r * factorial(r) for q, r in p.items()),
                )
                for p in partitions(n)
            )
        )

    @lru_cache(maxsize=None)
    def c(n):
        return n * b(n) - sum(c(k) * b(n - k) for k in range(1, n))

    return (
        b(n) - sum(mobius(n // d) * c(d) for d in divisors(n, generator=True)) // n
        << n - 1
    )


def A324461(n):
    return (
        sum(
            mobius(m := n // d) << (n * (d - 1) >> 1) + d * (m >> 1)
            for d in divisors(n, generator=True)
        )
        if n
        else 1
    )


def A216785(n):
    @lru_cache(maxsize=None)
    def b(n):
        return int(
            sum(
                Fraction(
                    1
                    << sum(
                        p[r] * p[s] * gcd(r, s) for r, s in combinations(p.keys(), 2)
                    )
                    + sum((q >> 1) * r + (q * r * (r - 1) >> 1) for q, r in p.items()),
                    prod(q**r * factorial(r) for q, r in p.items()),
                )
                for p in partitions(n)
            )
        )

    @lru_cache(maxsize=None)
    def c(n):
        return n * b(n) - sum(c(k) * b(n - k) for k in range(1, n))

    @lru_cache(maxsize=None)
    def d(n):
        return sum(mobius(n // d) * c(d) for d in divisors(n, generator=True)) // n

    return sum(d(i) * d(n - i) for i in range(1, n + 1 >> 1)) + (
        0 if n & 1 else comb(d(n >> 1), 2)
    )


def A275166(n):
    @lru_cache(maxsize=None)
    def b(n):
        return int(
            sum(
                Fraction(
                    1
                    << sum(
                        p[r] * p[s] * gcd(r, s) for r, s in combinations(p.keys(), 2)
                    )
                    + sum((q >> 1) * r + (q * r * (r - 1) >> 1) for q, r in p.items()),
                    prod(q**r * factorial(r) for q, r in p.items()),
                )
                for p in partitions(n)
            )
        )

    @lru_cache(maxsize=None)
    def c(n):
        return n * b(n) - sum(c(k) * b(n - k) for k in range(1, n))

    @lru_cache(maxsize=None)
    def d(n):
        return (
            sum(mobius(n // d) * c(d) for d in divisors(n, generator=True)) // n
            if n
            else 1
        )

    return sum(d(i) * d(n - i) for i in range(n + 1 >> 1)) + (
        0 if n & 1 else comb(d(n >> 1), 2)
    )


def A275165(n):
    @lru_cache(maxsize=None)
    def b(n):
        return int(
            sum(
                Fraction(
                    1
                    << sum(
                        p[r] * p[s] * gcd(r, s) for r, s in combinations(p.keys(), 2)
                    )
                    + sum((q >> 1) * r + (q * r * (r - 1) >> 1) for q, r in p.items()),
                    prod(q**r * factorial(r) for q, r in p.items()),
                )
                for p in partitions(n)
            )
        )

    @lru_cache(maxsize=None)
    def c(n):
        return n * b(n) - sum(c(k) * b(n - k) for k in range(1, n))

    @lru_cache(maxsize=None)
    def d(n):
        return (
            sum(mobius(n // d) * c(d) for d in divisors(n, generator=True)) // n
            if n
            else 1
        )

    return sum(d(i) * d(n - i) for i in range(n + 1 >> 1)) + (
        0 if n & 1 else comb(d(n >> 1) + 1, 2)
    )


def A334335(n):
    @lru_cache(maxsize=None)
    def b(n):
        return int(
            sum(
                Fraction(
                    1
                    << (
                        sum(
                            p[r] * p[s] * gcd(r, s)
                            for r, s in product(p.keys(), repeat=2)
                        )
                        - sum(p.values())
                        >> 1
                    ),
                    prod(q ** p[q] * factorial(p[q]) for q in p),
                )
                for p in partitions(n)
                if all(q & 1 for q in p)
            )
        )

    @lru_cache(maxsize=None)
    def c(n):
        return n * b(n) - sum(c(k) * b(n - k) for k in range(1, n))

    return sum(mobius(n // d) * c(d) for d in divisors(n, generator=True)) // n


def A367142(n):
    if n == 0:
        return 1

    @lru_cache(maxsize=None)
    def b(n):
        return int(
            sum(
                Fraction(
                    1
                    << sum(
                        p[r] * p[s] * gcd(r, s) for r, s in combinations(p.keys(), 2)
                    )
                    + sum((q >> 1) * r + (q * r * (r - 1) >> 1) for q, r in p.items()),
                    prod(q**r * factorial(r) for q, r in p.items()),
                )
                for p in partitions(n)
            )
        )

    @lru_cache(maxsize=None)
    def c(n):
        return n * b(n) - sum(c(k) * b(n - k) for k in range(1, n))

    return sum(mobius(n // d) * c(d) for d in divisors(n, generator=True)) // n - b(
        n - 1
    )


def A292300(n):
    @lru_cache(maxsize=None)
    def b(n):
        return int(
            sum(
                Fraction(
                    1
                    << sum(
                        p[r] * p[s] * gcd(r, s) for r, s in combinations(p.keys(), 2)
                    )
                    + sum((q >> 1) * r + (q * r * (r - 1) >> 1) for q, r in p.items()),
                    prod(q**r * factorial(r) for q, r in p.items()),
                )
                for p in partitions(n)
            )
        )

    @lru_cache(maxsize=None)
    def c(n):
        return n * b(n) - sum(c(k) * b(n - k) for k in range(1, n))

    return sum(
        sum(mobius(m // d) * c(d) for d in divisors(m, generator=True)) // m
        for m in range(2, n + 1)
    )


def A241841(n):
    return A001349(n) - A000055(n)


def A158007(n):
    return A001349(n) - A003049(n)


@lru_cache(maxsize=None)
def A007126(n):
    return (
        A000088(n - 1) - sum(A007126(k) * A002854(n - k) for k in range(1, n))
        if n > 1
        else 1
    )


def A136722(n):
    if n == 0:
        return 1

    @lru_cache(maxsize=None)
    def b(n):
        return int(
            sum(
                Fraction(
                    1
                    << sum(
                        p[r] * p[s] * gcd(r, s) for r, s in combinations(p.keys(), 2)
                    )
                    + sum((q >> 1) * r + (q * r * (r - 1) >> 1) for q, r in p.items()),
                    prod(q**r * factorial(r) for q, r in p.items()),
                )
                for p in partitions(n)
            )
        )

    @lru_cache(maxsize=None)
    def c(n):
        return n * b(n) - sum(c(k) * b(n - k) for k in range(1, n))

    return sum(mobius(n // d) * c(d) for d in divisors(n, generator=True)) // n << n - 1


def A054915(n):
    @lru_cache(maxsize=None)
    def b(n):
        return int(
            sum(
                Fraction(
                    1
                    << sum(
                        p[r] * p[s] * gcd(r, s) for r, s in combinations(p.keys(), 2)
                    )
                    + sum((q >> 1) * r + (q * r * (r - 1) >> 1) for q, r in p.items()),
                    prod(q**r * factorial(r) for q, r in p.items()),
                )
                for p in partitions(n)
            )
        )

    @lru_cache(maxsize=None)
    def c(n):
        return n * b(n) - sum(c(k) * b(n - k) for k in range(1, n))

    return (
        sum(mobius(n // d) * c(d) for d in divisors(n, generator=True)) // n << 1
    ) - b(n)


def A367143(n):
    return A000088(n) - (A000088(n - 1) << 1) if n > 1 else 1 - n


def A133736(n):
    return sum(A003049(i) for i in range(1, n + 1))


def A374322(n):
    return isqrt(10 ** (n - 1 << 1) * 96059601 // 9732872) % 10


def A027852(n):
    return sum(A000081(k) * A000081(n - k) for k in range(1, n + 1 >> 1)) + (
        0 if n & 1 else comb(A000081(n >> 1) + 1, 2)
    )


def A000106(n):
    return (sum(A000081(k) * A000081(n - k) for k in range(1, n + 1 >> 1)) << 1) + (
        0 if n & 1 else A000081(n >> 1) ** 2
    )


def A343935(n):
    return comb(divisor_count(n) + n - 1, n)


def A163767(n):
    return prod(comb(n + e - 1, e) for e in factorint(n).values())


def A060690(n):
    return comb((1 << n) + n - 1, n)


def A000273(n):
    return int(
        sum(
            Fraction(
                1
                << sum(
                    p[r] * p[s] * gcd(r, s) << 1 for r, s in combinations(p.keys(), 2)
                )
                + sum(r * (q * r - 1) for q, r in p.items()),
                prod(q**r * factorial(r) for q, r in p.items()),
            )
            for p in partitions(n)
        )
    )


def A053763(n):
    return 1 << n * (n - 1)


def A309980(n):
    return A000595(n) - (A000273(n) << 1)


def A199012(n):
    return (n * (n - 1) >> 1) * int(
        sum(
            Fraction(
                1
                << sum(
                    p[r] * p[s] * gcd(r, s) << 1 for r, s in combinations(p.keys(), 2)
                )
                + sum(r * (q * r - 1) for q, r in p.items()),
                prod(q**r * factorial(r) for q, r in p.items()),
            )
            for p in partitions(n)
        )
    )


def A127909(n):
    return int(
        sum(
            Fraction(
                (
                    1
                    << sum(
                        p[r] * p[s] * gcd(r, s) << 1
                        for r, s in combinations(p.keys(), 2)
                    )
                    + sum(r * (q * r - 1) for q, r in p.items())
                )
                - (
                    1
                    << sum(
                        p[r] * p[s] * gcd(r, s) for r, s in combinations(p.keys(), 2)
                    )
                    + sum((q >> 1) * r + (q * r * (r - 1) >> 1) for q, r in p.items())
                ),
                prod(q**r * factorial(r) for q, r in p.items()),
            )
            for p in partitions(n)
        )
    )


def A003085(n):
    @lru_cache(maxsize=None)
    def b(n):
        return int(
            sum(
                Fraction(
                    1
                    << sum(
                        p[r] * p[s] * gcd(r, s) << 1
                        for r, s in combinations(p.keys(), 2)
                    )
                    + sum(r * (q * r - 1) for q, r in p.items()),
                    prod(q**r * factorial(r) for q, r in p.items()),
                )
                for p in partitions(n)
            )
        )

    @lru_cache(maxsize=None)
    def c(n):
        return n * b(n) - sum(c(k) * b(n - k) for k in range(1, n))

    return sum(mobius(n // d) * c(d) for d in divisors(n, generator=True)) // n


def A054918(n):
    @lru_cache(maxsize=None)
    def b(n):
        return int(
            sum(
                Fraction(
                    1
                    << sum(
                        p[r] * p[s] * gcd(r, s) << 1
                        for r, s in combinations(p.keys(), 2)
                    )
                    + sum(r * (q * r - 1) for q, r in p.items()),
                    prod(q**r * factorial(r) for q, r in p.items()),
                )
                for p in partitions(n)
            )
        )

    @lru_cache(maxsize=None)
    def c(n):
        return n * b(n) - sum(c(k) * b(n - k) for k in range(1, n))

    return (
        sum(mobius(n // d) * c(d) for d in divisors(n, generator=True)) // n << 1
    ) - b(n)


def A054590(n):
    @lru_cache(maxsize=None)
    def b(n):
        return int(
            sum(
                Fraction(
                    1
                    << sum(
                        p[r] * p[s] * gcd(r, s) << 1
                        for r, s in combinations(p.keys(), 2)
                    )
                    + sum(r * (q * r - 1) for q, r in p.items()),
                    prod(q**r * factorial(r) for q, r in p.items()),
                )
                for p in partitions(n)
            )
        )

    @lru_cache(maxsize=None)
    def c(n):
        return n * b(n) - sum(c(k) * b(n - k) for k in range(1, n))

    return b(n) - sum(mobius(n // d) * c(d) for d in divisors(n, generator=True)) // n


def A053598(n):
    return (
        int(
            sum(
                Fraction(
                    1
                    << sum(
                        p[r] * p[s] * gcd(r, s) << 1
                        for r, s in combinations(p.keys(), 2)
                    )
                    + sum(r * (q * r - 1) for q, r in p.items()),
                    prod(q**r * factorial(r) for q, r in p.items()),
                )
                for p in partitions(n)
            )
        )
        - int(
            sum(
                Fraction(
                    1
                    << sum(
                        p[r] * p[s] * gcd(r, s) << 1
                        for r, s in combinations(p.keys(), 2)
                    )
                    + sum(r * (q * r - 1) for q, r in p.items()),
                    prod(q**r * factorial(r) for q, r in p.items()),
                )
                for p in partitions(n - 1)
            )
        )
        if n
        else 1
    )


def A003083(n):
    return sum(d * A001349(d) for d in divisors(n, generator=True))


def A001616(n):
    return prod(p ** (e >> 1) + p ** (e - 1 >> 1) for p, e in factorint(n).items())


def A372866_gen():  # generator of terms
    c = 0
    for n in count(1):
        c += prod(p ** (e >> 1) + p ** (e - 1 >> 1) for p, e in factorint(n).items())
        yield c


def A007427(n):
    return prod(-comb(2, e) if e & 1 else comb(2, e) for e in factorint(n).values())


def A374367(n):
    return mobius(n) * (0, 1, 0, -1)[n & 3]


def A374357(n):
    return integer_nthroot(109 * 10 ** (5 * (n - 1)), 5)[0] % 10


def A374366(n):
    a = 0
    for p in primefactors(n >> (~n & n - 1).bit_length()):
        if p & 2:
            a += 1
        else:
            return 0
    return 1 << a


def A005091(n):
    return sum(1 for p in primefactors(n) if p & 3 == 3)


def A072592_gen(startvalue=1):  # generator of terms >= startvalue
    return (
        n << 1
        for n in count(max(startvalue, 1))
        if any(p & 3 == 1 for p in primefactors(n))
    )


def A373098(n):
    return n * pow(2, n, 10) % 10


def A374084(n):
    return (n * (n + 1) + 4 if n & 1 else n * (n + 3)) >> 1


def A372914(n):
    return isqrt(27 * 10 ** (n + 1 << 1) // 169) % 10


def A372912(n):
    return isqrt(12 * 10 ** (n + 1 << 1) // 49) % 10


def A373859(n):
    return (
        next(p for p in ((n + 1) * 10**m - 1 for m in count(1)) if isprime(p))
        if n % 3
        else -1
    )


if sys.version_info >= (3, 10):

    def A374178(n):
        p = 2
        while q := nextprime(p):
            if (p & q).bit_count() == n:
                return p
            p = q

    def A374179(n):
        p, pb = 2, 2
        while q := nextprime(p):
            if pb == (qb := q.bit_length()) and (p ^ q).bit_count() == n:
                return p
            p, pb = q, qb

else:

    def A374178(n):
        p = 2
        while q := nextprime(p):
            if bin(p & q).count("1") == n:
                return p
            p = q

    def A374179(n):
        p, pb = 2, 2
        while q := nextprime(p):
            if pb == (qb := q.bit_length()) and bin(p ^ q).count("1") == n:
                return p
            p, pb = q, qb


def A374362(n):
    return int(gmpy2digits(n, 3).replace("1", "0").replace("2", "1"), 3)


def A004107(n):
    return int(
        sum(
            Fraction(
                3
                ** (
                    (
                        sum(
                            p[r] * p[s] * gcd(r, s)
                            for r, s in combinations(p.keys(), 2)
                        )
                        << 1
                    )
                    + sum(((q & -2) + q * (r - 1)) * r for q, r in p.items())
                ),
                prod(q**r * factorial(r) for q, r in p.items()),
            )
            for p in partitions(n)
        )
    )


def A004103(n):
    return int(
        sum(
            Fraction(
                3
                ** (
                    sum(p[r] * p[s] * gcd(r, s) for r, s in combinations(p.keys(), 2))
                    + sum((q >> 1) * r + (q * r * (r - 1) >> 1) for q, r in p.items())
                )
                << s,
                prod(q**r * factorial(r) for q, r in p.items()),
            )
            for s, p in partitions(n, size=True)
        )
    )


def A004102(n):
    return int(
        sum(
            Fraction(
                3
                ** (
                    sum(p[r] * p[s] * gcd(r, s) for r, s in combinations(p.keys(), 2))
                    + sum((q >> 1) * r + (q * r * (r - 1) >> 1) for q, r in p.items())
                ),
                prod(q**r * factorial(r) for q, r in p.items()),
            )
            for p in partitions(n)
        )
    )


def A004104(n):
    return int(
        sum(
            Fraction(
                3
                ** (
                    sum(
                        p[r] * p[s] * gcd(r, s)
                        for r, s in combinations(p.keys(), 2)
                        if not (r & 1 and s & 1)
                    )
                    + sum(
                        ((q >> 1) & -2) * r + (q * r * (r - 1) >> 1)
                        for q, r in p.items()
                        if q & 1 ^ 1
                    )
                ),
                prod(q**r * factorial(r) for q, r in p.items()),
            )
            for p in partitions(n)
        )
    )


def A052111(n):
    return int(
        sum(
            Fraction(
                3
                ** (
                    sum(
                        p[r] * p[s] * gcd(r, s)
                        for r, s in combinations(p.keys(), 2)
                        if not (r & 1 and s & 1)
                    )
                    + sum(
                        ((q >> 1) | 1) * r + (q * r * (r - 1) >> 1)
                        for q, r in p.items()
                        if q & 1 ^ 1
                    )
                ),
                prod(q**r * factorial(r) for q, r in p.items()),
            )
            for p in partitions(n)
        )
    )


def A053513(n):
    return int(
        sum(
            Fraction(
                3
                ** (
                    sum(p[r] * p[s] * gcd(r, s) for r, s in combinations(p.keys(), 2))
                    + sum(
                        ((q >> 1) + 1) * r + (q * r * (r - 1) >> 1)
                        for q, r in p.items()
                    )
                ),
                prod(q**r * factorial(r) for q, r in p.items()),
            )
            for p in partitions(n)
        )
    )


def A358497(n):
    s, c, i = str(n), {}, 49
    for d in map(ord, s):
        if d not in c:
            c[d] = i
            i += 1
    return int(s.translate(c))


def A374238_gen():  # generator of terms
    for l in count(1):
        p, q, a, b = nextprime(10 ** (l - 1)), 10**l, set(), {}
        while p < q:
            s, c, i = str(p), {}, 49
            for d in map(ord, s):
                if d not in c:
                    c[d] = i
                    i += 1
            m = int(s.translate(c))
            if m in b:
                if b[m] != False:
                    a.remove(b[m])
                b[m] = False
            else:
                b[m] = p
                a.add(p)
            p = nextprime(p)
        yield from sorted(a)


def A053514(n):
    return int(
        sum(
            Fraction(
                1
                << (
                    sum(p[r] * p[s] * gcd(r, s) for r, s in combinations(p.keys(), 2))
                    + sum(
                        ((q >> 1) + 1) * r + (q * r * (r - 1) >> 1)
                        for q, r in p.items()
                    )
                    << 1
                ),
                prod(q**r * factorial(r) for q, r in p.items()),
            )
            for p in partitions(n)
        )
    )


def A053400(n):
    return int(
        sum(
            Fraction(
                1
                << (
                    sum(p[r] * p[s] * gcd(r, s) for r, s in combinations(p.keys(), 2))
                    + sum((q >> 1) * r + (q * r * (r - 1) >> 1) for q, r in p.items())
                    << 1
                ),
                prod(q**r * factorial(r) for q, r in p.items()),
            )
            for p in partitions(n)
        )
    )


def A053420(n):
    return int(
        sum(
            Fraction(
                5
                ** (
                    sum(p[r] * p[s] * gcd(r, s) for r, s in combinations(p.keys(), 2))
                    + sum((q >> 1) * r + (q * r * (r - 1) >> 1) for q, r in p.items())
                ),
                prod(q**r * factorial(r) for q, r in p.items()),
            )
            for p in partitions(n)
        )
    )


def A053421(n):
    return int(
        sum(
            Fraction(
                6
                ** (
                    sum(p[r] * p[s] * gcd(r, s) for r, s in combinations(p.keys(), 2))
                    + sum((q >> 1) * r + (q * r * (r - 1) >> 1) for q, r in p.items())
                ),
                prod(q**r * factorial(r) for q, r in p.items()),
            )
            for p in partitions(n)
        )
    )


def A063841_T(n, k):
    return int(
        sum(
            Fraction(
                (k + 1)
                ** (
                    sum(p[r] * p[s] * gcd(r, s) for r, s in combinations(p.keys(), 2))
                    + sum((q >> 1) * r + (q * r * (r - 1) >> 1) for q, r in p.items())
                ),
                prod(q**r * factorial(r) for q, r in p.items()),
            )
            for p in partitions(n)
        )
    )


def A327084_T(n, k):
    return int(
        sum(
            Fraction(
                k
                ** (
                    sum(p[r] * p[s] * gcd(r, s) for r, s in combinations(p.keys(), 2))
                    + sum((q >> 1) * r + (q * r * (r - 1) >> 1) for q, r in p.items())
                ),
                prod(q**r * factorial(r) for q, r in p.items()),
            )
            for p in partitions(n + 1)
        )
    )


def A374522(n):
    return n * (comb((n << 2), n) - 1)


def A066383(n):
    return sum(comb(comb(n + 1, 2), k) for k in range(n + 1))


def A054921(n):
    @lru_cache(maxsize=None)
    def b(n):
        return int(
            sum(
                Fraction(
                    1
                    << sum(
                        p[r] * p[s] * gcd(r, s) for r, s in combinations(p.keys(), 2)
                    )
                    + sum(
                        ((q >> 1) + 1) * r + (q * r * (r - 1) >> 1)
                        for q, r in p.items()
                    ),
                    prod(q**r * factorial(r) for q, r in p.items()),
                )
                for p in partitions(n)
            )
        )

    @lru_cache(maxsize=None)
    def c(n):
        return n * b(n) - sum(c(k) * b(n - k) for k in range(1, n))

    return (
        sum(mobius(d) * c(n // d) for d in divisors(n, generator=True)) // n if n else 1
    )


def A054922(n):
    @lru_cache(maxsize=None)
    def b(n):
        return int(
            sum(
                Fraction(
                    1
                    << sum(
                        p[r] * p[s] * gcd(r, s) for r, s in combinations(p.keys(), 2)
                    )
                    + sum(
                        ((q >> 1) + 1) * r + (q * r * (r - 1) >> 1)
                        for q, r in p.items()
                    ),
                    prod(q**r * factorial(r) for q, r in p.items()),
                )
                for p in partitions(n)
            )
        )

    @lru_cache(maxsize=None)
    def c(n):
        return n * b(n) - sum(c(k) * b(n - k) for k in range(1, n))

    return (
        sum(mobius(d) * c(n // d) for d in divisors(n, generator=True)) // n << 1
    ) - b(n)


def A004106(n):
    return int(
        sum(
            Fraction(
                3
                ** (
                    sum(
                        p[r] * p[s] * gcd(r, s)
                        for r, s in combinations(p.keys(), 2)
                        if not (r & 1 and s & 1)
                    )
                    + sum(
                        ((q >> 1) & -2) * r + (q * r * (r - 1) >> 1)
                        for q, r in p.items()
                        if q & 1 ^ 1
                    )
                )
                << s,
                prod(q**r * factorial(r) for q, r in p.items()),
            )
            for s, p in partitions(n, size=True)
        )
    )


def A004105(n):
    return int(
        sum(
            Fraction(
                3
                ** (
                    (
                        sum(
                            p[r] * p[s] * gcd(r, s)
                            for r, s in combinations(p.keys(), 2)
                        )
                        << 1
                    )
                    + sum(q * r**2 for q, r in p.items())
                ),
                prod(q**r * factorial(r) for q, r in p.items()),
            )
            for p in partitions(n)
        )
    )


def A001374(n):
    return int(
        sum(
            Fraction(
                1
                << (
                    (
                        sum(
                            p[r] * p[s] * gcd(r, s)
                            for r, s in combinations(p.keys(), 2)
                        )
                        << 1
                    )
                    + sum(q * r**2 for q, r in p.items())
                    << 1
                ),
                prod(q**r * factorial(r) for q, r in p.items()),
            )
            for p in partitions(n)
        )
    )


def A053468(n):
    return int(
        sum(
            Fraction(
                1
                << (
                    (
                        sum(
                            p[r] * p[s] * gcd(r, s)
                            for r, s in combinations(p.keys(), 2)
                        )
                        << 1
                    )
                    + sum(q * r**2 for q, r in p.items())
                    - s
                    << 1
                ),
                prod(q**r * factorial(r) for q, r in p.items()),
            )
            for s, p in partitions(n, size=True)
        )
    )


def A053467(n):
    return int(
        sum(
            Fraction(
                3
                ** (
                    (
                        sum(
                            p[r] * p[s] * gcd(r, s)
                            for r, s in combinations(p.keys(), 2)
                        )
                        << 1
                    )
                    + sum(q * r**2 for q, r in p.items())
                    - s
                ),
                prod(q**r * factorial(r) for q, r in p.items()),
            )
            for s, p in partitions(n, size=True)
        )
    )


def A373745(n):
    s = bin(prime(n))[2:]
    return next(
        i
        for i in range(len(s), 0, -1)
        if ("01" * (i + 1 >> 1))[:i] in s or ("10" * (i + 1 >> 1))[:i] in s
    )


def A374176(n):
    s = bin(n)[2:]
    return next(
        i - 1
        for i in range(len(s), 0, -1)
        if ("01" * (i + 1 >> 1))[:i] in s or ("10" * (i + 1 >> 1))[:i] in s
    )


def A246008_gen():  # generator of terms
    a, b, k = 0, 1, 2
    yield 0
    while True:
        yield b
        a, b = b, int(
            (c := k - x) * x + int(str(c)[-2::-1] or 0)
            if (k := k + b - a) < (x := 10 ** (len(str(k >> 1)) - 1)) + (y := 10 * x)
            else (c := k - y) * y + int(str(c)[::-1] or 0)
        )


def A186698(n):
    return int(
        nextprime(
            (c := n + 1 - x) * x + int(str(c)[-2::-1] or 0)
            if n + 1 < (x := 10 ** (len(str(n + 1 >> 1)) - 1)) + (y := 10 * x)
            else (c := n + 1 - y) * y + int(str(c)[::-1] or 0)
        )
    )


def A110786(n):
    s = str(
        (c := n + 1 - x) * x + int(str(c)[-2::-1] or 0)
        if n + 1 < (x := 10 ** (len(str(n + 1 >> 1)) - 1)) + (y := 10 * x)
        else (c := n + 1 - y) * y + int(str(c)[::-1] or 0)
    )
    for k in count(2):
        if isprime(
            pq := int(
                s
                + str(
                    (c := k - x) * x + int(str(c)[-2::-1] or 0)
                    if k < (x := 10 ** (len(str(k >> 1)) - 1)) + (y := 10 * x)
                    else (c := k - y) * y + int(str(c)[::-1] or 0)
                )
            )
        ):
            return pq


def A110787(n):
    s = str(
        (c := n + 1 - x) * x + int(str(c)[-2::-1] or 0)
        if n + 1 < (x := 10 ** (len(str(n + 1 >> 1)) - 1)) + (y := 10 * x)
        else (c := n + 1 - y) * y + int(str(c)[::-1] or 0)
    )
    for k in count(2):
        if isprime(
            int(
                s
                + str(
                    q := (
                        (c := k - x) * x + int(str(c)[-2::-1] or 0)
                        if k < (x := 10 ** (len(str(k >> 1)) - 1)) + (y := 10 * x)
                        else (c := k - y) * y + int(str(c)[::-1] or 0)
                    )
                )
            )
        ):
            return int(q)


def A373733(n):
    return comb(comb(n + 2, 3) + 1, 2)


def A028401(n):
    return ((m := 1 << n - 3) + 1) * ((m << 1) + 1) if n > 2 else 3


def A083145(n):
    p = (
        (c := n + 1 - x) * x + int(str(c)[-2::-1] or 0)
        if n + 1 < (x := 10 ** (len(str(n + 1 >> 1)) - 1)) + (y := 10 * x)
        else (c := n + 1 - y) * y + int(str(c)[::-1] or 0)
    )
    for i in count(n + 2):
        if (
            not (
                q := (
                    (c := i - x) * x + int(str(c)[-2::-1] or 0)
                    if i < (x := 10 ** (len(str(i >> 1)) - 1)) + (y := 10 * x)
                    else (c := i - y) * y + int(str(c)[::-1] or 0)
                )
            )
            % p
        ):
            return q


def A083146(n):
    p = (
        (c := n + 1 - x) * x + int(str(c)[-2::-1] or 0)
        if n + 1 < (x := 10 ** (len(str(n + 1 >> 1)) - 1)) + (y := 10 * x)
        else (c := n + 1 - y) * y + int(str(c)[::-1] or 0)
    )
    for i in count(n + 2):
        if not (
            q := (
                (c := i - x) * x + int(str(c)[-2::-1] or 0)
                if i < (x := 10 ** (len(str(i >> 1)) - 1)) + (y := 10 * x)
                else (c := i - y) * y + int(str(c)[::-1] or 0)
            )
        ) % p and (s := str(q)) != (t := str(p)) * (len(s) // len(t)):
            return q


def A119368_gen():  # generator of terms
    for n in count(2):
        p = (
            (c := n - x) * x + int(str(c)[-2::-1] or 0)
            if n < (x := 10 ** (len(str(n >> 1)) - 1)) + (y := 10 * x)
            else (c := n - y) * y + int(str(c)[::-1] or 0)
        )
        for i in count(n + 1):
            if (
                not (
                    q := (
                        (c := i - x) * x + int(str(c)[-2::-1] or 0)
                        if i < (x := 10 ** (len(str(i >> 1)) - 1)) + (y := 10 * x)
                        else (c := i - y) * y + int(str(c)[::-1] or 0)
                    )
                )
                % p
            ):
                if (s := str(q)) == (t := str(p)) * (len(s) // len(t)):
                    yield p
                break


def A049417(n):
    return prod(
        p ** (1 << i) + 1
        for p, e in factorint(n).items()
        for i, j in enumerate(bin(e)[-1:1:-1])
        if j == "1"
    )


def A374539(n):
    return prod(
        p ** (1 << i) + 1
        for p, e in factorint(n).items()
        for i, j in enumerate(bin(e)[-1:1:-1], 1)
        if j == "1"
    )


def A087386(n):
    q = (
        (c := n + 1 - x) * x + int(str(c)[-2::-1] or 0)
        if n + 1 < (x := 10 ** (len(str(n + 1 >> 1)) - 1)) + (y := 10 * x)
        else (c := n + 1 - y) * y + int(str(c)[::-1] or 0)
    )
    return next(p for p in count(q + 1, q) if isprime(p))


def A087387_gen():  # generator of terms
    for n in count(2):
        q = (
            (c := n - x) * x + int(str(c)[-2::-1] or 0)
            if n < (x := 10 ** (len(str(n >> 1)) - 1)) + (y := 10 * x)
            else (c := n - y) * y + int(str(c)[::-1] or 0)
        )
        r = next(p for p in count(q + 1, q) if isprime(p))
        if (s := str(r))[: (t := len(s) + 1 >> 1)] == s[: -t - 1 : -1]:
            yield r


def A085054(n):
    s = str(
        (c := n - x) * x + int(str(c)[-2::-1] or 0)
        if n < (x := 10 ** (len(str(n >> 1)) - 1)) + (y := 10 * x)
        else (c := n - y) * y + int(str(c)[::-1] or 0)
    )
    for k in count(n):
        p = (
            (c := k - x) * x + int(str(c)[-2::-1] or 0)
            if k < (x := 10 ** (len(str(k >> 1)) - 1)) + (y := 10 * x)
            else (c := k - y) * y + int(str(c)[::-1] or 0)
        )
        if s in str(p) and isprime(p):
            return p


def A328151(n):
    return next(
        m for m in ((k**2 << 1) if n & 1 else k for k in count(0)) if A063725(m) == n
    )


def A351307(n):
    return prod(
        (p ** (4 + ((e & -2) << 1)) - 1) // (p**4 - 1) for p, e in factorint(n).items()
    )


def A083477(n):
    if n == 1:
        return 2
    q = (
        (c := n + 1 - x) * x + int(str(c)[-2::-1] or 0)
        if n + 1 < (x := 10 ** (len(str(n + 1 >> 1)) - 1)) + (y := 10 * x)
        else (c := n + 1 - y) * y + int(str(c)[::-1] or 0)
    )
    for k in count(n + 2):
        if (
            p := int(
                (c := k - x) * x + int(str(c)[-2::-1] or 0)
                if k < (x := 10 ** (len(str(k >> 1)) - 1)) + (y := 10 * x)
                else (c := k - y) * y + int(str(c)[::-1] or 0)
            )
        ) % q == 1:
            return p


def A374559_gen(startvalue=1):  # generator of terms >= startvalue
    return filter(
        lambda n: max(d := gmpy2digits(n, 7)) <= "3"
        and not (d.count("1") % 3 or (d.count("2") ^ d.count("3")) & 1),
        count(max(startvalue, 1)),
    )


def A374332_gen():  # generator of terms
    a = Fraction(0, 1)
    for n in count(1):
        yield a.numerator
        a = (2 * a + Fraction(1, n)) % 1


def A374333_gen():  # generator of terms
    a = Fraction(0, 1)
    for n in count(1):
        yield a.denominator
        a = (2 * a + Fraction(1, n)) % 1


def A043555(n):
    return len(list(groupby(sympydigits(n, 3)[1:])))


if sys.version_info >= (3, 10):

    def A037834(n):
        return (n ^ (n >> 1)).bit_count() - 1

    def A246960(n):
        return (n ^ (n >> 1)).bit_count() & 3

    def A105500(n):
        return ((n ^ (n >> 1)).bit_count() & 3) + 1

else:

    def A037834(n):
        return bin(n ^ (n >> 1))[3:].count("1")

    def A246960(n):
        return bin(n ^ (n >> 1))[3:].count("1") & 3

    def A105500(n):
        return (bin(n ^ (n >> 1))[3:].count("1") & 3) + 1


def A004273(n):
    return (n << 1) - 1 if n else 0


def A373716(n):
    return A027424(n) - A004273(n)


def A065091(n):
    return prime(n + 1)


def A065090(n):
    return composite(n - 2) if n > 2 else n


def A043556(n):
    return len(list(groupby(sympydigits(n, 4)[1:])))


def A297772(n):
    return len(set(map(lambda x: tuple(x[1]), groupby(sympydigits(n, 4)[1:]))))


def A297770(n):
    return len(set(map(lambda x: tuple(x[1]), groupby(bin(n)[2:]))))


def A297771(n):
    return len(set(map(lambda x: tuple(x[1]), groupby(sympydigits(n, 3)[1:]))))


def A374607(n):
    return (p := n * (n * (1134 * n + 2097) + 1188) + 193) // gcd(
        p, n * (n * (n * (324 * n + 648) + 441) + 117) + 10 << 5
    )


def A374608(n):
    return (q := n * (n * (n * (324 * n + 648) + 441) + 117) + 10 << 5) // gcd(
        n * (n * (1134 * n + 2097) + 1188) + 193, q
    )


def A374580(n):
    return (lambda p, q: p // gcd(p, q))(
        n * (120 * n + 151) + 47, n * (n * (n * (512 * n + 1024) + 712) + 194) + 15
    )


def A374581(n):
    return (lambda p, q: q // gcd(p, q))(
        n * (120 * n + 151) + 47, n * (n * (n * (512 * n + 1024) + 712) + 194) + 15
    )


def A369192(n):
    return sum(comb(comb(n, 2), k) for k in range(n + 1))


def A322700(n):
    return (
        int(
            sum(
                Fraction(
                    1
                    << sum(
                        p[r] * p[s] * gcd(r, s) for r, s in combinations(p.keys(), 2)
                    )
                    + sum(
                        ((q >> 1) + 1) * r + (q * r * (r - 1) >> 1)
                        for q, r in p.items()
                    ),
                    prod(q**r * factorial(r) for q, r in p.items()),
                )
                for p in partitions(n)
            )
            - sum(
                Fraction(
                    1
                    << sum(
                        p[r] * p[s] * gcd(r, s) for r, s in combinations(p.keys(), 2)
                    )
                    + sum(
                        ((q >> 1) + 1) * r + (q * r * (r - 1) >> 1)
                        for q, r in p.items()
                    ),
                    prod(q**r * factorial(r) for q, r in p.items()),
                )
                for p in partitions(n - 1)
            )
        )
        if n
        else 1
    )


def A014068(n):
    return comb(comb(n + 1, 2), n)


def A000250(n):
    return int(
        sum(
            Fraction(
                1
                << sum(p[r] * p[s] * gcd(r, s) for r, s in combinations(p.keys(), 2))
                + sum(((q >> 1) + 1) * r + (q * r * (r - 1) >> 1) for q, r in p.items())
                - 1,
                prod(q**r * factorial(r) for q, r in p.items()),
            )
            for p in partitions(n)
        )
    )


def A001174(n):
    return int(
        sum(
            Fraction(
                3
                ** (
                    sum(p[r] * p[s] * gcd(r, s) for r, s in combinations(p.keys(), 2))
                    + sum(
                        (q - 1 >> 1) * r + (q * r * (r - 1) >> 1) for q, r in p.items()
                    )
                ),
                prod(q**r * factorial(r) for q, r in p.items()),
            )
            for p in partitions(n)
        )
    )


def A086345(n):
    @lru_cache(maxsize=None)
    def b(n):
        return int(
            sum(
                Fraction(
                    3
                    ** (
                        sum(
                            p[r] * p[s] * gcd(r, s)
                            for r, s in combinations(p.keys(), 2)
                        )
                        + sum(
                            (q - 1 >> 1) * r + (q * r * (r - 1) >> 1)
                            for q, r in p.items()
                        )
                    ),
                    prod(q**r * factorial(r) for q, r in p.items()),
                )
                for p in partitions(n)
            )
        )

    @lru_cache(maxsize=None)
    def c(n):
        return n * b(n) - sum(c(k) * b(n - k) for k in range(1, n))

    return (
        sum(mobius(d) * c(n // d) for d in divisors(n, generator=True)) // n if n else 1
    )


def A320779(n):
    @lru_cache(maxsize=None)
    def b(n):
        return divisor_count(n)

    @lru_cache(maxsize=None)
    def c(n):
        return n * b(n) - sum(c(k) * b(n - k) for k in range(1, n))

    return sum(mobius(d) * c(n // d) for d in divisors(n, generator=True)) // n


def A320781(n):
    @lru_cache(maxsize=None)
    def b(n):
        return mobius(n)

    @lru_cache(maxsize=None)
    def c(n):
        return n * b(n) - sum(c(k) * b(n - k) for k in range(1, n))

    return sum(b(d) * c(n // d) for d in divisors(n, generator=True)) // n


@lru_cache(maxsize=None)
def A023894(n):
    @lru_cache(maxsize=None)
    def c(n):
        return sum((p ** (e + 1) - p) // (p - 1) for p, e in factorint(n).items())

    return (c(n) + sum(c(k) * A023894(n - k) for k in range(1, n))) // n if n else 1


@lru_cache(maxsize=None)
def A023893(n):
    @lru_cache(maxsize=None)
    def c(n):
        return sum((p ** (e + 1) - p) // (p - 1) for p, e in factorint(n).items()) + 1

    return (c(n) + sum(c(k) * A023893(n - k) for k in range(1, n))) // n if n else 1


@lru_cache(maxsize=None)
def A007294(n):
    @lru_cache(maxsize=None)
    def a(n):
        return is_square((n << 3) + 1)

    @lru_cache(maxsize=None)
    def c(n):
        return sum(d for d in divisors(n, generator=True) if a(d))

    return (c(n) + sum(c(k) * A007294(n - k) for k in range(1, n))) // n if n else 1


@lru_cache(maxsize=None)
def A003108(n):
    @lru_cache(maxsize=None)
    def a(n):
        return integer_nthroot(n, 3)[1]

    @lru_cache(maxsize=None)
    def c(n):
        return sum(d for d in divisors(n, generator=True) if a(d))

    return (c(n) + sum(c(k) * A003108(n - k) for k in range(1, n))) // n if n else 1


def A370649(n):
    return n * (15 * (n - 1) ** 2 + 1)


def A248733(n):
    return len(gmpy2digits(npartitions(6**n)))


def A373464_gen():  # generator of terms
    p, plist, pset = 1, [], set()
    while True:
        p = nextprime(p)
        for q in plist:
            r = Fraction(q + 1, p + 1)
            q2 = r * (q + 1) - 1
            if q2 < 2:
                break
            if q2.denominator == 1:
                q2 = int(q2)
                if q2 in pset:
                    q3 = r * (q2 + 1) - 1
                    if q3 < 2:
                        break
                    if q3.denominator == 1 and int(q3) in pset:
                        yield p
        plist = [p] + plist
        pset.add(p)


def A373652_gen():  # generator of terms
    for c in count(1):
        g = [prod(i * c + j for j in range(1, c + 1)) for i in range(1, c + 1)]
        yield from filter(
            lambda k: not (k == 1 or isprime(k) or any(1 < gcd(d, k) < k for d in g)),
            range(c**4, (c + 1) ** 4),
        )


def A374625(n):
    return ((1 << (n.bit_length() << 1) + 1) - 2) // 3 - int(bin(n)[2:], 4) if n else 2


def A179888(n):
    return ((1 << (n.bit_length() << 1)) - 1) // 3 + int(bin(n)[2:], 4)


def A374510(n):
    return sum(
        d
        for d, e in Counter(
            sum(s) for s in combinations((m**2 for m in range(1, n + 1)), n >> 1)
        ).items()
        if e == 1
    )


def A374715(n):
    return len(
        {
            i**2 + j**2 + k**2
            for i in range(1, n + 1)
            for j in range(i, n + 1)
            for k in range(j, n + 1)
        }
    )


def A374716(n):
    return len(
        {
            i**2 + j**2 + k**2 + l**2
            for i in range(1, n + 1)
            for j in range(i, n + 1)
            for k in range(j, n + 1)
            for l in range(k, n + 1)
        }
    )


def A115637(n):
    return int(bin((~(n + 2)) ^ (-1 << (n + 2).bit_length()))[2:], 4)


def A115638(n):
    return int(bin((~(n + 2)) ^ (-1 << (n + 2).bit_length()))[2:], 4) - int(
        bin((~(n + 1)) ^ (-1 << (n + 1).bit_length()))[2:], 4
    )


def A003817(n):
    return (1 << n.bit_length()) - 1


def A374714(n):
    return len(
        {
            i**3 + j**3 + k**3 + l**3
            for i in range(1, n + 1)
            for j in range(i, n + 1)
            for k in range(j, n + 1)
            for l in range(k, n + 1)
        }
    )


def A374711(n):
    return len(
        {
            i**3 + j**3 + k**3 + l**3
            for i in range(n + 1)
            for j in range(i, n + 1)
            for k in range(j, n + 1)
            for l in range(k, n + 1)
        }
    )


def A374020_gen():  # generator of terms
    c, s = 0, Counter()
    for n in count(1):
        n2 = n**2
        for i in range(1, n):
            c += s[m := i**2 + n2]
            s[m] += 1
        yield c


def A237526(n):
    return sum(isqrt(n - k**2) for k in range(1, isqrt(n) + 1))


def A374532(n):
    return sum(isqrt(k * ((n << 1) - k) + 1) for k in range(n)) << 2


def A001182(n):
    return sum(isqrt(k * ((n << 1) - k)) for k in range(1, n))


def A119677(n):
    return sum(isqrt(k * ((n << 1) - k)) for k in range(1, n)) << 2


def A000603(n):
    return (m := n << 1) + sum(isqrt(k * (m - k)) for k in range(1, n)) + 1


def A125228(n):
    return (
        (m := n << 1)
        - 1
        + (sum(isqrt((k * (m - k + 1) - n << 2) - 1) for k in range(1, n)) << 1)
    )


def A341423(n):
    c, n2 = 0, n**2
    for x1 in range(1, n + 1):
        y1 = x1**2
        for x2 in range(1, n + 1):
            y2 = x2**2
            if y1 + y2 > n2:
                break
            for x3 in range(1, n + 1):
                y3 = x3**2
                y4 = n2 - y1 - y2 - y3
                if y4 < 1:
                    break
                c += isqrt(y4)
    return c


if sys.version_info >= (3, 10):

    def A177329(n):
        return sum(
            map(
                int.bit_count,
                sum(
                    (Counter(factorint(i)) for i in range(2, n + 1)), start=Counter()
                ).values(),
            )
        )

    def A374674(n):
        if n == 1:
            return 2
        c, a, l = Counter(), 0, 0
        for m in count(2):
            c += Counter(factorint(m))
            b = sum(map(int.bit_count, c.values()))
            if b < a:
                l += 1
            else:
                if l == n - 1:
                    return m - n
                l = 0
            a = b

    def A374673(n):
        if n == 1:
            return 2
        c, a, l = Counter(), 0, 0
        for m in count(2):
            c += Counter(factorint(m))
            b = sum(map(int.bit_count, c.values()))
            if b == a:
                l += 1
            else:
                if l == n - 1:
                    return m - n
                l = 0
            a = b

    def A064547(n):
        return sum(map(int.bit_count, factorint(n).values()))

else:

    def A177329(n):
        return sum(
            bin(e).count("1")
            for e in sum(
                (Counter(factorint(i)) for i in range(2, n + 1)), start=Counter()
            ).values()
        )

    def A374674(n):
        if n == 1:
            return 2
        c, a, l = Counter(), 0, 0
        for m in count(2):
            c += Counter(factorint(m))
            b = sum(bin(e).count("1") for e in c.values())
            if b < a:
                l += 1
            else:
                if l == n - 1:
                    return m - n
                l = 0
            a = b

    def A374673(n):
        if n == 1:
            return 2
        c, a, l = Counter(), 0, 0
        for m in count(2):
            c += Counter(factorint(m))
            b = sum(bin(e).count("1") for e in c.values())
            if b == a:
                l += 1
            else:
                if l == n - 1:
                    return m - n
                l = 0
            a = b

    def A064547(n):
        return sum(bin(e).count("1") for e in factorint(n).values())


def A065359(n):
    return sum((0, 1, -1, 0)[i] for i in sympydigits(n, 4)[1:])


def A005536(n):
    return sum(
        sum((0, 1, -1, 0)[i] for i in sympydigits(m, 4)[1:]) for m in range(n + 1)
    )


def A065081(n):
    return sum((0, 1, -1, 0)[i] for i in sympydigits(prime(n), 4)[1:])


def A065368(n):
    return sum((0, 1, 2, -1, 0, 1, -2, -1, 0)[i] for i in sympydigits(n, 9)[1:])


def A261891(n):
    return next(k for k in count(2) if not n & k * n)


def A261892(n):
    return next(k for k in count(n << 1, n) if not n & k)


def A116361(n):
    return next(k for k in count(0) if n ^ (m := n << k) == m + n)


def A374736(n):
    s = list(map(int, str(n)[::-1]))
    return next(
        k
        for k in count(n, n)
        if all(a + b <= 9 for a, b in zip(s, map(int, str(k)[::-1])))
    )


def A374735(n):
    s = list(map(int, str(n)[::-1]))
    return next(
        k
        for k in count(1)
        if all(a + b <= 9 for a, b in zip(s, map(int, str(k * n)[::-1])))
    )


def A160520(n):
    return len(
        set(
            continued_fraction_periodic(
                0, 1, n + (k := isqrt(n)) + int(n >= k * (k + 1) + 1)
            )[-1]
        )
    )


def A013943(n):
    return len(
        continued_fraction_periodic(
            0, 1, n + (k := isqrt(n)) + int(n >= k * (k + 1) + 1)
        )[-1]
    )


def A071989(n):
    return (
        isqrt(10 ** (n << 1) * (n + (k := isqrt(n)) + int(n >= k * (k + 1) + 1))) % 10
    )


def A099725(n):
    return (
        continued_fraction_periodic(
            0, 1, n + (k := isqrt(n)) + int(n >= k * (k + 1) + 1)
        )[-1]
    ).count(1)


def A013944(n):
    return sum(
        continued_fraction_periodic(
            0, 1, n + (k := isqrt(n)) + int(n >= k * (k + 1) + 1)
        )[-1]
    )


def A013929(n):
    def f(x):
        return n + sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

    return iterfun(f, n)


def A063035(n):
    return (m := 10**n) - sum(mobius(k) * (m // k**2) for k in range(1, isqrt(m) + 1))


def A374812(n):
    r = 10**n

    @lru_cache(maxsize=None)
    def g(x):
        return mobius(x)

    def f(x):
        return r + sum(g(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

    m, k = r, f(r)
    while m != k:
        m, k = k, f(k)
    return m


def A061399(n):
    return sum(not mobius(m) for m in range(prime(n) + 1, prime(n + 1)))


def A071404(n):
    return -sum(mobius(k) * (n**2 // k**2) for k in range(2, n + 1))


def A071403(n):
    return (p := prime(n)) + sum(
        mobius(k) * (p // k**2) for k in range(2, isqrt(p) + 1)
    )


def A374770(n):
    if isprime(n):
        return n + 1
    s = {}
    for d in divisors(n, generator=True):
        t = {}
        for a in combinations(range(n), d):
            for i in range(1, n):
                if (w := tuple((i + b) % n for b in a)) in t:
                    t[w] += 1
                    break
            else:
                t[a] = 1
        s[d] = t
    c = 0
    for d in divisors(n, generator=True):
        for a in s[d]:
            for b in s[n // d]:
                if len({(x + y) % n for x in a for y in b}) == n:
                    c += s[d][a]
                    break
    return c


def A056045(n):
    return sum(comb(n, d) for d in divisors(n, generator=True))


def A308943(n):
    return prod(comb(n, d) for d in divisors(n, generator=True))


def A045663(n):
    return (
        sum(
            mobius(d) << n // d
            for d in divisors(n >> (~n & n - 1).bit_length(), generator=True)
        )
        if n
        else 1
    )


def A045654(n):
    return sum(1 << (n >> k) for k in range((~n & n - 1).bit_length() + 1)) if n else 1


def A046028(n):
    def f(x):
        return n + sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

    m, k = n, f(n)
    while m != k:
        m, k = k, f(k)
    s = factorint(m)
    return next(p for p in sorted(s, reverse=True) if s[p] > 1)


def A046027(n):
    def f(x):
        return n + sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

    m, k = n, f(n)
    while m != k:
        m, k = k, f(k)
    s = factorint(m)
    return next(p for p in sorted(s) if s[p] > 1)


def A212177(n):
    def f(x):
        return n + sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

    m, k = n, f(n)
    while m != k:
        m, k = k, f(k)
    return sum(1 for e in factorint(m).values() if e > 1)


def A087050(n):
    def f(x):
        return n + sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

    m, k = n, f(n)
    while m != k:
        m, k = k, f(k)
    return prod(p ** (e >> 1) for p, e in factorint(m).items() if e > 1)


def A373058(n):
    def f(x):
        return n + sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

    m, k = n, f(n)
    while m != k:
        m, k = k, f(k)
    return prod((p ** (e + 1) - 1) // (p - 1) - 1 for p, e in factorint(m).items()) - m


def A005117(n):
    def f(x):
        return n + x - sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

    m, k = n, f(n)
    while m != k:
        m, k = k, f(k)
    return m


def A065515(n):
    return 1 + sum(primepi(integer_nthroot(n, k)[0]) for k in range(1, n.bit_length()))


def A024619(n):
    def f(x):
        return int(
            n
            + 1
            + sum(primepi(integer_nthroot(x, k)[0]) for k in range(1, x.bit_length()))
        )

    m, k = n, f(n)
    while m != k:
        m, k = k, f(k)
    return m


def A000961(n):
    def f(x):
        return int(
            n
            + x
            - 1
            - sum(primepi(integer_nthroot(x, k)[0]) for k in range(1, x.bit_length()))
        )

    m, k = n, f(n)
    while m != k:
        m, k = k, f(k)
    return m


def A072000(n):
    return int(
        -((t := primepi(s := isqrt(n))) * (t - 1) >> 1)
        + sum(primepi(n // p) for p in primerange(s + 1))
    )


def A194113(n):
    return sum(isqrt(10 * j**2) for j in range(1, n + 1))


def A001358(n):
    def f(x):
        return int(
            n
            + x
            + ((t := primepi(s := isqrt(x))) * (t - 1) >> 1)
            - sum(primepi(x // p) for p in primerange(s + 1))
        )

    return iterfun(f, n)


def A072613(n):
    return int(
        sum(primepi(n // prime(k)) - k + 1 for k in range(1, primepi(isqrt(n)) + 1))
    ) - primepi(isqrt(n))


def A373630(n):
    p = prime(n)
    q = n + int(
        sum(primepi(p // prime(k)) - k + 1 for k in range(1, primepi(isqrt(p)) + 1))
    )

    def f(x):
        return int(
            q
            + x
            - sum(
                primepi(x // prime(k)) - k + 1 for k in range(1, primepi(isqrt(x)) + 1)
            )
        )

    m, k = q, f(q)
    while m != k:
        m, k = k, f(k)
    return m


def A243906(n):
    return int(
        sum(primepi(n // prime(k)) - k + 1 for k in range(1, primepi(isqrt(n)) + 1))
    ) - primepi(n)


def A205726(n):
    return int(sum(primepi(n**2 // prime(k)) - k + 1 for k in range(1, primepi(n) + 1)))


def A175613(n):
    m = 1 << prime(n)
    return int(
        sum(primepi(m // prime(k)) - k + 1 for k in range(1, primepi(isqrt(m)) + 1))
    )


def A146167(n):
    return (
        int(
            sum(primepi(n // prime(k)) - k + 1 for k in range(2, primepi(isqrt(n)) + 1))
        )
        - primepi(isqrt(n))
        + 1
        if n > 3
        else 0
    )


def A100959(n):
    def f(x):
        return n + int(
            sum(primepi(x // prime(k)) - k + 1 for k in range(1, primepi(isqrt(x)) + 1))
        )

    m, k = n, f(n)
    while m != k:
        m, k = k, f(k)
    return m


def A128301(n):
    m = prime(n) ** 2
    return int(sum(primepi(m // prime(k)) - k + 1 for k in range(1, n + 1)))


def A334940(n):
    return (
        int(
            sum(primepi(n // prime(k)) - k + 1 for k in range(1, primepi(isqrt(n)) + 1))
        )
        << 1
    ) - primepi(isqrt(n))


def A230595(n):
    f = factorint(n).values()
    if sum(f) > 2:
        return 0
    elif max(f) == 2:
        return 1
    else:
        return 2


def A230595(n):
    return 0 if sum(f := factorint(n).values()) != 2 else len(f)


def A230594(n):
    return (
        0
        if sum(f := factorint(n).values()) > 2
        else (1 if n == 1 or max(f) == 2 else 2)
    )


def A101705(n):
    if n == 1:
        return 0
    a = 1 << n.bit_length() - 2
    s = bin(a | (n & a - 1))[2:]
    return 540 * int(s + (s[::-1] if a & n else s[-2::-1]))


def A192775(n):
    if n == 1:
        return 0
    a = 1 << (l := n.bit_length() - 2)
    m = a | (n & a - 1)
    return (
        (m << l + 1) + int(bin(m)[-1:1:-1] or "0", 2)
        if a & n
        else (m << l) + int(bin(m)[-2:1:-1] or "0", 2)
    ) ** 2


def A192776(n):
    if n == 1:
        return 0
    a = 1 << (l := n.bit_length() - 2)
    m = a | (n & a - 1)
    return int(
        bin(
            (
                (m << l + 1) + int(bin(m)[-1:1:-1] or "0", 2)
                if a & n
                else (m << l) + int(bin(m)[-2:1:-1] or "0", 2)
            )
            ** 2
        )[2:]
    )


def A193434(n):
    a = 1 << (m := n + 1).bit_length() - 2
    s = bin(a | (m & a - 1))[2:]
    return 45 * int(s + (s[::-1] if a & m else s[-2::-1]))


def A136687(n):
    l = len(s := str(n))
    k = l + 1 >> 1
    return (
        n // 10 ** (l - k)
        - (int(s[k - 1 :: -1]) > n % 10**k)
        + 10 ** (k - 1 + (l & 1 ^ 1))
    )


def A137180(n):
    l = len(s := str(n))
    k = l + 1 >> 1
    return (
        n // 10 ** (l - k)
        - (int(s[k - 1 :: -1]) > n % 10**k)
        + 10 ** (k - 1 + (l & 1 ^ 1))
        - 1
    )


def A029742(n):
    def f(x):
        return (
            n
            + x // 10 ** ((l := len(s := str(x))) - (k := l + 1 >> 1))
            - (int(s[k - 1 :: -1]) > x % 10**k)
            + 10 ** (k - 1 + (l & 1 ^ 1))
            - 1
        )

    m, k = n, f(n)
    while m != k:
        m, k = k, f(k)
    return m


def A206915(n):
    l = n.bit_length()
    k = l + 1 >> 1
    return (
        (n >> l - k)
        - (int(bin(n)[k + 1 : 1 : -1] or "0", 2) > (n & (1 << k) - 1))
        + (1 << k - 1 + (l & 1 ^ 1))
    )


def A206916(n):
    l = n.bit_length()
    k = l + 1 >> 1
    return (
        (n >> l - k)
        + (int(bin(n)[k + 1 : 1 : -1] or "0", 2) < (n & (1 << k) - 1))
        + (1 << k - 1 + (l & 1 ^ 1))
    )


def A319441(n):
    def f(x):
        return (
            n
            + x // 10 ** ((l := len(s := str(x))) - (k := l + 1 >> 1))
            - (int(s[k - 1 :: -1]) > x % 10**k)
            + 10 ** (k - 1 + (l & 1 ^ 1))
            - 1
        )

    m, k = n, f(n)
    while m != k:
        m, k = k, f(k)
    return m**3


def A154809(n):
    def f(x):
        return (
            n
            + (x >> (l := x.bit_length()) - (k := l + 1 >> 1))
            - (int(bin(x)[k + 1 : 1 : -1], 2) > (x & (1 << k) - 1))
            + (1 << k - 1 + (l & 1 ^ 1))
            - 1
        )

    m, k = n, f(n)
    while m != k:
        m, k = k, f(k)
    return m


def A154810(n):
    def f(x):
        return (
            n
            + (x >> (l := x.bit_length()) - (k := l + 1 >> 1))
            - (int(bin(x)[k + 1 : 1 : -1], 2) > (x & (1 << k) - 1))
            + (1 << k - 1 + (l & 1 ^ 1))
            - 1
        )

    m, k = n, f(n)
    while m != k:
        m, k = k, f(k)
    return int(bin(m)[2:])


def A076888(n):
    y = 10 * (x := 10 ** (len(str(n + 1 >> 1)) - 1))
    return divisor_count(
        int(
            (c := n + 1 - x) * x + int(str(c)[-2::-1] or 0)
            if n + 1 < x + y
            else (c := n + 1 - y) * y + int(str(c)[::-1] or 0)
        )
    )


def A085927(n):
    y = 10 * (x := 10 ** (len(str(n + 1 >> 1)) - 1))
    m = str(
        (c := n + 1 - x) * x + int(str(c)[-2::-1] or 0)
        if n + 1 < x + y
        else (c := n + 1 - y) * y + int(str(c)[::-1] or 0)
    )
    return int("".join("9753113579"[int(d)] for d in m))


def A043262(n):
    if n == 1:
        return 0
    y = 3 * (x := 3 ** (len(gmpy2digits(n >> 1, 3)) - 1))
    return (
        int((s := gmpy2digits(n - x, 3))[-1]) + (sum(int(d) for d in s[:-1]) << 1)
        if n < x + y
        else sum(map(int, gmpy2digits(n - y, 3))) << 1
    )


def A248754_gen():  # generator of terms
    def f(n):
        y = 10 * (x := 10 ** (len(str(n >> 1)) - 1))
        return (
            (c := n - x) * x + int(str(c)[-2::-1] or 0)
            if n < x + y
            else (c := n - y) * y + int(str(c)[::-1] or 0)
        )

    for n in count(2):
        if str(m := f(n)) in str(k := f(m)):
            yield k


def A248753_gen(startvalue=2):  # generator of terms >= startvalue
    def f(n):
        y = 10 * (x := 10 ** (len(str(n >> 1)) - 1))
        return (
            (c := n - x) * x + int(str(c)[-2::-1] or 0)
            if n < x + y
            else (c := n - y) * y + int(str(c)[::-1] or 0)
        )

    for n in count(max(2, startvalue)):
        if str(n) in str(k := f(n)):
            yield k


def A374930(n):
    f = factorint(n).items()
    return (
        31 * prod((p ** (5 * (e + 1)) - 1) // (p**5 - 1) for p, e in f)
        - 70 * (n + 1) * prod((p ** (3 * (e + 1)) - 1) // (p**3 - 1) for p, e in f)
        + (20 * n * ((n << 1) + 3) + 9)
        * prod((p ** (e + 1) - 1) // (p - 1) for p, e in f)
    ) // 1920


def A374928(n):
    return int(factorial(n * (n + 1) >> 1) // factorial2((n << 1) - 1))


def A191829(n):
    return sum(
        divisor_count(i)
        * sum(divisor_count(j) * divisor_count(n - i - j) for j in range(1, n - i))
        for i in range(1, n - 1)
    )


def A000385(n):
    f = factorint(n + 1).items()
    return (
        5 * prod((p ** (3 * (e + 1)) - 1) // (p**3 - 1) for p, e in f)
        - (5 + 6 * n) * prod((p ** (e + 1) - 1) // (p - 1) for p, e in f)
    ) // 12


def A374951(n):
    return (
        60 * sum(divisor_sigma(i) * divisor_sigma(n - i, 3) for i in range(1, n))
        + divisor_sigma(n) * (9 * n * (2 * n - 1) + 1)
        - 5 * divisor_sigma(n, 3) * (3 * n - 1)
    ) // 144


def A000441(n):
    return (n * (1 - 6 * n) * divisor_sigma(n) + 5 * n * divisor_sigma(n, 3)) // 24


def A374963(n):
    return sum(divisor_sigma(i) * divisor_sigma(n - i, 3) for i in range(1, n))


def A055507(n):
    return (
        sum(divisor_count(i + 1) * divisor_count(n - i) for i in range(n >> 1)) << 1
    ) + (divisor_count(n + 1 >> 1) ** 2 if n & 1 else 0)


def A212151(n):
    return sum(
        (sum(divisor_count(i + 1) * divisor_count(j - i) for i in range(j >> 1)) << 1)
        + (divisor_count(j + 1 >> 1) ** 2 if j & 1 else 0)
        for j in range(1, n - 1)
    )


def A212240(n):
    return n**4 - sum(
        (sum(divisor_count(i + 1) * divisor_count(j - i) for i in range(j >> 1)) << 1)
        + (divisor_count(j + 1 >> 1) ** 2 if j & 1 else 0)
        for j in range(1, n - 1)
    )


def A374977(n):
    return (
        sum(
            (5 * divisor_sigma(i + 1, 3) - (5 + 6 * i) * divisor_sigma(i + 1))
            * (
                5 * divisor_sigma(n - i - 1, 3)
                - (5 + 6 * (n - i - 2)) * divisor_sigma(n - i - 1)
            )
            for i in range(1, n - 2)
        )
        // 144
    )


def A374978(n):
    return (
        sum(
            divisor_sigma(j)
            * sum(
                (5 * divisor_sigma(i + 1, 3) - (5 + 6 * i) * divisor_sigma(i + 1))
                * (
                    5 * divisor_sigma(n - j - i - 1, 3)
                    - (5 + 6 * (n - j - i - 2)) * divisor_sigma(n - j - i - 1)
                )
                for i in range(1, n - j - 2)
            )
            for j in range(1, n)
        )
        // 144
    )


def A374979(n):
    return sum(
        A000385(i) * A000385(j) * A000385(n - 3 - i - j)
        for i in range(1, n - 4)
        for j in range(1, n - i - 3)
    )


def A374969(n):
    f = factorint(n).items()
    return (n + 1) * prod(e + 1 for p, e in f) - (
        prod((p ** (e + 1) - 1) // (p - 1) for p, e in f) << 1
    )


def A374970(n):
    return sum(
        1
        for d in divisors(n, generator=True)
        for x in range(1, d)
        for y in range(1, n // d)
        if gcd(x, y, d - x, n // d - y) == 1
    )


def A373797(n):
    c = [set()] + [set(primefactors(i)) for i in range(1, n + 1)] + [set()]
    for k in range(n - primepi(n) + primepi(n >> 1), 0, -1):
        for a in permutations(range(1, n + 1), k):
            alist = [0] + list(a) + [n + 1]
            if all(
                (p in c[alist[i - 1]]) ^ (p in c[alist[i + 1]])
                for i, d in enumerate(alist[1:-1], 1)
                for p in c[d]
            ):
                return k


def A055071_gen():  # generator of terms
    c = Counter()
    for i in count(1):
        c += Counter(factorint(i))
        yield prod(p ** (e - (e & 1)) for p, e in c.items())


def A375003(n):
    k = 0
    for c in range(1, n - 1):
        for d in divisors(c, generator=True):
            for x in range(1, d):
                xy = x * (d - x)
                a = (c // d) ** 2
                b = a - (n - c - xy << 2)
                if b >= 0:
                    q, r = integer_nthroot(b, 2)
                    if r:
                        w = c // d + q >> 1
                        if 1 <= w < c // d:
                            k += 1 + bool(q)
    return k


def A375004(n):
    k = 0
    for c in range(1, n - 1):
        for d in divisors(c, generator=True):
            for x in range(1, d):
                y = d - x
                xy = x * y
                a = (c // d) ** 2
                b = a - (n - c - xy << 2)
                if b >= 0:
                    q, r = integer_nthroot(b, 2)
                    if r:
                        w = c // d + q >> 1
                        z = c // d - w
                        if 1 <= w < c // d and gcd(x, y, z, w) == 1:
                            k += 1
                        if q:
                            w = c // d - q >> 1
                            z = c // d - w
                            if 1 <= w < c // d and gcd(x, y, z, w) == 1:
                                k += 1

    return k


def A374989_gen():  # generator of terms
    c = Counter()
    for i in count(0):
        c += Counter(factorint(i))
        yield prod(p ** (e >> 1) for p, e in c.items() if e & 1 ^ 1)


def A374988_gen():  # generator of terms
    c = Counter()
    for i in count(0):
        c += Counter(factorint(i))
        yield prod(p**e for p, e in c.items() if e & 1 ^ 1)


def A071974(n):
    return prod(p ** (e >> 1) for p, e in factorint(n).items() if e & 1 ^ 1)


def A375002(n):
    return sum(A055507(i) * A055507(n - 2 - i) for i in range(1, n - 2))


def A374527_gen(startvalue=1):  # generator of terms >= startvalue
    s = max(startvalue, 1)
    for n in count(s + (s & 1 ^ 1), 2):
        t, a, c = [n], n, set()
        while a > 1:
            a = 3 * a + 1 if a & 1 else a >> 1
            for p in t:
                if (b := p + a) in c:
                    break
                c.add(b)
            else:
                t.append(a)
                continue
            break
        else:
            yield n


def A375006_gen(startvalue=1):  # generator of terms >= startvalue
    for n in count(max(startvalue, 1)):
        t, a, c = [n], n, set()
        while a > 1:
            a = 3 * a + 1 if a & 1 else a >> 1
            for p in t:
                if (b := p + a) in c:
                    break
                c.add(b)
            else:
                t.append(a)
                continue
            break
        else:
            yield n


def A374965_gen():  # generator of terms
    a, p = 1, 3
    while True:
        yield a
        a, p = p - 1 if isprime(a) else (a << 1) | 1, nextprime(p)


def A373799_gen():  # generator of terms
    a, p = 1, 3
    for i in count(1):
        if isprime(a):
            yield i
            a = p - 1
        else:
            a = (a << 1) | 1
        p = nextprime(p)


def A374965_gen():  # generator of terms
    a, p = 1, 3
    while True:
        yield a
        a, p = p - 1 if isprime(a) else (a << 1) | 1, nextprime(p)


def A375028_gen():  # generator of terms
    a, p = 1, 3
    while True:
        if isprime(a):
            yield a
            a = p - 1
        else:
            a = (a << 1) | 1
        p = nextprime(p)


def A374959(n):
    return next(k for j in range(n + 1) for k in range(j + 1) if not (comb(j, k) % n))


def A375082(n):
    return next(
        a
        for a, b in (divmod(comb(j, k), n) for j in range(n + 1) for k in range(j + 1))
        if not b
    )


def A375084_gen():  # generator of terms
    c = 0
    for n in count(1):
        if (
            d := next(
                a
                for a, b in (
                    divmod(comb(j, k), n) for j in range(n + 1) for k in range(j + 1)
                )
                if not b
            )
        ) > c:
            c = d
            yield n


def A375083_gen():  # generator of terms
    return filter(
        lambda n: next(
            c
            for c in (comb(j, k) for j in range(n + 1) for k in range(j + 1))
            if not c % n
        )
        > n,
        count(1),
    )


def A375077(n):
    a, c, k = prod(n + 1 - i for i in range(n + 1)), comb(n + 1 << 1, n + 1), n + 1
    while c % a:
        k += 1
        a = a * k // (k - n - 1)
        c = c * ((k << 1) - 1 << 1) // k
    return k


def A375081(n):
    a = Fraction((n << 1) + 1, n * (n + 1))
    for k in count(n + 1):
        if a.denominator > (a := a + Fraction(1, k + 1)).denominator:
            return k


def A375080(n):
    f = factorint(n).items()
    return (
        n
        - Fraction(
            prod((p ** (e + 1) - 1) // (p - 1) for p, e in f), prod(e + 1 for p, e in f)
        )
    ).numerator


def A071904(n):
    if n == 1:
        return 9
    m, k = n, primepi(n) + n + (n >> 1)
    while m != k:
        m, k = k, primepi(k) + n + (k >> 1)
    return m


def A014076(n):
    if n == 1:
        return 1
    m, k = n - 1, primepi(n) + n - 1 + (n >> 1)
    while m != k:
        m, k = k, primepi(k) + n - 1 + (k >> 1)
    return m


def A374846_gen(startvalue=1):  # generator of terms >= startvalue
    return filter(
        lambda n: n == 4
        or (isprime(n) and n & 3 == 3)
        or (isprime(n >> 1) and n & 7 == 6),
        count(max(startvalue, 1)),
    )


def A047845(n):
    if n == 1:
        return 0
    m, k = n - 1, primepi(n) + n - 1 + (n >> 1)
    while m != k:
        m, k = k, primepi(k) + n - 1 + (k >> 1)
    return m - 1 >> 1


def A374882(n):
    m, k = n, primepi(n + 1) + n + (n + 1 >> 1)
    while m != k:
        m, k = k, primepi(k) + n + (k >> 1)
    return m + 1 >> 1


def A116922(n):
    return n + 1 >> 1 if n & 1 or n == 2 else (n >> 1) + (2 if n & 2 else 1)


def A116921(n):
    return n >> 1 if n & 1 or n == 2 else (n >> 1) - (2 if n & 2 else 1)


def A062532(n):
    if n == 1:
        return 1
    m, k = n - 1, primepi(n) + n - 1 + (n >> 1)
    while m != k:
        m, k = k, primepi(k) + n - 1 + (k >> 1)
    return m**2


def A062533(n):
    if n == 1:
        return 1
    m, k = n - 1, primepi(n) + n - 1 + (n >> 1)
    while m != k:
        m, k = k, primepi(k) + n - 1 + (k >> 1)
    return totient(m)


def A163300(n):
    return n << 1 if n > 1 else 0


def A087156(n):
    return n if n > 1 else 0


def A056653(n):
    return composite(n) if n > 1 else 1


def A162022(n):
    if n == 1:
        return 3
    m, k = n, primepi(n) + n + (n >> 1)
    while m != k:
        m, k = k, primepi(k) + n + (k >> 1)
    return min(primefactors(m))


def A336407(n):
    if n == 1:
        return 3
    m, k = n, (r := primepi(n)) + n + (n >> 1)
    while m != k:
        m, k = k, (r := primepi(k)) + n + (k >> 1)
    return m - r - 2


def A106092(n):
    m, k = n, 1 + (n << 1) - primepi(n) - (n >> 1)
    while m != k:
        m, k = k, 1 + n + k - primepi(k) - (k >> 1)
    return m


def A163636(n):
    if n == 1:
        return 1
    m, k, n2 = n - 1, primepi(n) + n - 1 + (n >> 1), (n << 1) - 1
    while m != k:
        m, k = k, primepi(k) + n - 1 + (k >> 1)
    return (lambda x: (x + n2) * (x - n2 + 2) >> 2)(m)


def A067970(n):
    if n == 0:
        return 8
    m, k = n, primepi(n + 1) + n + (n + 1 >> 1)
    while m != k:
        m, k = k, primepi(k) + n + (k >> 1)
    for d in range(2, 7, 2):
        if not isprime(m + d):
            return d


def A196274(n):
    if n == 1:
        return 4
    m, k = n - 1, primepi(n) + n - 1 + (n >> 1)
    while m != k:
        m, k = k, primepi(k) + n - 1 + (k >> 1)
    for d in range(1, 4):
        if not isprime(m + (d << 1)):
            return d


def A375155_gen():  # generator of terms
    a, p = 147, 3
    while True:
        yield a
        a, p = p - 1 if isprime(a) else (a << 1) | 1, nextprime(p)


def A375071(n):
    a, b = n + 1, n + 2
    for k in count(1):
        if not b % a:
            return k
        a *= n + k + 1
        b = b * (n + 2 * k + 1) * (n + 2 * k + 2) // (n + k + 1)


def A165955(n):
    if n == 1:
        return 1
    m, k = n - 1, primepi(n) + n - 1 + (n >> 1)
    while m != k:
        m, k = k, primepi(k) + n - 1 + (k >> 1)
    return m + (n << 1)


def A165971(n):
    if n == 1:
        return 1
    m, k = n - 1, primepi(n) + n - 1 + (n >> 1)
    while m != k:
        m, k = k, primepi(k) + n - 1 + (k >> 1)
    return m - (n << 1)


def A160522(n):
    if n == 1:
        return 5
    m, k = n, primepi(n) + n + (n >> 1)
    while m != k:
        m, k = k, primepi(k) + n + (k >> 1)
    return m - (n + 1 << 1)


def A129146(n):
    if n == 1:
        return -6
    m, k = n, primepi(n) + n + (n >> 1)
    while m != k:
        m, k = k, primepi(k) + n + (k >> 1)
    return prime(n + 1) - m


def A129145(n):
    if n & 1:
        return prime((n >> 1) + 2)
    if n == 2:
        return 9
    r = n >> 1
    m, k = r, primepi(r) + r + (r >> 1)
    while m != k:
        m, k = k, primepi(k) + r + (k >> 1)
    return m


def A008508(n):
    if n == 1:
        return 3
    m, k = n, (r := primepi(n)) + n + (n >> 1)
    while m != k:
        m, k = k, (r := primepi(k)) + n + (k >> 1)
    return r - 1


if sys.version_info >= (3, 10):

    def A365476(n):
        if n == 1:
            return 4
        m, k = n, primepi(n) + n + (n >> 1)
        while m != k:
            m, k = k, primepi(k) + n + (k >> 1)
        return min(
            int(d).bit_count() * int(m // d).bit_count()
            for d in divisors(m, generator=True)
            if 1 < d < m
        )

    def A372433(n):
        def f(x):
            return n + x - sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

        m, k = n, f(n)
        while m != k:
            m, k = k, f(k)
        return int(m).bit_count()

else:

    def A365476(n):
        if n == 1:
            return 4
        m, k = n, primepi(n) + n + (n >> 1)
        while m != k:
            m, k = k, primepi(k) + n + (k >> 1)
        return min(
            bin(d).count("1") * bin(m // d).count("1")
            for d in divisors(m, generator=True)
            if 1 < d < m
        )

    def A372433(n):
        def f(x):
            return n + x - sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

        m, k = n, f(n)
        while m != k:
            m, k = k, f(k)
        return bin(m).count("1")


def A309355(n):
    if n == 1:
        return 8
    m, k = n, primepi(n) + n + (n >> 1)
    while m != k:
        m, k = k, primepi(k) + n + (k >> 1)
    return m - 1


def A060462(n):
    return composite(n - 1) - 1 if n > 1 else 1


def A072668(n):
    return composite(n) - 1


def A306863(n):
    if n == 1:
        return 2
    m, k = n, primepi(n) + n + (n >> 1)
    while m != k:
        m, k = k, primepi(k) + n + (k >> 1)
    return next(c for c in count(0) if not isprime(m + (c << 1) + 2))


def A287016(n):
    if n == 1:
        return 0
    m, k = n, primepi(n) + n + (n >> 1)
    while m != k:
        m, k = k, primepi(k) + n + (k >> 1)
    return (
        0
        if is_square(int(m))
        else -(d := divisors(m))[l := (len(d) >> 1) - 1] + d[l + 1] >> 1
    )


def A055396(n):
    return primepi(min(primefactors(n))) if n > 1 else 0


def A281681(n):
    if n == 1:
        return 1
    m, k = n, primepi(n) + n + (n >> 1)
    while m != k:
        m, k = k, primepi(k) + n + (k >> 1)
    return primepi(min(primefactors(m))) - 1


def A276662(n):
    if n == 1:
        return 311
    m, k = n, primepi(n) + n + (n >> 1)
    while m != k:
        m, k = k, primepi(k) + n + (k >> 1)
    while sum((f := factorint(m)).values()) > 1:
        m = int(str(p := min(f)) + str(m // p))
    return m


def A164510(n):
    m, k = n, primepi(n + 1) + n + (n + 1 >> 1)
    while m != k:
        m, k = k, primepi(k) + n + (k >> 1)
    for d in range(2, 7, 2):
        if not isprime(m + d):
            return d


def A000469(n):
    def f(x):
        return (
            n
            + primepi(x)
            + x
            - sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))
        )

    m, k = n, f(n)
    while m != k:
        m, k = k, f(k)
    return m


def A053726(n):
    if n == 1:
        return 5
    m, k = n, (r := primepi(n)) + n + (n >> 1)
    while m != k:
        m, k = k, (r := primepi(k)) + n + (k >> 1)
    return r + n


def A104275(n):
    if n <= 2:
        return ((n - 1) << 2) + 1
    m, k = n - 1, (r := primepi(n - 1)) + n - 1 + (n - 1 >> 1)
    while m != k:
        m, k = k, (r := primepi(k)) + n - 1 + (k >> 1)
    return r + n - 1


def A316941(n):
    while n > 1 and sum((f := factorint(n)).values()) > 1:
        n = int(str(p := min(f)) + str(n // p))
    return n


def A111333(n):
    return prime(n) + 1 >> 1


def A062875(n):
    return 5 ** (prime(n) - 1 >> 1)


def A062876(n):
    return prime(n) << 2 if n > 1 else 4


def A006254(n):
    return prime(n + 1) + 1 >> 1


def A120944(n):
    def f(x):
        return (
            n
            + 1
            + primepi(x)
            + x
            - sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))
        )

    m, k = n + 1, f(n + 1)
    while m != k:
        m, k = k, f(k)
    return m


def A177493(n):
    def f(x):
        return (
            n
            + 1
            + primepi(x)
            + x
            - sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))
        )

    m, k = n + 1, f(n + 1)
    while m != k:
        m, k = k, f(k)
    return m**3


def A177492(n):
    def f(x):
        return (
            n
            + 1
            + primepi(x)
            + x
            - sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))
        )

    m, k = n + 1, f(n + 1)
    while m != k:
        m, k = k, f(k)
    return m**2


def A109352(n):
    def f(x):
        return (
            n
            + 1
            + primepi(x)
            + x
            - sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))
        )

    m, k = n + 1, f(n + 1)
    while m != k:
        m, k = k, f(k)
    return sum(primefactors(m))


def A366807(n):
    def f(x):
        return (
            n
            + 1
            + primepi(x)
            + x
            - sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))
        )

    m, k = n + 1, f(n + 1)
    while m != k:
        m, k = k, f(k)
    return m * min(primefactors(m))


def A363597(n):
    if n == 1:
        return 1

    def f(x):
        return (
            n
            - 1
            + sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))
            - primepi(x)
        )

    m, k = n - 1, f(n - 1)
    while m != k:
        m, k = k, f(k)
    return m


def A372475(n):
    def f(x):
        return n + x - sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

    m, k = n, f(n)
    while m != k:
        m, k = k, f(k)
    return int(m).bit_length()


def A373048(n):
    return isqrt((m := factorial(n)) * (n + 1)) - isqrt(m)


def A375078_gen():  # generator of terms
    c, n = Counter({1: 1}), 1
    yield 1
    while True:
        n = (n + 1) % 10
        yield c[n]
        c += Counter(map(int, str(c[n])))


def A056624(n):
    return 1 << sum(e & 1 ^ 1 for e in factorint(n).values())


def A375187(n):
    return 1 << sum(
        e & 1 ^ 1
        for e in sum(
            (Counter(factorint(m)) for m in range(2, n + 1)), start=Counter()
        ).values()
    )


def A046951(n):
    return prod((e >> 1) + 1 for e in factorint(n).values())


def A375188(n):
    f = sum((Counter(factorint(m)) for m in range(2, n + 1)), start=Counter()).values()
    return prod((e >> 1) + 1 for e in f) - (1 << sum(e & 1 ^ 1 for e in f))


def A056626(n):
    f = factorint(n).values()
    return prod((e >> 1) + 1 for e in f) - (1 << sum(e & 1 ^ 1 for e in f))


def A062570(n):
    return totient(n) if n & 1 else totient(n) << 1


@lru_cache(maxsize=None)
def A049690(n):
    return A002088(n) + A049690(n >> 1) if n else 0


def A374263(n):
    return (sum(totient(n) for n in range(1, n + 1, 2)) >> 1) + sum(
        totient(n) for n in range(2, n + 1, 2)
    )


def A055034(n):
    return totient(n) >> 1 if n > 1 and n & 1 else totient(n)


def A068773(n):
    return A002088(n) - (A049690(n >> 1) << 1)


def A067929_gen():  # generator of terms
    for k in count(1):
        if not A068773(k) % k:
            yield k


def A099957(n):
    return A002088((n << 1) - 1) - A049690(n - 1)


def A083239(n):
    return (
        A002088(n) - (A049690(n >> 1) << 1) - 1
        if n & 1
        else 1 + (A049690(n >> 1) << 1) - A002088(n)
    )


def A360452(n):
    return (A002088((n << 1) - 1) - A049690(n - 1) << 1) | 1 if n else 0


def A274401(n):
    return (A002088(n >> 1) << 3) if n & 1 else A002088(n - 1) - A049690((n >> 1) - 1)


@lru_cache(maxsize=None)
def A049691(n):
    if n == 0:
        return 0
    c, j = 1, 2
    k1 = n // j
    while k1 > 1:
        j2 = n // k1 + 1
        c += (j2 - j) * (A049691(k1) - 2)
        j, k1 = j2, n // j2
    return n * (n - 1) - c + j + 2


@lru_cache(maxsize=None)
def A206297(n):
    if n == 1:
        return 1
    c, j = 1, 2
    k1 = (n - 1) // j
    while k1 > 1:
        j2 = (n - 1) // k1 + 1
        c += (j2 - j) * (A206297(k1 + 1) - 2)
        j, k1 = j2, (n - 1) // j2
    return (n - 2) * (n - 1) - c + j + 2


def A106481(n):
    return A002088(n + 1) - A049690(n + 1 >> 1) if n & 1 else A049690(n >> 1)


def A018806(n):
    return sum(totient(k) * (n // k) ** 2 for k in range(1, n + 1))


def A051193(n):
    return n * (
        1 + prod((p ** ((e << 1) + 1) + 1) // (p + 1) for p, e in factorint(n).items())
        >> 1
    )


def A344525(n):
    return sum(totient(k) * (n // k) ** n for k in range(1, n + 1))


def A109043(n):
    return n << 1 if n & 1 else n


def A030640(n):
    return (
        (-(n + 1 >> 1) if n & 2 else n + 1 >> 1)
        if n & 1
        else (-n - 1 if n & 2 else n + 1)
    )


def A373693(n):  # assumes n <= 51
    for k in count(1):
        c = max(map(int, s := str(k))) + 1
        if all(is_prime(mpz(s, b)) for b in range(c, c + n)) and not is_prime(
            mpz(s, c + n)
        ):
            return k


def A004709(n):
    def f(x):
        return (
            n
            + x
            - sum(
                mobius(k) * (x // k**3) for k in range(1, integer_nthroot(x, 3)[0] + 1)
            )
        )

    m, k = n, f(n)
    while m != k:
        m, k = k, f(k)
    return m


def A046099(n):
    def f(x):
        return n + sum(
            mobius(k) * (x // k**3) for k in range(1, integer_nthroot(x, 3)[0] + 1)
        )

    m, k = n, f(n)
    while m != k:
        m, k = k, f(k)
    return m


def A366536(n):
    def f(x):
        return (
            n
            + x
            - sum(
                mobius(k) * (x // k**3) for k in range(1, integer_nthroot(x, 3)[0] + 1)
            )
        )

    m, k = n, f(n)
    while m != k:
        m, k = k, f(k)
    return udivisor_count(m)


def A366537(n):
    def f(x):
        return (
            n
            + x
            - sum(
                mobius(k) * (x // k**3) for k in range(1, integer_nthroot(x, 3)[0] + 1)
            )
        )

    m, k = n, f(n)
    while m != k:
        m, k = k, f(k)
    return udivisor_sigma(m)


def A048798(n):
    return prod(p ** (-e % 3) for p, e in factorint(n).items())


def A277802(n):
    def f(x):
        return (
            n
            + x
            - sum(
                mobius(k) * (x // k**3) for k in range(1, integer_nthroot(x, 3)[0] + 1)
            )
        )

    m, k = n, f(n)
    while m != k:
        m, k = k, f(k)
    return prod(p ** (-e % 3) for p, e in factorint(m).items())


def A277803(n):
    def f(x):
        return (
            n
            + x
            - sum(
                mobius(k) * (x // k**3) for k in range(1, integer_nthroot(x, 3)[0] + 1)
            )
        )

    m, k = n, f(n)
    while m != k:
        m, k = k, f(k)
    return min(m, prod(p ** (-e % 3) for p, e in factorint(m).items()))


def A046101(n):
    def f(x):
        return n + sum(
            mobius(k) * (x // k**4) for k in range(1, integer_nthroot(x, 4)[0] + 1)
        )

    m, k = n, f(n)
    while m != k:
        m, k = k, f(k)
    return m


def A046100(n):
    def f(x):
        return (
            n
            + x
            - sum(
                mobius(k) * (x // k**4) for k in range(1, integer_nthroot(x, 4)[0] + 1)
            )
        )

    m, k = n, f(n)
    while m != k:
        m, k = k, f(k)
    return m


def A375072(n):
    def f(x):
        return (
            n
            + x
            - sum(
                mobius(k) * (x // k**4 - x // k**3)
                for k in range(1, integer_nthroot(x, 4)[0] + 1)
            )
            + sum(
                mobius(k) * (x // k**3)
                for k in range(
                    integer_nthroot(x, 4)[0] + 1, integer_nthroot(x, 3)[0] + 1
                )
            )
        )

    m, k = n, f(n)
    while m != k:
        m, k = k, f(k)
    return m


def A160813(n):
    return A005117(n) + A004709(n)


def A067259(n):
    def f(x):
        return (
            n
            + x
            + sum(
                mobius(k) * (x // k**2 - x // k**3)
                for k in range(1, integer_nthroot(x, 3)[0] + 1)
            )
            + sum(
                mobius(k) * (x // k**2)
                for k in range(integer_nthroot(x, 3)[0] + 1, isqrt(x) + 1)
            )
        )

    m, k = n, f(n)
    while m != k:
        m, k = k, f(k)
    return m


def A144972(n):
    def f(x):
        return (
            n
            + x
            - sum(
                mobius(k) * (x // k**6) for k in range(1, integer_nthroot(x, 6)[0] + 1)
            )
        )

    m, k = n, f(n)
    while m != k:
        m, k = k, f(k)
    return m


def A373801_gen():  # generator of terms
    a, p = 2, 3
    while True:
        yield a
        a, p = p + 1 if isprime(a) else (a << 1) - 1, nextprime(p)


def A373802_gen():  # generator of terms
    a, p = 2, 3
    for i in count(1):
        if isprime(a):
            yield a
            a = p + 1
        else:
            a = (a << 1) - 1
        p = nextprime(p)


def A373803_gen():  # generator of terms
    a, p = 2, 3
    for i in count(1):
        if isprime(a):
            yield i
            a = p + 1
        else:
            a = (a << 1) - 1
        p = nextprime(p)


def A060431(n):
    return sum(mobius(k) * (n // k**3) for k in range(1, integer_nthroot(n, 3)[0] + 1))


def A370833(n):
    def f(x):
        return (
            n
            + x
            - sum(
                mobius(k) * (x // k**3) for k in range(1, integer_nthroot(x, 3)[0] + 1)
            )
        )

    return max(primefactors(iterfun(f, n)), default=1)


def A368779(n):
    def f(x):
        return (
            n
            + x
            - sum(
                mobius(k) * (x // k**3) for k in range(1, integer_nthroot(x, 3)[0] + 1)
            )
        )

    return primeomega(iterfun(f, n))


def A366440(n):
    def f(x):
        return (
            n
            + x
            - sum(
                mobius(k) * (x // k**3) for k in range(1, integer_nthroot(x, 3)[0] + 1)
            )
        )

    return divisor_sigma(iterfun(f, n))


def A360539(n):
    return prod(p**e for p, e in factorint(n).items() if e <= 2)


def A358040(n):
    def f(x):
        return (
            n
            + x
            - sum(
                mobius(k) * (x // k**3) for k in range(1, integer_nthroot(x, 3)[0] + 1)
            )
        )

    return divisor_count(iterfun(f, n))


def A358039(n):
    def f(x):
        return (
            n
            + x
            - sum(
                mobius(k) * (x // k**3) for k in range(1, integer_nthroot(x, 3)[0] + 1)
            )
        )

    return totient(iterfun(f, n))


def A160112(n):
    q = 10**n
    m = integer_nthroot(q, 3)[0] + 1
    a, b = bitarray(m), bitarray(m)
    a[1], p, i, c = 1, 2, 4, q - sum(q // k**3 for k in range(2, m))
    while i < m:
        j = 2
        while i < m:
            if j == p:
                c -= (b[i] ^ 1 if a[i] else -1) * (q // i**3)
                j, a[i], b[i] = 0, 1, 1
            else:
                t1, t2 = a[i], b[i]
                if (t1 & t2) ^ 1:
                    a[i], b[i] = (t1 ^ 1) & t2, ((t1 ^ 1) & t2) ^ 1
                    c += (
                        (t2 if t1 else 2) * (q // i**3)
                        if (t1 ^ 1) & t2
                        else (t2 - 2 if t1 else 0) * (q // i**3)
                    )
            i += p
            j += 1
        p += 1
        while a[p] | b[p]:
            p += 1
        i = p << 1
    return c


def A160113(n):
    q = 1 << n
    m = integer_nthroot(q, 3)[0] + 1
    a, b = bitarray(m), bitarray(m)
    a[1], p, i, c = 1, 2, 4, q - sum(q // k**3 for k in range(2, m))
    while i < m:
        j = 2
        while i < m:
            if j == p:
                c -= (b[i] ^ 1 if a[i] else -1) * (q // i**3)
                j, a[i], b[i] = 0, 1, 1
            else:
                t1, t2 = a[i], b[i]
                if (t1 & t2) ^ 1:
                    a[i], b[i] = (t1 ^ 1) & t2, ((t1 ^ 1) & t2) ^ 1
                    c += (
                        (t2 if t1 else 2) * (q // i**3)
                        if (t1 ^ 1) & t2
                        else (t2 - 2 if t1 else 0) * (q // i**3)
                    )
            i += p
            j += 1
        p += 1
        while a[p] | b[p]:
            p += 1
        i = p << 1
    return c


def A143658(n):
    if n < 2:
        return n + 1
    q = 1 << n
    I = integer_nthroot(q >> 2, 3)[0]
    D = isqrt(q // I)
    m = D + 1
    a, b = bitarray(m), bitarray(m)
    a[1], p, i, c = (
        1,
        2,
        4,
        q
        - sum(q // k**2 for k in range(2, m))
        + (1 - I) * A002321(D)
        + sum(A002321(isqrt(q // i)) for i in range(1, I)),
    )
    while i < m:
        j = 2
        while i < m:
            if j == p:
                c -= (b[i] ^ 1 if a[i] else -1) * (q // i**2)
                j, a[i], b[i] = 0, 1, 1
            else:
                t1, t2 = a[i], b[i]
                if (t1 & t2) ^ 1:
                    a[i], b[i] = (t1 ^ 1) & t2, ((t1 ^ 1) & t2) ^ 1
                    c += (
                        (t2 if t1 else 2) * (q // i**2)
                        if (t1 ^ 1) & t2
                        else (t2 - 2 if t1 else 0) * (q // i**2)
                    )
            i += p
            j += 1
        p += 1
        while a[p] | b[p]:
            p += 1
        i = p << 1
    return c


def A071172(n):
    if n == 0:
        return 1
    q = 10**n
    I = integer_nthroot(q >> 2, 3)[0]
    D = isqrt(q // I)
    m = D + 1
    a, b = bitarray(m), bitarray(m)
    a[1], p, i, c = (
        1,
        2,
        4,
        q
        - sum(q // k**2 for k in range(2, m))
        + (1 - I) * A002321(D)
        + sum(A002321(isqrt(q // i)) for i in range(1, I)),
    )
    while i < m:
        j = 2
        while i < m:
            if j == p:
                c -= (b[i] ^ 1 if a[i] else -1) * (q // i**2)
                j, a[i], b[i] = 0, 1, 1
            else:
                t1, t2 = a[i], b[i]
                if (t1 & t2) ^ 1:
                    a[i], b[i] = (t1 ^ 1) & t2, ((t1 ^ 1) & t2) ^ 1
                    c += (
                        (t2 if t1 else 2) * (q // i**2)
                        if (t1 ^ 1) & t2
                        else (t2 - 2 if t1 else 0) * (q // i**2)
                    )
            i += p
            j += 1
        p += 1
        while a[p] | b[p]:
            p += 1
        i = p << 1
    return c


def A375245(n):
    return int(
        sum(mobius(k) * (n // k**4) for k in range(1, integer_nthroot(n, 4)[0] + 1))
    )


def A375246(n):
    return int(
        sum(
            mobius(k) * (10**n // k**4)
            for k in range(1, integer_nthroot(10**n, 4)[0] + 1)
        )
    )


def A335324(n):
    return prod(p ** (e & 2) for p, e in factorint(n).items())


def A008833(n):
    return prod(p ** (e & -2) for p, e in factorint(n).items())


def A365490(n):
    return prod(e & -4 | 1 for e in factorint(n).values())


def A008835(n):
    return prod(p ** (e & -4) for p, e in factorint(n).items())


def A008834(n):
    return prod(p ** (e - e % 3) for p, e in factorint(n).items())


def A002760(n):
    def f(x):
        return (
            n - 1 + x + integer_nthroot(x, 6)[0] - integer_nthroot(x, 3)[0] - isqrt(x)
        )

    m, k = n - 1, f(n - 1)
    while m != k:
        m, k = k, f(k)
    return m


def A075052(n):
    def f(x):
        return (
            n
            - 1
            + x
            + integer_nthroot(x, 6)[0]
            - (b := integer_nthroot(x, 3)[0])
            - (a := isqrt(x)),
            a,
            b,
        )

    m = n - 1
    k, a, b = f(n - 1)
    while m != k:
        m = k
        k, a, b = f(k)
    return min((a + 1) ** 2, (b + 1) ** 3) - m


def A374754(n):
    def f(x):
        return (
            n
            - 1
            + x
            + integer_nthroot(x, 6)[0]
            - (b := integer_nthroot(x, 3)[0])
            - (a := isqrt(x)),
            a,
            b,
        )

    m = n - 1
    k, a, b = f(n - 1)
    while m != k:
        m = k
        k, a, b = f(k)
    return a * (a + 1) * ((a << 1) + 1) // 3 - ((b * (b + 1)) ** 2 >> 1) >> 1


def A087797(n):
    def f(x):
        return int(
            n + x - primepi(x) - primepi(isqrt(x)) - primepi(integer_nthroot(x, 3)[0])
        )

    return iterfun(f, n)


def A000430(n):
    def f(x):
        return int(n + x - primepi(x) - primepi(isqrt(x)))

    return iterfun(f, n)


def A168363(n):
    def f(x):
        return int(n + x - primepi(isqrt(x)) - primepi(integer_nthroot(x, 3)[0]))

    return iterfun(f, n)


def A001248(n):
    return prime(n) ** 2


def A034785(n):
    return 1 << prime(n)


def A166684(n):
    def f(x):
        return int(n - 1 + x - primepi(x) - primepi(isqrt(x)))

    return iterfun(f, n)


def A229964(n):
    return sum(
        1
        for d in divisors(n, generator=True)
        for e in range(d + 1, n)
        if 1 < d < n and (n // d) * (n // e) == n * (n // lcm(d, e))
    )


def A375019_gen(startvalue=1):  # generator of terms >= startvalue
    yield from (
        n
        for n in count(max(startvalue, 1))
        if prod(set(primefactors(n - 1)).union(primefactors(n), primefactors(n + 1)))
        < n**2
    )


def A145522(n):
    def f(x):
        return int(
            n
            + x
            - sum(primepi(integer_nthroot(x, p)[0]) for p in primerange(x.bit_length()))
        )

    a = prod(e**p for p, e in factorint(iterfun(f, n)).items())
    return sum(primepi(integer_nthroot(a, p)[0]) for p in primerange(a.bit_length()))


def A375262(n):
    for m in count(1):
        f = factorint(m)
        if ((n << 1) + 1) * m * prod((p - 1) ** 2 for p in f) == prod(
            p ** (e + 2) - p for p, e in f.items()
        ) << 1:
            return m


def A065824(n):
    for m in count(1):
        f = factorint(m)
        if (n + 1) * m * prod((p - 1) ** 2 for p in f) == n * prod(
            p ** (e + 2) - p for p, e in f.items()
        ):
            return m


def A020492_gen(startvalue=1):  # generator of terms >= startvalue
    for m in count(max(startvalue, 1)):
        f = factorint(m)
        if not prod(p ** (e + 2) - p for p, e in f.items()) % (
            m * prod((p - 1) ** 2 for p in f)
        ):
            yield m


def A023897_gen(startvalue=1):  # generator of terms >= startvalue
    for m in count(max(startvalue, 1)):
        f = factorint(m)
        q, r = divmod(
            prod(p ** (e + 2) - p for p, e in f.items()),
            m * prod((p - 1) ** 2 for p in f),
        )
        if not r:
            yield q


def A065884(n):
    m, k = n, primepi(n + 1) + n + (n + 1 >> 1)
    while m != k:
        m, k = k, primepi(k) + n + (k >> 1)
    m = m - 1 >> 1
    for k in count(1):
        f = factorint(k)
        if (m + 1) * k * prod((p - 1) ** 2 for p in f) == m * prod(
            p ** (e + 2) - p for p, e in f.items()
        ):
            return k


def A055234(n):
    for m in count(1):
        f = factorint(m)
        if n * m * prod((p - 1) ** 2 for p in f) == prod(
            p ** (e + 2) - p for p, e in f.items()
        ):
            return m


def A369889(n):
    def f(x):
        return (
            n
            + x
            - sum(
                mobius(k) * (x // k**3) for k in range(1, integer_nthroot(x, 3)[0] + 1)
            )
        )

    return prod(p + 1 for p in primefactors(iterfun(f, n)))


def A368712(n):
    def f(x):
        return (
            n
            + x
            - sum(
                mobius(k) * (x // k**3) for k in range(1, integer_nthroot(x, 3)[0] + 1)
            )
        )

    return max(factorint(iterfun(f, n)).values(), default=0)


def A180499(n):
    def f(x):
        return (
            n
            + x
            - sum(
                mobius(k) * (x // k**3) for k in range(1, integer_nthroot(x, 3)[0] + 1)
            )
        )

    return n**3 + iterfun(f, n)


def A072048(n):
    def f(x):
        return n + x - sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

    return divisor_count(iterfun(f, n))


def A073245(n):
    def f(x):
        return n + x - sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

    return (m := iterfun(f, n)) * divisor_sigma(m)


def A062822(n):
    def f(x):
        return n + x - sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

    return divisor_sigma(iterfun(f, n))


def A373550(n):
    def f(x):
        return n + x - sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

    return iterfun(f, n) & 1


def A365435(n):
    if n == 0:
        return 1
    p = primorial(n)
    return sum(mobius(k) * (p // k**2) for k in range(1, isqrt(p) + 1))


def A374964(n):
    m = n**n + n
    return next(d for d in count(1) if not m % (n + d))


def A243348(n):
    def f(x):
        return n + x - sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

    return iterfun(f, n) - n


def A243351(n):
    def f(x):
        return n + x - sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

    return (n << 1) - iterfun(f, n)


def A088611(n):
    return A005117(n) if max(factorint(n).values(), default=0) < 2 else A013929(n)


def A088612(n):
    return (
        A013929(n)
        if max(factorint(n).values(), default=0) < 2 and n > 1
        else A005117(n)
    )


def A161203(n):
    def f(x):
        return n + x - sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

    return iterfun(f, n) + n**2


def A367452(n):
    def f(x):
        return n + x - sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

    return (c := primenu(iterfun(f, n))) * (c - 1) >> 1


def A048105(n):
    return -(1 << len(f := factorint(n).values())) + prod(e + 1 for e in f)


def A174961(n):
    def f(x):
        return n + sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

    return -(1 << len(g := factorint(iterfun(f, n)).values())) + prod(e + 1 for e in g)


def A072358(n):
    return sum(
        mobius(k) * (n // k**3 - n // k**2)
        for k in range(1, integer_nthroot(n, 3)[0] + 1)
    ) - sum(
        mobius(k) * (n // k**2)
        for k in range(integer_nthroot(n, 3)[0] + 1, isqrt(n) + 1)
    )


def A375349(n):
    def f(x):
        return (
            n
            + x
            - sum(
                mobius(k) * (x // k**3) for k in range(1, integer_nthroot(x, 3)[0] + 1)
            )
        )

    return iterfun(f, n) & 1


def A334393(n):
    def f(x):
        return int(
            n
            - 1
            + x
            - primepi(x)
            - sum(primepi(integer_nthroot(x, p)[0]) for p in primerange(x.bit_length()))
        )

    return iterfun(f, n)


def A070428(n):
    return int(
        1
        - sum(
            mobius(x) * (integer_nthroot(10**n, x)[0] - 1)
            for x in range(2, (10**n).bit_length())
        )
    )


def A007916(n):
    def f(x):
        return int(
            n
            + 1
            - sum(
                mobius(k) * (integer_nthroot(x, k)[0] - 1)
                for k in range(2, x.bit_length())
            )
        )

    return iterfun(f, n)


def A075308(n):
    return (
        int(
            sum(
                mobius(x)
                * (integer_nthroot(10 ** (n - 1), x)[0] - integer_nthroot(10**n, x)[0])
                for x in range(2, ((10 ** (n - 1)).bit_length()))
            )
            - sum(
                mobius(x) * (integer_nthroot(10**n, x)[0] - 1)
                for x in range((10 ** (n - 1)).bit_length(), (10**n).bit_length())
            )
        )
        if n > 2
        else n << 2
    )


def A089579(n):
    return (
        int(
            sum(
                mobius(x) * (1 - integer_nthroot(10**n, x)[0])
                for x in range(2, (10**n).bit_length())
            )
        )
        - 1
        if n > 1
        else 3
    )


def A070228(n):
    return int(
        1
        + sum(mobius(x) * (1 - integer_nthroot(1 << n, x)[0]) for x in range(2, n + 1))
    )


def A188951(n):
    return (
        int(
            sum(
                mobius(x) * (1 - integer_nthroot(1 << n, x)[0]) for x in range(2, n + 1)
            )
        )
        if n != 1
        else 1
    )


def A153158(n):
    def f(x):
        return int(
            n
            + 1
            - sum(
                mobius(k) * (integer_nthroot(x, k)[0] - 1)
                for k in range(2, x.bit_length())
            )
        )

    return iterfun(f, n) ** 2


def A001597(n):
    def f(x):
        return int(
            n
            - 1
            + x
            + sum(
                mobius(k) * (integer_nthroot(x, k)[0] - 1)
                for k in range(2, x.bit_length())
            )
        )

    return bisection(f, m := f(f(n)), m)


def A025478(n):
    if n == 1:
        return 1

    def f(x):
        return int(
            n
            - 1
            + x
            + sum(
                mobius(k) * (integer_nthroot(x, k)[0] - 1)
                for k in range(2, x.bit_length())
            )
        )

    return integer_nthroot(kmax := bisection(f, n, n), gcd(*factorint(kmax).values()))[
        0
    ]


def A076405(n):
    if n == 1:
        return 1

    def f(x):
        return int(
            n
            - 1
            + x
            + sum(
                mobius(k) * (integer_nthroot(x, k)[0] - 1)
                for k in range(2, x.bit_length())
            )
        )

    return (kmax := bisection(f, n, n)) * integer_nthroot(
        kmax, gcd(*factorint(kmax).values())
    )[0]


def A025475(n):
    if n == 1:
        return 1

    def f(x):
        return int(
            n
            - 1
            + x
            - sum(primepi(integer_nthroot(x, k)[0]) for k in range(2, x.bit_length()))
        )

    return bisection(f, n, n)


def A056798(n):
    if n == 1:
        return 1

    def f(x):
        return int(
            n
            - 1
            + x
            - sum(
                primepi(integer_nthroot(x, k)[0]) for k in range(2, x.bit_length(), 2)
            )
        )

    return bisection(f, n, n)


def A246551(n):
    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(integer_nthroot(x, k)[0]) for k in range(1, x.bit_length(), 2)
            )
        )

    return bisection(f, n, n)


def A053810(n):
    def f(x):
        return int(
            n
            + x
            - sum(primepi(integer_nthroot(x, p)[0]) for p in primerange(x.bit_length()))
        )

    return bisection(f, n, n)


def A053811(n):
    def f(x):
        return int(
            n
            + x
            - sum(primepi(integer_nthroot(x, p)[0]) for p in primerange(x.bit_length()))
        )

    return primefactors(bisection(f, n, n))[0]


def A053812(n):
    def f(x):
        return int(
            n
            + x
            - sum(primepi(integer_nthroot(x, p)[0]) for p in primerange(x.bit_length()))
        )

    return list(factorint(bisection(f, n, n)).values())[0]


def A145521(n):
    def f(x):
        return int(
            n
            + x
            - sum(primepi(integer_nthroot(x, p)[0]) for p in primerange(x.bit_length()))
        )

    return prod(e**p for p, e in factorint(bisection(f, n, n)).items())


def A053707(n):
    if n == 1:
        return 3

    def f(x):
        return int(
            n
            - 2
            + x
            - sum(primepi(integer_nthroot(x, k)[0]) for k in range(2, x.bit_length()))
        )

    kmin, kmax = 1, 2
    while f(kmax) + 1 >= kmax:
        kmax <<= 1
    rmin, rmax = 1, kmax
    while True:
        kmid = kmax + kmin >> 1
        if f(kmid) + 1 < kmid:
            kmax = kmid
        else:
            kmin = kmid
        if kmax - kmin <= 1:
            break
    while True:
        rmid = rmax + rmin >> 1
        if f(rmid) < rmid:
            rmax = rmid
        else:
            rmin = rmid
        if rmax - rmin <= 1:
            break
    return kmax - rmax


def A053289(n):
    if n == 1:
        return 3

    def f(x):
        return int(
            n
            - 2
            + x
            + sum(
                mobius(k) * (integer_nthroot(x, k)[0] - 1)
                for k in range(2, x.bit_length())
            )
        )

    kmin, kmax = 1, 2
    while f(kmax) + 1 >= kmax:
        kmax <<= 1
    rmin, rmax = 1, kmax
    while True:
        kmid = kmax + kmin >> 1
        if f(kmid) + 1 < kmid:
            kmax = kmid
        else:
            kmin = kmid
        if kmax - kmin <= 1:
            break
    while True:
        rmid = rmax + rmin >> 1
        if f(rmid) < rmid:
            rmax = rmid
        else:
            rmin = rmid
        if rmax - rmin <= 1:
            break
    return kmax - rmax


def A069623(n):
    return int(
        n
        + sum(
            mobius(k) * (1 - integer_nthroot(n, k)[0]) for k in range(1, n.bit_length())
        )
    )


def A253641(n):
    return gcd(*factorint(n).values()) if n > 1 else 1


def A253642(n):
    if n == 1:
        return 0

    def f(x):
        return int(
            n
            - 1
            + x
            + sum(
                mobius(k) * (integer_nthroot(x, k)[0] - 1)
                for k in range(2, x.bit_length())
            )
        )

    return divisor_count(gcd(*factorint(bisection(f, n, n)).values())) - 1


def A175064(n):
    if n == 1:
        return 1

    def f(x):
        return int(
            n
            - 1
            + x
            + sum(
                mobius(k) * (integer_nthroot(x, k)[0] - 1)
                for k in range(2, x.bit_length())
            )
        )

    return divisor_count(gcd(*factorint(bisection(f, n, n)).values()))


def A099998(n):
    def f(x):
        return int(
            (n << 1)
            - 1
            + x
            + sum(
                mobius(k) * (integer_nthroot(x, k)[0] - 1)
                for k in range(2, x.bit_length())
            )
        )

    return bisection(f, n, n)


def A099997(n):
    def f(x):
        return int(
            (n << 1)
            - 2
            + x
            + sum(
                mobius(k) * (integer_nthroot(x, k)[0] - 1)
                for k in range(2, x.bit_length())
            )
        )

    return bisection(f, n, n)


def A246547(n):
    def f(x):
        return int(
            n
            + x
            - sum(primepi(integer_nthroot(x, k)[0]) for k in range(2, x.bit_length()))
        )

    return bisection(f, n, n)


def A097054(n):
    def f(x):
        return int(
            n
            + x
            + sum(
                mobius(k) * (integer_nthroot(x, k)[0] - 1)
                for k in range(3, x.bit_length())
            )
        )

    return bisection(f, n, n)


def A070265(n):
    def f(x):
        return int(
            n
            - 1
            + x
            + sum(
                mobius(k) * (integer_nthroot(x, k)[0] - 1)
                for k in range(3, x.bit_length(), 2)
            )
        )

    return bisection(f, n, n)


def A097055_gen(startvalue=2):  # generator of terms >= startvalue
    return filter(
        lambda n: sum(
            mobius(k) * (1 - integer_nthroot((n + 1) ** 2, k)[0])
            for k in range((n**2).bit_length(), ((n + 1) ** 2).bit_length())
        )
        + sum(
            mobius(k)
            * (integer_nthroot(n**2, k)[0] - integer_nthroot((n + 1) ** 2, k)[0])
            for k in range(3, (n**2).bit_length())
        ),
        count(max(startvalue, 2)),
    )


def A076400(n):
    def f(x):
        return int(
            n
            - 1
            + x
            + sum(
                mobius(k) * (integer_nthroot(x, k)[0] - 1)
                for k in range(2, x.bit_length())
            )
        )

    return int(divisor_count(bisection(f, n, n)))


def A076399(n):
    def f(x):
        return int(
            n
            - 1
            + x
            + sum(
                mobius(k) * (integer_nthroot(x, k)[0] - 1)
                for k in range(2, x.bit_length())
            )
        )

    return int(primeomega(bisection(f, n, n)))


def A076398(n):
    def f(x):
        return int(
            n
            - 1
            + x
            + sum(
                mobius(k) * (integer_nthroot(x, k)[0] - 1)
                for k in range(2, x.bit_length())
            )
        )

    return int(primenu(bisection(f, n, n)))


def A340585(n):
    def f(x):
        return int(
            n
            + 1
            + x
            - isqrt(x)
            + sum(
                mobius(k) * (integer_nthroot(x, k)[0] - 1)
                for k in range(5, x.bit_length())
            )
        )

    return bisection(f, n, n)


def A239728(n):
    def f(x):
        return int(
            n
            + 1
            + x
            - integer_nthroot(x, 5)[0]
            + sum(
                mobius(k) * (integer_nthroot(x, k)[0] - 1)
                for k in range(7, x.bit_length())
            )
        )

    return bisection(f, n, n)


def A076467(n):
    def f(x):
        return int(
            n
            + x
            - integer_nthroot(x, 4)[0]
            + sum(
                mobius(k)
                * (integer_nthroot(x, k)[0] + integer_nthroot(x, k << 1)[0] - 2)
                for k in range(3, x.bit_length())
            )
        )

    return bisection(f, n, n)


def A076468(n):
    def f(x):
        return int(
            n
            + 3
            + x
            - integer_nthroot(x, 4)[0]
            - (integer_nthroot(x, 6)[0] << 1)
            - integer_nthroot(x, 9)[0]
            + sum(
                mobius(k)
                * (
                    integer_nthroot(x, k)[0]
                    + integer_nthroot(x, k << 1)[0]
                    + integer_nthroot(x, 3 * k)[0]
                    - 3
                )
                for k in range(5, x.bit_length())
            )
        )

    return bisection(f, n, n)


def A076469(n):
    def f(x):
        return int(
            n
            + 4
            + x
            - (integer_nthroot(x, 6)[0] << 1)
            - integer_nthroot(x, 8)[0]
            - integer_nthroot(x, 9)[0]
            - integer_nthroot(x, 12)[0]
            + sum(
                mobius(k)
                * (
                    integer_nthroot(x, k)[0]
                    + integer_nthroot(x, k << 1)[0]
                    + integer_nthroot(x, 3 * k)[0]
                    + integer_nthroot(x, k << 2)[0]
                    - 4
                )
                for k in range(5, x.bit_length())
            )
        )

    return bisection(f, n, n)


def A076470(n):
    def f(x):
        return int(
            n
            + 10
            + x
            - (sum(integer_nthroot(x, d)[0] for d in (6, 10, 15)) << 1)
            - sum(integer_nthroot(x, d)[0] for d in (8, 9, 12, 20, 25))
            + sum(
                mobius(k) * (sum(integer_nthroot(x, k * i)[0] for i in range(1, 6)) - 5)
                for k in range(6, x.bit_length())
            )
        )

    return bisection(f, n, n)


def A131605(n):
    def f(x):
        return int(
            n
            - 1
            + x
            + sum(
                mobius(k) * ((a := integer_nthroot(x, k)[0]) - 1) + primepi(a)
                for k in range(2, x.bit_length())
            )
        )

    return bisection(f, n, n)


def A340588(n):
    def f(x):
        return int(
            n
            - 1
            + x
            + sum(
                mobius(k) * (integer_nthroot(x, k)[0] - 1)
                for k in range(2, x.bit_length())
            )
        )

    return bisection(f, n, n) ** 2


def A062965(n):
    def f(x):
        return int(
            n
            + x
            + sum(
                mobius(k) * (integer_nthroot(x, k)[0] - 1)
                for k in range(2, x.bit_length())
            )
        )

    return bisection(f, n, n) ** 2 - 1


def A267574(n):
    return sum(
        primepi(integer_nthroot(10**n, k)[0]) for k in range(2, (10**n).bit_length())
    )


def A365670(n):
    return (
        int(
            sum(
                mobius(x) * (1 - (a := integer_nthroot(10**n, x)[0])) - primepi(a)
                for x in range(2, (10**n).bit_length())
            )
        )
        - 1
        if n > 1
        else n - 1
    )


def A051451(n):
    def f(x):
        return int(
            n
            + x
            - 1
            - sum(primepi(integer_nthroot(x, k)[0]) for k in range(1, x.bit_length()))
        )

    m = iterfun(f, n)
    return prod(p ** integer_log(m, p)[0] for p in primerange(m + 1))


def A051452(n):
    def f(x):
        return int(
            n
            + x
            - 1
            - sum(primepi(integer_nthroot(x, k)[0]) for k in range(1, x.bit_length()))
        )

    m = iterfun(f, n)
    return 1 + prod(p ** integer_log(m, p)[0] for p in primerange(m + 1))


def A208768(n):
    def f(x):
        return int(
            n
            + x
            - 1
            - sum(primepi(integer_nthroot(x, k)[0]) for k in range(1, x.bit_length()))
        )

    m = iterfun(f, n)
    return prod(p ** integer_log(m, p)[0] for p in primerange(m + 1)) - 1


def A051454(n):
    def f(x):
        return int(
            n
            + x
            - 1
            - sum(primepi(integer_nthroot(x, k)[0]) for k in range(1, x.bit_length()))
        )

    m = iterfun(f, n)
    return min(
        primefactors(1 + prod(p ** integer_log(m, p)[0] for p in primerange(m + 1)))
    )


def A126706(n):
    def f(x):
        return int(
            n
            + sum(primepi(integer_nthroot(x, k)[0]) for k in range(2, x.bit_length()))
            + sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))
        )

    return bisection(f, m := f(f(n)), m)


def A358089(n):
    def f(x):
        return int(
            n
            + sum(primepi(integer_nthroot(x, k)[0]) for k in range(2, x.bit_length()))
            + sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))
        )

    m, k = n, f(n)
    while m != k:
        m, k = k, f(k)
    r, k = n + 1, f(n + 1) + 1
    while r != k:
        r, k = k, f(k) + 1
    return r - m


def A025473(n):
    if n == 1:
        return 1

    def f(x):
        return int(
            n
            + x
            - 1
            - sum(primepi(integer_nthroot(x, k)[0]) for k in range(1, x.bit_length()))
        )

    return primefactors(iterfun(f, n))[0]


def A025476(n):
    def f(x):
        return int(
            n
            + x
            - sum(primepi(integer_nthroot(x, k)[0]) for k in range(2, x.bit_length()))
        )

    return primefactors(bisection(f, m := f(f(n)), m))[0]


def A048148(n):
    return prod(A025476(i) for i in range(1, n))


def A025474(n):
    if n == 1:
        return 0

    def f(x):
        return int(
            n
            + x
            - 1
            - sum(primepi(integer_nthroot(x, k)[0]) for k in range(1, x.bit_length()))
        )

    return list(factorint(iterfun(f, n)).values())[0]


def A192015(n):
    if n == 1:
        return 0

    def f(x):
        return int(
            n
            + x
            - 1
            - sum(primepi(integer_nthroot(x, k)[0]) for k in range(1, x.bit_length()))
        )

    m = iterfun(f, n)
    return sum((m * e // p for p, e in factorint(m).items()))


def A085501(n):
    return 1 + sum(primepi(integer_nthroot(n, k)[0]) for k in range(2, n.bit_length()))


def A069637(n):
    return sum(primepi(integer_nthroot(n, k)[0]) for k in range(2, n.bit_length()))


def A025528(n):
    return sum(primepi(integer_nthroot(n, k)[0]) for k in range(1, n.bit_length()))


def A010846(n):
    return sum((m := n**k) // k - (m - 1) // k for k in range(1, n + 1))


def A363924(n):
    def f(x):
        return n + x - sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

    m = iterfun(f, n)
    return int(sum(mobius(k) * (m // k) for k in range(1, m + 1) if gcd(m, k) == 1))


def A133466(n):
    def f(x):
        return int(n + x - sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1)))

    return iterfun(f, n) << 2


def A076259(n):
    def f(x):
        return n + x - sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

    m, k = n, f(n)
    while m != k:
        m, k = k, f(k)
    r, k = n + 1, f(n + 1) + 1
    while r != k:
        r, k = k, f(k) + 1
    return int(r - m)


def A006881(n):
    def f(x):
        return int(
            n
            + x
            + (t := primepi(s := isqrt(x)))
            + (t * (t - 1) >> 1)
            - sum(primepi(x // k) for k in primerange(1, s + 1))
        )

    return iterfun(f, n)


def A036351(n):
    return int(
        -(t := primepi(s := isqrt(m := 10**n)))
        - (t * (t - 1) >> 1)
        + sum(primepi(m // k) for k in primerange(1, s + 1))
    )


def A036352(n):
    return int(
        (-(t := primepi(s := isqrt(m := 10**n))) * (t - 1) >> 1)
        + sum(primepi(m // k) for k in primerange(1, s + 1))
    )


def A066265(n):
    return (
        int(
            (-(t := primepi(s := isqrt(m := 10**n))) * (t - 1) >> 1)
            + sum(primepi(m // k) for k in primerange(1, s + 1))
        )
        if n > 1
        else 3 * n
    )


def A371453(n):
    def f(x, n):
        return int(
            n
            + x
            + (t := primepi(s := isqrt(x)))
            + (t * (t - 1) >> 1)
            - sum(primepi(x // k) for k in primerange(1, s + 1))
        )

    def A006881(n):
        m, k = n, f(n, n)
        while m != k:
            m, k = k, f(k, n)
        return m

    return sum(1 << A006881(i) - 1 for i, j in enumerate(bin(n)[:1:-1], 1) if j == "1")


def A371454(n):
    def f(x, n):
        return int(
            n
            + x
            + ((t := primepi(s := isqrt(x))) * (t - 1) >> 1)
            - sum(primepi(x // k) for k in primerange(1, s + 1))
        )

    def A001358(n):
        m, k = n, f(n, n)
        while m != k:
            m, k = k, f(k, n)
        return m

    return sum(1 << A001358(i) - 1 for i, j in enumerate(bin(n)[:1:-1], 1) if j == "1")


def A228578(n):
    def f(x):
        return int(
            n
            + x
            + (t := primepi(s := isqrt(x)))
            + (t * (t - 1) >> 1)
            - sum(primepi(x // k) for k in primerange(1, s + 1))
        )

    return sum(primefactors(iterfun(f, n)))


def A105997(n):
    def f(x, n):
        return int(
            n
            + x
            + ((t := primepi(s := isqrt(x))) * (t - 1) >> 1)
            - sum(primepi(x // k) for k in primerange(1, s + 1))
        )

    def A001358(n):
        m, k = n, f(n, n)
        while m != k:
            m, k = k, f(k, n)
        return m

    return A001358(A001358(A001358(n)))


def A105998(n):
    def f(x):
        return int(
            x
            + ((t := primepi(s := isqrt(x))) * (t - 1) >> 1)
            - sum(primepi(x // k) for k in primerange(1, s + 1))
        )

    def A001358(n):
        m, k = n, f(n) + n
        while m != k:
            m, k = k, f(k) + n
        return m

    return A001358(A001358(A001358(A001358(n))))


def A030513(n):
    def f(x):
        return int(
            n
            + x
            - primepi(integer_nthroot(x, 3)[0])
            + (t := primepi(s := isqrt(x)))
            + (t * (t - 1) >> 1)
            - sum(primepi(x // k) for k in primerange(1, s + 1))
        )

    return iterfun(f, n)


def A007422(n):
    def f(x):
        return int(
            n
            - 1
            + x
            - primepi(integer_nthroot(x, 3)[0])
            + (t := primepi(s := isqrt(x)))
            + (t * (t - 1) >> 1)
            - sum(primepi(x // k) for k in primerange(1, s + 1))
        )

    return iterfun(f, n)


def A072114(n):
    return int(
        sum(
            primepi(n // (k * m)) - b
            for a, k in enumerate(primerange(integer_nthroot(n, 3)[0] + 1))
            for b, m in enumerate(primerange(k, isqrt(n // k) + 1), a)
        )
    )


def A014612(n):
    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(x // (k * m)) - b
                for a, k in enumerate(primerange(integer_nthroot(x, 3)[0] + 1))
                for b, m in enumerate(primerange(k, isqrt(x // k) + 1), a)
            )
        )

    return bisection(f, m := f(f(n)), m)


def A014613(n):
    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(x // (k * m * r)) - c
                for a, k in enumerate(primerange(integer_nthroot(x, 4)[0] + 1))
                for b, m in enumerate(
                    primerange(k, integer_nthroot(x // k, 3)[0] + 1), a
                )
                for c, r in enumerate(primerange(m, isqrt(x // (k * m)) + 1), b)
            )
        )

    return bisection(f, m := f(f(n)), m)


def A253721(n):
    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(x // (k * m)) - b
                for a, k in enumerate(primerange(integer_nthroot(x, 3)[0] + 1))
                for b, m in enumerate(primerange(k, isqrt(x // k) + 1), a)
            )
        )

    return iterfun(f, n) % 10


def A046315(n):
    def f(x):
        return int(
            n
            + x
            + ((t := primepi(s := isqrt(x))) * (t - 1) >> 1)
            - sum(primepi(x // k) for k in primerange(3, s + 1))
        )

    return bisection(f, m := f(f(n)), m)


def A114106(n):
    return sum(
        primepi(10**n // (k * m * r)) - c
        for a, k in enumerate(primerange(integer_nthroot(10**n, 4)[0] + 1))
        for b, m in enumerate(primerange(k, integer_nthroot(10**n // k, 3)[0] + 1), a)
        for c, r in enumerate(primerange(m, isqrt(10**n // (k * m)) + 1), b)
    )


def A014614(n):
    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(x // (k * m * r * s)) - d
                for a, k in enumerate(primerange(integer_nthroot(x, 5)[0] + 1))
                for b, m in enumerate(
                    primerange(k, integer_nthroot(x // k, 4)[0] + 1), a
                )
                for c, r in enumerate(
                    primerange(m, integer_nthroot(x // (k * m), 3)[0] + 1), b
                )
                for d, s in enumerate(primerange(r, isqrt(x // (k * m * r)) + 1), c)
            )
        )

    return bisection(f, m := f(f(n)), m)


def A124284(n):
    def f(x):
        return int(
            x
            - sum(
                primepi(x // (k * m * r)) - c
                for a, k in enumerate(primerange(integer_nthroot(x, 4)[0] + 1))
                for b, m in enumerate(
                    primerange(k, integer_nthroot(x // k, 3)[0] + 1), a
                )
                for c, r in enumerate(primerange(m, isqrt(x // (k * m)) + 1), b)
            )
        )

    m, k = n, f(n) + n
    while m != k:
        m, k = k, f(k) + n
    r, k = (p := prime(n)), f(p) + p
    while r != k:
        r, k = k, f(k) + p
    return prime(m) - r


def A005179(n):
    def mult_factors(n):
        if isprime(n):
            return [(n,)]
        c = []
        for d in divisors(n, generator=True):
            if 1 < d < n:
                for a in mult_factors(n // d):
                    c.append(tuple(sorted((d,) + a)))
        return list(set(c))

    return min(
        (
            prod(prime(i) ** (j - 1) for i, j in enumerate(reversed(d), 1))
            for d in mult_factors(n)
        ),
        default=1,
    )


def A061218(n):
    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(x // (k * m * r)) - c
                for a, k in enumerate(primerange(integer_nthroot(x, 4)[0] + 1))
                for b, m in enumerate(
                    primerange(k, integer_nthroot(x // k, 3)[0] + 1), a
                )
                for c, r in enumerate(primerange(m, isqrt(x // (k * m)) + 1), b)
            )
        )

    def mult_factors(n):
        if isprime(n):
            return [(n,)]
        c = []
        for d in divisors(n, generator=True):
            if 1 < d < n:
                for a in mult_factors(n // d):
                    c.append(tuple(sorted((d,) + a)))
        return list(set(c))

    k = f(f(n))
    return min(
        (
            prod(prime(i) ** (j - 1) for i, j in enumerate(reversed(d), 1))
            for d in mult_factors(bisection(f, k, k))
        ),
        default=1,
    )


def A038547(n):
    def mult_factors(n):
        if isprime(n):
            return [(n,)]
        c = []
        for d in divisors(n, generator=True):
            if 1 < d < n:
                for a in mult_factors(n // d):
                    c.append(tuple(sorted((d,) + a)))
        return list(set(c))

    return min(
        (
            prod(prime(i) ** (j - 1) for i, j in enumerate(reversed(d), 2))
            for d in mult_factors(n)
        ),
        default=1,
    )


def A143525(n):
    def mult_factors(n):
        if isprime(n):
            return [(n,)]
        c = []
        for d in divisors(n, generator=True):
            if 1 < d < n:
                for a in mult_factors(n // d):
                    c.append(tuple(sorted((d,) + a)))
        return list(set(c))

    return int(
        divisor_count(
            min(
                (
                    prod(prime(i) ** (j - 1) for i, j in enumerate(reversed(d), 1))
                    for d in mult_factors(n)
                ),
                default=1,
            )
            - 1
        )
    )


def A124319(n):
    def f(x):
        return int(
            x
            - sum(
                primepi(x // (k * m)) - b
                for a, k in enumerate(primerange(integer_nthroot(x, 3)[0] + 1))
                for b, m in enumerate(primerange(k, isqrt(x // k) + 1), a)
            )
        )

    def g(x):
        return int(
            x
            + ((t := primepi(s := isqrt(x))) * (t - 1) >> 1)
            - sum(primepi(x // k) for k in primerange(1, s + 1))
        )

    def A001358(n):
        m, k = n, g(n) + n
        while m != k:
            m, k = k, g(k) + n
        return m

    m, k = n, f(n) + n
    while m != k:
        m, k = k, f(k) + n
    r, k = (p := A001358(n)), f(p) + p
    while r != k:
        r, k = k, f(k) + p
    return A001358(m) - r


def A124317(n):
    def f(x):
        return int(
            x
            - sum(
                primepi(x // (k * m)) - b
                for a, k in enumerate(primerange(integer_nthroot(x, 3)[0] + 1))
                for b, m in enumerate(primerange(k, isqrt(x // k) + 1), a)
            )
        )

    def g(x):
        return int(
            x
            + ((t := primepi(s := isqrt(x))) * (t - 1) >> 1)
            - sum(primepi(x // k) for k in primerange(1, s + 1))
        )

    m, k = n, f(n) + n
    while m != k:
        m, k = k, f(k) + n
    r, k = m, g(m) + m
    while r != k:
        r, k = k, g(k) + m
    return r


def A124318(n):
    def g(x):
        return int(
            x
            - sum(
                primepi(x // (k * m)) - b
                for a, k in enumerate(primerange(integer_nthroot(x, 3)[0] + 1))
                for b, m in enumerate(primerange(k, isqrt(x // k) + 1), a)
            )
        )

    def f(x):
        return int(
            x
            + ((t := primepi(s := isqrt(x))) * (t - 1) >> 1)
            - sum(primepi(x // k) for k in primerange(1, s + 1))
        )

    m, k = n, f(n) + n
    while m != k:
        m, k = k, f(k) + n
    r, k = m, g(m) + m
    while r != k:
        r, k = k, g(k) + m
    return r


def A185445(n):
    def mult_factors(n):
        if isprime(n):
            return [(n,)]
        c = []
        for d in divisors(n, generator=True):
            if 1 < d < n:
                for a in mult_factors(n // d):
                    c.append(tuple(sorted((d,) + a)))
        return list(set(c))

    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(x // (k * m)) - b
                for a, k in enumerate(primerange(integer_nthroot(x, 3)[0] + 1))
                for b, m in enumerate(primerange(k, isqrt(x // k) + 1), a)
            )
        )

    return min(
        (
            prod(prime(i) ** (j - 1) for i, j in enumerate(reversed(d), 1))
            for d in mult_factors(iterfun(f, n))
        ),
        default=1,
    )


def A375491(n):
    def f(x):
        return n + x - sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

    a = set(primefactors(bisection(f, k := f(f(n)), k)))
    return sum(
        prod((p ** sum(1 for q in b if q % p == 1) - 1) // (p - 1) for p in a - set(b))
        for l in range(0, len(a) + 1)
        for b in combinations(a, l)
    )


def A375483(n):
    def f(x):
        return n + x - sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

    a = set(primefactors(m := bisection(f, k := f(f(n)), k)))
    return sum(
        prod((p ** sum(1 for q in b if q % p == 1) - 1) // (p - 1) for p in a - set(b))
        for l in range(0, len(a) + 1)
        for b in combinations(a, l)
    ) - prod(map(npartitions, factorint(m).values()))


def A085986(n):
    def f(x):
        return int(
            n
            + x
            + (t := primepi(s := isqrt(x)))
            + (t * (t - 1) >> 1)
            - sum(primepi(x // k) for k in primerange(1, s + 1))
        )

    return bisection(f, m := f(f(n)), m) ** 2


def A072774(n):
    def g(x):
        return int(sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))) - 1

    def f(x):
        return (
            n
            - 1
            + x
            - sum(g(integer_nthroot(x, k)[0]) for k in range(1, x.bit_length()))
        )

    return bisection(f, m := f(f(n)), m)


def A072775(n):
    def g(x):
        return int(sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))) - 1

    def f(x):
        return (
            n
            - 1
            + x
            - sum(g(integer_nthroot(x, k)[0]) for k in range(1, x.bit_length()))
        )

    return prod(primefactors(bisection(f, m := f(f(n)), m)))


def A072490(n):
    return (
        int(sum(mobius(k) * ((n - 1) // k**2) for k in range(1, isqrt(n - 1) + 1))) - 1
        if n > 1
        else 0
    )


def A072777(n):
    def g(x):
        return int(sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))) - 1

    def f(x):
        return (
            n + x - sum(g(integer_nthroot(x, k)[0]) for k in range(2, x.bit_length()))
        )

    return bisection(f, m := f(f(n)), m)


def A072778(n):
    def f(x):
        return int(sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1)))

    return (
        2
        - (m := n.bit_length())
        + sum(f(integer_nthroot(n, k)[0]) for k in range(1, m))
    )


def A072776(n):
    def g(x):
        return int(sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))) - 1

    def f(x):
        return (
            n
            - 1
            + x
            - sum(g(integer_nthroot(x, k)[0]) for k in range(1, x.bit_length()))
        )

    return 1 if not (p := perfect_power(bisection(f, m := f(f(n)), m))) else p[1]


def A062503(n):
    def f(x):
        return n + x - sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

    return bisection(f, m := f(f(n)), m) ** 2


def A062770(n):
    def g(x):
        return int(sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1)))

    def f(x):
        return (
            n
            - 2
            + x
            + (y := x.bit_length())
            - sum(g(integer_nthroot(x, k)[0]) for k in range(1, y))
        )

    return bisection(f, m := f(f(n)), m)


def A375109(n):
    return (
        len({i * j for i in range(1, n + 1) for j in range((n << 1) // i + 1, i + 1)})
        + 1
    )


def A113849(n):
    def f(x):
        return n + 1 + x - sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

    return bisection(f, m := f(f(n)), m) ** 4


def A059404(n):
    def g(x):
        return int(sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1)))

    def f(x):
        return (
            n
            + 2
            - (y := x.bit_length())
            + sum(g(integer_nthroot(x, k)[0]) for k in range(1, y))
        )

    return bisection(f, m := f(f(n)), m)


def A303946(n):
    def f(x):
        return int(
            n
            + sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))
            - sum(
                mobius(k) * (integer_nthroot(x, k)[0] - 1)
                for k in range(2, x.bit_length())
            )
        )

    return iterfun(f, n)


def A304449(n):
    def f(x):
        return int(
            n
            + x
            - sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))
            + sum(
                mobius(k) * (integer_nthroot(x, k)[0] - 1)
                for k in range(2, x.bit_length())
            )
        )

    return iterfun(f, n)


def A303554(n):
    def f(x):
        return int(
            n
            + x
            - sum(primepi(integer_nthroot(x, k)[0]) for k in range(2, x.bit_length()))
            - sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))
        )

    return iterfun(f, n)


def A108954(n):
    return primepi(n << 1) - primepi(n)


def A067434(n):
    return primenu(comb(n << 1, n))


def A303661(n):
    def g(x):
        return int(
            -(t := primepi(s := isqrt(x)))
            - (t * (t - 1) >> 1)
            + sum(primepi(x // k) for k in primerange(1, s + 1))
        )

    def f(x):
        return (
            n + x - sum(g(integer_nthroot(x, k)[0]) for k in range(2, x.bit_length()))
        )

    return bisection(f, m := f(f(n)), m)


def A303606(n):
    if n == 1:
        return 36

    def g(x):
        return int(
            sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1)) - primepi(x)
        )

    def f(x):
        return (
            n
            - 2
            + x
            + (y := x.bit_length())
            - sum(g(integer_nthroot(x, k)[0]) for k in range(2, y))
        )

    return bisection(f, m := f(f(n)), m)


def A182853(n):
    def g(x):
        return int(
            sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1)) - primepi(x)
        )

    def f(x):
        return (
            n
            - 1
            + x
            + (y := x.bit_length())
            - sum(g(integer_nthroot(x, k)[0]) for k in range(1, y))
        )

    return bisection(f, m := f(f(n)), m)


def A001690(n):
    def f(x):
        a, b, c = 1, 1, n
        while True:
            if b > x:
                return c
            a, b = b, a + b
            c += 1

    return iterfun(f, n)


def A246655(n):
    def f(x):
        return int(
            n
            + x
            - sum(primepi(integer_nthroot(x, k)[0]) for k in range(1, x.bit_length()))
        )

    return bisection(f, m := f(f(n)), m)


def A085970(n):
    return (
        n - 1 - sum(primepi(integer_nthroot(n, k)[0]) for k in range(1, n.bit_length()))
    )


def A085972(n):
    return (
        n - 1 - sum(primepi(integer_nthroot(n, k)[0]) for k in range(2, n.bit_length()))
    )


def A085971(n):
    def f(x):
        return int(
            n
            + 1
            + sum(primepi(integer_nthroot(x, k)[0]) for k in range(2, x.bit_length()))
        )

    return bisection(f, m := f(f(n)), m)


def A085818(n):
    return (
        1
        if n == 1
        else (
            f[0]
            if len(f := primefactors(n)) == 1 and f[0] < n
            else prime(
                n
                - 1
                - sum(
                    primepi(integer_nthroot(n, k)[0]) for k in range(2, n.bit_length())
                )
            )
        )
    )


def A085819(n):
    return prod(A085818(i) for i in range(2, n + 1))


def A359129(n):
    def f(x):
        return int(
            n
            - 1
            + x
            - sum(primepi(integer_nthroot(x, k)[0]) for k in range(1, x.bit_length()))
        )

    return (
        (m := bisection(f, k := f(f(n)), k) ** 2)
        * (m * (m * (m * (m * (m * (m * (m - 1) + 1) - 2) + 2) - 2) + 1) - 1)
        + 1
    ) * m**6


def A037253(n):
    return (m := n**2) ** 6 * (
        m * (m * (m * (m * (m * (m * (m * (m - 1) + 1) - 2) + 2) - 2) + 1) - 1) + 1
    )


def A064588(n):
    return (m := 1 << (n << 1)) * (
        m * (m * (m * (m * (m * (m * (m - 1) + 1) - 2) + 2) - 2) + 1) - 1
    ) + 1 << 12 * n


def A064587(n):
    return n**6 * (
        n * (n * (n * (n * (n * (n * (n * (n - 1) + 1) - 2) + 2) - 2) + 1) - 1) + 1
    )


def A064589(n):
    return (m := 3 ** (n << 1)) ** 6 * (
        m * (m * (m * (m * (m * (m * (m * (m - 1) + 1) - 2) + 2) - 2) + 1) - 1) + 1
    )


def A330669(n):
    if n == 1:
        return 0

    def f(x):
        return int(
            n
            - 1
            + x
            - sum(primepi(integer_nthroot(x, k)[0]) for k in range(1, x.bit_length()))
        )

    return int(primepi(primefactors(bisection(f, m := f(f(n)), m))[0]))


def A371195(n):
    def f(x):
        return int(
            n
            - 1
            + x
            - sum(primepi(integer_nthroot(x, k)[0]) for k in range(1, x.bit_length()))
        )

    return (k := bisection(f, m := f(f(n)), m)) ** 4 * (k - 1)


def A368325(n):
    @lru_cache(maxsize=None)
    def g(x):
        return primorial(x)

    def f(x):
        c = n + x - x.bit_length()
        kmin, kmax = 1, 2
        while g(kmax) <= x:
            kmax <<= 1
        while True:
            kmid = kmax + kmin >> 1
            if g(kmid) > x:
                kmax = kmid
            else:
                kmin = kmid
            if kmax - kmin <= 1:
                break
        return c - kmin

    kmin, kmax = 1, 2
    while f(kmax) >= kmax:
        kmax <<= 1
    while True:
        kmid = kmax + kmin >> 1
        if f(kmid) < kmid:
            kmax = kmid
        else:
            kmin = kmid
        if kmax - kmin <= 1:
            break
    return kmax


def A375580(n):
    return sum(
        1
        for x in range(n // 3)
        for y in range(x, n - x - 1 >> 1)
        if integer_nthroot((n - x - y - 2) * (x + 1) * (y + 1), 3)[1]
    )


def A338939(n):
    return len(diop_quadratic(symbolx * (n - symbolx) - symboly**2)) >> 2


def A115878(n):
    return sum(
        1 for d in takewhile(lambda d: d < n, divisors(n**2)) if not (d - n**2 // d) & 3
    )


def A338940(n):
    return A338939(n) * A115878(n)


def A337140_gen(startvalue=2):  # generator of terms >= startvalue
    return filter(
        lambda n: n & 1 ^ 1
        or not all(p & 2 for p in primefactors(n >> (~n & n - 1).bit_length())),
        count(max(startvalue, 2)),
    )


def A004614_gen(startvalue=1):  # generator of terms >= startvalue
    return filter(
        lambda n: n & 1
        and all(p & 2 for p in primefactors(n >> (~n & n - 1).bit_length())),
        count(max(startvalue, 1)),
    )


def A115880(n):
    a, b = divmod(n, 4)
    return (a**2 - 1, (c := a << 1) * (c + 1), c * (a + 1), c * (c + 3) + 2)[b]


def A115881(n):
    a, b = divmod(n, 4)
    return ((c := a**2) - (a << 1) + 1, (d := c << 2), c << 1, d + (a << 2) + 1)[b]


def A115879(n):
    return (
        -(
            a := next(
                iter(
                    deque(
                        (
                            d
                            for d in takewhile(lambda d: d < n, divisors(n**2))
                            if not (d - n**2 // d) & 3
                        ),
                        1,
                    )
                ),
                0,
            )
        )
        + (n**2 // a if a else 0)
        >> 2
    )


def A067721(n):
    return (
        (
            (
                a := next(
                    iter(
                        deque(
                            (
                                d
                                for d in takewhile(lambda d: d < n, divisors(n**2))
                                if not (d - n**2 // d) & 3
                            ),
                            1,
                        )
                    ),
                    0,
                )
            )
            + (n**2 // a - (n << 1) if a else 0)
            >> 2
        )
        if n
        else 1
    )


def A180622(n):
    @lru_cache(maxsize=None)
    def f(n):  # based on second formula in A018805
        if n == 0:
            return 0
        c, j = 0, 2
        k1 = n // j
        while k1 > 1:
            j2 = n // k1 + 1
            c += (j2 - j) * (f(k1) - 1)
            j, k1 = j2, n // j2
        return n * (n - 1) - c + j

    return (
        len({i * j for i in range(1, n + 1) for j in range(1, i + 1)})
        + f(n)
        + primepi(n << 1)
        - primepi(n)
        - n
    )


if sys.version_info >= (3, 10):

    def A375635(n):
        return 1 << sum(
            e.bit_count()
            for e in sum(
                (Counter(factorint(i)) for i in range(2, n + 1)), start=Counter()
            ).values()
        )

else:

    def A375635(n):
        return 1 << sum(
            bin(e).count("1")
            for e in sum(
                (Counter(factorint(i)) for i in range(2, n + 1)), start=Counter()
            ).values()
        )


def A375567(n):
    return sum(
        1
        for x in range(n // 3)
        for y in range(x, n - x - 1 >> 1)
        if is_square((n - x - y - 2) * (x + 1) * (y + 1))
    )


def A375512(n):
    return sum(
        1
        for x in range(1, (n >> 2) + 1)
        for y in range(x + 1, (n - x) // 3 + 1)
        for z in range(y, (n - y >> 1) + 1)
        if x < y <= z < (n - x - y - z) and y * z == x * (n - x - y - z)
    )


def A048146(n):
    return divisor_sigma(n) - udivisor_sigma(n)


def A028982(n):
    def f(x):
        return n + x - isqrt(x) - isqrt(x >> 1)

    return bisection(f, m := f(f(n)), m)


def A028983(n):
    def f(x):
        return n + isqrt(x) + isqrt(x >> 1)

    return bisection(f, m := f(f(n)), m)


@lru_cache(maxsize=None)
def A073576(n):
    return (
        sum(
            sum(d * abs(mobius(d)) for d in divisors(i, generator=True))
            * A073576(n - i)
            for i in range(1, n + 1)
        )
        // n
        if n
        else 1
    )


def A303365(n):
    return A073576(A005117(n))


def A046306(n):
    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b, isqrt(x // c) + 1), a))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b, integer_nthroot(x // c, m)[0] + 1), a
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0] for a in g(x, 0, 1, 1, 6)
            )
        )

    return bisection(f, m := f(f(n)), m)


def A069281(n):
    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b, isqrt(x // c) + 1), a))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b, integer_nthroot(x // c, m)[0] + 1), a
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0]
                for a in g(x, 0, 1, 1, 20)
            )
        )

    return bisection(f, m := f(f(n)), m)


def A101695(n):
    if n == 1:
        return 2

    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b, isqrt(x // c) + 1), a))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b, integer_nthroot(x // c, m)[0] + 1), a
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0] for a in g(x, 0, 1, 1, n)
            )
        )

    return bisection(f, m := f(f(n)), m)


def A078841(n):
    if n <= 1:
        return (n << 1) + 1

    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b, isqrt(x // c) + 1), a))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b, integer_nthroot(x // c, m)[0] + 1), a
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            n
            + 1
            + x
            - sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0] for a in g(x, 0, 1, 1, n)
            )
        )

    return bisection(f, m := f(f(n)), m)


def A078840_T(n, k):
    if n == 1:
        return prime(k)

    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b, isqrt(x // c) + 1), a))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b, integer_nthroot(x // c, m)[0] + 1), a
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            k
            + x
            - sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0] for a in g(x, 0, 1, 1, n)
            )
        )

    return bisection(f, m := f(f(k)), m)


def A069280(n):
    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b, isqrt(x // c) + 1), a))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b, integer_nthroot(x // c, m)[0] + 1), a
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0]
                for a in g(x, 0, 1, 1, 19)
            )
        )

    return bisection(f, m := f(f(n)), m)


def A069279(n):
    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b, isqrt(x // c) + 1), a))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b, integer_nthroot(x // c, m)[0] + 1), a
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0]
                for a in g(x, 0, 1, 1, 18)
            )
        )

    return bisection(f, m := f(f(n)), m)


def A046308(n):
    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b, isqrt(x // c) + 1), a))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b, integer_nthroot(x // c, m)[0] + 1), a
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0] for a in g(x, 0, 1, 1, 7)
            )
        )

    return bisection(f, m := f(f(n)), m)


def A046307(n):
    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b, isqrt(x // c) + 1), a))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b, integer_nthroot(x // c, m)[0] + 1), a
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            n
            + 1
            + primepi(x)
            + sum(
                sum(
                    primepi(x // prod(c[1] for c in a)) - a[-1][0]
                    for a in g(x, 0, 1, 1, i)
                )
                for i in range(2, 7)
            )
        )

    return bisection(f, m := f(f(n)), m)


def A046311(n):
    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b, isqrt(x // c) + 1), a))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b, integer_nthroot(x // c, m)[0] + 1), a
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            n
            + 1
            + primepi(x)
            + sum(
                sum(
                    primepi(x // prod(c[1] for c in a)) - a[-1][0]
                    for a in g(x, 0, 1, 1, i)
                )
                for i in range(2, 9)
            )
        )

    return bisection(f, m := f(f(n)), m)


def A046309(n):
    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b, isqrt(x // c) + 1), a))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b, integer_nthroot(x // c, m)[0] + 1), a
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            n
            + 1
            + primepi(x)
            + sum(
                sum(
                    primepi(x // prod(c[1] for c in a)) - a[-1][0]
                    for a in g(x, 0, 1, 1, i)
                )
                for i in range(2, 8)
            )
        )

    return bisection(f, m := f(f(n)), m)


def A116453(n):
    return 9 << n - 2 if n > 1 else 5


def A078842(n):
    return sum(A078840_T(i + 1, n - i) for i in range(n)) if n else 1


def A046310(n):
    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b, isqrt(x // c) + 1), a))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b, integer_nthroot(x // c, m)[0] + 1), a
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0] for a in g(x, 0, 1, 1, 8)
            )
        )

    return bisection(f, m := f(f(n)), m)


def A046321(n):
    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b, isqrt(x // c) + 1), a))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b, integer_nthroot(x // c, m)[0] + 1), a
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0] for a in g(x, 1, 3, 1, 8)
            )
        )

    return bisection(f, m := f(f(n)), m)


def A120049(n):
    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b, isqrt(x // c) + 1), a))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b, integer_nthroot(x // c, m)[0] + 1), a
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    return int(
        sum(
            primepi(10**n // prod(c[1] for c in a)) - a[-1][0]
            for a in g(10**n, 0, 1, 1, 8)
        )
    )


def A116430(n):
    if n <= 1:
        return 3 * n + 1

    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b, isqrt(x // c) + 1), a))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b, integer_nthroot(x // c, m)[0] + 1), a
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    return int(
        sum(
            primepi(10**n // prod(c[1] for c in a)) - a[-1][0]
            for a in g(10**n, 0, 1, 1, n)
        )
    )


def A046323(n):
    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b, isqrt(x // c) + 1), a))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b, integer_nthroot(x // c, m)[0] + 1), a
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0]
                for a in g(x, 1, 3, 1, 10)
            )
        )

    return bisection(f, m := f(f(n)), m)


def A033987(n):
    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b, isqrt(x // c) + 1), a))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b, integer_nthroot(x // c, m)[0] + 1), a
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            n
            + 1
            + primepi(x)
            + sum(
                sum(
                    primepi(x // prod(c[1] for c in a)) - a[-1][0]
                    for a in g(x, 0, 1, 1, i)
                )
                for i in range(2, 4)
            )
        )

    return bisection(f, m := f(f(n)), m)


def A037144(n):
    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b, isqrt(x // c) + 1), a))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b, integer_nthroot(x // c, m)[0] + 1), a
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            n
            + x
            - 1
            - primepi(x)
            - sum(
                sum(
                    primepi(x // prod(c[1] for c in a)) - a[-1][0]
                    for a in g(x, 0, 1, 1, i)
                )
                for i in range(2, 4)
            )
        )

    return bisection(f, m := f(f(n)), m)


def A128644(n):
    if n == 1:
        return 1

    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b, isqrt(x // c) + 1), a))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b, integer_nthroot(x // c, m)[0] + 1), a
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            n
            + x
            - 1
            - primepi(x)
            - sum(
                sum(
                    primepi(x // prod(c[1] for c in a)) - a[-1][0]
                    for a in g(x, 0, 1, 1, i)
                )
                for i in range(2, 4)
            )
        )

    fs = factorint(bisection(f, m := f(f(n)), m))
    if max(fs.values()) == 1:
        a = set(fs.keys())
        return sum(
            prod(
                (p ** sum(1 for q in b if q % p == 1) - 1) // (p - 1)
                for p in a - set(b)
            )
            for l in range(0, len(a) + 1)
            for b in combinations(a, l)
        )
    if len(fs) == 1:
        return 3 * list(fs.values())[0] - 4
    p, q = list(fs.keys())
    if fs[p] > 1:
        p, q = q, p
    if q % p == 1 and p & 1:
        return p + 9 >> 1
    r = (p - 1) % (q**2)
    if (p == 3 and q == 2) or (p == 2 and q & 1) or not r:
        return 5
    if not (p - 1) % q and p > 3 and r:
        return 4
    if not (q + 1) % p and p & 1 and q & 1:
        return 3
    if (q + 1) % p and (q - 1) % p and (p - 1) % q:
        return 2


def A033942(n):
    def f(x):
        return int(
            n
            + 1
            + primepi(x)
            + sum(primepi(x // k) - a for a, k in enumerate(primerange(isqrt(x) + 1)))
        )

    return bisection(f, m := f(f(n)), m)


def A037143(n):
    def f(x):
        return int(
            n
            - 1
            + x
            - primepi(x)
            - sum(primepi(x // k) - a for a, k in enumerate(primerange(isqrt(x) + 1)))
        )

    return bisection(f, m := f(f(n)), m)


def A046313(n):
    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b, isqrt(x // c) + 1), a))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b, integer_nthroot(x // c, m)[0] + 1), a
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            n
            + 1
            + primepi(x)
            + sum(
                sum(
                    primepi(x // prod(c[1] for c in a)) - a[-1][0]
                    for a in g(x, 0, 1, 1, i)
                )
                for i in range(2, 10)
            )
        )

    return bisection(f, m := f(f(n)), m)


def A120053(n):
    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b, isqrt(x // c) + 1), a))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b, integer_nthroot(x // c, m)[0] + 1), a
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    return int(
        sum(
            primepi(10**n // prod(c[1] for c in a)) - a[-1][0]
            for a in g(10**n, 0, 1, 1, 12)
        )
    )


def A372683(n):
    return next(i for i in count(1 << n) if max(factorint(i).values(), default=1) == 1)


def A090864(n):
    def f(x):
        return n + (m := isqrt(24 * x + 1) + 1) // 6 + (m - 2) // 6

    return bisection(f, m := f(f(n)), m)


def A183218(n):
    return n + (isqrt(n << 1) + 1 >> 1)


def A135668(n):
    return n + (a := integer_nthroot(n, 2))[0] + (not a[1])


def A138929(n):
    def f(x):
        return int(
            n
            - 1
            + x
            - sum(primepi(integer_nthroot(x, k)[0]) for k in range(1, x.bit_length()))
        )

    return bisection(f, m := f(f(n)), m) << 1


def A230078(n):
    if n == 1:
        return 1

    def f(x):
        return int(
            n
            + 1
            + sum(
                primepi(integer_nthroot(x >> 1, k)[0])
                for k in range(1, (x >> 1).bit_length())
            )
        )

    return bisection(f, m := f(f(n)), m)


def A020513(n):
    return (
        (-1, -2, 0)[n]
        if n < 3
        else (f[0] if n & 1 ^ 1 and len(f := primefactors(n >> 1)) == 1 else 1)
    )


def A215218(n):
    return int(
        sum(
            primepi(10**n // (k * m)) - b
            for a, k in enumerate(primerange(integer_nthroot(10**n, 3)[0] + 1), 1)
            for b, m in enumerate(primerange(k + 1, isqrt(10**n // k) + 1), a + 1)
        )
    )


def A007304(n):
    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(x // (k * m)) - b
                for a, k in enumerate(primerange(integer_nthroot(x, 3)[0] + 1), 1)
                for b, m in enumerate(primerange(k + 1, isqrt(x // k) + 1), a + 1)
            )
        )

    return bisection(f, m := f(f(n)), m)


def A162143(n):
    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(x // (k * m)) - b
                for a, k in enumerate(primerange(integer_nthroot(x, 3)[0] + 1), 1)
                for b, m in enumerate(primerange(k + 1, isqrt(x // k) + 1), a + 1)
            )
        )

    return bisection(f, m := f(f(n)), m) ** 2


def A096917(n):
    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(x // (k * m)) - b
                for a, k in enumerate(primerange(integer_nthroot(x, 3)[0] + 1), 1)
                for b, m in enumerate(primerange(k + 1, isqrt(x // k) + 1), a + 1)
            )
        )

    return min(primefactors(bisection(f, m := f(f(n)), m)))


def A096918(n):
    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(x // (k * m)) - b
                for a, k in enumerate(primerange(integer_nthroot(x, 3)[0] + 1), 1)
                for b, m in enumerate(primerange(k + 1, isqrt(x // k) + 1), a + 1)
            )
        )

    return sorted(primefactors(bisection(f, m := f(f(n)), m)))[1]


def A096919(n):
    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(x // (k * m)) - b
                for a, k in enumerate(primerange(integer_nthroot(x, 3)[0] + 1), 1)
                for b, m in enumerate(primerange(k + 1, isqrt(x // k) + 1), a + 1)
            )
        )

    return max(primefactors(bisection(f, m := f(f(n)), m)))


def A087053(n):
    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(x // (k * m)) - b
                for a, k in enumerate(primerange(integer_nthroot(x, 3)[0] + 1), 1)
                for b, m in enumerate(primerange(k + 1, isqrt(x // k) + 1), a + 1)
            )
        )

    return (p := primefactors(bisection(f, m := f(f(n)), m)))[0] * (p[1] + p[2]) + p[
        1
    ] * p[2]


def A162144(n):
    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(x // (k * m)) - b
                for a, k in enumerate(primerange(integer_nthroot(x, 3)[0] + 1), 1)
                for b, m in enumerate(primerange(k + 1, isqrt(x // k) + 1), a + 1)
            )
        )

    return bisection(f, m := f(f(n)), m) ** 3


def A271329(n):
    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(x // (k * m)) - b
                for a, k in enumerate(primerange(integer_nthroot(x, 3)[0] + 1), 1)
                for b, m in enumerate(primerange(k + 1, isqrt(x // k) + 1), a + 1)
            )
        )

    return divisor_sigma(bisection(f, m := f(f(n)), m))


def A246716(n):
    def f(x):
        return int(
            n
            - (t := primepi(s := isqrt(x)))
            - (t * (t - 1) >> 1)
            + sum(primepi(x // k) for k in primerange(1, s + 1))
        )

    return bisection(f, m := f(f(n)), m)


def A046386(n):
    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(x // (k * m * r)) - c
                for a, k in enumerate(primerange(integer_nthroot(x, 4)[0] + 1), 1)
                for b, m in enumerate(
                    primerange(k + 1, integer_nthroot(x // k, 3)[0] + 1), a + 1
                )
                for c, r in enumerate(primerange(m + 1, isqrt(x // (k * m)) + 1), b + 1)
            )
        )

    return bisection(f, m := f(f(n)), m)


def A046387(n):
    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b + 1, isqrt(x // c) + 1), a + 1))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b + 1, integer_nthroot(x // c, m)[0] + 1), a + 1
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0] for a in g(x, 0, 1, 1, 5)
            )
        )

    return bisection(f, m := f(f(n)), m)


def A067885(n):
    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b + 1, isqrt(x // c) + 1), a + 1))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b + 1, integer_nthroot(x // c, m)[0] + 1), a + 1
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0] for a in g(x, 0, 1, 1, 6)
            )
        )

    return bisection(f, m := f(f(n)), m)


def A361102(n):
    def f(x):
        return int(
            n + sum(primepi(integer_nthroot(x, k)[0]) for k in range(1, x.bit_length()))
        )

    return bisection(f, m := f(f(n)), m)


def A123321(n):
    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b + 1, isqrt(x // c) + 1), a + 1))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b + 1, integer_nthroot(x // c, m)[0] + 1), a + 1
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0] for a in g(x, 0, 1, 1, 7)
            )
        )

    return bisection(f, m := f(f(n)), m)


def A123322(n):
    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b + 1, isqrt(x // c) + 1), a + 1))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b + 1, integer_nthroot(x // c, m)[0] + 1), a + 1
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0] for a in g(x, 0, 1, 1, 8)
            )
        )

    return bisection(f, m := f(f(n)), m)


def A115343(n):
    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b + 1, isqrt(x // c) + 1), a + 1))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b + 1, integer_nthroot(x // c, m)[0] + 1), a + 1
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0] for a in g(x, 0, 1, 1, 9)
            )
        )

    return bisection(f, m := f(f(n)), m)


def A281222(n):
    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b + 1, isqrt(x // c) + 1), a + 1))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b + 1, integer_nthroot(x // c, m)[0] + 1), a + 1
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0]
                for a in g(x, 0, 1, 1, 10)
            )
        )

    return bisection(f, m := f(f(n)), m)


def A340467(n):
    if n == 1:
        return 2

    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b + 1, isqrt(x // c) + 1), a + 1))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b + 1, integer_nthroot(x // c, m)[0] + 1), a + 1
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0] for a in g(x, 0, 1, 1, n)
            )
        )

    return bisection(f, m := f(f(n)), m)


def A356683(n):
    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b + 1, isqrt(x // c) + 1), a + 1))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b + 1, integer_nthroot(x // c, m)[0] + 1), a + 1
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(k, n):
        return (
            sum(
                primepi(k // prod(c[1] for c in a)) - a[-1][0] for a in g(k, 0, 1, 1, n)
            )
            if n > 1
            else primepi(k)
        )

    return (
        2
        if n == 1
        else next(k for k in count(1) if (x := f(k, n - 1)) > 0 and x == f(k, n))
    )


def A340316_T(n, k):
    if n == 1:
        return prime(k)

    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b + 1, isqrt(x // c) + 1), a + 1))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b + 1, integer_nthroot(x // c, m)[0] + 1), a + 1
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            k
            + x
            - sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0] for a in g(x, 0, 1, 1, n)
            )
        )

    return bisection(f, m := f(f(n)), m)


def A072047(n):
    def f(x):
        return n + x - sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

    return primenu(bisection(f, m := f(f(n)), m))


def A340313(n):
    if n == 1:
        return 1

    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b + 1, isqrt(x // c) + 1), a + 1))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b + 1, integer_nthroot(x // c, m)[0] + 1), a + 1
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return n + x - sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

    kmax = bisection(f, m := f(f(n)), m)
    return int(
        sum(
            primepi(kmax // prod(c[1] for c in a)) - a[-1][0]
            for a in g(kmax, 0, 1, 1, m)
        )
        if (m := primenu(kmax)) > 1
        else primepi(kmax)
    )


def A337877(n):
    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(x // k**2) - a
                for a, k in enumerate(primerange(integer_nthroot(x, 3)[0] + 1))
            )
        )

    return bisection(f, m := f(f(n)), m)


def A068499(n):
    return prime(n - 1) - 1 if n > 3 else n


def A006093(n):
    return prime(n) - 1


def A183917_T(n, k):
    return sum(1 for p in partitions(k * n, m=n, k=k << 1))


def A166460(n):
    return composite(n - 1) - 1 if n > 2 else n - 1


def A375783(n):
    def A183917_T(n, k):
        return sum(1 for p in partitions(k * n, m=n, k=k << 1))

    x = (
        sum(
            A183917_T((n + 1) // d - 2, d - 1)
            for d in divisors(n + 1 >> 1, generator=True)
        )
        if n & 1
        else 0
    )
    y = (
        sum(
            A183917_T(d - 2, (n + 1) // d - 1)
            for d in divisors((n + 1) >> (~(n + 1) & n).bit_length(), generator=True)
            if d >= 3
        )
        << 1
    )
    return x + y


def A375089(n):
    a, b = fib2((m := n << 1) + 1)
    return sum(1 for d in divisors(gcd(a - 1, b), generator=True) if A001175(d) == m)


def A375519(n):
    a, b = fib2(n + 1)
    return sum(1 for d in divisors(gcd(a - 1, b), generator=True) if A001175(d) == n)


def A058933(n):
    if n == 1:
        return 1
    if isprime(n):
        return primepi(n)

    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b, isqrt(x // c) + 1), a))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b, integer_nthroot(x // c, m)[0] + 1), a
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    return int(
        sum(
            primepi(n // prod(c[1] for c in a)) - a[-1][0]
            for a in g(n, 0, 1, 1, primeomega(n))
        )
    )


def A335097(n):
    if n == 1:
        return 0
    if isprime(n):
        return primepi(n) - 1

    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b, isqrt(x // c) + 1), a))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b, integer_nthroot(x // c, m)[0] + 1), a
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    return int(
        sum(
            primepi(n // prod(c[1] for c in a)) - a[-1][0]
            for a in g(n, 0, 1, 1, primeomega(n))
        )
        - 1
    )


def A069278(n):
    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b, isqrt(x // c) + 1), a))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b, integer_nthroot(x // c, m)[0] + 1), a
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0]
                for a in g(x, 0, 1, 1, 17)
            )
        )

    return bisection(f, m := f(f(n)), m)


def A069277(n):
    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b, isqrt(x // c) + 1), a))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b, integer_nthroot(x // c, m)[0] + 1), a
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0]
                for a in g(x, 0, 1, 1, 16)
            )
        )

    return bisection(f, m := f(f(n)), m)


def A073481(n):
    def f(x):
        return n + x - sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

    return min(primefactors(bisection(f, m := f(f(n)), m)), default=1)


def A073482(n):
    def f(x):
        return n + x - sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

    return max(primefactors(bisection(f, m := f(f(n)), m)), default=1)


def A374663_gen():  # generator of terms
    p, q = 0, 1
    for k in count(1):
        yield (m := q // (k * (q - p)) + 1)
        p, q = p * k * m + q, k * m * q
        p //= (r := gcd(p, q))
        q //= r


def A374983_gen():  # generator of terms
    p, q = 0, 1
    for k in count(1):
        yield p
        m = q // (k * (q - p)) + 1
        p, q = p * k * m + q, k * m * q
        p //= (r := gcd(p, q))
        q //= r


def A375516_gen():  # generator of terms
    p, q = 0, 1
    for k in count(1):
        yield q
        m = q // (k * (q - p)) + 1
        p, q = p * k * m + q, k * m * q
        p //= (r := gcd(p, q))
        q //= r


def A375517_gen():  # generator of terms
    p, q = 0, 1
    for k in count(1):
        m = q // (k * (q - p)) + 1
        p, q = p * k * m + q, k * m * q
        p //= (r := gcd(p, q))
        q //= r
        yield q // k


def A375520_gen():  # generator of terms
    p, q, c = 0, 1, 1
    for k in count(1):
        m = q // (k * (q - p)) + 1
        p, q = p * k * m + q, k * m * q
        p //= (r := gcd(p, q))
        q //= r
        c = lcm(c, k)
        yield q // c


def A277010(n):
    def f(x):
        return n + x - sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

    m = f(f(n))
    return sum(
        1 << primepi(p) + i
        for i, p in enumerate(factorint(bisection(f, m, m), multiple=True), -1)
    )


def A277195(n):
    def f(x):
        return n + x - sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

    m = f(f(n))
    return sum(
        fibonacci(primepi(p) + i)
        for i, p in enumerate(factorint(bisection(f, m, m), multiple=True), 1)
    )


def A062320(n):
    def f(x):
        return n + 1 + sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

    return bisection(f, m := f(f(n)), m) ** 2


def A030229(n):
    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b + 1, isqrt(x // c) + 1), a + 1))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b + 1, integer_nthroot(x // c, m)[0] + 1), a + 1
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            n
            - 1
            + x
            - sum(
                sum(
                    primepi(x // prod(c[1] for c in a)) - a[-1][0]
                    for a in g(x, 0, 1, 1, i)
                )
                for i in range(2, x.bit_length(), 2)
            )
        )

    return bisection(f, m := f(f(n)), m)


def A030059(n):
    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b + 1, isqrt(x // c) + 1), a + 1))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b + 1, integer_nthroot(x // c, m)[0] + 1), a + 1
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            n
            + x
            - primepi(x)
            - sum(
                sum(
                    primepi(x // prod(c[1] for c in a)) - a[-1][0]
                    for a in g(x, 0, 1, 1, i)
                )
                for i in range(3, x.bit_length(), 2)
            )
        )

    return bisection(f, m := f(f(n)), m)


def A106419(n):
    if n == 1:
        return 97

    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b + 1, isqrt(x // c) + 1), a + 1))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b + 1, integer_nthroot(x // c, m)[0] + 1), a + 1
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0] for a in g(x, 0, 1, 1, n)
            )
        )

    for l in count(len(str(primorial(n))) - 1):
        kmin, kmax = 9 * 10**l - 1, 10 ** (l + 1) - 1
        mmin, mmax = f(kmin), f(kmax)
        if mmax > mmin:
            while kmax - kmin > 1:
                kmid = kmax + kmin >> 1
                mmid = f(kmid)
                if mmid > mmin:
                    kmax, mmax = kmid, mmid
                else:
                    kmin, mmin = kmid, mmid
            return kmax


def A106429(n):
    if n == 1:
        return 97

    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b, isqrt(x // c) + 1), a))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b, integer_nthroot(x // c, m)[0] + 1), a
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0] for a in g(x, 0, 1, 1, n)
            )
        )

    for l in count(len(str(1 << n)) - 1):
        kmin, kmax = 9 * 10**l - 1, 10 ** (l + 1) - 1
        mmin, mmax = f(kmin), f(kmax)
        if mmax > mmin:
            while kmax - kmin > 1:
                kmid = kmax + kmin >> 1
                mmid = f(kmid)
                if mmid > mmin:
                    kmax, mmax = kmid, mmid
                else:
                    kmin, mmin = kmid, mmid
            return kmax


def A106418(n):
    if n == 1:
        return 83

    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b + 1, isqrt(x // c) + 1), a + 1))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b + 1, integer_nthroot(x // c, m)[0] + 1), a + 1
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0] for a in g(x, 0, 1, 1, n)
            )
        )

    def bisection(f, kmin, kmax, mmin, mmax):
        while kmax - kmin > 1:
            kmid = kmax + kmin >> 1
            mmid = f(kmid)
            if mmid > mmin:
                kmax, mmax = kmid, mmid
            else:
                kmin, mmin = kmid, mmid
        return kmax

    for l in count(len(str(primorial(n))) - 1):
        kmin, kmax = 8 * 10**l - 1, 9 * 10**l - 1
        mmin, mmax = f(kmin), f(kmax)
        if mmax > mmin:
            return bisection(f, kmin, kmax, mmin, mmax)


def A375791_gen():  # generator of terms
    p, q = 0, 1
    for k in count(1):
        m = q // (k * (q - p)) + 1
        p, q = p * k * m + q, k * m * q
        p //= (r := gcd(p, q))
        q //= r
        yield k * m // r


def A375781_gen():  # generator of terms
    p, q, k = 0, 1, 1
    while k := nextprime(k):
        yield (m := q // (k * (q - p)) + 1)
        p, q = p * k * m + q, k * m * q
        p //= (r := gcd(p, q))
        q //= r


def A375776_gen():  # generator of terms
    a, l = [], 1
    for n in count(1):
        k = next((k for k, m in enumerate(a, 1) if not n & m), l)
        yield k
        if k == l:
            a.append(n)
            l += 1
        else:
            a[k - 1] |= n


def A164346(n):
    return 3 << (n << 1)


def A375764(n):
    return (m := n * (n + 1) - 4) * (m + 10) >> 3 if n > 1 else 0


def A002817(n):
    return (m := n * (n + 1)) * (m + 2) >> 3


def A068911(n):
    return 3 ** (n >> 1) << 1 if n & 1 else (3 ** (n - 1 >> 1) << 2 if n else 1)


def A365544(n):
    return (
        (1 << n) - (3 ** (n >> 1) << 1 if n & 1 else 3 ** (n - 1 >> 1) << 2) if n else 0
    )


def A165211(n):
    return n & 1 ^ bool(n & 4)


def A130198(n):
    return n & 1 ^ bool(n + 1 & 4)


def A375521_gen():  # generator of terms
    p, q, k = 0, 1, 1
    while k := nextprime(k):
        m = q // (k * (q - p)) + 1
        p, q = p * k * m + q, k * m * q
        p //= (r := gcd(p, q))
        q //= r
        yield p


def A375522_gen():  # generator of terms
    p, q, k = 0, 1, 1
    while k := nextprime(k):
        m = q // (k * (q - p)) + 1
        p, q = p * k * m + q, k * m * q
        p //= (r := gcd(p, q))
        q //= r
        yield q


def A375820(n):
    return (2, 2, 6, 4, 1, 5, 0, 9, 4, 3, 3, 9, 6)[n % 13] if n > 2 else 5 - (n << 1)


def A171397(n):
    return int(str(n), 11)


def A052404(n):
    return int(
        "".join(str(int(d) + 1) if d > "1" else d for d in gmpy2digits(n - 1, 9))
    )


def A274628(n):
    return int(
        sum(
            divisor_sigma(j, 0) * divisor_sigma(n - j, 0)
            for j in range(1, (n - 1 >> 1) + 1)
        )
        + (
            (divisor_sigma(n + 1 >> 1, 0) ** 2 if n - 1 & 1 else 0)
            - divisor_sigma(n, 0)
            + 3 * divisor_sigma(n)
            >> 1
        )
    )


def A031216(n):
    return int(str(prime(n)), 11)


def A120041(n):
    return -almostprimepi(m := 1 << n, 10) + almostprimepi(m << 1, 10)


def A120043(n):
    return -almostprimepi(m := 1 << n, 12) + almostprimepi(m << 1, 12)


def A375849(n):
    return max(
        filter(
            lambda x: x & 1,
            sum(
                (Counter(factorint(i)) for i in range(2, n + 1)), start=Counter()
            ).values(),
        )
    )


def A375850(n):
    return max(
        filter(
            lambda x: x & 1 ^ 1,
            sum(
                (Counter(factorint(i)) for i in range(2, n + 1)), start=Counter()
            ).values(),
        ),
        default=0,
    )


def A366786(n):
    def f(x):
        return n + x - sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

    return (m := bisection(f, k := f(f(n)), k)) * min(primefactors(m), default=1)


def A278567(n):
    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(x // (k * m)) - b
                for a, k in enumerate(primerange(integer_nthroot(x, 3)[0] + 1), 1)
                for b, m in enumerate(primerange(k + 1, isqrt(x // k) + 1), a + 1)
            )
        )

    m = f(f(n))
    return max(
        int(abs(x[1][0][0])) for x in cyclotomic_poly(bisection(f, m, m)).as_terms()[0]
    )


def A239656(n):
    return A007304(n + 1) - A007304(n)


def A375875(n):
    m = 1 << n - 1
    k = squarefreepi(m)
    for i in count(k + 1):
        a = squarefree(i)
        if not (isprime(a) or any((a - 1) % (p - 1) for p in primefactors(a))):
            return a


def A242493(n):
    return sum(primepi(n // i) - primepi(i) for i in range(1, isqrt(n) + 1))


def A064052(n):
    def f(x):
        return int(
            n + x - sum(primepi(x // i) - primepi(i) for i in range(1, isqrt(x) + 1))
        )

    return bisection(f, m := f(f(n)), m)


def A048098(n):
    def f(x):
        return int(
            n + sum(primepi(x // i) - primepi(i) for i in range(1, isqrt(x) + 1))
        )

    return bisection(f, m := f(f(n)), m)


def A078843(n):
    return almostprimepi(3**n, n) if n else 1


def A078846(n):
    return almostprimepi(11**n, n) if n else 1


def A116435(n):
    return almostprimepi(n**n, n)


def A291972(n):
    return next(
        k
        for k in (squarefreealmostprime(i, n) for i in count(1))
        if (m := prod(Fraction(p + 1, p - 1) for p in primefactors(k))).denominator == 1
        and isprime(m.numerator)
    )


def A081548(n):
    return (
        next(
            k + 1
            for k in (squarefreealmostprime(i, n) for i in count(1))
            if not isprime(k + 1)
        )
        if n
        in {
            0,
            1,
            2,
            3,
            4,
            5,
            11,
            75,
            171,
            172,
            384,
            457,
            616,
            643,
            1391,
            1613,
            2122,
            2647,
            2673,
            4413,
            13494,
            31260,
            33237,
            304723,
            365071,
        }
        else primorial(n) + 1
    )


def A116434(n):
    return almostprimepi((n + 1) ** n, n)


def A368210_T(n, k):
    return almostprimepi(n, k)


def A375730(n):
    return n * (n * (n ** (n - 2) + 1) + 2) + 1 if n > 1 else 3 * n + 2


def A124309(n):
    return almostprime(prime(n), 5)


def A124308(n):
    return prime(almostprime(n, 5))


def A124283(n):
    def f(x):
        return int(
            prime(n)
            + x
            - sum(
                primepi(x // (k * m * r)) - c
                for a, k in enumerate(primerange(integer_nthroot(x, 4)[0] + 1))
                for b, m in enumerate(
                    primerange(k, integer_nthroot(x // k, 3)[0] + 1), a
                )
                for c, r in enumerate(primerange(m, isqrt(x // (k * m)) + 1), b)
            )
        )

    return bisection(f, m := f(f(n)), m)


def A045763(n):
    return n + 1 - divisor_count(n) - totient(n)


def A369167(n):
    return A000688(n + A000688(n))


def A369162(n):
    return A000688(A000688(n))


def A081547(n):
    return 10 if n == 2 else ((3 << n - 1) + 1 if isprime(m := (1 << n) + 1) else m)


def A061357(n):
    return sum(1 for p in primerange(n) if isprime((n << 1) - p))


def A002372(n):
    return int(isprime(n)) + (A061357(n) << 1) if n != 2 else 0


def A281069(n):
    return (
        next(
            k
            for k in (squarefreealmostprime(i, n) for i in count(1))
            if (p := perfect_power(prod(p - 1 for p in primefactors(k)))) and p[1] == n
        )
        if n > 1
        else 2
    )


def A132296(n):
    return n * (n + 1) - (((r := integer_nthroot(n, 3)[0]) * (r + 1)) ** 2 >> 1) >> 1


def A158527(n):
    return (
        n
        * (n * (n * (n * (n * (n * (n * (6 * (n + 4)) + 54) + 78) + 69) + 36) + 10) + 1)
        >> 1
    )


def A139819(n):
    m, k = n, n + 9 * ((l := len(str(n))) - 1) + 9 * n // (10**l - 1)
    while m != k:
        m, k = k, n + 9 * ((l := len(str(k))) - 1) + 9 * k // (10**l - 1)
    return m


def A048396(n):
    return n * (n * (n * (n * (6 * n + 15) + 18) + 12) + 3) >> 1


def A367642(n):
    if n == 1:
        return 2

    def f(x):
        return int(
            1
            - sum(
                mobius(k) * (integer_nthroot(x, k)[0] - 1)
                for k in range(2, x.bit_length())
            )
        )

    m = (f(n) << 1) - bool(perfect_power(n))

    def g(x):
        return m + x - f(x)

    return bisection(g, k := g(g(m)), k) + 1


def A145397(n):
    return n + (m := integer_nthroot(6 * n, 3)[0]) - (n + m <= comb(m + 2, 3))


def A185550(n):
    def f(x):
        return n + integer_nthroot(x**2, 3)[0]

    return iterfun(f, n)


def A269020(n):
    a, b = integer_nthroot(n ** (n + 1), n)
    return a + (b ^ 1)


def A059921(n):
    return integer_nthroot(n ** (n + 1), n)[0]


def A375543_gen():  # generator of terms
    M, p, q, pq, r = set(), [], [], [], 1
    while True:
        p.append(r + 1)
        pq.append(r + 1)
        r *= r + 1
        for i in count(1):
            s = sieve[i]
            if s not in M:
                for j, a in enumerate(pq):
                    if not a % s:
                        M.add(s)
                        q.append(s)
                        pq[j] = a // s
                        yield s
                        break
                else:
                    continue
                break


def A155559(n):
    return 1 << n if n else 0


def A274089(n):
    return n + (k := n.bit_length()) + bool(n + k & (1 << k)) >> 1


def A375998(n):
    K = 4
    ds = [gmpy2digits(d, n) for d in range(n)]
    dsl = [gmpy2digits(d, n) * K for d in range(n)]
    for d in range(1, n):
        s = gmpy2digits(d, n) * K
        t = mpz(s, n)
        for b in range(n - 1, 1, -1):
            a = gmpy2digits(t, b)
            if all(dsl[e] not in a for e in range(b)):
                break
        else:
            return int(t)
    for l in count(1):
        mmax = n ** (l + K + 1)
        mc = mmax
        for d in range(0, n):
            s = gmpy2digits(d, n) * K
            for p in product(ds, repeat=l):
                for a in range(l + 1):
                    w = "".join(p[:a]) + s + "".join(p[a:])
                    if w[0] != "0":
                        t = mpz(w, n)
                        if t < mc:
                            for b in range(n - 1, 1, -1):
                                a = gmpy2digits(t, b)
                                if all(dsl[e] not in a for e in range(b)):
                                    break
                            else:
                                mc = t
        if mc < mmax:
            return int(mc)


def A376014(n):
    return sum(
        d**d * comb(n // d, d) for d in takewhile(lambda d: d**2 <= n, divisors(n))
    )


def A376015(n):
    return sum(
        d**n * comb(n // d, d) for d in takewhile(lambda d: d**2 <= n, divisors(n))
    )


def A376016(n):
    return sum(
        d ** (m := n // d) * comb(m, d)
        for d in takewhile(lambda d: d**2 <= n, divisors(n))
    )


def A376017(n):
    return sum(
        d ** ((m := n // d) - d) * comb(m, d)
        for d in takewhile(lambda d: d**2 <= n, divisors(n))
    )


def A376021(n):
    return sum(
        d ** ((m := n // d) - d) * comb(m - 1, d - 1)
        for d in takewhile(lambda d: d**2 <= n, divisors(n))
    )


def A376020(n):
    return sum(
        d ** (m := n // d) * comb(m - 1, d - 1)
        for d in takewhile(lambda d: d**2 <= n, divisors(n))
    )


def A376019(n):
    return sum(
        d**n * comb(n // d - 1, d - 1)
        for d in takewhile(lambda d: d**2 <= n, divisors(n))
    )


def A376018(n):
    return sum(
        d**d * comb(n // d - 1, d - 1)
        for d in takewhile(lambda d: d**2 <= n, divisors(n))
    )


def A375706(n):
    def f(x):
        return int(
            n
            + 1
            - sum(
                mobius(k) * (integer_nthroot(x, k)[0] - 1)
                for k in range(2, x.bit_length())
            )
        )

    m, k = n, f(n)
    while m != k:
        m, k = k, f(k)
    return next(i for i in count(m + 1) if not perfect_power(i)) - m


def A375708(n):
    def f(x):
        return int(
            n + sum(primepi(integer_nthroot(x, k)[0]) for k in range(1, x.bit_length()))
        )

    m, k = n, f(n)
    while m != k:
        m, k = k, f(k)
    return next(i for i in count(m + 1) if len(primefactors(i)) > 1) - m


def A375735(n):
    def f(x):
        return int(
            n
            + 1
            + sum(primepi(integer_nthroot(x, k)[0]) for k in range(1, x.bit_length()))
        )

    m, k = n, f(n)
    while m != k:
        m, k = k, f(k)
    return next(i for i in count(m + 1) if len(primefactors(i)) > 1) - m


def A075772(n):
    if n == 1:
        return 3

    def f(x):
        return int(
            n
            - 2
            + x
            + sum(
                mobius(k) * (integer_nthroot(x, k)[0] - 1)
                for k in range(2, x.bit_length())
            )
        )

    a = bisection(f, m := f(f(n - 1)), m)
    b = bisection(lambda x: f(x) + 1, a, a)
    return min(b - a, bisection(lambda x: f(x) + 2, b, b) - b)


def A080769(n):
    def f(x):
        return int(
            n
            - 1
            + x
            + sum(
                mobius(k) * (integer_nthroot(x, k)[0] - 1)
                for k in range(2, x.bit_length())
            )
        )

    return int(
        -primepi(a := bisection(f, m := f(f(n)), m))
        + primepi(bisection(lambda x: f(x) + 1, a, a))
    )


def A076432_gen():  # generator of terms
    def f(x):
        return int(
            x
            + sum(
                mobius(k) * (integer_nthroot(x, k)[0] - 1)
                for k in range(2, x.bit_length())
            )
        )

    a = bisection(f, m := f(f(1)), m)
    b = bisection(lambda x: f(x) + 1, a, a)
    c = bisection(lambda x: f(x) + 2, b, b)
    d = bisection(lambda x: f(x) + 3, c, c)
    for i in count(4):
        e = bisection(lambda x: f(x) + i, d, d)
        if d - a < e - d:
            yield d
        a, b, c, d = b, c, d, e


def A076433_gen():  # generator of terms
    def f(x):
        return int(
            x
            + sum(
                mobius(k) * (integer_nthroot(x, k)[0] - 1)
                for k in range(2, x.bit_length())
            )
        )

    a = bisection(f, m := f(f(1)), m)
    b = bisection(lambda x: f(x) + 1, a, a)
    c = bisection(lambda x: f(x) + 2, b, b)
    for i in count(3):
        d = bisection(lambda x: f(x) + i, c, c)
        if b - a > d - b:
            yield b
        a, b, c = b, c, d


def A001694(n):
    def f(x):
        c, l = n + x, 0
        j = isqrt(x)
        while j > 1:
            k2 = integer_nthroot(x // j**2, 3)[0] + 1
            w = squarefreepi(k2 - 1)
            c -= j * (w - l)
            l, j = w, isqrt(x // k2**3)
        c -= squarefreepi(integer_nthroot(x, 3)[0]) - l
        return c

    return bisection(f, n, n)


def A052485(n):
    def f(x):
        return int(
            n
            + sum(
                isqrt(x // k**3)
                for k in range(1, integer_nthroot(x, 3)[0] + 1)
                if all(d <= 1 for d in factorint(k).values())
            )
        )

    return iterfun(f, n)


def A076446(n):
    def f(x):
        c, l = n + x, 0
        j = isqrt(x)
        while j > 1:
            k2 = integer_nthroot(x // j**2, 3)[0] + 1
            w = squarefreepi(k2 - 1)
            c -= j * (w - l)
            l, j = w, isqrt(x // k2**3)
        c -= squarefreepi(integer_nthroot(x, 3)[0]) - l
        return c

    return -(a := bisection(f, n, n)) + bisection(lambda x: f(x) + 1, a, a)


def A119241(n):
    def f(x):
        return int(
            sum(
                isqrt(x // k**3)
                for k in range(1, integer_nthroot(x, 3)[0] + 1)
                if all(d <= 1 for d in factorint(k).values())
            )
        )

    return f((n + 1) ** 2 - 1) - f(n**2)


def A180114(n):
    def f(x):
        c, l = n + x, 0
        j = isqrt(x)
        while j > 1:
            k2 = integer_nthroot(x // j**2, 3)[0] + 1
            w = squarefreepi(k2 - 1)
            c -= j * (w - l)
            l, j = w, isqrt(x // k2**3)
        c -= squarefreepi(integer_nthroot(x, 3)[0]) - l
        return c

    return divisor_sigma(bisection(f, n, n))


def A258567(n):
    def f(x):
        c, l = n + x, 0
        j = isqrt(x)
        while j > 1:
            k2 = integer_nthroot(x // j**2, 3)[0] + 1
            w = squarefreepi(k2 - 1)
            c -= j * (w - l)
            l, j = w, isqrt(x // k2**3)
        c -= squarefreepi(integer_nthroot(x, 3)[0]) - l
        return c

    return min(primefactors(bisection(f, n, n)), default=1)


def A078147(n):
    def f(x):
        return n + sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

    m = iterfun(f, n)
    return next(i for i in range(1, 5) if any(d > 1 for d in factorint(m + i).values()))


def A374291(n):
    def f(x):
        c, l = n + x, 0
        j = isqrt(x)
        while j > 1:
            k2 = integer_nthroot(x // j**2, 3)[0] + 1
            w = squarefreepi(k2 - 1)
            c -= j * (w - l)
            l, j = w, isqrt(x // k2**3)
        c -= squarefreepi(integer_nthroot(x, 3)[0]) - l
        return c

    return bisection(f, n, n) ** 2


def A373549(n):
    def f(x):
        c, l = n + x, 0
        j = isqrt(x)
        while j > 1:
            k2 = integer_nthroot(x // j**2, 3)[0] + 1
            w = squarefreepi(k2 - 1)
            c -= j * (w - l)
            l, j = w, isqrt(x // k2**3)
        c -= squarefreepi(integer_nthroot(x, 3)[0]) - l
        return c

    return bisection(f, n, n) & 1


def A118896(n):
    m, c, l = 10**n, 0, 0
    j = isqrt(m)
    while j > 1:
        k2 = integer_nthroot(m // j**2, 3)[0] + 1
        w = squarefreepi(k2 - 1)
        c += j * (w - l)
        l, j = w, isqrt(m // k2**3)
    c += squarefreepi(integer_nthroot(m, 3)[0]) - l
    return c


def A052486(n):
    def f(x):
        c, l = n + x + 1, 0
        j = isqrt(x)
        while j > 1:
            k2 = integer_nthroot(x // j**2, 3)[0] + 1
            w = squarefreepi(k2 - 1)
            c -= j * (w - l)
            l, j = w, isqrt(x // k2**3)
        c -= (
            squarefreepi(integer_nthroot(x, 3)[0])
            - l
            + sum(
                mobius(k) * (integer_nthroot(x, k)[0] - 1)
                for k in range(2, x.bit_length())
            )
        )
        return c

    return bisection(f, n, n)


def A036966(n):
    def f(x):
        c = n + x
        for w in range(1, integer_nthroot(x, 5)[0] + 1):
            if all(d <= 1 for d in factorint(w).values()):
                for y in range(1, integer_nthroot(z := x // w**5, 4)[0] + 1):
                    if gcd(w, y) == 1 and all(d <= 1 for d in factorint(y).values()):
                        c -= integer_nthroot(z // y**4, 3)[0]
        return c

    return bisection(f, n, n)


def A247246(n):
    def f(x):
        c, l = n + x + 1, 0
        j = isqrt(x)
        while j > 1:
            k2 = integer_nthroot(x // j**2, 3)[0] + 1
            w = squarefreepi(k2 - 1)
            c -= j * (w - l)
            l, j = w, isqrt(x // k2**3)
        c -= (
            squarefreepi(integer_nthroot(x, 3)[0])
            - l
            + sum(
                mobius(k) * (integer_nthroot(x, k)[0] - 1)
                for k in range(2, x.bit_length())
            )
        )
        return c

    return -(a := bisection(f, n, n)) + bisection(lambda x: f(x) + 1, a, a)


def A036967(n):
    def f(x):
        c = n + x
        for u in range(1, integer_nthroot(x, 7)[0] + 1):
            if all(d <= 1 for d in factorint(u).values()):
                for w in range(1, integer_nthroot(a := x // u**7, 6)[0] + 1):
                    if gcd(w, u) == 1 and all(d <= 1 for d in factorint(w).values()):
                        for y in range(1, integer_nthroot(z := a // w**6, 5)[0] + 1):
                            if (
                                gcd(w, y) == 1
                                and gcd(u, y) == 1
                                and all(d <= 1 for d in factorint(y).values())
                            ):
                                c -= integer_nthroot(z // y**5, 4)[0]
        return c

    return bisection(f, n, n)


def A069492(n):
    def f(x):
        c = n + x
        for t in range(1, integer_nthroot(x, 9)[0] + 1):
            if all(d <= 1 for d in factorint(t).values()):
                for u in range(1, integer_nthroot(s := x // t**9, 8)[0] + 1):
                    if gcd(t, u) == 1 and all(d <= 1 for d in factorint(u).values()):
                        for w in range(1, integer_nthroot(a := s // u**8, 7)[0] + 1):
                            if (
                                gcd(u, w) == 1
                                and gcd(t, w) == 1
                                and all(d <= 1 for d in factorint(w).values())
                            ):
                                for y in range(
                                    1, integer_nthroot(z := a // w**7, 6)[0] + 1
                                ):
                                    if (
                                        gcd(w, y) == 1
                                        and gcd(u, y) == 1
                                        and gcd(t, y) == 1
                                        and all(d <= 1 for d in factorint(y).values())
                                    ):
                                        c -= integer_nthroot(z // y**6, 5)[0]
        return c

    return bisection(f, n, n)


def A069493(n):
    def f(x):
        c = n + x
        for y1 in range(1, integer_nthroot(x, 11)[0] + 1):
            if all(d <= 1 for d in factorint(y1).values()):
                for y2 in range(1, integer_nthroot(z2 := x // y1**11, 10)[0] + 1):
                    if gcd(y2, y1) == 1 and all(d <= 1 for d in factorint(y2).values()):
                        for y3 in range(
                            1, integer_nthroot(z3 := z2 // y2**10, 9)[0] + 1
                        ):
                            if (
                                gcd(y3, y1) == 1
                                and gcd(y3, y2) == 1
                                and all(d <= 1 for d in factorint(y3).values())
                            ):
                                for y4 in range(
                                    1, integer_nthroot(z4 := z3 // y3**9, 8)[0] + 1
                                ):
                                    if (
                                        gcd(y4, y1) == 1
                                        and gcd(y4, y2) == 1
                                        and gcd(y4, y3) == 1
                                        and all(d <= 1 for d in factorint(y4).values())
                                    ):
                                        for y5 in range(
                                            1,
                                            integer_nthroot(z5 := z4 // y4**8, 7)[0]
                                            + 1,
                                        ):
                                            if (
                                                gcd(y5, y1) == 1
                                                and gcd(y5, y2) == 1
                                                and gcd(y5, y3) == 1
                                                and gcd(y5, y4) == 1
                                                and all(
                                                    d <= 1
                                                    for d in factorint(y5).values()
                                                )
                                            ):
                                                c -= integer_nthroot(z5 // y5**7, 6)[0]
        return c

    return bisection(f, n, n)


def A286708(n):
    def f(x):
        c, l = n + x, 0
        j = isqrt(x)
        while j > 1:
            k2 = integer_nthroot(x // j**2, 3)[0] + 1
            w = squarefreepi(k2 - 1)
            c -= j * (w - l)
            l, j = w, isqrt(x // k2**3)
        c -= squarefreepi(integer_nthroot(x, 3)[0]) - l
        return (
            c
            + 1
            + sum(primepi(integer_nthroot(x, k)[0]) for k in range(2, x.bit_length()))
        )

    return bisection(f, n, n)


def A358173(n):
    def f(x):
        c, l = (
            n
            + x
            + 1
            + sum(primepi(integer_nthroot(x, k)[0]) for k in range(2, x.bit_length())),
            0,
        )
        j = isqrt(x)
        while j > 1:
            k2 = integer_nthroot(x // j**2, 3)[0] + 1
            w = squarefreepi(k2 - 1)
            c -= j * (w - l)
            l, j = w, isqrt(x // k2**3)
        c -= squarefreepi(integer_nthroot(x, 3)[0]) - l
        return c

    return -(a := bisection(f, n, n)) + bisection(lambda x: f(x) + 1, a, a)


def A203663_gen():  # generator of terms
    return map(
        lambda x: x[0],
        filter(
            lambda x: all(d > 1 for d in x[1]) and gcd(*x[1]) == 1,
            map(
                lambda x: (x, factorint(x << 1).values()),
                (A052486(i) for i in count(1)),
            ),
        ),
    )


def A194085_gen():  # generator of terms
    return map(
        lambda x: x[0],
        filter(
            lambda x: all(d > 1 for d in x[1]) and gcd(*x[1]) == 1,
            map(
                lambda x: (x, factorint(totient(x)).values()),
                (A052486(i) for i in count(1)),
            ),
        ),
    )


def A138836(n):
    return (
        n
        + (k := int(primepi((n).bit_length()) - 1))
        + int(n + k + 1 >= 1 << prime(k + 1))
        if n > 1
        else 1
    )


def A066343(n):
    return (5**n).bit_length() + n - 1


def A066344(n):
    return integer_log(1 << n, 5)[0] + n


def A129344(n):
    return -(m := 5 ** (n - 1)).bit_length() + (5 * m).bit_length() + 1 if n > 1 else 4


def A337736(n):
    def f(x):
        c = 0
        for w in range(1, integer_nthroot(x, 5)[0] + 1):
            if all(d <= 1 for d in factorint(w).values()):
                for y in range(1, integer_nthroot(z := x // w**5, 4)[0] + 1):
                    if gcd(w, y) == 1 and all(d <= 1 for d in factorint(y).values()):
                        c += integer_nthroot(z // y**4, 3)[0]
        return c

    return f((n + 1) ** 3 - 1) - f(n**3)


def A360841_gen():  # generator of terms
    def f(x):
        c = x
        for u in range(1, integer_nthroot(x, 7)[0] + 1):
            if all(d <= 1 for d in factorint(u).values()):
                for w in range(1, integer_nthroot(a := x // u**7, 6)[0] + 1):
                    if gcd(w, u) == 1 and all(d <= 1 for d in factorint(w).values()):
                        for y in range(1, integer_nthroot(z := a // w**6, 5)[0] + 1):
                            if (
                                gcd(w, y) == 1
                                and gcd(u, y) == 1
                                and all(d <= 1 for d in factorint(y).values())
                            ):
                                c -= integer_nthroot(z // y**5, 4)[0]
        return c

    a = 1
    for i in count(0):
        a = bisection(lambda x: f(x) + i, a, a)
        if isprime(a - 1) and isprime(a + 1):
            yield a


def A372841(n):
    def f(x):
        c = (
            n
            + x
            + 1
            + sum(primepi(integer_nthroot(x, k)[0]) for k in range(4, x.bit_length()))
        )
        for u in range(1, integer_nthroot(x, 7)[0] + 1):
            if all(d <= 1 for d in factorint(u).values()):
                for w in range(1, integer_nthroot(a := x // u**7, 6)[0] + 1):
                    if gcd(w, u) == 1 and all(d <= 1 for d in factorint(w).values()):
                        for y in range(1, integer_nthroot(z := a // w**6, 5)[0] + 1):
                            if (
                                gcd(w, y) == 1
                                and gcd(u, y) == 1
                                and all(d <= 1 for d in factorint(y).values())
                            ):
                                c -= integer_nthroot(z // y**5, 4)[0]
        return c

    return bisection(f, n, n)


def A375774(n):
    return (
        (
            10,
            27,
            55,
            85,
            108,
            119,
            118,
            108,
            94,
            78,
            60,
            46,
            35,
            27,
            19,
            14,
            10,
            7,
            4,
            2,
            1,
        )[n - 1]
        if n < 22
        else 0
    )


def A375706(n):
    def f(x):
        return int(
            n
            + 1
            - sum(
                mobius(k) * (integer_nthroot(x, k)[0] - 1)
                for k in range(2, x.bit_length())
            )
        )

    return -(a := iterfun(f, n)) + iterfun(lambda x: f(x) + 1, a)


def A090946(n):
    if n == 1:
        return 0

    def f(x):
        if x <= 2:
            return n
        a, b, c = 1, 3, 0
        while b <= x:
            a, b = b, a + b
            c += 1
        return n + c

    return iterfun(f, n)


def A057854(n):
    def f(x):
        if x <= 2:
            return n + 2
        a, b, c = 1, 3, 0
        while b <= x:
            a, b = b, a + b
            c += 1
        return n + c + 2

    return iterfun(f, n)


def A000093(n):
    return isqrt(n**3)


def A077121(n):
    return isqrt(n**3) + 1


def A185543(n):
    def f(x):
        return n - 1 + (a := integer_nthroot((x + 1) ** 2, 3))[0] + (a[1] ^ 1)

    return iterfun(f, n)


def A269023(n):
    def f(x):
        if x == 1:
            return n + 1
        z = x**x
        for y in count(x, -1):
            if y ** (y + 1) <= z:
                return n + y
            z //= x

    return bisection(f, n, n)


def A138890(n):
    def f(x):
        if x <= 1:
            return n + 1
        a, b, c, d = 1, 1, 1, 0
        while c <= x:
            a, b, c = b, c, a + b
            d += 1
        return n + d - 1

    return iterfun(f, n)


def A376045(n):
    def f(x):
        c, l = 0, len(str(x))
        for i in range(l):
            k = 10**i
            for j in (1, 2, 4, 5, 7, 8):
                if j * k <= x:
                    c += 1
        for a in combinations((10**i for i in range(l)), 2):
            for b in (
                (1, 1),
                (1, 4),
                (1, 7),
                (2, 2),
                (2, 5),
                (2, 8),
                (4, 1),
                (4, 4),
                (4, 7),
                (5, 2),
                (5, 5),
                (5, 8),
                (7, 1),
                (7, 4),
                (7, 7),
                (8, 2),
                (8, 5),
                (8, 8),
            ):
                if a[0] * b[0] + a[1] * b[1] <= x:
                    c += 1
        return n + c

    return iterfun(f, n)


def A325112(n):
    def f(x):
        c, l = 0, len(str(x))
        for i in range(l):
            k = 10**i
            for j in (1, 2, 4, 5, 7, 8):
                if j * k <= x:
                    c += 1
        for a in combinations((10**i for i in range(l)), 2):
            for b in (
                (1, 1),
                (1, 4),
                (1, 7),
                (2, 2),
                (2, 5),
                (2, 8),
                (4, 1),
                (4, 4),
                (4, 7),
                (5, 2),
                (5, 5),
                (5, 8),
                (7, 1),
                (7, 4),
                (7, 7),
                (8, 2),
                (8, 5),
                (8, 8),
            ):
                if a[0] * b[0] + a[1] * b[1] <= x:
                    c += 1
        return n + x - c

    return bisection(f, n, n)


def A046388(n):
    if n == 1:
        return 15

    def f(x):
        return int(
            n
            - 1
            + x
            + (t := primepi(s := isqrt(x)))
            + (t * (t - 1) >> 1)
            - sum(primepi(x // k) for k in primerange(3, s + 1))
        )

    return bisection(f, n, n)


def A046389(n):
    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(x // (k * m)) - b
                for a, k in enumerate(primerange(3, integer_nthroot(x, 3)[0] + 1), 2)
                for b, m in enumerate(primerange(k + 1, isqrt(x // k) + 1), a + 1)
            )
        )

    return bisection(f, n, n)


def A361075(n):
    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b + 1, isqrt(x // c) + 1), a + 1))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b + 1, integer_nthroot(x // c, m)[0] + 1), a + 1
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0] for a in g(x, 1, 2, 1, 7)
            )
        )

    return bisection(f, n, n)


def A168352(n):
    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b + 1, isqrt(x // c) + 1), a + 1))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b + 1, integer_nthroot(x // c, m)[0] + 1), a + 1
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0] for a in g(x, 1, 2, 1, 6)
            )
        )

    return bisection(f, n, n)


def A376092(n):
    m = 10**n

    def f(x):
        c, l = m + x, 0
        j = isqrt(x)
        while j > 1:
            k2 = integer_nthroot(x // j**2, 3)[0] + 1
            w = squarefreepi(k2 - 1)
            c -= j * (w - l)
            l, j = w, isqrt(x // k2**3)
        c -= squarefreepi(integer_nthroot(x, 3)[0]) - l
        return c

    return bisection(f, m, m)


def A022801(n):
    def f(x):
        if x <= 2:
            return n + 1
        a, b, c = 1, 3, 0
        while b <= x:
            a, b = b, a + b
            c += 1
        return n + 1 + c

    return iterfun(f, n + 1) + lucas(n)


def A258601(n):
    c, m = 0, prime(n) ** 4
    for u in range(1, integer_nthroot(m, 7)[0] + 1):
        if all(d <= 1 for d in factorint(u).values()):
            for w in range(1, integer_nthroot(a := m // u**7, 6)[0] + 1):
                if gcd(w, u) == 1 and all(d <= 1 for d in factorint(w).values()):
                    for y in range(1, integer_nthroot(z := a // w**6, 5)[0] + 1):
                        if (
                            gcd(w, y) == 1
                            and gcd(u, y) == 1
                            and all(d <= 1 for d in factorint(y).values())
                        ):
                            c += integer_nthroot(z // y**5, 4)[0]
    return c


def A258603(n):
    c, m = 0, prime(n) ** 6
    for y1 in range(1, integer_nthroot(m, 11)[0] + 1):
        if all(d <= 1 for d in factorint(y1).values()):
            for y2 in range(1, integer_nthroot(z2 := m // y1**11, 10)[0] + 1):
                if gcd(y2, y1) == 1 and all(d <= 1 for d in factorint(y2).values()):
                    for y3 in range(1, integer_nthroot(z3 := z2 // y2**10, 9)[0] + 1):
                        if all(gcd(y3, x) == 1 for x in (y1, y2)) and all(
                            d <= 1 for d in factorint(y3).values()
                        ):
                            for y4 in range(
                                1, integer_nthroot(z4 := z3 // y3**9, 8)[0] + 1
                            ):
                                if all(gcd(y4, x) == 1 for x in (y1, y2, y3)) and all(
                                    d <= 1 for d in factorint(y4).values()
                                ):
                                    for y5 in range(
                                        1, integer_nthroot(z5 := z4 // y4**8, 7)[0] + 1
                                    ):
                                        if all(
                                            gcd(y5, x) == 1 for x in (y1, y2, y3, y4)
                                        ) and all(
                                            d <= 1 for d in factorint(y5).values()
                                        ):
                                            c += integer_nthroot(z5 // y5**7, 6)[0]
    return c


def A001595(n):
    return (fibonacci(n + 1) << 1) - 1


def A376108(n):
    def f(x):
        a, b, c = 1, 1, n
        while True:
            if b > x:
                return c
            a, b = b, a + b + 1
            c += 1

    m, k = n, f(n)
    while m != k:
        m, k = k, f(k)
    return m


def A203662_gen():  # generator of terms
    def g(x):
        (f := factorint(x))[min(f)] -= 1
        return (x, f.values())

    return map(
        lambda x: x[0],
        filter(
            lambda x: all(d > 1 for d in x[1]) and gcd(*x[1]) == 1,
            map(g, (A052486(i) for i in count(1))),
        ),
    )


def A258602(n):
    c, m = 0, prime(n) ** 5
    for t in range(1, integer_nthroot(m, 9)[0] + 1):
        if all(d <= 1 for d in factorint(t).values()):
            for u in range(1, integer_nthroot(s := m // t**9, 8)[0] + 1):
                if gcd(t, u) == 1 and all(d <= 1 for d in factorint(u).values()):
                    for w in range(1, integer_nthroot(a := s // u**8, 7)[0] + 1):
                        if (
                            gcd(u, w) == 1
                            and gcd(t, w) == 1
                            and all(d <= 1 for d in factorint(w).values())
                        ):
                            for y in range(
                                1, integer_nthroot(z := a // w**7, 6)[0] + 1
                            ):
                                if (
                                    gcd(w, y) == 1
                                    and gcd(u, y) == 1
                                    and gcd(t, y) == 1
                                    and all(d <= 1 for d in factorint(y).values())
                                ):
                                    c += integer_nthroot(z // y**6, 5)[0]
    return c


def A258600(n):
    c, m = 0, prime(n) ** 3
    for w in range(1, integer_nthroot(m, 5)[0] + 1):
        if all(d <= 1 for d in factorint(w).values()):
            for y in range(1, integer_nthroot(z := m // w**5, 4)[0] + 1):
                if gcd(w, y) == 1 and all(d <= 1 for d in factorint(y).values()):
                    c += integer_nthroot(z // y**4, 3)[0]
    return c


def A258599(n):
    c, l, m = 0, 0, prime(n) ** 2
    j = isqrt(m)
    while j > 1:
        k2 = integer_nthroot(m // j**2, 3)[0] + 1
        w = squarefreepi(k2 - 1)
        c += j * (w - l)
        l, j = w, isqrt(m // k2**3)
    c += squarefreepi(integer_nthroot(m, 3)[0]) - l
    return c


def A375709_gen():  # generator of terms
    def f(x):
        return sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

    a = 4
    for k in count(1):
        b = iterfun(lambda x: f(x) + k + 1, a)
        if b - a == 1:
            yield k
        a = b


def A375710_gen():  # generator of terms
    def f(x):
        return sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

    a = 4
    for k in count(1):
        b = iterfun(lambda x: f(x) + k + 1, a)
        if b - a == 2:
            yield k
        a = b


def A375711_gen():  # generator of terms
    def f(x):
        return sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

    a = 4
    for k in count(1):
        b = iterfun(lambda x: f(x) + k + 1, a)
        if b - a == 3:
            yield k
        a = b


def A375712_gen():  # generator of terms
    def f(x):
        return sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

    a = 4
    for k in count(1):
        b = iterfun(lambda x: f(x) + k + 1, a)
        if b - a == 4:
            yield k
        a = b


def A106411(n):
    if n <= 1:
        return 1 + 10 * n

    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b + 1, isqrt(x // c) + 1), a + 1))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b + 1, integer_nthroot(x // c, m)[0] + 1), a + 1
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0] for a in g(x, 0, 1, 1, n)
            )
        )

    for l in count(len(str(primorial(n))) - 1):
        kmin, kmax = 10**l - 1, 2 * 10**l - 1
        mmin, mmax = f(kmin), f(kmax)
        if mmax > mmin:
            while kmax - kmin > 1:
                kmid = kmax + kmin >> 1
                mmid = f(kmid)
                if mmid > mmin:
                    kmax, mmax = kmid, mmid
                else:
                    kmin, mmin = kmid, mmid
            return kmax


def A106412(n):
    if n == 1:
        return 2

    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b + 1, isqrt(x // c) + 1), a + 1))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b + 1, integer_nthroot(x // c, m)[0] + 1), a + 1
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0] for a in g(x, 0, 1, 1, n)
            )
        )

    for l in count(len(str(primorial(n))) - 1):
        kmin, kmax = 2 * 10**l - 1, 3 * 10**l - 1
        mmin, mmax = f(kmin), f(kmax)
        if mmax > mmin:
            while kmax - kmin > 1:
                kmid = kmax + kmin >> 1
                mmid = f(kmid)
                if mmid > mmin:
                    kmax, mmax = kmid, mmid
                else:
                    kmin, mmin = kmid, mmid
            return kmax


def A217395(n):
    return n + 26 * 10 ** (len(str(9 * n - 8)) - 1) // 9


def A131835(n):
    return n + 8 * 10 ** (len(str(9 * n - 8)) - 1) // 9


def A075326(n):
    return (
        5 * n - 1 - int((n | (~((m := n - 1 >> 1) + 1) & m).bit_length()) & 1)
        if n
        else 0
    )


def A249031(n):
    return (
        n
        + (n + 1 - (m := n - 3 & 7) >> 2)
        + int(m >= 4 and (m != 4 or (~((k := n - 3 >> 3) + 1) & k).bit_length() & 1))
    )


def A249032(n):
    return (
        4
        + int((n + 1 | (~((m := n >> 1) + 1) & m).bit_length()) & 1 ^ 1)
        + int((n | (~((k := n - 1 >> 1) + 1) & k).bit_length()) & 1)
        if n
        else 3
    )


def A375714_gen():  # generator of terms
    a, b = 0, 0
    for n in count(2):
        c = not perfect_power(n)
        if c:
            a += 1
        if b & (c ^ 1):
            yield a
        b = c


def A375740_gen():  # generator of terms
    a, b = -1, 0
    for n in count(2):
        c = not perfect_power(n)
        if c:
            a += 1
        if b & c:
            yield a
        b = c


def A106413(n):
    if n == 1:
        return 3

    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b + 1, isqrt(x // c) + 1), a + 1))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b + 1, integer_nthroot(x // c, m)[0] + 1), a + 1
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0] for a in g(x, 0, 1, 1, n)
            )
        )

    for l in count(len(str(primorial(n))) - 1):
        kmin, kmax = 3 * 10**l - 1, 4 * 10**l - 1
        mmin, mmax = f(kmin), f(kmax)
        if mmax > mmin:
            while kmax - kmin > 1:
                kmid = kmax + kmin >> 1
                mmid = f(kmid)
                if mmid > mmin:
                    kmax, mmax = kmid, mmid
                else:
                    kmin, mmin = kmid, mmid
            return kmax


def A106414(n):
    if n == 1:
        return 41

    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b + 1, isqrt(x // c) + 1), a + 1))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b + 1, integer_nthroot(x // c, m)[0] + 1), a + 1
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0] for a in g(x, 0, 1, 1, n)
            )
        )

    for l in count(len(str(primorial(n))) - 1):
        kmin, kmax = 4 * 10**l - 1, 5 * 10**l - 1
        mmin, mmax = f(kmin), f(kmax)
        if mmax > mmin:
            while kmax - kmin > 1:
                kmid = kmax + kmin >> 1
                mmid = f(kmid)
                if mmid > mmin:
                    kmax, mmax = kmid, mmid
                else:
                    kmin, mmin = kmid, mmid
            return kmax


def A106415(n):
    if n == 1:
        return 5

    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b + 1, isqrt(x // c) + 1), a + 1))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b + 1, integer_nthroot(x // c, m)[0] + 1), a + 1
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0] for a in g(x, 0, 1, 1, n)
            )
        )

    for l in count(len(str(primorial(n))) - 1):
        kmin, kmax = 5 * 10**l - 1, 6 * 10**l - 1
        mmin, mmax = f(kmin), f(kmax)
        if mmax > mmin:
            while kmax - kmin > 1:
                kmid = kmax + kmin >> 1
                mmid = f(kmid)
                if mmid > mmin:
                    kmax, mmax = kmid, mmid
                else:
                    kmin, mmin = kmid, mmid
            return kmax


def A106416(n):
    if n == 1:
        return 61

    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b + 1, isqrt(x // c) + 1), a + 1))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b + 1, integer_nthroot(x // c, m)[0] + 1), a + 1
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0] for a in g(x, 0, 1, 1, n)
            )
        )

    for l in count(len(str(primorial(n))) - 1):
        kmin, kmax = 6 * 10**l - 1, 7 * 10**l - 1
        mmin, mmax = f(kmin), f(kmax)
        if mmax > mmin:
            while kmax - kmin > 1:
                kmid = kmax + kmin >> 1
                mmid = f(kmid)
                if mmid > mmin:
                    kmax, mmax = kmid, mmid
                else:
                    kmin, mmin = kmid, mmid
            return kmax


def A106417(n):
    if n == 1:
        return 7

    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b + 1, isqrt(x // c) + 1), a + 1))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b + 1, integer_nthroot(x // c, m)[0] + 1), a + 1
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0] for a in g(x, 0, 1, 1, n)
            )
        )

    for l in count(len(str(primorial(n))) - 1):
        kmin, kmax = 7 * 10**l - 1, 8 * 10**l - 1
        mmin, mmax = f(kmin), f(kmax)
        if mmax > mmin:
            while kmax - kmin > 1:
                kmid = kmax + kmin >> 1
                mmid = f(kmid)
                if mmid > mmin:
                    kmax, mmax = kmid, mmid
                else:
                    kmin, mmin = kmid, mmid
            return kmax


def A106418(n):
    if n == 1:
        return 83

    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b + 1, isqrt(x // c) + 1), a + 1))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b + 1, integer_nthroot(x // c, m)[0] + 1), a + 1
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0] for a in g(x, 0, 1, 1, n)
            )
        )

    for l in count(len(str(primorial(n))) - 1):
        kmin, kmax = 8 * 10**l - 1, 9 * 10**l - 1
        mmin, mmax = f(kmin), f(kmax)
        if mmax > mmin:
            while kmax - kmin > 1:
                kmid = kmax + kmin >> 1
                mmid = f(kmid)
                if mmid > mmin:
                    kmax, mmax = kmid, mmid
                else:
                    kmin, mmin = kmid, mmid
            return kmax


def A106428(n):
    if n == 1:
        return 83

    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b, isqrt(x // c) + 1), a))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b, integer_nthroot(x // c, m)[0] + 1), a
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0] for a in g(x, 0, 1, 1, n)
            )
        )

    for l in count(len(str(1 << n)) - 1):
        kmin, kmax = 8 * 10**l - 1, 9 * 10**l - 1
        mmin, mmax = f(kmin), f(kmax)
        if mmax > mmin:
            while kmax - kmin > 1:
                kmid = kmax + kmin >> 1
                mmid = f(kmid)
                if mmid > mmin:
                    kmax, mmax = kmid, mmid
                else:
                    kmin, mmin = kmid, mmid
            return kmax


def A106427(n):
    if n == 1:
        return 7

    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b, isqrt(x // c) + 1), a))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b, integer_nthroot(x // c, m)[0] + 1), a
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0] for a in g(x, 0, 1, 1, n)
            )
        )

    for l in count(len(str(1 << n)) - 1):
        kmin, kmax = 7 * 10**l - 1, 8 * 10**l - 1
        mmin, mmax = f(kmin), f(kmax)
        if mmax > mmin:
            while kmax - kmin > 1:
                kmid = kmax + kmin >> 1
                mmid = f(kmid)
                if mmid > mmin:
                    kmax, mmax = kmid, mmid
                else:
                    kmin, mmin = kmid, mmid
            return kmax


def A106426(n):
    if n == 1:
        return 61

    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b, isqrt(x // c) + 1), a))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b, integer_nthroot(x // c, m)[0] + 1), a
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0] for a in g(x, 0, 1, 1, n)
            )
        )

    for l in count(len(str(1 << n)) - 1):
        kmin, kmax = 6 * 10**l - 1, 7 * 10**l - 1
        mmin, mmax = f(kmin), f(kmax)
        if mmax > mmin:
            while kmax - kmin > 1:
                kmid = kmax + kmin >> 1
                mmid = f(kmid)
                if mmid > mmin:
                    kmax, mmax = kmid, mmid
                else:
                    kmin, mmin = kmid, mmid
            return kmax


def A106425(n):
    if n == 1:
        return 5

    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b, isqrt(x // c) + 1), a))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b, integer_nthroot(x // c, m)[0] + 1), a
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0] for a in g(x, 0, 1, 1, n)
            )
        )

    for l in count(len(str(1 << n)) - 1):
        kmin, kmax = 5 * 10**l - 1, 6 * 10**l - 1
        mmin, mmax = f(kmin), f(kmax)
        if mmax > mmin:
            while kmax - kmin > 1:
                kmid = kmax + kmin >> 1
                mmid = f(kmid)
                if mmid > mmin:
                    kmax, mmax = kmid, mmid
                else:
                    kmin, mmin = kmid, mmid
            return kmax


def A106424(n):
    if n == 1:
        return 41

    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b, isqrt(x // c) + 1), a))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b, integer_nthroot(x // c, m)[0] + 1), a
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0] for a in g(x, 0, 1, 1, n)
            )
        )

    for l in count(len(str(1 << n)) - 1):
        kmin, kmax = 4 * 10**l - 1, 5 * 10**l - 1
        mmin, mmax = f(kmin), f(kmax)
        if mmax > mmin:
            while kmax - kmin > 1:
                kmid = kmax + kmin >> 1
                mmid = f(kmid)
                if mmid > mmin:
                    kmax, mmax = kmid, mmid
                else:
                    kmin, mmin = kmid, mmid
            return kmax


def A106423(n):
    if n == 1:
        return 3

    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b, isqrt(x // c) + 1), a))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b, integer_nthroot(x // c, m)[0] + 1), a
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0] for a in g(x, 0, 1, 1, n)
            )
        )

    for l in count(len(str(1 << n)) - 1):
        kmin, kmax = 3 * 10**l - 1, 4 * 10**l - 1
        mmin, mmax = f(kmin), f(kmax)
        if mmax > mmin:
            while kmax - kmin > 1:
                kmid = kmax + kmin >> 1
                mmid = f(kmid)
                if mmid > mmin:
                    kmax, mmax = kmid, mmid
                else:
                    kmin, mmin = kmid, mmid
            return kmax


def A106422(n):
    if n == 1:
        return 2

    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b, isqrt(x // c) + 1), a))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b, integer_nthroot(x // c, m)[0] + 1), a
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0] for a in g(x, 0, 1, 1, n)
            )
        )

    for l in count(len(str(1 << n)) - 1):
        kmin, kmax = 2 * 10**l - 1, 3 * 10**l - 1
        mmin, mmax = f(kmin), f(kmax)
        if mmax > mmin:
            while kmax - kmin > 1:
                kmid = kmax + kmin >> 1
                mmid = f(kmid)
                if mmid > mmin:
                    kmax, mmax = kmid, mmid
                else:
                    kmin, mmin = kmid, mmid
            return kmax


def A106421(n):
    if n <= 1:
        return 1 + 10 * n

    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b, isqrt(x // c) + 1), a))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b, integer_nthroot(x // c, m)[0] + 1), a
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            sum(
                primepi(x // prod(c[1] for c in a)) - a[-1][0] for a in g(x, 0, 1, 1, n)
            )
        )

    for l in count(len(str(1 << n)) - 1):
        kmin, kmax = 10**l - 1, 2 * 10**l - 1
        mmin, mmax = f(kmin), f(kmax)
        if mmax > mmin:
            while kmax - kmin > 1:
                kmid = kmax + kmin >> 1
                mmid = f(kmid)
                if mmid > mmin:
                    kmax, mmax = kmid, mmid
                else:
                    kmin, mmin = kmid, mmid
            return kmax


def A131323_gen(startvalue=3):  # generator of terms >= startvalue
    return map(
        lambda n: (n << 1) + 1,
        filter(
            lambda n: (~(n + 1) & n).bit_length() & 1, count(max(startvalue >> 1, 1))
        ),
    )


def A350352(n):
    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b + 1, isqrt(x // c) + 1), a + 1))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b + 1, integer_nthroot(x // c, m)[0] + 1), a + 1
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            n
            + x
            - sum(
                sum(
                    primepi(x // prod(c[1] for c in a)) - a[-1][0]
                    for a in g(x, 0, 1, 1, i)
                )
                for i in range(3, x.bit_length())
            )
        )

    return bisection(f, n, n)


def A246549(n):
    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b + 1, isqrt(x // c) + 1), a + 1))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b + 1, integer_nthroot(x // c, m)[0] + 1), a + 1
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            n
            + x
            - sum(primepi(integer_nthroot(x, k)[0]) for k in range(3, x.bit_length()))
        )

    return bisection(f, n, n)


def A088247(n):
    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b + 1, isqrt(x // c) + 1), a + 1))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b + 1, integer_nthroot(x // c, m)[0] + 1), a + 1
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            n
            + 1
            + x
            - sum(primepi(integer_nthroot(x, k)[0]) for k in range(3, x.bit_length()))
        )

    return bisection(f, n, n)


def A088248(n):
    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b + 1, isqrt(x // c) + 1), a + 1))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b + 1, integer_nthroot(x // c, m)[0] + 1), a + 1
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            n
            + x
            + primepi(x.bit_length() - 1)
            - sum(primepi(integer_nthroot(x, k)[0]) for k in range(3, x.bit_length()))
        )

    return bisection(f, n, n)


def A153147(n):
    def f(x):
        return int(
            n
            + 1
            - sum(
                mobius(k) * (integer_nthroot(x, k)[0] - 1)
                for k in range(2, x.bit_length())
            )
        )

    return iterfun(f, n) ** 3


def A062838(n):
    def f(x):
        return n + x - sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

    return iterfun(f, n) ** 3


def A246550(n):
    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b + 1, isqrt(x // c) + 1), a + 1))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b + 1, integer_nthroot(x // c, m)[0] + 1), a + 1
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    def f(x):
        return int(
            n
            + x
            - sum(primepi(integer_nthroot(x, k)[0]) for k in range(4, x.bit_length()))
        )

    return bisection(f, n, n)


def A062780(n):
    def f(x):
        return int(
            n
            + x
            - sum(primepi(integer_nthroot(x, p)[0]) for p in primerange(x.bit_length()))
        )

    return -(a := bisection(f, n, n)) + bisection(lambda x: f(x) + 1, a, a)


def A057820(n):
    def f(x):
        return int(
            n
            + x
            - 1
            - sum(primepi(integer_nthroot(x, k)[0]) for k in range(1, x.bit_length()))
        )

    m, k = n, f(n)
    while m != k:
        m, k = k, f(k)
    r, k = m, f(m) + 1
    while r != k:
        r, k = k, f(k) + 1
    return r - m


def A113877(n):
    def A072000(n):
        return int(
            -((t := primepi(s := isqrt(n))) * (t - 1) >> 1)
            + sum(primepi(n // p) for p in primerange(s + 1))
        )

    def f(x):
        return int(
            n
            + x
            - sum(
                A072000(integer_nthroot(x, p)[0])
                for p in range(4, x.bit_length())
                if sum(factorint(p).values()) == 2
            )
        )

    return bisection(f, n, n)


def A352519(n):
    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(primepi(integer_nthroot(x, p)[0]))
                for p in primerange(x.bit_length())
            )
        )

    return bisection(f, n, n)


def A096165(n):
    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(integer_nthroot(x, k)[0])
                for k in range(1, x.bit_length())
                if len(factorint(k)) <= 1
            )
        )

    return bisection(f, n, n)


def A217784(n):
    def g(x):
        return int(
            sum(
                primepi(x // (k * m)) - b
                for a, k in enumerate(primerange(integer_nthroot(x, 3)[0] + 1))
                for b, m in enumerate(primerange(k, isqrt(x // k) + 1), a)
            )
        )

    def f(x):
        return int(
            n
            + x
            - sum(
                g(integer_nthroot(x, k)[0])
                for k in range(1, x.bit_length())
                if sum(factorint(k).values()) == 3
            )
        )

    return bisection(f, n, n)


def A076700(n):
    return int(
        sum(
            primepi(integer_nthroot(10**n, p)[0])
            for p in primerange((10**n).bit_length())
        )
    )


def A118092(n):
    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(integer_nthroot(x, p)[0]) - 1
                for p in primerange(3, x.bit_length())
            )
        )

    return bisection(f, n, n)


def A280609(n):
    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(integer_nthroot(x, p)[0]) - 1
                for p in primerange(x.bit_length())
            )
        )

    return bisection(f, n, n)


def A376139(n):
    return -1 if max(factorint(n).values(), default=0) & 1 else 1


def A217908(n):
    def A072000(n):
        return int(
            -((t := primepi(s := isqrt(n))) * (t - 1) >> 1)
            + sum(primepi(n // p) for p in primerange(s + 1))
        )

    def f(x):
        return int(
            n
            + x
            - sum(
                A072000(integer_nthroot(x, p)[0]) - (p**p <= x)
                for p in range(4, x.bit_length())
                if sum(factorint(p).values()) == 2
            )
        )

    return bisection(f, n, n)


def A186637(n):
    def A072000(n):
        return int(
            -((t := primepi(s := isqrt(n))) * (t - 1) >> 1)
            + sum(primepi(n // p) for p in primerange(s + 1))
        )

    def f(x):
        return int(
            n
            + x
            - sum(
                A072000(integer_nthroot(x, p - 1)[0])
                for p in range(4, x.bit_length() + 1)
                if sum(factorint(p).values()) == 2
            )
        )

    return bisection(f, n, n)


def A036454(n):
    def f(x):
        return int(
            n
            + x
            - sum(
                primepi(integer_nthroot(x, p - 1)[0])
                for p in primerange(3, x.bit_length() + 1)
            )
        )

    return bisection(f, n, n)


def A372695(n):
    def f(x):
        c = (
            n
            + 1
            + x
            + sum(primepi(integer_nthroot(x, k)[0]) for k in range(3, x.bit_length()))
        )
        for w in range(1, integer_nthroot(x, 5)[0] + 1):
            if all(d <= 1 for d in factorint(w).values()):
                for y in range(1, integer_nthroot(z := x // w**5, 4)[0] + 1):
                    if gcd(w, y) == 1 and all(d <= 1 for d in factorint(y).values()):
                        c -= integer_nthroot(z // y**4, 3)[0]
        return c

    return bisection(f, n, n)


def A371185(n):
    def f(x):
        c = n + x
        for w in range(1, integer_nthroot(x, 5)[0] + 1):
            if all(d <= 1 for d in factorint(w).values()):
                for y in range(1, integer_nthroot(z := x // w**5, 4)[0] + 1):
                    if gcd(w, y) == 1 and all(d <= 1 for d in factorint(y).values()):
                        c -= integer_nthroot(z // y**4, 3)[0]
        return c

    c, l, m = 0, 0, bisection(f, n, n)
    j = isqrt(m)
    while j > 1:
        k2 = integer_nthroot(m // j**2, 3)[0] + 1
        w = squarefreepi(k2 - 1)
        c += j * (w - l)
        l, j = w, isqrt(m // k2**3)
    c += squarefreepi(integer_nthroot(m, 3)[0]) - l
    return c


def A368107(n):
    def f(x):
        c = n + x
        for k in range(1, x.bit_length()):
            m = integer_nthroot(x, k)[0]
            c -= sum(1 for p in primefactors(k) if p <= m)
        return c

    return bisection(f, n, n)


def A217038(n):
    c, l = 0, 0
    j = isqrt(n - 1)
    while j > 1:
        k2 = integer_nthroot((n - 1) // j**2, 3)[0] + 1
        w = squarefreepi(k2 - 1)
        c += j * (w - l)
        l, j = w, isqrt((n - 1) // k2**3)
    c += squarefreepi(integer_nthroot(n - 1, 3)[0]) - l
    return c


def A361936(n):
    c, l, m = 0, 0, n**2
    j = isqrt(m)
    while j > 1:
        k2 = integer_nthroot(m // j**2, 3)[0] + 1
        w = squarefreepi(k2 - 1)
        c += j * (w - l)
        l, j = w, isqrt(m // k2**3)
    c += squarefreepi(integer_nthroot(m, 3)[0]) - l
    return c


def A102834(n):
    def f(x):
        j = isqrt(x)
        c, l = n + x + j, 0
        while j > 1:
            k2 = integer_nthroot(x // j**2, 3)[0] + 1
            w = squarefreepi(k2 - 1)
            c -= j * (w - l)
            l, j = w, isqrt(x // k2**3)
        c -= squarefreepi(integer_nthroot(x, 3)[0]) - l
        return c

    return bisection(f, n, n)


def A084371(n):
    def f(x):
        c, l, j = n + x - squarefreepi(integer_nthroot(x, 3)[0]), 0, isqrt(x)
        while j > 1:
            k2 = integer_nthroot(x // j**2, 3)[0] + 1
            w = squarefreepi(k2 - 1)
            c -= j * (w - l)
            l, j = w, isqrt(x // k2**3)
        return c + l

    return prod(primefactors(bisection(f, n, n)))


def A062762(n):
    m = 1 << n
    c, l, j = squarefreepi(integer_nthroot(m, 3)[0]), 0, isqrt(m)
    while j > 1:
        k2 = integer_nthroot(m // j**2, 3)[0] + 1
        w = squarefreepi(k2 - 1)
        c += j * (w - l)
        l, j = w, isqrt(m // k2**3)
    return c - l


def A062761(n):
    return A062762(n) - A062762(n - 1) if n else 1


def A060847(n):
    def f(x):
        return int(
            n
            + x
            - sum(primepi(integer_nthroot(x, k)[0]) for k in range(2, x.bit_length()))
        )

    return (a := bisection(f, n, n)) - prevprime(a)


def A180602(n):
    return ((1 << n + 1) - 1) ** n


def A216427(n):
    def f(x):
        j, b = isqrt(x), integer_nthroot(x, 6)[0]
        l, c = 0, n + x - 1 + primepi(b) + sum(
            mobius(k) * (j // k**3) for k in range(1, b + 1)
        )
        while j > 1:
            k2 = integer_nthroot(x // j**2, 3)[0] + 1
            w = squarefreepi(k2 - 1)
            c -= j * (w - l)
            l, j = w, isqrt(x // k2**3)
        return c + l

    return bisection(f, n, n)


def A216426(n):
    def f(x):
        j, b, a, d = (
            isqrt(x),
            integer_nthroot(x, 6)[0],
            integer_nthroot(x, 5)[0],
            integer_nthroot(x, 10)[0],
        )
        l, c = 0, n + x - 2 + primepi(b) + sum(
            mobius(k) * (j // k**3) for k in range(d + 1, b + 1)
        ) + primepi(d) + sum(
            mobius(k) * (a // k**2 + j // k**3) for k in range(1, d + 1)
        )
        while j > 1:
            k2 = integer_nthroot(x // j**2, 3)[0] + 1
            w = sum(mobius(k) * ((k2 - 1) // k**2) for k in range(1, isqrt(k2 - 1) + 1))
            c -= j * (w - l)
            l, j = w, isqrt(x // k2**3)
        return c + l

    return bisection(f, n, n)


def A113850(n):
    def f(x):
        return int(
            n + x + 1 - sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))
        )

    m, k = n, f(n)
    while m != k:
        m, k = k, f(k)
    return m**5


def A030629(n):
    return prime(n) ** 10


def A376090_gen(startvalue=1):  # generator of terms >= startvalue
    for a in count(max(startvalue, 1)):
        m2, m5 = (~a & a - 1).bit_length(), multiplicity(5, a)
        b = min(m2, m5)
        a2 = a // 10**b
        m2 -= b
        m5 -= b
        r = max(m2, m5)
        k, m = 10**r, 10 ** (t := n_order(10, (a2 >> m2) // 5**m5)) - 1
        c = k // a2
        if not len(
            (
                set(d for d in str(c) if d != "0")
                | set(d for d in str(m * k // a2 - c * m) if d != "0")
            )
            & set(d for d in str(a2) if d != "0")
        ):
            yield a


def A376089_gen(startvalue=1):  # generator of terms >= startvalue
    for a in count(max(startvalue, 1)):
        m2, m5 = (~a & a - 1).bit_length(), multiplicity(5, a)
        b = min(m2, m5)
        a2 = a // 10**b
        m2 -= b
        m5 -= b
        r = max(m2, m5)
        k, m = 10**r, 10 ** (t := n_order(10, (a2 >> m2) // 5**m5)) - 1
        c = k // a2
        if set(d for d in str(c) if d != "0") | set(
            d for d in str(m * k // a2 - c * m) if d != "0"
        ) == set(d for d in str(a2) if d != "0"):
            yield a


def A336175(n):
    @lru_cache(maxsize=None)
    def g(x):
        c, l = 0, 0
        j = isqrt(x)
        while j > 1:
            k2 = integer_nthroot(x // j**2, 3)[0] + 1
            w = squarefreepi(k2 - 1)
            c += j * (w - l)
            l, j = w, isqrt(x // k2**3)
        c += squarefreepi(integer_nthroot(x, 3)[0]) - l
        return c

    def f(x):
        c, a = n + x, 1
        for k in range(1, x + 1):
            b = g((k + 1) ** 2)
            if b == a + 1:
                c -= 1
            a = b
        return c

    return bisection(f, n, n)


def A332785(n):
    def f(x):
        c, l, j = (
            n - 1 + squarefreepi(integer_nthroot(x, 3)[0]) + squarefreepi(x),
            0,
            isqrt(x),
        )
        while j > 1:
            k2 = integer_nthroot(x // j**2, 3)[0] + 1
            w = squarefreepi(k2 - 1)
            c += j * (w - l)
            l, j = w, isqrt(x // k2**3)
        return c - l

    return bisection(f, n, n)


def A336178(n):
    @lru_cache(maxsize=None)
    def g(x):
        c, l = 0, 0
        j = isqrt(x)
        while j > 1:
            k2 = integer_nthroot(x // j**2, 3)[0] + 1
            w = squarefreepi(k2 - 1)
            c += j * (w - l)
            l, j = w, isqrt(x // k2**3)
        c += squarefreepi(integer_nthroot(x, 3)[0]) - l
        return c

    def f(x):
        c, a = n + x, 1
        for k in range(1, x + 1):
            b = g((k + 1) ** 2)
            if b == a + 4:
                c -= 1
            a = b
        return c

    return bisection(f, n, n)


def A306458(n):
    def f(x):
        c, l = n + x - squarefreepi(integer_nthroot(x, 3)[0]), 0
        j = isqrt(x)
        while j > 1:
            k2 = integer_nthroot(x // j**2, 3)[0] + 1
            w = squarefreepi(k2 - 1)
            c -= j * (w - l)
            l, j = w, isqrt(x // k2**3)
        return c + l

    return (m := bisection(f, n, n)) // prod(primefactors(m))


def A323332(n):
    def f(x):
        c, l = n + x - squarefreepi(integer_nthroot(x, 3)[0]), 0
        j = isqrt(x)
        while j > 1:
            k2 = integer_nthroot(x // j**2, 3)[0] + 1
            w = squarefreepi(k2 - 1)
            c -= j * (w - l)
            l, j = w, isqrt(x // k2**3)
        return c + l

    a = primefactors(m := bisection(f, n, n))
    return m * prod(p + 1 for p in a) // prod(a)


def A240591_gen():  # generator of terms
    def f(x):
        c, l, j = x - squarefreepi(integer_nthroot(x, 3)[0]), 0, isqrt(x)
        while j > 1:
            k2 = integer_nthroot(x // j**2, 3)[0] + 1
            w = squarefreepi(k2 - 1)
            c -= j * (w - l)
            l, j = w, isqrt(x // k2**3)
        return c + l

    m = 1
    for n in count(2):
        k = bisection(lambda x: f(x) + n, m, m)
        if nextprime(m) > k:
            yield m
        m = k


def A320966(n):
    def f(x):
        c, l = (
            n + x + squarefreepi(isqrt(x)) - squarefreepi(integer_nthroot(x, 3)[0]),
            0,
        )
        j = isqrt(x)
        while j > 1:
            k2 = integer_nthroot(x // j**2, 3)[0] + 1
            w = squarefreepi(k2 - 1)
            c -= j * (w - l)
            l, j = w, isqrt(x // k2**3)
        return c + l

    return bisection(f, n, n)


def A375926(n):
    def f(x):
        return n + bisection(lambda y: primepi(x + 1 + y)) - 1

    return bisection(f, n, n)


def A375929(n):
    def f(x):
        return n + bisection(lambda y: primepi(x + 2 + y)) - 2

    return bisection(f, n, n)


def A375575(n):
    return (
        -1
        if len(k := Counter(str(factorial(n)).rstrip("0")).most_common()) > 1
        and k[-1][1] == k[-2][1]
        else int(k[-1][0])
    )


def A375348(n):
    return (
        -1
        if len(k := Counter(str(factorial(n)).rstrip("0")).most_common(2)) > 1
        and k[0][1] == k[1][1]
        else int(k[0][0])
    )


def A371189_gen():  # generator of terms
    def f(x):
        c, l, j = x - squarefreepi(integer_nthroot(x, 3)[0]), 0, isqrt(x)
        while j > 1:
            k2 = integer_nthroot(x // j**2, 3)[0] + 1
            w = squarefreepi(k2 - 1)
            c -= j * (w - l)
            l, j = w, isqrt(x // k2**3)
        return c + l

    def g(x):
        c = x
        for w in range(1, integer_nthroot(x, 5)[0] + 1):
            if all(d <= 1 for d in factorint(w).values()):
                for y in range(1, integer_nthroot(z := x // w**5, 4)[0] + 1):
                    if gcd(w, y) == 1 and all(d <= 1 for d in factorint(y).values()):
                        c -= integer_nthroot(z // y**4, 3)[0]
        return c

    m, w = 1, 1
    for n in count(2):
        k = bisection(lambda x: g(x) + n, m, m)
        if (a := f(k)) - w == k - 1 - m:
            yield m
        m, w = k, a


def A371190_gen():  # generator of terms
    def f(x):
        c, l, j = x - squarefreepi(integer_nthroot(x, 3)[0]), 0, isqrt(x)
        while j > 1:
            k2 = integer_nthroot(x // j**2, 3)[0] + 1
            w = squarefreepi(k2 - 1)
            c -= j * (w - l)
            l, j = w, isqrt(x // k2**3)
        return c + l

    m, w = 1, 1
    for n in count(2):
        k = bisection(lambda x: f(x) + n, m, m)
        if (a := squarefreepi(k)) - w == k - 1 - m:
            yield m
        m, w = k, a


def A240590(n):
    def f(x):
        c, l = n + x, 0
        j = isqrt(x)
        while j > 1:
            k2 = integer_nthroot(x // j**2, 3)[0] + 1
            w = squarefreepi(k2 - 1)
            c -= j * (w - l)
            l, j = w, isqrt(x // k2**3)
        c -= squarefreepi(integer_nthroot(x, 3)[0]) - l
        return c

    return -primepi(a := bisection(f, n, n)) + primepi(
        bisection(lambda x: f(x) + 1, a, a)
    )


def A112526(n):
    return int(all(e > 1 for e in factorint(n).values()))


def A060845(n):
    def f(x):
        return int(
            n
            + x
            - sum(primepi(integer_nthroot(x, k)[0]) for k in range(2, x.bit_length()))
        )

    return prevprime(bisection(f, n, n))


def A060846(n):
    def f(x):
        return int(
            n
            + x
            - sum(primepi(integer_nthroot(x, k)[0]) for k in range(2, x.bit_length()))
        )

    return nextprime(bisection(f, n, n))


def A071521(n):
    return sum((n // 3**i).bit_length() for i in range(integer_log(n, 3)[0] + 1))


def A003586(n):
    def f(x):
        return (
            n
            + x
            - sum((x // 3**i).bit_length() for i in range(integer_log(x, 3)[0] + 1))
        )

    return bisection(f, n, n)


def A033845(n):
    def f(x):
        return (
            n
            + x
            - sum((x // 3**i).bit_length() for i in range(integer_log(x, 3)[0] + 1))
        )

    return 6 * bisection(f, n, n)


def A191475(n):
    def f(x):
        return (
            n
            + x
            - sum((x // 3**i).bit_length() for i in range(integer_log(x, 3)[0] + 1))
        )

    return 1 + (~(m := bisection(f, n, n)) & m - 1).bit_length()


def A191476(n):
    def f(x):
        return (
            n
            + x
            - sum((x // 3**i).bit_length() for i in range(integer_log(x, 3)[0] + 1))
        )

    return 1 + integer_log((m := bisection(f, n, n)) >> (~m & m - 1).bit_length(), 3)[0]


def A022329(n):
    def f(x):
        return (
            n
            + x
            - sum((x // 3**i).bit_length() for i in range(integer_log(x, 3)[0] + 1))
        )

    return integer_log((m := bisection(f, n, n)) >> (~m & m - 1).bit_length(), 3)[0]


def A022328(n):
    def f(x):
        return (
            n
            + x
            - sum((x // 3**i).bit_length() for i in range(integer_log(x, 3)[0] + 1))
        )

    return (~(m := bisection(f, n, n)) & m - 1).bit_length()


def A055600(n):
    def f(x):
        return (
            n
            + x
            - sum((x // 3**i).bit_length() for i in range(integer_log(x, 3)[0] + 1))
        )

    return bisection(f, n, n) + 1


def A022330(n):
    return sum((3**i).bit_length() for i in range(n + 1))


def A022331(n):
    m = 1 << n
    return sum((m // 3**i).bit_length() for i in range(integer_log(m, 3)[0] + 1))


def A006899(n):
    return (
        1 << k
        if integer_log(m := 3 ** (n - 1), 6)[0] < (k := integer_log(3 * m, 6)[0])
        else 3 ** integer_log(1 << n, 6)[0]
    )


def A374484(n):
    return (
        sum(
            ((1 << k) // 3**i).bit_length()
            for i in range(integer_log(1 << k, 3)[0] + 1)
        )
        if integer_log(m := 3 ** (n - 1), 6)[0] < (k := integer_log(3 * m, 6)[0])
        else sum((3**i).bit_length() for i in range(integer_log(1 << n, 6)[0] + 1))
    )


def A081063(n):
    return int(
        1
        - (a := n.bit_length())
        - (b := integer_log(n, 3)[0])
        + sum((n // 3**i).bit_length() for i in range(b + 1))
        + sum(primepi(integer_nthroot(n, k)[0]) for k in range(1, a))
    )


def A081061(n):
    def f(x):
        return int(
            n
            + x
            - 1
            + (a := x.bit_length())
            + (b := integer_log(x, 3)[0])
            - sum((x // 3**i).bit_length() for i in range(b + 1))
            - sum(primepi(integer_nthroot(x, k)[0]) for k in range(1, a))
        )

    return iterfun(f, n)


def A081062(n):
    def f(x):
        return int(
            n
            + 1
            - (a := x.bit_length())
            - (b := integer_log(x, 3)[0])
            + sum((x // 3**i).bit_length() for i in range(b + 1))
            + sum(primepi(integer_nthroot(x, k)[0]) for k in range(1, a))
        )

    return iterfun(f, n)


def A071520(n):
    c = 0
    for i in range(integer_log(n, 5)[0] + 1):
        for j in range(integer_log(m := n // 5**i, 3)[0] + 1):
            c += (m // 3**j).bit_length()
    return c


def A051037(n):
    def f(x):
        c = n + x
        i, i5 = 0, 1
        while i5 <= x:
            j, j3 = 0, 1
            y = x // i5
            z = y
            while j3 <= y:
                c -= z.bit_length()
                j += 1
                j3 *= 3
                z //= 3
            i += 1
            i5 *= 5
        return c

    return bisection(f, n, n)


def A080193(n):
    def f(x):
        c = n + x
        for i in range(integer_log(x, 5)[0] + 1):
            for j in range(integer_log(y := x // 5**i, 3)[0] + 1):
                c -= (y // 3**j).bit_length()
        return c

    return bisection(f, n, n) * 5


def A071604(n):
    c = 0
    for i in range(integer_log(n, 7)[0] + 1):
        for j in range(integer_log(m := n // 7**i, 5)[0] + 1):
            for k in range(integer_log(r := m // 5**j, 3)[0] + 1):
                c += (r // 3**k).bit_length()
    return c


def A002473(n):
    def f(x):
        c = n + x
        for i in range(integer_log(x, 7)[0] + 1):
            for j in range(integer_log(m := x // 7**i, 5)[0] + 1):
                for k in range(integer_log(r := m // 5**j, 3)[0] + 1):
                    c -= (r // 3**k).bit_length()
        return c

    return bisection(f, n, n)


def A068191(n):
    def f(x):
        c = n
        for i in range(integer_log(x, 7)[0] + 1):
            for j in range(integer_log(m := x // 7**i, 5)[0] + 1):
                for k in range(integer_log(r := m // 5**j, 3)[0] + 1):
                    c += (r // 3**k).bit_length()
        return c

    return iterfun(f, n)


def A051038(n):
    def g(x, m):
        return (
            sum((x // 3**i).bit_length() for i in range(integer_log(x, 3)[0] + 1))
            if m == 3
            else sum(
                g(x // (m**i), prevprime(m)) for i in range(integer_log(x, m)[0] + 1)
            )
        )

    def f(x):
        return n + x - g(x, 11)

    return bisection(f, n, n)


def A080197(n):
    def g(x, m):
        return (
            sum((x // 3**i).bit_length() for i in range(integer_log(x, 3)[0] + 1))
            if m == 3
            else sum(
                g(x // (m**i), prevprime(m)) for i in range(integer_log(x, m)[0] + 1)
            )
        )

    def f(x):
        return n + x - g(x, 13)

    return bisection(f, n, n)


def A080683(n):
    def g(x, m):
        return (
            sum((x // 3**i).bit_length() for i in range(integer_log(x, 3)[0] + 1))
            if m == 3
            else sum(
                g(x // (m**i), prevprime(m)) for i in range(integer_log(x, m)[0] + 1)
            )
        )

    def f(x):
        return n + x - g(x, 23)

    return bisection(f, n, n)


def A117221(n):
    def f(x):
        return (
            n
            + x
            - sum((x // 3**i).bit_length() for i in range(integer_log(x, 3)[0] + 1))
        )

    return npartitions(bisection(f, n, n))


def A279622(n):
    def f(x):
        c = n
        for i in range(integer_log(x, 5)[0] + 1):
            for j in range(integer_log(y := x // 5**i, 3)[0] + 1):
                c += (y // 3**j).bit_length()
        return c

    return iterfun(f, n)


def A059485(n):
    def f(x):
        return n + sum(
            (x // 3**i).bit_length() for i in range(integer_log(x, 3)[0] + 1)
        )

    return iterfun(f, n)


def A080681(n):
    def g(x, m):
        return (
            sum((x // 3**i).bit_length() for i in range(integer_log(x, 3)[0] + 1))
            if m == 3
            else sum(
                g(x // (m**i), prevprime(m)) for i in range(integer_log(x, m)[0] + 1)
            )
        )

    def f(x):
        return n + x - g(x, 17)

    return bisection(f, n, n)


def A080682(n):
    def g(x, m):
        return (
            sum((x // 3**i).bit_length() for i in range(integer_log(x, 3)[0] + 1))
            if m == 3
            else sum(
                g(x // (m**i), prevprime(m)) for i in range(integer_log(x, m)[0] + 1)
            )
        )

    def f(x):
        return n + x - g(x, 19)

    return bisection(f, n, n)


def A372401(n):
    c, x = 0, 210**n
    for i in range(integer_log(x, 7)[0] + 1):
        for j in range(integer_log(m := x // 7**i, 5)[0] + 1):
            for k in range(integer_log(r := m // 5**j, 3)[0] + 1):
                c += (r // 3**k).bit_length()
    return c


def A372402(n):
    def g(x, m):
        return (
            sum((x // 3**i).bit_length() for i in range(integer_log(x, 3)[0] + 1))
            if m == 3
            else sum(
                g(x // (m**i), prevprime(m)) for i in range(integer_log(x, m)[0] + 1)
            )
        )

    return g(2310**n, 11)


def A372400(n):
    c, x = 0, 30**n
    for i in range(integer_log(x, 5)[0] + 1):
        for j in range(integer_log(y := x // 5**i, 3)[0] + 1):
            c += (y // 3**j).bit_length()
    return c


def A147572(n):
    def g(x, m):
        return (
            sum((x // 3**i).bit_length() for i in range(integer_log(x, 3)[0] + 1))
            if m == 3
            else sum(
                g(x // (m**i), prevprime(m)) for i in range(integer_log(x, m)[0] + 1)
            )
        )

    def f(x):
        return n + x - g(x, 11)

    return 2310 * bisection(f, n, n)


def A108347(n):
    def f(x):
        c = n + x
        for i in range(integer_log(x, 7)[0] + 1):
            for j in range(integer_log(m := x // 7**i, 5)[0] + 1):
                c -= integer_log(m // 5**j, 3)[0] + 1
        return c

    return bisection(f, n, n)


def A003595(n):
    def f(x):
        return (
            n
            + x
            - sum(
                integer_log(x // 7**i, 5)[0] + 1
                for i in range(integer_log(x, 7)[0] + 1)
            )
        )

    return bisection(f, n, n)


def A003594(n):
    def f(x):
        return (
            n
            + x
            - sum(
                integer_log(x // 7**i, 3)[0] + 1
                for i in range(integer_log(x, 7)[0] + 1)
            )
        )

    return bisection(f, n, n)


def A003591(n):
    def f(x):
        return (
            n
            + x
            - sum((x // 7**i).bit_length() for i in range(integer_log(x, 7)[0] + 1))
        )

    return bisection(f, n, n)


def A143207(n):
    def f(x):
        c = n + x
        for i in range(integer_log(x, 5)[0] + 1):
            for j in range(integer_log(m := x // 5**i, 3)[0] + 1):
                c -= (m // 3**j).bit_length()
        return c

    return bisection(f, n, n) * 30


def A352618(n):
    def f(x):
        c = n + x
        for i in range(integer_log(x, 7)[0] + 1):
            for j in range(integer_log(m := x // 7**i, 5)[0] + 1):
                for k in range(integer_log(r := m // 5**j, 3)[0] + 1):
                    c -= (r // 3**k).bit_length()
        return c

    return bisection(f, n, n) ** 2


def A051801(n):
    return prod(map(int, filter(lambda x: x > "1", str(n))))


def A352598(n):
    return prod(
        map(
            lambda x: (0, 1, 4, 9, 16, 25, 36, 49, 64, 81)[int(x)],
            filter(lambda x: x > "1", str(n)),
        )
    )


def A352172(n):
    return prod(
        map(
            lambda x: (0, 1, 8, 27, 64, 125, 216, 343, 512, 729)[int(x)],
            filter(lambda x: x > "1", str(n)),
        )
    )


def A085126(n):
    def f(x):
        c = n + x
        for i in range(integer_log(x, 7)[0] + 1):
            for j in range(integer_log(m := x // 7**i, 5)[0] + 1):
                for k in range(integer_log(r := m // 5**j, 3)[0] + 1):
                    c -= (r // 3**k).bit_length()
        return c

    return bisection(f, n, n) * 3


def A080194(n):
    def f(x):
        c = n + x
        for i in range(integer_log(x, 7)[0] + 1):
            for j in range(integer_log(m := x // 7**i, 5)[0] + 1):
                for k in range(integer_log(r := m // 5**j, 3)[0] + 1):
                    c -= (r // 3**k).bit_length()
        return c

    return bisection(f, n, n) * 7


def A342950(n):
    def f(x):
        c = n + x
        for i in range(integer_log(x, 7)[0] + 1):
            for j in range(integer_log(m := x // 7**i, 3)[0] + 1):
                c -= (k := m // 3**j).bit_length() + integer_log(k, 5)[0]
        return c

    return bisection(f, n, n)


def A133581(n):
    if n == 1:
        return 8

    def g(x, m):
        return (
            sum((x // 3**i).bit_length() for i in range(integer_log(x, 3)[0] + 1))
            if m == 3
            else sum(
                g(x // (m**i), prevprime(m)) for i in range(integer_log(x, m)[0] + 1)
            )
        )

    k = prime(n)

    def f(x):
        return k**2 + x - g(x, k)

    return bisection(f, k**2, k**2)


def A085908(n):
    if n < 2:
        return n

    def f(x):
        c = 0
        for i in range(integer_log(x, 7)[0] + 1):
            for j in range(integer_log(m := x // 7**i, 5)[0] + 1):
                for k in range(integer_log(r := m // 5**j, 3)[0] + 1):
                    c += (r // 3**k).bit_length()
        return c

    for l in count(0):
        kmin, kmax = n * 10**l - 1, (n + 1) * 10**l - 1
        mmin, mmax = f(kmin), f(kmax)
        if mmax > mmin:
            while kmax - kmin > 1:
                kmid = kmax + kmin >> 1
                mmid = f(kmid)
                if mmid > mmin:
                    kmax, mmax = kmid, mmid
                else:
                    kmin, mmin = kmid, mmid
            return kmax


def A080686(n):
    def g(x, m):
        return (
            sum((x // 3**i).bit_length() for i in range(integer_log(x, 3)[0] + 1))
            if m == 3
            else sum(
                g(x // (m**i), prevprime(m)) for i in range(integer_log(x, m)[0] + 1)
            )
        )

    return g(n, 19)


if sys.version_info >= (3, 10):

    def A376116(n):
        return (n << 1) - n.bit_count() - n.bit_length()

else:

    def A376116(n):
        return (n << 1) - bin(n).count("1") - n.bit_length()


def A091090(n):
    return (~(n + 1) & n).bit_length() + bool(n & (n + 1)) if n else 1


def A135517(n):
    return (1 << (~(n + 1) & n).bit_length() - (not n & (n + 1))) if n else 1


def A088705(n):
    return 1 - (~n & n - 1).bit_length()


def A375553(n):
    p, q, m = prime(n), 2, 10
    for l in count(1):
        while q < m:
            if isprime(m * (p + q) + q):
                return q
            q = nextprime(q)
        m *= 10


def A375552_gen():  # generator of terms
    p, a = 2, set()
    yield from (2, 5)
    while True:
        q, m = 2, 10
        for l in count(1):
            while q < m:
                if isprime(m * (p + q) + q):
                    if q not in a:
                        yield q
                        a.add(q)
                    break
                q = nextprime(q)
            else:
                m *= 10
                continue
            break
        p = nextprime(p)


def A371587(n):
    return n // 3 + integer_nthroot(n, 3)[0] - integer_nthroot(n // 27, 3)[0]


def A376279(n):
    def f(x):
        return (
            n
            - 1
            + x
            - x // 3
            - integer_nthroot(x, 3)[0]
            + integer_nthroot(x // 27, 3)[0]
        )

    m, k = n - 1, f(n - 1)
    while m != k:
        m, k = k, f(k)
    return m


def A329547(n):
    return (n >> 1) + (isqrt(n) + 1 >> 1)


def A176693(n):
    def f(x):
        return n - 1 + (x >> 1) + (x & 1) - (isqrt(x) + 1 >> 1)

    m, k = n - 1, f(n - 1)
    while m != k:
        m, k = k, f(k)
    return m


def A109251(n):
    r = 10**n
    return int(
        sum(
            primepi(r // (k * m)) - b
            for a, k in enumerate(primerange(integer_nthroot(r, 3)[0] + 1))
            for b, m in enumerate(primerange(k, isqrt(r // k) + 1), a)
        )
    )


def A114453(n):
    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b, isqrt(x // c) + 1), a))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b, integer_nthroot(x // c, m)[0] + 1), a
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    return int(
        sum(
            primepi(10**n // prod(c[1] for c in a)) - a[-1][0]
            for a in g(10**n, 0, 1, 1, 5)
        )
    )


def A174414(n):
    for l in count(1):
        if gcd(n, (m := 10**l) + 1) == 1:
            r = m // 10
            a = m * (n + r) + r
            for k in range(r, m):
                if isprime(a):
                    return k
                a += m + 1


def A376219_gen():  # generator of terms
    c = 0
    for n in count(1):
        for l in count(1):
            if gcd(n, (m := 10**l) + 1) == 1:
                r = m // 10
                a = m * (n + r) + r
                for k in range(r, m):
                    if isprime(a):
                        if k > c:
                            yield n
                            c = k
                        break
                    a += m + 1
                else:
                    continue
                break


def A376220_gen():  # generator of terms
    c = 0
    for n in count(1):
        for l in count(1):
            if gcd(n, (m := 10**l) + 1) == 1:
                r = m // 10
                a = m * (n + r) + r
                for k in range(r, m):
                    if isprime(a):
                        if k > c:
                            yield k
                            c = k
                        break
                    a += m + 1
                else:
                    continue
                break


def A375874(n):
    if n < 4:
        return (1, 2, 14, 70)[n]
    a, b = integer_log(n - 2, 3)[0] + 1, integer_log((n >> 1) - 1, 3)[0] + 1
    return (n - 1) * (
        (1 + (a - b << 1)) * (n - 1) + ((c := 3**a) + (3**b << 1)) << 1
    ) - c**2 << 1


def A376279_gen(startvalue=0):  # generator of terms >= startvalue
    return filter(
        lambda k: not k % 3 or integer_nthroot(k, 3)[1], count(max(startvalue, 0))
    )


def A376296(n):
    c = 0
    for x in range(n):
        for y in range(x, n):
            xy, xyp = x * y % n, (x + y) % n
            for z in range(y, n):
                xyz, xyzp = xy * z % n - 1, (xyp + z) % n
                c += sum(not (xyz * w - xyzp) % n for w in range(z, n))
    return c


def A376183(n):
    c = 0
    for x in range(n):
        for y in range(x, n):
            xy, xyp = x * y % n - 1, (x + y) % n
            c += sum(not (xy * z - xyp) % n for z in range(y, n))
    return c


def A188915(n):
    def f(x):
        return n + x - isqrt(x) - ((m := x.bit_length() - 1) >> 1) - (m & 1)

    return bisection(f, n - 1, n**2)


def A174090(n):
    def f(x):
        return int(n + x + (0 if x <= 1 else 1 - primepi(x)) - x.bit_length())

    return bisection(f, n, n)


def A111774(n):
    def f(x):
        return int(n + (0 if x <= 1 else primepi(x) - 1) + x.bit_length())

    return iterfun(f, n)


def A067133(n):
    def f(x):
        return int(n + x - (x > 5) + (0 if x <= 1 else 1 - primepi(x)) - x.bit_length())

    return bisection(f, n, n)


def A376315_gen(startvalue=2):  # generator of terms >= startvalue
    for k in count(max(startvalue + (startvalue & 1), 2), 2):
        f = {p: k * e for p, e in factorint(k).items()}
        f[2] += 1
        if not any(v % 3 for v in f.values()):
            yield k


def A376269(n):
    return n**2 * factorial(n - 2) + n - 3


def A376280_gen():  # generator of terms
    def f(x):
        c = 0
        i7 = 1
        m = x
        for i in count(0):
            if i7 > x:
                break
            j5 = 1
            r = m
            for j in count(0):
                if j5 > m:
                    break
                k3 = 1
                t = r
                for k in count(0):
                    if k3 > r:
                        break
                    c += t.bit_length()
                    k3 *= 3
                    t //= 3
                j5 *= 5
                r //= 5
            i7 *= 7
            m //= 7
        return c

    c = 1
    yield 1
    for n in count(2):
        for l in count(0):
            kmin, kmax = n * 10**l - 1, (n + 1) * 10**l - 1
            mmin, mmax = f(kmin), f(kmax)
            if mmax > mmin:
                while kmax - kmin > 1:
                    kmid = kmax + kmin >> 1
                    mmid = f(kmid)
                    if mmid > mmin:
                        kmax, mmax = kmid, mmid
                    else:
                        kmin, mmin = kmid, mmid
                break
        if kmax > c:
            yield kmax
            c = kmax


def A376278_gen():  # generator of terms
    def f(x):
        c = 0
        i7 = 1
        m = x
        for i in count(0):
            if i7 > x:
                break
            j5 = 1
            r = m
            for j in count(0):
                if j5 > m:
                    break
                k3 = 1
                t = r
                for k in count(0):
                    if k3 > r:
                        break
                    c += t.bit_length()
                    k3 *= 3
                    t //= 3
                j5 *= 5
                r //= 5
            i7 *= 7
            m //= 7
        return c

    c = 1
    yield 1
    for n in count(2):
        for l in count(0):
            kmin, kmax = n * 10**l - 1, (n + 1) * 10**l - 1
            mmin, mmax = f(kmin), f(kmax)
            if mmax > mmin:
                while kmax - kmin > 1:
                    kmid = kmax + kmin >> 1
                    mmid = f(kmid)
                    if mmid > mmin:
                        kmax, mmax = kmid, mmid
                    else:
                        kmin, mmin = kmid, mmid
                break
        if kmax > c:
            yield n
            c = kmax


def A341300(n):
    return (n**2 * (n - 2) + 1) * factorial(n - 3) + n - 3


def A361373(n):
    return sum(integer_log(n, p)[0] for p in primefactors(n))


def A152061(n):
    return -sum(mobius(n // d) << d for d in divisors(n, generator=True) if d < n)


def A178472(n):
    return -sum(mobius(n // d) << d - 1 for d in divisors(n, generator=True) if d < n)


def A050871(n):
    return -sum(
        mobius((n << 1) // d) << d
        for d in divisors(n << 1, generator=True)
        if d < n << 1
    )


def A050872(n):
    return -sum(
        mobius((n << 1) // d) << d - 1
        for d in divisors(n << 1, generator=True)
        if d < n << 1
    )


def A325240(n):
    def f(x):
        c, l = n + x, 0
        j = isqrt(x)
        while j > 1:
            k2 = integer_nthroot(x // j**2, 3)[0] + 1
            w = squarefreepi(k2 - 1)
            c -= j * (w - l)
            l, j = w, isqrt(x // k2**3)
        c -= squarefreepi(integer_nthroot(x, 3)[0]) - l
        for w in range(1, integer_nthroot(x, 5)[0] + 1):
            if all(d <= 1 for d in factorint(w).values()):
                for y in range(1, integer_nthroot(z := x // w**5, 4)[0] + 1):
                    if gcd(w, y) == 1 and all(d <= 1 for d in factorint(y).values()):
                        c += integer_nthroot(z // y**4, 3)[0]
        return c

    return bisection(f, n, n**2)


def A376151_gen():  # generator of terms
    for l in count(1):
        c = []
        for d in combinations_with_replacement("0123456789", l):
            if (s := sum(map(int, d))) > 1:
                for a in range(1, min(10, s)):
                    a2 = a * 10 ** (l + 1)
                    for b in range(min(10, s - a)):
                        for x in multiset_permutations(d):
                            c.append(a2 + 10 * int("".join(x)) + b)
        yield from sorted(c)


def A376427(n):
    s = set()
    for x in range(n):
        for y in range(x, n):
            xy, xyp = x * y % n, (x + y) % n
            for z in range(y, n):
                try:
                    s.add((xyp + z + pow(xy * z % n, -1, n)) % n)
                except:
                    continue
    return len(s)


def A376318(n):
    s = set()
    for x in range(n):
        for y in range(x, n):
            try:
                s.add((x + y + pow(x * y % n, -1, n)) % n)
            except:
                continue
    return len(s)


def A212289_gen():  # generator of terms
    yield (c := 0)
    for n in count(1):
        m = sum(
            reduce(
                lambda x, y: (x[0], x[0] + x[1]) if int(y) else (x[0] + x[1], x[1]),
                bin(n)[-1:2:-1],
                (1, 0),
            )
        )
        if m > c:
            yield (c := m)


def A375966(n):
    return 1 << (n ^ 1) if n & 1 else 3 ** (n >> 1)


def A098293(n):
    return 3 ** (n >> 1) if n & 1 else 1 << (n >> 1)


def A072345(n):
    return 2 << (n >> 1) if n & 1 else 1


def A376485_gen():  # generator of terms
    plist, p = [3, 5], 7
    while True:
        clist = []
        for l in range(2, len(plist) + 1):
            for q in combinations(plist, l):
                k = prod(q) * p - 1
                if not (k % (p - 1) or any(k % (r - 1) for r in q)):
                    clist.append(k + 1)
        yield from sorted(clist)
        plist.append(p)
        p = nextprime(p)


def A283715(n):
    plist, c = list(primerange(3, p := prime(n))), 0
    for l in range(2, len(plist) + 1):
        for q in combinations(plist, l):
            k = prod(q) * p - 1
            if not (k % (p - 1) or any(k % (r - 1) for r in q)):
                c += 1
    return c


def A280617(n):
    plist, c = list(primerange(3, n + 1)), 0
    for l in range(2, len(plist) + 1):
        for q in combinations(plist, l):
            k = prod(q) - 1
            if not any(k % (r - 1) for r in q):
                c += 1
    return c


def A375921(n):
    return lcm(*range(1, n + 1 << 1)) // 6


def A376007(n):
    if (m := n & 7) == 0 or m == 4:
        return n * (n**2 - 4) + 8 >> 3
    elif m == 1 or m == 7:
        return n * (n**2 - 9) + 24 >> 4
    elif m == 2 or m == 6:
        return n**3 >> 3
    else:
        return n * (n**2 - 1) + 8 >> 4


def A375956_gen():  # generator of terms
    a, l, r = 2, 1, 10
    yield 2
    for n in count(1):
        b = 10**n
        c = b * r
        for i in count(10 ** (n - 1)):
            m = c * i + a * b + int(str(i)[::-1])
            if isprime(m):
                yield m
                a = m
                l += n << 1
                r *= 10 ** (n << 1)
                break


def A036563(n):
    return (1 << n) - 3


def A375961(n):
    return (~(3 * n + 1) & 3 * n).bit_length() + 1


def A078845(n):
    return almostprimepi(7**n, n) if n else 1


def A116431(n):
    if n <= 1:
        return 4 * n + 1

    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b, isqrt(x // c) + 1), a))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b, integer_nthroot(x // c, m)[0] + 1), a
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    return int(
        sum(
            primepi(12**n // prod(c[1] for c in a)) - a[-1][0]
            for a in g(12**n, 0, 1, 1, n)
        )
    )


def A116426(n):
    if n <= 1:
        return n + 1

    def g(x, a, b, c, m):
        yield from (
            ((d,) for d in enumerate(primerange(b, isqrt(x // c) + 1), a))
            if m == 2
            else (
                ((a2, b2),) + d
                for a2, b2 in enumerate(
                    primerange(b, integer_nthroot(x // c, m)[0] + 1), a
                )
                for d in g(x, a2, b2, c * b2, m - 1)
            )
        )

    return int(
        sum(
            primepi((1 << (n << 1)) // prod(c[1] for c in a)) - a[-1][0]
            for a in g(1 << (n << 1), 0, 1, 1, n)
        )
    )


def A351304(n):
    return prod(p ** (9 * e) + p ** (9 * (e - 1)) for p, e in factorint(n).items())


def A302058(n):
    return (
        n + (m := integer_nthroot(3 * n, 3)[0]) - (6 * n <= m * (m - 1) * (2 * m + 5))
    )


def A036263(n):
    return prime(n) - (prime(n + 1) << 1) + prime(n + 2)


def A376573(n):
    return (
        n
        + (m := integer_nthroot(k := n << 2, 4)[0])
        - (k <= m * (m - 1) * (m**2 + 3 * m + 4))
    )


def A375564_gen():  # generator of terms
    aset, a, b = {1, 2}, 2, 3
    yield from (1, 2)
    while True:
        c = b
        if isprime(a):
            while c in aset or gcd(c, a) > 1:
                c += 1
        else:
            while c in aset or gcd(c, a) == 1:
                c += 1
        aset.add(c)
        yield (a := c)
        while b in aset:
            b += 1


def A376584_gen():  # generator of terms
    aset, a, b = {1, 2}, 2, 3
    yield from (1, 2)
    for i in count(3):
        c = b
        if isprime(a):
            while c in aset or gcd(c, a) > 1:
                c += 1
        else:
            while c in aset or gcd(c, a) == 1:
                c += 1
        aset.add(a := c)
        if i == c:
            yield i
        while b in aset:
            b += 1


def A375976(n):
    return sum(
        (0, 1, 4, 9, 16, 25, 36, 49, 64, 81)[int(d)] for d in str(1 << n) if d > "0"
    )


def A376240(n):
    c = 0
    for x in range(1, n):
        for y in range(x, n):
            xy, xyp = x * y % n - 1, n - (x + y) % n
            c += sum(not (z == xyp or (xy * z + xyp) % n) for z in range(y, n))
    return c


def A184005(n):
    return n + ((m := 3 * n**2) >> 2) - (not m & 3)


def A184004(n):
    return n + isqrt((n << 2) // 3)


def A078358(n):
    return n + operator_sub(*integer_nthroot(n, 2))


def A077425(n):
    return n + operator_sub(*integer_nthroot(n, 2)) << 2 | 1


def A108906(n):
    m, m2 = 3 ** (n - 1), 1 << n
    k, k2, k3 = integer_log(m, 6)[0], integer_log(3 * m, 6)[0], integer_log(9 * m, 6)[0]
    return (
        (1 << k2 if k2 < k3 else 3 ** integer_log(m2 << 1, 6)[0] - (1 << k2))
        if k < k2
        else (
            (1 << k3) - 3 ** integer_log(m2, 6)[0]
            if k2 < k3
            else 3 ** integer_log(m2 << 1, 6)[0] - 3 ** integer_log(m2, 6)[0]
        )
    )


def A188917(n):
    return (n + 1 >> 1) + isqrt(1 << n)


def A350757(n):
    return n + (m := isqrt(n >> 1)) - int(n <= m * ((m << 1) + 1) + 1) if n > 1 else 1


def A099776(n):
    return (n << 1) * (n + 1) + 1


def A376252(n):
    return int("1" + str(n)) % n


def A376593(n):
    def f(x):
        return n + sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

    m = iterfun(f, n)
    k = next(i for i in range(1, 5) if any(d > 1 for d in factorint(m + i).values()))
    return next(
        i
        for i in range(1 - k, 5 - k)
        if any(d > 1 for d in factorint(m + (k << 1) + i).values())
    )


def A376562(n):
    def f(x):
        return int(
            n
            + 1
            - sum(
                mobius(k) * (integer_nthroot(x, k)[0] - 1)
                for k in range(2, x.bit_length())
            )
        )

    m = iterfun(f, n)
    r = m + ((k := next(i for i in count(1) if not perfect_power(m + i))) << 1)
    return next(i for i in count(1 - k) if not perfect_power(r + i))


def A376559(n):
    def f(x):
        return int(
            n
            - 1
            + x
            + sum(
                mobius(k) * (integer_nthroot(x, k)[0] - 1)
                for k in range(2, x.bit_length())
            )
        )

    a = bisection(f, n, n)
    b = bisection(lambda x: f(x) + 1, a, a)
    return a + bisection(lambda x: f(x) + 2, b, b) - (b << 1)


def A376590(n):
    def f(x):
        return n + x - sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))

    a = iterfun(f, n)
    b = iterfun(lambda x: f(x) + 1, a)
    return a + iterfun(lambda x: f(x) + 2, b) - (b << 1)


def A002309(n):
    return n * (n**2 * (6 * n**2 - 5 << 3) + 7) // 15


def A128201(n):
    def f(x):
        return n + (x >> 1) - (isqrt(x) >> 1)

    m, k = n, f(n)
    while m != k:
        m, k = k, f(k)
    return m


def A375310_gen():  # generator of terms
    f = 1
    for k in count(1):
        if isprime((k**2 + 1) * f - 1):
            yield k
        f *= k**2


def A374901_gen():  # generator of terms
    f = 1
    for k in count(1):
        if isprime((k**2 + 1) * f + 1):
            yield k
        f *= k**2


def A376691(n):
    c = 0
    for x in range(n):
        m = x * (1 - x) % n
        c += sum(1 for y in range(x, n) if y * (y - 1) % n == m and not m * (x - y) % n)
    return c


def A376646(n):
    c = 0
    for x in range(n):
        m = x * (1 - x) % n
        c += sum(1 for y in range(x, n) if y * (y - 1) % n == m)
    return c


def A376596(n):
    def f(x):
        return int(
            n
            + x
            - 1
            - sum(primepi(integer_nthroot(x, k)[0]) for k in range(1, x.bit_length()))
        )

    return (
        (a := iterfun(f, n))
        - ((b := iterfun(lambda x: f(x) + 1, a)) << 1)
        + iterfun(lambda x: f(x) + 2, b)
    )


def A376599(n):
    def f(x):
        return int(
            n
            + 1
            + sum(primepi(integer_nthroot(x, k)[0]) for k in range(1, x.bit_length()))
        )

    return (
        (a := iterfun(f, n))
        - ((b := iterfun(lambda x: f(x) + 1, a)) << 1)
        + iterfun(lambda x: f(x) + 2, b)
    )


def A100682(n):
    return integer_nthroot(comb(n + 3, 4), 4)[0]


def A073445(n):
    return (
        (a := iterfun(f := lambda x: n + primepi(x) + 1, n))
        - ((b := iterfun(lambda x: f(x) + 1, a)) << 1)
        + iterfun(lambda x: f(x) + 2, b)
    )


def A129954(n):
    return n + 4 << n - 2 if n > 1 else 2 * n + 1


def A129952(n):
    return n << n - 2 if n > 1 else 1


def A129953(n):
    return n + 2 << n - 2 if n > 1 else n


def A087447(n):
    return n + 2 << n - 2 if n > 1 else 1


def A376745(n):
    return n + (m := integer_nthroot(k := n << 1, 3)[0]) - (k <= m * (m - 1) * (m + 2))


def A351760(n):
    return (
        n
        * (
            n
            * (
                n
                * (
                    n
                    * (
                        n
                        * (
                            n * (n * (n * (n * (9 * n + 20 << 2) - 105) - 300) + 88)
                            + 390
                        )
                        - 20
                    )
                    - 200
                )
                + 1
            )
            + 30
        )
        // 1800
    )


def A259108(n):
    return n * (n**2 * (n * (3 * (2 * n + 5)) + 10) - 1) // 15


def A000539(n):
    return n**2 * (n**2 * (n * (n + 3 << 1) + 5) - 1) // 12


def A101092(n):
    return n * (n * (n * (n * (n * (n * (n + 7 << 1) + 35) + 35) + 7) - 7) - 2) // 84


def A113646(n):
    return n + isprime(n) if n > 2 else 4


def A014683(n):
    return n + isprime(n)


def A376714(n):
    return sum(
        (0, 1, 4, 9, 16, 25, 36, 49, 64, 81)[int(d)] for d in str(prime(n)) if d > "0"
    )


def A376114_gen():  # generator of terms
    for n in count(1):
        k = prod((e << 1 | 1) + (p == 2) for p, e in factorint(n).items())
        if not (m := n**2 << 1) % k:
            yield m


def A036896_gen():  # generator of terms
    for n in count(1, 2):
        if not (m := n**2) % prod(e << 1 | 1 for e in factorint(n).values()):
            yield m


def A376120_gen():  # generator of terms
    def f(x):
        return int(
            x
            - 1
            + sum(
                mobius(k) * (integer_nthroot(x, k)[0] - 1)
                for k in range(2, x.bit_length())
            )
        )

    m = 1
    for n in count(1):
        m = bisection(lambda x: f(x) + n, m, m)
        if not m % prod(e + 1 for e in factorint(m).values()):
            yield m


def A183219(n):
    return n + (isqrt((n << 3) // 5) + 1 >> 1)


def A183217(n):
    return n + (isqrt((n << 3) // 3) + 1 >> 1)


def A111651(n):
    return isqrt((n << 3) // 3) + 1 >> 1


def A183220(n):
    return n + (isqrt((n << 2) // 3) + 1 >> 1)


def A183221(n):
    return n + (isqrt((n << 3) // 7) + 1 >> 1)


def A183222(n):
    return n + (isqrt(n) + 1 >> 1)


def A376720(n):
    def f(x):
        return int(
            n
            + sum(primepi(integer_nthroot(x, k)[0]) for k in range(2, x.bit_length()))
            + sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))
        )

    return (m := bisection(f, n, n)) * prod(primefactors(m))


def A265640_gen(startvalue=1):  # generator of terms >= startvalue
    return filter(
        lambda n: sum(1 for e in factorint(n).values() if e & 1) <= 1,
        count(max(startvalue, 1)),
    )


def A376715_gen(startvalue=1):  # generator of terms >= startvalue
    return filter(
        lambda n: n > 3
        and not isprime(n)
        and sum(1 for e in factorint(n).values() if e & 1) <= 1,
        count(max(startvalue, 1)),
    )


def A063538(n):
    def f(x):
        return int(
            n
            + x
            - primepi(x // (y := isqrt(x)))
            - sum(primepi(x // i) - primepi(i) for i in range(1, y))
        )

    return iterfun(f, n)


def A063539(n):
    def f(x):
        return int(
            n
            + primepi(x // (y := isqrt(x)))
            + sum(primepi(x // i) - primepi(i) for i in range(1, y))
        )

    return bisection(f, n, n)


def A064775(n):
    return int(n + sum(primepi(i) - primepi(n // i) for i in range(1, isqrt(n) + 1)))


def A063762(n):
    def f(x):
        return int(
            n
            + (
                x
                if x <= 3
                else x
                - primepi(x // (y := isqrt(x)))
                - sum(primepi(x // i) - primepi(i) for i in range(2, y))
            )
        )

    return iterfun(f, n)


def A063763(n):
    def f(x):
        return int(
            n + x - sum(primepi(x // i) - primepi(i) for i in range(2, isqrt(x) + 1))
        )

    return iterfun(f, n)


def A376003_gen(startvalue=1):  # generator of terms >= startvalue
    return filter(
        lambda n: not (
            (n & 1 and n > 1)
            or any(d == "0" or d == "5" or n % int(d) for d in str(n**2))
        ),
        count(max(startvalue, 1)),
    )


def A333535(n):
    return int(
        n
        - 1
        - primepi(n // (m := isqrt(n)))
        + sum(primepi(i) - primepi(n // i) for i in range(1, m))
    )


def A295084(n):
    return int(n - sum(n // p for p in primerange(isqrt(n) + 1, n + 1)))


def A241419(n):
    return int(sum(n // p for p in primerange(isqrt(n) + 1, n + 1)))


def A013939(n):
    return sum(n // p for p in primerange(n + 1))


def A071325(n):
    return prod((e >> 1) + 1 for e in factorint(n).values()) - 1


def A183223(n):
    return n + (isqrt((n << 3 | 4) // 9) + 1 >> 1)


def A183224(n):
    return n + (isqrt((n << 2 | 2) // 5) + 1 >> 1)


def A183225_T(n, k):
    return n + (
        isqrt(((n << 3) + (-8 + (k + 1 & -4) if k > 10 else 0)) // (k - 2)) + 1 >> 1
    )


def A183225_gen():  # generator of terms
    return (A183225_T(m - k + 3, k) for m in count(1) for k in range(3, m + 3))


def A080075_gen(startvalue=3):  # generator of terms >= startvalue
    return filter(lambda n: (n - 1 & -n + 1) ** 2 + 1 >= n, count(max(startvalue, 3)))


def A116883_gen(startvalue=1):  # generator of terms >= startvalue
    return filter(lambda n: n == 1 or (n & -n) ** 2 < n, count(max(startvalue, 1)))


def A376757(n):
    return sum(
        d * (d + 1) >> 1 for d in Counter(pow(x, 3, n) for x in range(n)).values()
    )


def A376833(n):
    def f(x):
        return (
            n
            + 1
            + primepi(x)
            + x
            - sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1))
        )

    m, k = n + 1, f(n + 1)
    while m != k:
        m, k = k, f(k)
    return primefactors(m)[1]


def A376202(n):
    c = 0
    for x in range(1, n):
        if gcd(x, n) == 1:
            for y in range(x, n):
                if (
                    gcd(y, n) == gcd(z := x + y, n) == 1
                    and not (w := z**2 - x * y) // gcd(w, x * y * z) % n
                ):
                    c += 1
    return c


def A376755(n):
    c, m = 0, 6 * n | 1
    for x in range(1, m):
        if gcd(x, m) == 1:
            for y in range(x, m):
                if (
                    gcd(y, m) == gcd(z := x + y, m) == 1
                    and not (w := z**2 - x * y) // gcd(w, x * y * z) % m
                ):
                    c += 1
    return c // 6


def A376203(n):
    c, m = 0, (n << 1) - 1
    for x in range(1, m):
        if gcd(x, m) == 1:
            for y in range(x, m):
                if (
                    gcd(y, m) == gcd(z := x + y, m) == 1
                    and not (w := z**2 - x * y) // gcd(w, x * y * z) % m
                ):
                    c += 1
    return c >> 1


def A376756(n):
    c = 0
    for x in range(n):
        z = x**2 % n
        for y in range(x, n):
            if not (z + y * (x + y)) % n:
                c += 1
    return c


def A255177(n):
    return 14 * n * (n**2 * (3 * n**2 + 5) + 1) if n else 1


def A085141(n):
    return (isqrt(24 * n + 1) - 1) // 6


def A339183(n):
    return isqrt(n >> 1)


def A290731(n):
    return prod(
        (p ** (e + 1) // (p + (q := p > 2)) >> 1) + q for p, e in factorint(n).items()
    )


def A000224(n):
    return prod(
        (p ** (e + 1) // ((p + 1) * (q := 1 + (p == 2))) >> 1) + q
        for p, e in factorint(n).items()
    )


def A095972(n):
    return n - prod(
        (p ** (e + 1) // ((p + 1) * (q := 1 + (p == 2))) >> 1) + q
        for p, e in factorint(n).items()
    )


def A218578(n):
    return sum(
        1
        for i in range(1, 2 * n + 3)
        if n
        == i
        - prod(
            (p ** (e + 1) // ((p + 1) * (q := 1 + (p == 2))) >> 1) + q
            for p, e in factorint(i).items()
        )
    )


def A376868(n):
    return factorial(n) << n * (n - 1)


def A376654_gen():  # generator of terms
    def f(x):
        return int(
            x - sum(primepi(integer_nthroot(x, k)[0]) for k in range(1, x.bit_length()))
        )

    s, a, b = {0}, 2, 3
    for n in count(1):
        m = a - (b << 1) + (c := iterfun(lambda x: f(x) + n + 2, b))
        if m not in s:
            yield n
            s.add(m)
        a, b = b, c


def A376653_gen():  # generator of terms
    def f(x):
        return int(
            x - sum(primepi(integer_nthroot(x, k)[0]) for k in range(1, x.bit_length()))
        )

    s, a, b = set(), 1, 2
    for n in count(1):
        m = a - (b << 1) + (c := iterfun(lambda x: f(x) + n + 1, b))
        if m not in s:
            yield n
            s.add(m)
        a, b = b, c


def A376655_gen():  # generator of terms
    def f(x):
        return int(x - sum(mobius(k) * (x // k**2) for k in range(1, isqrt(x) + 1)))

    s, a, b = set(), 1, 2
    for n in count(1):
        m = a - (b << 1) + (c := iterfun(lambda x: f(x) + n + 2, b))
        if m not in s:
            yield n
            s.add(m)
        a, b = b, c


def A376532(n):
    m, r, c, a, b, d = 3**n, n**2, 1, 2, n**2, 1
    for k in range(1, r + 1):
        c += b // d * a % m
        a = a * 2 % m
        b *= r - k
        d *= k + 1
    return c // m


def A376536(n):
    m, r, c, a, b, d = 3**n, n**3, 1, 2, n**3, 1
    for k in range(1, r + 1):
        c += b // d * a % m
        a = a * 2 % m
        b *= r - k
        d *= k + 1
    return c // m


def A376198_gen():  # generator of terms
    yield from (1, 2)
    a, p, q = 2, 3, 4
    while True:
        yield (a := min(p, q) if isprime(a) else (p if a == 2 * p else q))
        if a == p:
            p = nextprime(p)
        else:
            q += isprime(q + 1) + 1


def A376201_gen():  # generator of terms
    yield from (1, 2)
    a, p, q = 2, 3, 4
    for n in count(3):
        a = min(p, q) if isprime(a) else (p if a == (p << 1) else q)
        if a == n:
            yield n
        if a == p:
            p = nextprime(p)
        else:
            q += isprime(q + 1) + 1


def A376758_gen():  # generator of terms
    c, a, p, q = 2, 2, 3, 4
    for n in count(3):
        b = min(p, q) if isprime(a) else (p if a == (p << 1) else q)
        if b == n:
            if b == a + 1:
                c += 1
            else:
                yield c >> 1
                c = 1
        if b == p:
            p = nextprime(p)
        else:
            q += isprime(q + 1) + 1
        a = b


def A124301(n):
    c, m = 1, 1
    for i in count(2):
        k = mobius(i)
        if m != k:
            if c > n:
                return i - c
            c = 0
        c += 1
        m = k
